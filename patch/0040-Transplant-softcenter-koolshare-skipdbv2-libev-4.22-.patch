From 48470234c3dcf087d79ebf9bb0aad62e9b4df6e1 Mon Sep 17 00:00:00 2001
From: Rokis <ghost1988102@gmail.com>
Date: Tue, 19 May 2020 01:06:29 +0800
Subject: [PATCH 040/122] Transplant softcenter(koolshare): skipdbv2,
 libev-4.22, softcenter1.0.4. Add softcenter web tab. Transplant httpd for
 softcenter.

Signed-off-by: Rokis <ghost1988102@gmail.com>
---
 release/src-rt/Makefile                       |     4 +
 release/src-rt/target.mak                     |     2 +-
 release/src/router/Makefile                   |    55 +
 release/src/router/config/config.in           |     4 +
 release/src/router/config_base                |     1 +
 release/src/router/httpd/Makefile             |     6 +-
 .../router/httpd/prebuild/RT-AC3100/httpd_bin |   Bin 0 -> 449813 bytes
 release/src/router/libev-4.22/Changes         |   517 +
 release/src/router/libev-4.22/LICENSE         |    37 +
 release/src/router/libev-4.22/Makefile.am     |    20 +
 release/src/router/libev-4.22/Makefile.in     |   909 +
 release/src/router/libev-4.22/README          |    58 +
 release/src/router/libev-4.22/Symbols.ev      |    73 +
 release/src/router/libev-4.22/Symbols.event   |    24 +
 release/src/router/libev-4.22/aclocal.m4      |  9787 +++++++++++
 release/src/router/libev-4.22/autogen.sh      |     3 +
 release/src/router/libev-4.22/compile         |   347 +
 release/src/router/libev-4.22/config.guess    |  1420 ++
 release/src/router/libev-4.22/config.h.in     |   125 +
 release/src/router/libev-4.22/config.sub      |  1799 ++
 release/src/router/libev-4.22/configure       | 14121 ++++++++++++++++
 release/src/router/libev-4.22/configure.ac    |    27 +
 release/src/router/libev-4.22/depcomp         |   791 +
 release/src/router/libev-4.22/ev++.h          |   816 +
 release/src/router/libev-4.22/ev.3            |  5643 ++++++
 release/src/router/libev-4.22/ev.c            |  5097 ++++++
 release/src/router/libev-4.22/ev.h            |   854 +
 release/src/router/libev-4.22/ev.pod          |  5564 ++++++
 release/src/router/libev-4.22/ev_epoll.c      |   282 +
 release/src/router/libev-4.22/ev_kqueue.c     |   214 +
 release/src/router/libev-4.22/ev_poll.c       |   148 +
 release/src/router/libev-4.22/ev_port.c       |   185 +
 release/src/router/libev-4.22/ev_select.c     |   314 +
 release/src/router/libev-4.22/ev_vars.h       |   204 +
 release/src/router/libev-4.22/ev_win32.c      |   162 +
 release/src/router/libev-4.22/ev_wrap.h       |   200 +
 release/src/router/libev-4.22/event.c         |   425 +
 release/src/router/libev-4.22/event.h         |   177 +
 release/src/router/libev-4.22/install-sh      |   527 +
 release/src/router/libev-4.22/libev.m4        |    42 +
 release/src/router/libev-4.22/ltmain.sh       |  9661 +++++++++++
 release/src/router/libev-4.22/missing         |   215 +
 release/src/router/libev-4.22/mkinstalldirs   |   162 +
 release/src/router/rc/k3.c                    |    12 +
 release/src/router/rc/services.c              |    43 +
 release/src/router/rc/ubifs.c                 |    10 +-
 release/src/router/skipdbv2/CMakeLists.txt    |    65 +
 release/src/router/skipdbv2/LICENSE           |   340 +
 release/src/router/skipdbv2/README.md         |    38 +
 release/src/router/skipdbv2/basekit/BStream.c |   624 +
 release/src/router/skipdbv2/basekit/BStream.h |   131 +
 .../src/router/skipdbv2/basekit/BStreamTag.c  |    77 +
 .../src/router/skipdbv2/basekit/BStreamTag.h  |    41 +
 release/src/router/skipdbv2/basekit/Base.h    |    13 +
 release/src/router/skipdbv2/basekit/Common.c  |   311 +
 release/src/router/skipdbv2/basekit/Common.h  |   197 +
 .../router/skipdbv2/basekit/Common_inline.h   |    70 +
 .../src/router/skipdbv2/basekit/ConvertUTF.c  |   564 +
 .../src/router/skipdbv2/basekit/ConvertUTF.h  |   149 +
 release/src/router/skipdbv2/basekit/Date.c    |   339 +
 release/src/router/skipdbv2/basekit/Date.h    |    94 +
 release/src/router/skipdbv2/basekit/Datum.c   |   329 +
 release/src/router/skipdbv2/basekit/Datum.h   |    67 +
 .../src/router/skipdbv2/basekit/Duration.c    |   212 +
 .../src/router/skipdbv2/basekit/Duration.h    |    63 +
 release/src/router/skipdbv2/basekit/DynLib.c  |   234 +
 release/src/router/skipdbv2/basekit/DynLib.h  |    55 +
 release/src/router/skipdbv2/basekit/List.c    |   247 +
 release/src/router/skipdbv2/basekit/List.h    |    96 +
 .../src/router/skipdbv2/basekit/List_inline.h |   403 +
 .../src/router/skipdbv2/basekit/MainArgs.c    |    56 +
 .../src/router/skipdbv2/basekit/MainArgs.h    |    35 +
 release/src/router/skipdbv2/basekit/PHash.c   |   271 +
 release/src/router/skipdbv2/basekit/PHash.h   |    74 +
 .../router/skipdbv2/basekit/PHash_inline.h    |   193 +
 .../skipdbv2/basekit/PortableGettimeofday.c   |    57 +
 .../skipdbv2/basekit/PortableGettimeofday.h   |    43 +
 .../skipdbv2/basekit/PortableSnprintf.c       |   959 ++
 .../router/skipdbv2/basekit/PortableStdint.h  |   106 +
 .../router/skipdbv2/basekit/PortableStrlcpy.c |    61 +
 .../router/skipdbv2/basekit/PortableStrlcpy.h |     9 +
 .../skipdbv2/basekit/PortableStrptime.c       |   400 +
 .../skipdbv2/basekit/PortableStrptime.h       |    13 +
 .../skipdbv2/basekit/PortableTruncate.c       |    44 +
 .../skipdbv2/basekit/PortableTruncate.h       |    21 +
 .../router/skipdbv2/basekit/PortableUsleep.c  |    32 +
 .../router/skipdbv2/basekit/PortableUsleep.h  |    10 +
 .../src/router/skipdbv2/basekit/RandomGen.c   |   324 +
 .../src/router/skipdbv2/basekit/RandomGen.h   |    38 +
 release/src/router/skipdbv2/basekit/SHash.c   |   269 +
 release/src/router/skipdbv2/basekit/SHash.h   |    80 +
 .../router/skipdbv2/basekit/SHash_inline.h    |   173 +
 release/src/router/skipdbv2/basekit/Sorting.c |    96 +
 release/src/router/skipdbv2/basekit/Sorting.h |    32 +
 release/src/router/skipdbv2/basekit/Stack.c   |   138 +
 release/src/router/skipdbv2/basekit/Stack.h   |    82 +
 .../router/skipdbv2/basekit/Stack_inline.h    |   162 +
 release/src/router/skipdbv2/basekit/UArray.c  |  1309 ++
 release/src/router/skipdbv2/basekit/UArray.h  |   455 +
 .../skipdbv2/basekit/UArray_character.c       |    39 +
 .../skipdbv2/basekit/UArray_character.h       |    21 +
 .../router/skipdbv2/basekit/UArray_format.c   |   122 +
 .../router/skipdbv2/basekit/UArray_format.h   |    11 +
 .../src/router/skipdbv2/basekit/UArray_math.c |   677 +
 .../src/router/skipdbv2/basekit/UArray_math.h |   112 +
 .../src/router/skipdbv2/basekit/UArray_path.c |   138 +
 .../src/router/skipdbv2/basekit/UArray_path.h |    51 +
 .../router/skipdbv2/basekit/UArray_stream.c   |   146 +
 .../router/skipdbv2/basekit/UArray_stream.h   |    20 +
 .../router/skipdbv2/basekit/UArray_string.c   |   506 +
 .../router/skipdbv2/basekit/UArray_string.h   |    72 +
 .../src/router/skipdbv2/basekit/UArray_utf.c  |   310 +
 .../src/router/skipdbv2/basekit/UArray_utf.h  |    18 +
 .../skipdbv2/basekit/simd_cph/LICENSE.txt     |    28 +
 .../basekit/simd_cph/docs/LICENSE.txt         |    28 +
 .../basekit/simd_cph/include/simd_cp.h        |   134 +
 .../simd_cph/include/simd_cp_arm-iwmmx.h      |   281 +
 .../basekit/simd_cph/include/simd_cp_emu.h    |   324 +
 .../basekit/simd_cph/include/simd_cp_x86.h    |   246 +
 .../skipdbv2/basekit/simd_cph/simd_cph.readme |   111 +
 .../skipdbv2/basekit/simd_cph/test/Makefile   |    25 +
 .../basekit/simd_cph/test/test_simd.c         |   109 +
 .../basekit/simd_cph/test/test_simd_emu       |   Bin 0 -> 16756 bytes
 release/src/router/skipdbv2/client/skbus.c    |   167 +
 release/src/router/skipdbv2/debug.txt         |     2 +
 release/src/router/skipdbv2/jfile/JFile.c     |   529 +
 release/src/router/skipdbv2/jfile/JFile.h     |   105 +
 release/src/router/skipdbv2/libev/ev++.h      |   816 +
 release/src/router/skipdbv2/libev/ev.h        |   854 +
 release/src/router/skipdbv2/mgr/array-heap.c  |    49 +
 release/src/router/skipdbv2/mgr/array-heap.h  |    16 +
 release/src/router/skipdbv2/mgr/coroutine.h   |    39 +
 release/src/router/skipdbv2/mgr/daemonize.c   |    91 +
 release/src/router/skipdbv2/mgr/dbapi.c       |   323 +
 release/src/router/skipdbv2/mgr/dbus.c        |   656 +
 release/src/router/skipdbv2/mgr/skipd.c       |  1506 ++
 release/src/router/skipdbv2/mgr/skipd.h       |    60 +
 .../router/skipdbv2/mgr/unix-echo-client.c    |   148 +
 .../router/skipdbv2/mgr/unix-echo-server.c    |   198 +
 release/src/router/skipdbv2/skipdb/SkipDB.c   |   915 +
 release/src/router/skipdbv2/skipdb/SkipDB.h   |   172 +
 .../src/router/skipdbv2/skipdb/SkipDBCursor.c |    97 +
 .../src/router/skipdbv2/skipdb/SkipDBCursor.h |    48 +
 .../src/router/skipdbv2/skipdb/SkipDBRecord.c |   739 +
 .../src/router/skipdbv2/skipdb/SkipDBRecord.h |   141 +
 release/src/router/skipdbv2/tests/check.sh    |    13 +
 release/src/router/skipdbv2/tests/env.c       |    27 +
 release/src/router/skipdbv2/tests/example.c   |    70 +
 release/src/router/skipdbv2/tests/jftest.c    |    30 +
 release/src/router/skipdbv2/tests/remove.sh   |    10 +
 release/src/router/skipdbv2/tests/skiplist.c  |   185 +
 release/src/router/skipdbv2/tests/test.c      |   162 +
 release/src/router/skipdbv2/tests/test.sh     |    14 +
 release/src/router/skipdbv2/tests/test2.c     |   174 +
 release/src/router/skipdbv2/tests/udbtest.c   |    66 +
 release/src/router/skipdbv2/udb/UDB.c         |   378 +
 release/src/router/skipdbv2/udb/UDB.h         |    80 +
 release/src/router/skipdbv2/udb/UDBIndex.c    |   198 +
 release/src/router/skipdbv2/udb/UDBIndex.h    |    66 +
 release/src/router/skipdbv2/udb/UDBRecord.c   |   169 +
 release/src/router/skipdbv2/udb/UDBRecord.h   |    72 +
 release/src/router/skipdbv2/udb/UDBRecords.c  |   234 +
 release/src/router/skipdbv2/udb/UDBRecords.h  |    69 +
 release/src/router/softcenter/Makefile        |    61 +
 release/src/router/softcenter/jffsinit.sh     |    84 +
 release/src/router/softcenter/koolshare-reset |    26 +
 .../router/softcenter/softcenter/.soft_ver    |     1 +
 .../src/router/softcenter/softcenter/.valid   |     1 +
 .../softcenter/softcenter/bin/base64_encode   |   Bin 0 -> 4424 bytes
 .../softcenter/softcenter/bin/helper.sh       |    37 +
 .../src/router/softcenter/softcenter/bin/htop |   Bin 0 -> 426824 bytes
 .../router/softcenter/softcenter/bin/httpdb   |   Bin 0 -> 620104 bytes
 .../softcenter/bin/ks-mount-start.sh          |    26 +
 .../softcenter/softcenter/bin/ks-nat-start.sh |    31 +
 .../softcenter/bin/ks-services-start.sh       |    33 +
 .../softcenter/softcenter/bin/ks-unmount.sh   |    25 +
 .../softcenter/softcenter/bin/ks-wan-start.sh |    34 +
 .../softcenter/softcenter/bin/kscore.sh       |    67 +
 .../router/softcenter/softcenter/bin/perpboot |   Bin 0 -> 11472 bytes
 .../router/softcenter/softcenter/bin/perpctl  |   Bin 0 -> 11364 bytes
 .../router/softcenter/softcenter/bin/perpd    |   Bin 0 -> 24012 bytes
 .../router/softcenter/softcenter/bin/perphup  |   Bin 0 -> 9008 bytes
 .../router/softcenter/softcenter/bin/perpls   |   Bin 0 -> 13532 bytes
 .../router/softcenter/softcenter/bin/perpok   |   Bin 0 -> 10940 bytes
 .../router/softcenter/softcenter/bin/perpstat |   Bin 0 -> 13084 bytes
 .../router/softcenter/softcenter/bin/sissylog |   Bin 0 -> 6584 bytes
 .../softcenter/bin/start-stop-daemon          |   Bin 0 -> 22548 bytes
 .../router/softcenter/softcenter/bin/tinylog  |   Bin 0 -> 15380 bytes
 .../softcenter/softcenter/bin/versioncmp      |   Bin 0 -> 4824 bytes
 .../softcenter/softcenter/init.d/S01softok.sh |    43 +
 .../softcenter/softcenter/init.d/V01softok.sh |    30 +
 .../softcenter/softcenter/perp/.boot/rc.log   |     3 +
 .../softcenter/softcenter/perp/.boot/rc.perp  |     2 +
 .../softcenter/perp/.control/perpd.pid        |     1 +
 .../softcenter/softcenter/perp/httpdb/rc.main |     7 +
 .../router/softcenter/softcenter/perp/perp.sh |    34 +
 .../softcenter/res/icon-default.png           |   Bin 0 -> 5486 bytes
 .../softcenter/softcenter/res/koolshare.png   |   Bin 0 -> 2574 bytes
 .../softcenter/softcenter/res/layer/layer.js  |   652 +
 .../softcenter/res/layer/mobile/layer.js      |     2 +
 .../res/layer/mobile/need/layer.css           |     1 +
 .../res/layer/theme/default/icon-ext.png      |   Bin 0 -> 5911 bytes
 .../res/layer/theme/default/icon.png          |   Bin 0 -> 11493 bytes
 .../res/layer/theme/default/layer.css         |   795 +
 .../res/layer/theme/default/loading-0.gif     |   Bin 0 -> 5793 bytes
 .../res/layer/theme/default/loading-1.gif     |   Bin 0 -> 701 bytes
 .../res/layer/theme/default/loading-2.gif     |   Bin 0 -> 1787 bytes
 .../softcenter/softcenter/res/proceding.gif   |   Bin 0 -> 1150 bytes
 .../softcenter/softcenter/res/softcenter.css  |    64 +
 .../softcenter/softcenter/res/softcenter.js   |   131 +
 .../softcenter/softcenter/res/upgrade.png     |   Bin 0 -> 14302 bytes
 .../softcenter/softcenter/scripts/base.sh     |    14 +
 .../softcenter/scripts/dummy_script.sh        |     5 +
 .../softcenter/scripts/ks_app_install.sh      |   285 +
 .../softcenter/scripts/ks_tar_install.sh      |   153 +
 .../softcenter/webs/Module_Softcenter.asp     |   752 +
 .../softcenter/webs/Module_Softsetting.asp    |   191 +
 .../router/www/images/New_ui/softcenter.png   |   Bin 0 -> 1344 bytes
 release/src/router/www/index_style.css        |     4 +
 .../menuTree_bwdpi_no_traffic_analyzer.js     |    16 +
 .../menuTree_bwdpi_traffic_analyzer.js        |    16 +
 .../require/menuTrees/menuTree_no_bwdpi.js    |    16 +
 release/src/router/www/state.js               |    21 +-
 223 files changed, 88264 insertions(+), 5 deletions(-)
 create mode 100755 release/src/router/httpd/prebuild/RT-AC3100/httpd_bin
 create mode 100644 release/src/router/libev-4.22/Changes
 create mode 100644 release/src/router/libev-4.22/LICENSE
 create mode 100644 release/src/router/libev-4.22/Makefile.am
 create mode 100644 release/src/router/libev-4.22/Makefile.in
 create mode 100644 release/src/router/libev-4.22/README
 create mode 100644 release/src/router/libev-4.22/Symbols.ev
 create mode 100644 release/src/router/libev-4.22/Symbols.event
 create mode 100644 release/src/router/libev-4.22/aclocal.m4
 create mode 100644 release/src/router/libev-4.22/autogen.sh
 create mode 100755 release/src/router/libev-4.22/compile
 create mode 100755 release/src/router/libev-4.22/config.guess
 create mode 100644 release/src/router/libev-4.22/config.h.in
 create mode 100755 release/src/router/libev-4.22/config.sub
 create mode 100755 release/src/router/libev-4.22/configure
 create mode 100644 release/src/router/libev-4.22/configure.ac
 create mode 100755 release/src/router/libev-4.22/depcomp
 create mode 100644 release/src/router/libev-4.22/ev++.h
 create mode 100644 release/src/router/libev-4.22/ev.3
 create mode 100644 release/src/router/libev-4.22/ev.c
 create mode 100644 release/src/router/libev-4.22/ev.h
 create mode 100644 release/src/router/libev-4.22/ev.pod
 create mode 100644 release/src/router/libev-4.22/ev_epoll.c
 create mode 100644 release/src/router/libev-4.22/ev_kqueue.c
 create mode 100644 release/src/router/libev-4.22/ev_poll.c
 create mode 100644 release/src/router/libev-4.22/ev_port.c
 create mode 100644 release/src/router/libev-4.22/ev_select.c
 create mode 100644 release/src/router/libev-4.22/ev_vars.h
 create mode 100644 release/src/router/libev-4.22/ev_win32.c
 create mode 100644 release/src/router/libev-4.22/ev_wrap.h
 create mode 100644 release/src/router/libev-4.22/event.c
 create mode 100644 release/src/router/libev-4.22/event.h
 create mode 100755 release/src/router/libev-4.22/install-sh
 create mode 100644 release/src/router/libev-4.22/libev.m4
 create mode 100644 release/src/router/libev-4.22/ltmain.sh
 create mode 100755 release/src/router/libev-4.22/missing
 create mode 100755 release/src/router/libev-4.22/mkinstalldirs
 create mode 100644 release/src/router/skipdbv2/CMakeLists.txt
 create mode 100644 release/src/router/skipdbv2/LICENSE
 create mode 100644 release/src/router/skipdbv2/README.md
 create mode 100644 release/src/router/skipdbv2/basekit/BStream.c
 create mode 100644 release/src/router/skipdbv2/basekit/BStream.h
 create mode 100644 release/src/router/skipdbv2/basekit/BStreamTag.c
 create mode 100644 release/src/router/skipdbv2/basekit/BStreamTag.h
 create mode 100644 release/src/router/skipdbv2/basekit/Base.h
 create mode 100644 release/src/router/skipdbv2/basekit/Common.c
 create mode 100644 release/src/router/skipdbv2/basekit/Common.h
 create mode 100644 release/src/router/skipdbv2/basekit/Common_inline.h
 create mode 100644 release/src/router/skipdbv2/basekit/ConvertUTF.c
 create mode 100644 release/src/router/skipdbv2/basekit/ConvertUTF.h
 create mode 100644 release/src/router/skipdbv2/basekit/Date.c
 create mode 100644 release/src/router/skipdbv2/basekit/Date.h
 create mode 100644 release/src/router/skipdbv2/basekit/Datum.c
 create mode 100644 release/src/router/skipdbv2/basekit/Datum.h
 create mode 100644 release/src/router/skipdbv2/basekit/Duration.c
 create mode 100644 release/src/router/skipdbv2/basekit/Duration.h
 create mode 100644 release/src/router/skipdbv2/basekit/DynLib.c
 create mode 100644 release/src/router/skipdbv2/basekit/DynLib.h
 create mode 100644 release/src/router/skipdbv2/basekit/List.c
 create mode 100644 release/src/router/skipdbv2/basekit/List.h
 create mode 100644 release/src/router/skipdbv2/basekit/List_inline.h
 create mode 100644 release/src/router/skipdbv2/basekit/MainArgs.c
 create mode 100644 release/src/router/skipdbv2/basekit/MainArgs.h
 create mode 100644 release/src/router/skipdbv2/basekit/PHash.c
 create mode 100644 release/src/router/skipdbv2/basekit/PHash.h
 create mode 100644 release/src/router/skipdbv2/basekit/PHash_inline.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableGettimeofday.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableGettimeofday.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableSnprintf.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableStdint.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableStrlcpy.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableStrlcpy.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableStrptime.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableStrptime.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableTruncate.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableTruncate.h
 create mode 100644 release/src/router/skipdbv2/basekit/PortableUsleep.c
 create mode 100644 release/src/router/skipdbv2/basekit/PortableUsleep.h
 create mode 100644 release/src/router/skipdbv2/basekit/RandomGen.c
 create mode 100644 release/src/router/skipdbv2/basekit/RandomGen.h
 create mode 100644 release/src/router/skipdbv2/basekit/SHash.c
 create mode 100644 release/src/router/skipdbv2/basekit/SHash.h
 create mode 100644 release/src/router/skipdbv2/basekit/SHash_inline.h
 create mode 100644 release/src/router/skipdbv2/basekit/Sorting.c
 create mode 100644 release/src/router/skipdbv2/basekit/Sorting.h
 create mode 100644 release/src/router/skipdbv2/basekit/Stack.c
 create mode 100644 release/src/router/skipdbv2/basekit/Stack.h
 create mode 100644 release/src/router/skipdbv2/basekit/Stack_inline.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_character.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_character.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_format.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_format.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_math.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_math.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_path.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_path.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_stream.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_stream.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_string.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_string.h
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_utf.c
 create mode 100644 release/src/router/skipdbv2/basekit/UArray_utf.h
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/LICENSE.txt
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/docs/LICENSE.txt
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp.h
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_arm-iwmmx.h
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_emu.h
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_x86.h
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/simd_cph.readme
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/test/Makefile
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/test/test_simd.c
 create mode 100644 release/src/router/skipdbv2/basekit/simd_cph/test/test_simd_emu
 create mode 100644 release/src/router/skipdbv2/client/skbus.c
 create mode 100644 release/src/router/skipdbv2/debug.txt
 create mode 100644 release/src/router/skipdbv2/jfile/JFile.c
 create mode 100644 release/src/router/skipdbv2/jfile/JFile.h
 create mode 100644 release/src/router/skipdbv2/libev/ev++.h
 create mode 100644 release/src/router/skipdbv2/libev/ev.h
 create mode 100644 release/src/router/skipdbv2/mgr/array-heap.c
 create mode 100644 release/src/router/skipdbv2/mgr/array-heap.h
 create mode 100644 release/src/router/skipdbv2/mgr/coroutine.h
 create mode 100644 release/src/router/skipdbv2/mgr/daemonize.c
 create mode 100644 release/src/router/skipdbv2/mgr/dbapi.c
 create mode 100644 release/src/router/skipdbv2/mgr/dbus.c
 create mode 100644 release/src/router/skipdbv2/mgr/skipd.c
 create mode 100644 release/src/router/skipdbv2/mgr/skipd.h
 create mode 100644 release/src/router/skipdbv2/mgr/unix-echo-client.c
 create mode 100644 release/src/router/skipdbv2/mgr/unix-echo-server.c
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDB.c
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDB.h
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDBCursor.c
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDBCursor.h
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDBRecord.c
 create mode 100644 release/src/router/skipdbv2/skipdb/SkipDBRecord.h
 create mode 100644 release/src/router/skipdbv2/tests/check.sh
 create mode 100644 release/src/router/skipdbv2/tests/env.c
 create mode 100644 release/src/router/skipdbv2/tests/example.c
 create mode 100644 release/src/router/skipdbv2/tests/jftest.c
 create mode 100644 release/src/router/skipdbv2/tests/remove.sh
 create mode 100644 release/src/router/skipdbv2/tests/skiplist.c
 create mode 100644 release/src/router/skipdbv2/tests/test.c
 create mode 100755 release/src/router/skipdbv2/tests/test.sh
 create mode 100644 release/src/router/skipdbv2/tests/test2.c
 create mode 100644 release/src/router/skipdbv2/tests/udbtest.c
 create mode 100644 release/src/router/skipdbv2/udb/UDB.c
 create mode 100644 release/src/router/skipdbv2/udb/UDB.h
 create mode 100644 release/src/router/skipdbv2/udb/UDBIndex.c
 create mode 100644 release/src/router/skipdbv2/udb/UDBIndex.h
 create mode 100644 release/src/router/skipdbv2/udb/UDBRecord.c
 create mode 100644 release/src/router/skipdbv2/udb/UDBRecord.h
 create mode 100644 release/src/router/skipdbv2/udb/UDBRecords.c
 create mode 100644 release/src/router/skipdbv2/udb/UDBRecords.h
 create mode 100755 release/src/router/softcenter/Makefile
 create mode 100755 release/src/router/softcenter/jffsinit.sh
 create mode 100755 release/src/router/softcenter/koolshare-reset
 create mode 100644 release/src/router/softcenter/softcenter/.soft_ver
 create mode 100644 release/src/router/softcenter/softcenter/.valid
 create mode 100755 release/src/router/softcenter/softcenter/bin/base64_encode
 create mode 100755 release/src/router/softcenter/softcenter/bin/helper.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/htop
 create mode 100755 release/src/router/softcenter/softcenter/bin/httpdb
 create mode 100755 release/src/router/softcenter/softcenter/bin/ks-mount-start.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/ks-nat-start.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/ks-services-start.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/ks-unmount.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/ks-wan-start.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/kscore.sh
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpboot
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpctl
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpd
 create mode 100755 release/src/router/softcenter/softcenter/bin/perphup
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpls
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpok
 create mode 100755 release/src/router/softcenter/softcenter/bin/perpstat
 create mode 100755 release/src/router/softcenter/softcenter/bin/sissylog
 create mode 100755 release/src/router/softcenter/softcenter/bin/start-stop-daemon
 create mode 100755 release/src/router/softcenter/softcenter/bin/tinylog
 create mode 100755 release/src/router/softcenter/softcenter/bin/versioncmp
 create mode 100755 release/src/router/softcenter/softcenter/init.d/S01softok.sh
 create mode 100755 release/src/router/softcenter/softcenter/init.d/V01softok.sh
 create mode 100755 release/src/router/softcenter/softcenter/perp/.boot/rc.log
 create mode 100755 release/src/router/softcenter/softcenter/perp/.boot/rc.perp
 create mode 100644 release/src/router/softcenter/softcenter/perp/.control/perpd.pid
 create mode 100755 release/src/router/softcenter/softcenter/perp/httpdb/rc.main
 create mode 100755 release/src/router/softcenter/softcenter/perp/perp.sh
 create mode 100644 release/src/router/softcenter/softcenter/res/icon-default.png
 create mode 100644 release/src/router/softcenter/softcenter/res/koolshare.png
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/layer.js
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/mobile/layer.js
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/mobile/need/layer.css
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/icon-ext.png
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/icon.png
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/layer.css
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/loading-0.gif
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/loading-1.gif
 create mode 100644 release/src/router/softcenter/softcenter/res/layer/theme/default/loading-2.gif
 create mode 100644 release/src/router/softcenter/softcenter/res/proceding.gif
 create mode 100644 release/src/router/softcenter/softcenter/res/softcenter.css
 create mode 100644 release/src/router/softcenter/softcenter/res/softcenter.js
 create mode 100755 release/src/router/softcenter/softcenter/res/upgrade.png
 create mode 100755 release/src/router/softcenter/softcenter/scripts/base.sh
 create mode 100755 release/src/router/softcenter/softcenter/scripts/dummy_script.sh
 create mode 100755 release/src/router/softcenter/softcenter/scripts/ks_app_install.sh
 create mode 100755 release/src/router/softcenter/softcenter/scripts/ks_tar_install.sh
 create mode 100644 release/src/router/softcenter/softcenter/webs/Module_Softcenter.asp
 create mode 100644 release/src/router/softcenter/softcenter/webs/Module_Softsetting.asp
 create mode 100755 release/src/router/www/images/New_ui/softcenter.png

diff --git a/release/src-rt/Makefile b/release/src-rt/Makefile
index bb6b28a8a1..ffcbf1ed1a 100755
--- a/release/src-rt/Makefile
+++ b/release/src-rt/Makefile
@@ -3607,6 +3607,10 @@ define RouterOptions
 		sed -i "/RTCONFIG_WIFI6E/d" $(1); \
 		echo "RTCONFIG_WIFI6E=y" >>$(1); \
 	fi; \
+	if [ "$(SOFTCENTER)" = "y" ]; then \
+	sed -i "/RTCONFIG_SOFTCENTER/d" $(1); \
+	echo "RTCONFIG_SOFTCENTER=y" >>$(1); \
+	fi; \
 	if [ "$(VAR_NVRAM)" = "y" ]; then \
 		sed -i "/RTCONFIG_VAR_NVRAM/d" $(1); \
 		echo "RTCONFIG_VAR_NVRAM=y" >>$(1); \
diff --git a/release/src-rt/target.mak b/release/src-rt/target.mak
index 73ecb2bd69..8dfc1f3eaa 100644
--- a/release/src-rt/target.mak
+++ b/release/src-rt/target.mak
@@ -209,7 +209,7 @@ export RT-K3 := $(RT-AC88U_BASE)
 export RT-K3 += BUILD_NAME="RT-K3" SWITCH2="" BCM_MMC=n BCM_7114=y NOWLALL=n ETLAN_LED=n ROMCFE=y \
 		NVSIZE="128" NOWL=y DHDAP=y DPSTA=y BCMFA=n GMAC3=y LACP=y WTFAST=y \
 		FORCE_SN="380" FORCE_EN="664" DISABLE_REPEATER_UI=n NEWSSID_REV2=y \
-		BRCM_NAND_JFFS2=n JFFS2LOG=n UBI=y UBIFS=y PSISTLOG=y
+		BRCM_NAND_JFFS2=n JFFS2LOG=n UBI=y UBIFS=y PSISTLOG=y SOFTCENTER=y
 
 export RT-AC5300 := $(RT-AC88U_BASE)
 export RT-AC5300 += BUILD_NAME="RT-AC5300" RGMII_BRCM5301X=y SWITCH2="" BCM_MMC=n BCM_7114=y ETLAN_LED=y \
diff --git a/release/src/router/Makefile b/release/src/router/Makefile
index 00b1d15431..e87137704d 100644
--- a/release/src/router/Makefile
+++ b/release/src/router/Makefile
@@ -890,6 +890,9 @@ ifeq ($(RTK3),y)
 obj-y += k3screenctrl
 #obj-y += bash
 endif
+ifeq ($(RTCONFIG_SOFTCENTER),y)
+obj-y += skipdbv2 libev-4.22 softcenter libiconv-1.14
+endif
 obj-y += httpd json-c
 obj-$(RTCONFIG_VISUALIZATION) += sqlite3 json-c libxml2 visdcoll visdcon
 obj-y += www
@@ -2576,6 +2579,9 @@ ifeq ($(RTK3),y)
 	$(MAKE) k3screenctrl-clean
 #	$(MAKE) bash-clean
 endif
+ifeq ($(RTCONFIG_SOFTCENTER),y)
+	$(MAKE) skipdbv2-clean libev-4.22-clean
+endif
 ifeq ($(RTCONFIG_BCMARM),y)
 	$(MAKE) compressed-clean
 endif
@@ -3623,6 +3629,55 @@ k3screenctrl-install: k3screenctrl
 	$(STRIP) $(INSTALLDIR)/k3screenctrl/usr/sbin/k3screenctrl
 	$(STRIP) $(INSTALLDIR)/k3screenctrl/usr/sbin/k3screenbg
 
+libev-4.22/configure:
+	cd libev-4.22 && ./autogen.sh
+
+libev-4.22/Makefile: libev-4.22/configure
+	cd libev-4.22 && $(CONFIGURE)\
+		--target=arm-linux --host=arm-linux --build=x86_64-linux-gnu --program-prefix= --program-suffix= \
+		--prefix=/usr --exec-prefix=/usr --bindir=/usr/bin --sbindir=/usr/sbin --libexecdir=/usr/lib --sysconfdir=/etc \
+		--datadir=/usr/share --localstatedir=/var --mandir=/usr/man --infodir=/usr/info --disable-nls --enable-shared --enable-static
+
+libev-4.22: libev-4.22/Makefile
+	$(MAKE) -C $@ && $(MAKE) $@-stage
+
+libev-4.22-clean:
+	[ ! -f libev-4.22/Makefile ] || $(MAKE) -C libev-4.22 -f Makefile distclean
+	@rm -f libev.la
+	@rm -f libev-4.22/stamp-h1
+	@rm -f libev-4.22/.libs
+	@rm -f libev-4.22/.deps
+
+libev-4.22-install:
+	install -D $(STAGEDIR)/usr/lib/libev.so.4.0.0 $(INSTALLDIR)/libev-4.22/usr/lib/libev.so.4.0.0
+	$(STRIP) $(INSTALLDIR)/libev-4.22/usr/lib/libev.so.4.0.0
+	cd $(INSTALLDIR)/libev-4.22/usr/lib && \
+		ln -sf libev.so.4.0.0 libev.so.4 && \
+		ln -sf libev.so.4.0.0 libev.so
+
+skipdbv2/Makefile: skipdbv2/CMakeLists.txt
+	cd skipdbv2 && cmake -DCMAKE_INSTALL_PREFIX=/usr \
+	-DCMAKE_BUILD_TYPE=Release \
+	-DCMAKE_EXE_LINKER_FLAGS="-L$(STAGEDIR)/usr/lib -lev"
+
+skipdbv2: libev-4.22 skipdbv2/Makefile
+	$(MAKE) -C $@
+
+skipdbv2-clean:
+	[ ! -f skipdbv2/Makefile ] || $(MAKE) -C skipdbv2 -f Makefile clean
+	@rm -rf skipdbv2/bin
+	@rm -rf skipdbv2/lib
+	@rm -rf skipdbv2/CMakeFiles
+	@rm -f skipdbv2/CMakeCache.txt
+	@rm -f skipdbv2/cmake_install.cmake
+	@rm -f skipdbv2/Makefile
+
+skipdbv2-install: skipdbv2
+	install -D skipdbv2/bin/skipd $(INSTALLDIR)/skipdbv2/usr/sbin/skipd
+	install -D skipdbv2/bin/dbus $(INSTALLDIR)/skipdbv2/usr/sbin/dbus
+	$(STRIP) $(INSTALLDIR)/skipdbv2/usr/sbin/skipd
+	$(STRIP) $(INSTALLDIR)/skipdbv2/usr/sbin/dbus
+
 miniupnpd/config.h: shared/version.h
 ifeq ($(RTCONFIG_IGD2),y)
 	cd miniupnpd && ./configure --vendorcfg --leasefile $(if $(RTCONFIG_IPV6),--ipv6,) --igd2 --portinuse $(if $(RTCONFIG_AURASYNC),--aurasync,) $(if $(RTCONFIG_GEFORCENOW),--nvgfn) --iptablespath=$(TOP)/$(IPTABLES)
diff --git a/release/src/router/config/config.in b/release/src/router/config/config.in
index 8ab32bb380..1742286315 100644
--- a/release/src/router/config/config.in
+++ b/release/src/router/config/config.in
@@ -2392,6 +2392,10 @@ config RTCONFIG_WIFI6E
 	bool "WiFi 6E"
 	default n
 
+config RTCONFIG_SOFTCENTER
+	bool "softcenter"
+	default n
+
 config RTCONFIG_VAR_NVRAM
 	bool "save some nvram under /var"
 	default n
diff --git a/release/src/router/config_base b/release/src/router/config_base
index e239cce0a6..115f052ea7 100644
--- a/release/src/router/config_base
+++ b/release/src/router/config_base
@@ -566,6 +566,7 @@ RTCONFIG_FRS_LIVE_UPDATE=y
 # RTCONFIG_OUTFOX is not set
 # RTCONFIG_CAPTCHA is not set
 # RTCONFIG_WIFI6E is not set
+# RTCONFIG_SOFTCENTER is not set
 # RTCONFIG_VAR_NVRAM is not set
 # RTCONFIG_BCM_OAM is not set
 # RTCONFIG_QCA_PLC2 is not set
diff --git a/release/src/router/httpd/Makefile b/release/src/router/httpd/Makefile
index 3443e39044..d786784478 100644
--- a/release/src/router/httpd/Makefile
+++ b/release/src/router/httpd/Makefile
@@ -327,13 +327,17 @@ all: httpd #test_apps
 #test_apps: apps.c
 #	$(CC) -DAPPS $(CFLAGS) $(LIBS) $^ -o $@
 
+ifeq ($(wildcard ./prebuild/httpd),)
 httpd: $(OBJS)
 	@echo " [httpd] CC $@"
 	@$(CC) -o $@ $(OBJS) $(LIBS) $(EXTRALDFLAGS)
 
 	$(SIZECHECK)
 	$(CPTMP)
-
+else
+httpd:
+	@-cp -f ./prebuild/httpd_bin httpd
+endif
 
 install: all
 	@echo " [httpd] Installing to $(INSTALLDIR)"
diff --git a/release/src/router/httpd/prebuild/RT-AC3100/httpd_bin b/release/src/router/httpd/prebuild/RT-AC3100/httpd_bin
new file mode 100755
index 0000000000000000000000000000000000000000..6f12d0f08b81a7b24c5c8f5141679a605e374f80
GIT binary patch
literal 449813
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%0DQ|1NEVJynPS}xo5lIn
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

literal 0
HcmV?d00001

diff --git a/release/src/router/libev-4.22/Changes b/release/src/router/libev-4.22/Changes
new file mode 100644
index 0000000000..b9d9b16ed6
--- /dev/null
+++ b/release/src/router/libev-4.22/Changes
@@ -0,0 +1,517 @@
+Revision history for libev, a high-performance and full-featured event loop.
+
+TODO: ev_loop_wakeup
+TODO: EV_STANDALONE == NO_HASSEL (do not use clock_gettime in ev_standalone)
+TODO: faq, process a thing in each iteration
+TODO: dbeugging tips, ev_verify, ev_init twice
+TODO: ev_break for immediate exit (EVBREAK_NOW?)
+TODO: ev_feed_child_event
+TODO: document the special problem of signals around fork.
+TODO: store pid for each signal
+TODO: document file descriptor usage per loop
+TODO: store loop pid_t and compare isndie signal handler,store 1 for same, 2 for differign pid, clean up in loop_fork
+TODO: embed watchers need updating when fd changes
+TODO: document portability requirements for atomic pointer access
+TODO: document requirements for function pointers and calling conventions.
+
+4.22 Sun Dec 20 22:11:50 CET 2015
+	- when epoll detects unremovable fds in the fd set, rebuild
+          only the epoll descriptor, not the signal pipe, to avoid
+          SIGPIPE in ev_async_send. This doesn't solve it on fork,
+          so document what needs to be done in ev_loop_fork
+          (analyzed by Benjamin Mahler).
+	- remove superfluous sys/timeb.h include on win32
+          (analyzed by Jason Madden).
+        - updated libecb.
+
+4.20 Sat Jun 20 13:01:43 CEST 2015
+	- prefer noexcept over throw () with C++ 11.
+        - update ecb.h due to incompatibilities with c11.
+        - fix a potential aliasing issue when reading and writing
+          watcher callbacks.
+
+4.19 Thu Sep 25 08:18:25 CEST 2014
+	- ev.h wasn't valid C++ anymore, which tripped compilers other than
+          clang, msvc or gcc (analyzed by Raphael 'kena' Poss). Unfortunately,
+          C++ doesn't support typedefs for function pointers fully, so the affected
+          declarations have to spell out the types each time.
+	- when not using autoconf, tighten the check for clock_gettime and related
+          functionality.
+
+4.18 Fri Sep  5 17:55:26 CEST 2014
+	- events on files were not always generated properly with the
+          epoll backend (testcase by Assaf Inbal).
+	- mark event pipe fd as cloexec after a fork (analyzed by Sami Farin).
+        - (ecb) support m68k, m88k and sh (patch by Miod Vallat).
+        - use a reasonable fallback for EV_NSIG instead of erroring out
+          when we can't detect the signal set size.
+        - in the absence of autoconf, do not use the clock syscall
+          on glibc >= 2.17 (avoids the syscall AND -lrt on systems
+          doing clock_gettime in userspace).
+        - ensure extern "C" function pointers are used for externally-visible
+          loop callbacks (not watcher callbacks yet).
+        - (ecb) work around memory barriers and volatile apparently both being
+          broken in visual studio 2008 and later (analysed and patch by Nicolas Noble).
+
+4.15 Fri Mar  1 12:04:50 CET 2013
+        - destroying a non-default loop would stop the global waitpid
+          watcher (Denis Bilenko).
+	- queueing pending watchers of higher priority from a watcher now invokes
+          them in a timely fashion (reported by Denis Bilenko).
+	- add throw() to all libev functions that cannot throw exceptions, for
+          further code size decrease when compiling for C++.
+        - add throw () to callbacks that must not throw exceptions (allocator,
+          syserr, loop acquire/release, periodic reschedule cbs).
+	- fix event_base_loop return code, add event_get_callback, event_base_new,
+          event_base_get_method calls to improve libevent 1.x emulation and add
+          some libevent 2.x functionality (based on a patch by Jeff Davey).
+        - add more memory fences to fix a bug reported by Jeff Davey. Better
+          be overfenced than underprotected.
+	- ev_run now returns a boolean status (true meaning watchers are
+          still active).
+	- ev_once: undef EV_ERROR in ev_kqueue.c, to avoid clashing with
+          libev's EV_ERROR (reported by 191919).
+	- (ecb) add memory fence support for xlC (Darin McBride).
+	- (ecb) add memory fence support for gcc-mips (Anton Kirilov).
+	- (ecb) add memory fence support for gcc-alpha (Christian Weisgerber).
+        - work around some kernels losing file descriptors by leaking
+          the kqueue descriptor in the child.
+        - work around linux inotify not reporting IN_ATTRIB changes for directories
+          in many cases.
+        - include sys/syscall.h instead of plain syscall.h.
+        - check for io watcher loops in ev_verify, check for the most
+          common reported usage bug in ev_io_start.
+        - choose socket vs. WSASocket at compiletime using EV_USE_WSASOCKET.
+        - always use WSASend/WSARecv directly on windows, hoping that this
+          works in all cases (unlike read/write/send/recv...).
+        - try to detect signals around a fork faster (test program by
+          Denis Bilenko).
+        - work around recent glibc versions that leak memory in realloc.
+        - rename ev::embed::set to ev::embed::set_embed to avoid clashing
+          the watcher base set (loop) method.
+        - rewrite the async/signal pipe logic to always keep a valid fd, which
+          simplifies (and hopefully correctifies :) the race checking
+          on fork, at the cost of one extra fd.
+        - add fat, msdos, jffs2, ramfs, ntfs and btrfs to the list of
+          inotify-supporting filesystems.
+        - move orig_CFLAGS assignment to after AC_INIT, as newer autoconf
+          versions ignore it before
+          (https://bugzilla.redhat.com/show_bug.cgi?id=908096).
+        - add some untested android support.
+        - enum expressions must be of type int (reported by Juan Pablo L).
+
+4.11 Sat Feb  4 19:52:39 CET 2012
+	- INCOMPATIBLE CHANGE: ev_timer_again now clears the pending status, as
+          was documented already, but not implemented in the repeating case.
+        - new compiletime symbols: EV_NO_SMP and EV_NO_THREADS.
+	- fix a race where the workaround against the epoll fork bugs
+          caused signals to not be handled anymore.
+	- correct backend_fudge for most backends, and implement a windows
+          specific workaround to avoid looping because we call both
+          select and Sleep, both with different time resolutions.
+        - document range and guarantees of ev_sleep.
+        - document reasonable ranges for periodics interval and offset.
+        - rename backend_fudge to backend_mintime to avoid future confusion :)
+	- change the default periodic reschedule function to hopefully be more
+          exact and correct even in corner cases or in the far future.
+        - do not rely on -lm anymore: use it when available but use our
+          own floor () if it is missing. This should make it easier to embed,
+          as no external libraries are required.
+        - strategically import macros from libecb and mark rarely-used functions
+          as cache-cold (saving almost 2k code size on typical amd64 setups).
+        - add Symbols.ev and Symbols.event files, that were missing.
+        - fix backend_mintime value for epoll (was 1/1024, is 1/1000 now).
+        - fix #3 "be smart about timeouts" to not "deadlock" when
+          timeout == now, also improve the section overall.
+        - avoid "AVOIDING FINISHING BEFORE RETURNING" idiom.
+        - support new EV_API_STATIC mode to make all libev symbols
+          static.
+        - supply default CFLAGS of -g -O3 with gcc when original CFLAGS
+          were empty.
+
+4.04 Wed Feb 16 09:01:51 CET 2011
+	- fix two problems in the native win32 backend, where reuse of fd's
+          with different underlying handles caused handles not to be removed
+          or added to the select set (analyzed and tested by Bert Belder).
+	- do no rely on ceil() in ev_e?poll.c.
+        - backport libev to HP-UX versions before 11 v3.
+        - configure did not detect nanosleep and clock_gettime properly when
+          they are available in the libc (as opposed to -lrt).
+
+4.03 Tue Jan 11 14:37:25 CET 2011
+	- officially support polling files with all backends.
+	- support files, /dev/zero etc. the same way as select in the epoll
+          backend, by generating events on our own.
+        - ports backend: work around solaris bug 6874410 and many related ones
+          (EINTR, maybe more), with no performance loss (note that the solaris
+          bug report is actually wrong, reality is far more bizarre and broken
+          than that).
+	- define EV_READ/EV_WRITE as macros in event.h, as some programs use
+          #ifdef to test for them.
+        - new (experimental) function: ev_feed_signal.
+        - new (to become default) EVFLAG_NOSIGMASK flag.
+        - new EVBACKEND_MASK symbol.
+        - updated COMMON IDIOMS SECTION.
+
+4.01 Fri Nov  5 21:51:29 CET 2010
+        - automake fucked it up, apparently, --add-missing -f is not quite enough
+          to make it update its files, so 4.00 didn't install ev++.h and
+          event.h on make install. grrr.
+        - ev_loop(count|depth) didn't return anything (Robin Haberkorn).
+        - change EV_UNDEF to 0xffffffff to silence some overzealous compilers.
+        - use "(libev) " prefix for all libev error messages now.
+
+4.00 Mon Oct 25 12:32:12 CEST 2010
+	- "PORTING FROM LIBEV 3.X TO 4.X" (in ev.pod) is recommended reading.
+	- ev_embed_stop did not correctly stop the watcher (very good
+          testcase by Vladimir Timofeev).
+        - ev_run will now always update the current loop time - it erroneously
+          didn't when idle watchers were active, causing timers not to fire.
+        - fix a bug where a timeout of zero caused the timer not to fire
+          in the libevent emulation (testcase by Péter Szabó).
+	- applied win32 fixes by Michael Lenaghan (also James Mansion).
+	- replace EV_MINIMAL by EV_FEATURES.
+        - prefer EPOLL_CTL_ADD over EPOLL_CTL_MOD in some more cases, as it
+          seems the former is *much* faster than the latter.
+        - linux kernel version detection (for inotify bug workarounds)
+          did not work properly.
+        - reduce the number of spurious wake-ups with the ports backend.
+        - remove dependency on sys/queue.h on freebsd (patch by Vanilla Hsu).
+        - do async init within ev_async_start, not ev_async_set, which avoids
+          an API quirk where the set function must be called in the C++ API
+          even when there is nothing to set.
+        - add (undocumented) EV_ENABLE when adding events with kqueue,
+          this might help with OS X, which seems to need it despite documenting
+          not to need it (helpfully pointed out by Tilghman Lesher).
+        - do not use poll by default on freebsd, it's broken (what isn't
+          on freebsd...).
+        - allow to embed epoll on kernels >= 2.6.32.
+        - configure now prepends -O3, not appends it, so one can still
+          override it.
+        - ev.pod: greatly expanded the portability section, added a porting
+          section, a description of watcher states and made lots of minor fixes.
+        - disable poll backend on AIX, the poll header spams the namespace
+          and it's not worth working around dead platforms (reported
+          and analyzed by Aivars Kalvans).
+        - improve header file compatibility of the standalone eventfd code
+          in an obscure case.
+        - implement EV_AVOID_STDIO option.
+        - do not use sscanf to parse linux version number (smaller, faster,
+          no sscanf dependency).
+        - new EV_CHILD_ENABLE and EV_SIGNAL_ENABLE configurable settings.
+        - update libev.m4 HAVE_CLOCK_SYSCALL test for newer glibcs.
+        - add section on accept() problems to the manpage.
+        - rename EV_TIMEOUT to EV_TIMER.
+        - rename ev_loop_count/depth/verify/loop/unloop.
+        - remove ev_default_destroy and ev_default_fork.
+        - switch to two-digit minor version.
+        - work around an apparent gentoo compiler bug.
+        - define _DARWIN_UNLIMITED_SELECT. just so.
+        - use enum instead of #define for most constants.
+        - improve compatibility to older C++ compilers.
+        - (experimental) ev_run/ev_default_loop/ev_break/ev_loop_new have now
+          default arguments when compiled as C++.
+        - enable automake dependency tracking.
+        - ev_loop_new no longer leaks memory when loop creation failed.
+        - new ev_cleanup watcher type.
+
+3.9  Thu Dec 31 07:59:59 CET 2009
+	- signalfd is no longer used by default and has to be requested
+          explicitly - this means that easy to catch bugs become hard to
+          catch race conditions, but the users have spoken.
+        - point out the unspecified signal mask in the documentation, and
+          that this is a race condition regardless of EV_SIGNALFD.
+	- backport inotify code to C89.
+        - inotify file descriptors could leak into child processes.
+        - ev_stat watchers could keep an erroneous extra ref on the loop,
+          preventing exit when unregistering all watchers (testcases
+          provided by ry@tinyclouds.org).
+        - implement EV_WIN32_HANDLE_TO_FD and EV_WIN32_CLOSE_FD configuration
+          symbols to make it easier for apps to do their own fd management.
+        - support EV_IDLE_ENABLE being disabled in ev++.h
+          (patch by Didier Spezia).
+        - take advantage of inotify_init1, if available, to set cloexec/nonblock
+          on fd creation, to avoid races.
+        - the signal handling pipe wasn't always initialised under windows
+          (analysed by lekma).
+        - changed minimum glibc requirement from glibc 2.9 to 2.7, for
+          signalfd.
+        - add missing string.h include (Denis F. Latypoff).
+        - only replace ev_stat.prev when we detect an actual difference,
+          so prev is (almost) always different to attr. this might
+          have caused the problems with 04_stat.t.
+        - add ev::timer->remaining () method to C++ API.
+
+3.8  Sun Aug  9 14:30:45 CEST 2009
+	- incompatible change: do not necessarily reset signal handler
+          to SIG_DFL when a sighandler is stopped.
+        - ev_default_destroy did not properly free or zero some members,
+          potentially causing crashes and memory corruption on repeated
+          ev_default_destroy/ev_default_loop calls.
+	- take advantage of signalfd on GNU/Linux systems.
+	- document that the signal mask might be in an unspecified
+          state when using libev's signal handling.
+        - take advantage of some GNU/Linux calls to set cloexec/nonblock
+          on fd creation, to avoid race conditions.
+
+3.7  Fri Jul 17 16:36:32 CEST 2009
+	- ev_unloop and ev_loop wrongly used a global variable to exit loops,
+          instead of using a per-loop variable (bug caught by accident...).
+	- the ev_set_io_collect_interval interpretation has changed.
+        - add new functionality: ev_set_userdata, ev_userdata,
+          ev_set_invoke_pending_cb, ev_set_loop_release_cb,
+          ev_invoke_pending, ev_pending_count, together with a long example
+          about thread locking.
+        - add ev_timer_remaining (as requested by Denis F. Latypoff).
+        - add ev_loop_depth.
+        - calling ev_unloop in fork/prepare watchers will no longer poll
+          for new events.
+	- Denis F. Latypoff corrected many typos in example code snippets.
+        - honor autoconf detection of EV_USE_CLOCK_SYSCALL, also double-
+          check that the syscall number is available before trying to
+          use it (reported by ry@tinyclouds).
+        - use GetSystemTimeAsFileTime instead of _timeb on windows, for
+          slightly higher accuracy.
+        - properly declare ev_loop_verify and ev_now_update even when
+          !EV_MULTIPLICITY.
+        - do not compile in any priority code when EV_MAXPRI == EV_MINPRI.
+        - support EV_MINIMAL==2 for a reduced API.
+        - actually 0-initialise struct sigaction when installing signals.
+        - add section on hibernate and stopped processes to ev_timer docs.
+
+3.6  Tue Apr 28 02:49:30 CEST 2009
+	- multiple timers becoming ready within an event loop iteration
+          will be invoked in the "correct" order now.
+	- do not leave the event loop early just because we have no active
+          watchers, fixing a problem when embedding a kqueue loop
+          that has active kernel events but no registered watchers
+          (reported by blacksand blacksand).
+	- correctly zero the idx values for arrays, so destroying and
+          reinitialising the default loop actually works (patch by
+          Malek Hadj-Ali).
+        - implement ev_suspend and ev_resume.
+        - new EV_CUSTOM revents flag for use by applications.
+        - add documentation section about priorities.
+        - add a glossary to the documentation.
+        - extend the ev_fork description slightly.
+        - optimize a jump out of call_pending.
+
+3.53 Sun Feb 15 02:38:20 CET 2009
+	- fix a bug in event pipe creation on win32 that would cause a
+          failed assertion on event loop creation (patch by Malek Hadj-Ali).
+	- probe for CLOCK_REALTIME support at runtime as well and fall
+          back to gettimeofday if there is an error, to support older
+          operating systems with newer header files/libraries.
+        - prefer gettimeofday over clock_gettime with USE_CLOCK_SYSCALL
+          (default most everywhere), otherwise not.
+
+3.52 Wed Jan  7 21:43:02 CET 2009
+	- fix compilation of select backend in fd_set mode when NFDBITS is
+          missing (to get it to compile on QNX, reported by Rodrigo Campos).
+        - better select-nfds handling when select backend is in fd_set mode.
+        - diagnose fd_set overruns when select backend is in fd_set mode.
+        - due to a thinko, instead of disabling everything but
+          select on the borked OS X platform, everything but select was
+          allowed (reported by Emanuele Giaquinta).
+        - actually verify that local and remote port are matching in
+          libev's socketpair emulation, which makes denial-of-service
+          attacks harder (but not impossible - it's windows). Make sure
+          it even works under vista, which thinks that getpeer/sockname
+          should return fantasy port numbers.
+        - include "libev" in all assertion messages for potentially
+          clearer diagnostics.
+        - event_get_version (libevent compatibility) returned
+          a useless string instead of the expected version string
+          (patch by W.C.A. Wijngaards).
+
+3.51 Wed Dec 24 23:00:11 CET 2008
+        - fix a bug where an inotify watcher was added twice, causing
+          freezes on hash collisions (reported and analysed by Graham Leggett).
+	- new config symbol, EV_USE_CLOCK_SYSCALL, to make libev use
+          a direct syscall - slower, but no dependency on librt et al.
+        - assume negative return values != -1 signals success of port_getn
+          (http://cvs.epicsol.org/cgi/viewcvs.cgi/epic5/source/newio.c?rev=1.52)
+          (no known failure reports, but it doesn't hurt).
+        - fork detection in ev_embed now stops and restarts the watcher
+          automatically.
+        - EXPERIMENTAL: default the method to operator () in ev++.h,
+          to make it nicer to use functors (requested by Benedek László).
+        - fixed const object callbacks in ev++.h.
+        - replaced loop_ref argument of watcher.set (loop) by a direct
+          ev_loop * in ev++.h, to avoid clashes with functor patch.
+        - do not try to watch the empty string via inotify.
+        - inotify watchers could be leaked under certain circumstances.
+        - OS X 10.5 is actually even more broken than earlier versions,
+          so fall back to select on that piece of garbage.
+        - fixed some weirdness in the ev_embed documentation.
+
+3.49 Wed Nov 19 11:26:53 CET 2008
+	- ev_stat watchers will now use inotify as a mere hint on
+          kernels <2.6.25, or if the filesystem is not in the
+          "known to be good" list.
+        - better mingw32 compatibility (it's not as borked as native win32)
+          (analysed by Roger Pack).
+        - include stdio.h in the example program, as too many people are
+          confused by the weird C language otherwise. I guess the next thing
+          I get told is that the "..." ellipses in the examples don't compile
+          with their C compiler.
+
+3.48 Thu Oct 30 09:02:37 CET 2008
+	- further optimise away the EPOLL_CTL_ADD/MOD combo in the epoll
+          backend by assuming the kernel event mask hasn't changed if
+          ADD fails with EEXIST.
+        - work around spurious event notification bugs in epoll by using
+          a 32-bit generation counter. recreate kernel state if we receive
+          spurious notifications or unwanted events. this is very costly,
+          but I didn't come up with this horrible design.
+        - use memset to initialise most arrays now and do away with the
+          init functions.
+        - expand time-out strategies into a "Be smart about timeouts" section.
+        - drop the "struct" from all ev_watcher declarations in the
+          documentation and did other clarifications (yeah, it was a mistake
+          to have a struct AND a function called ev_loop).
+	- fix a bug where ev_default would not initialise the default
+          loop again after it was destroyed with ev_default_destroy.
+        - rename syserr to ev_syserr to avoid name clashes when embedding,
+          do similar changes for event.c.
+
+3.45 Tue Oct 21 21:59:26 CEST 2008
+	- disable inotify usage on linux <2.6.25, as it is broken
+          (reported by Yoann Vandoorselaere).
+        - ev_stat erroneously would try to add inotify watchers
+          even when inotify wasn't available (this should only
+          have a performance impact).
+	- ev_once now passes both timeout and io to the callback if both
+          occur concurrently, instead of giving timeouts precedence.
+	- disable EV_USE_INOTIFY when sys/inotify.h is too old.
+
+3.44 Mon Sep 29 05:18:39 CEST 2008
+	- embed watchers now automatically invoke ev_loop_fork on the
+          embedded loop when the parent loop forks.
+	- new function: ev_now_update (loop).
+	- verify_watcher was not marked static.
+        - improve the "associating..." manpage section.
+        - documentation tweaks here and there.
+
+3.43 Sun Jul  6 05:34:41 CEST 2008
+	- include more include files on windows to get struct _stati64
+          (reported by Chris Hulbert, but doesn't quite fix his issue).
+	- add missing #include <io.h> in ev.c on windows (reported by
+          Matt Tolton).
+
+3.42 Tue Jun 17 12:12:07 CEST 2008
+	- work around yet another windows bug: FD_SET actually adds fd's
+          multiple times to the fd_*SET*, despite official MSN docs claiming
+          otherwise. Reported and well-analysed by Matt Tolton.
+	- define NFDBITS to 0 when EV_SELECT_IS_WINSOCKET to make it compile
+          (reported any analysed by Chris Hulbert).
+        - fix a bug in ev_ebadf (this function is only used to catch
+          programming errors in the libev user). reported by Matt Tolton.
+        - fix a bug in fd_intern on win32 (could lead to compile errors
+          under some circumstances, but would work correctly if it compiles).
+          reported by Matt Tolton.
+        - (try to) work around missing lstat on windows.
+	- pass in the write fd set as except fd set under windows. windows
+          is so uncontrollably lame that it requires this. this means that
+          switching off oobinline is not supported (but tcp/ip doesn't
+          have oob, so that would be stupid anyways.
+        - use posix module symbol to auto-detect monotonic clock presence
+          and some other default values.
+
+3.41 Fri May 23 18:42:54 CEST 2008
+	- work around an obscure bug in winsocket select: if you
+          provide only empty fd sets then select returns WSAEINVAL. how sucky.
+        - improve timer scheduling stability and reduce use of time_epsilon.
+        - use 1-based 2-heap for EV_MINIMAL, simplifies code, reduces
+          codesize and makes for better cache-efficiency.
+        - use 3-based 4-heap for !EV_MINIMAL. this makes better use
+          of cpu cache lines and gives better growth behaviour than
+          2-based heaps.
+        - cache timestamp within heap for !EV_MINIMAL, to avoid random
+          memory accesses.
+        - document/add EV_USE_4HEAP and EV_HEAP_CACHE_AT.
+        - fix a potential aliasing issue in ev_timer_again.
+        - add/document ev_periodic_at, retract direct access to ->at.
+        - improve ev_stat docs.
+        - add portability requirements section.
+	- fix manpage headers etc.
+        - normalise WSA error codes to lower range on windows.
+        - add consistency check code that can be called automatically
+          or on demand to check for internal structures (ev_loop_verify).
+
+3.31 Wed Apr 16 20:45:04 CEST 2008
+	- added last minute fix for ev_poll.c by Brandon Black.
+
+3.3  Wed Apr 16 19:04:10 CEST 2008
+        - event_base_loopexit should return 0 on success
+          (W.C.A. Wijngaards).
+	- added linux eventfd support.
+        - try to autodetect epoll and inotify support
+          by libc header version if not using autoconf.
+        - new symbols: EV_DEFAULT_UC and EV_DEFAULT_UC_.
+        - declare functions defined in ev.h as inline if
+          C99 or gcc are available.
+        - enable inlining with gcc versions 2 and 3.
+        - work around broken poll implementations potentially
+          not clearing revents field in ev_poll (Brandon Black)
+          (no such systems are known at this time).
+        - work around a bug in realloc on openbsd and darwin,
+          also makes the erroneous valgrind complaints
+          go away (noted by various people).
+        - fix ev_async_pending, add c++ wrapper for ev_async
+          (based on patch sent by Johannes Deisenhofer).
+        - add sensible set method to ev::embed.
+        - made integer constants type int in ev.h.
+
+3.2  Wed Apr  2 17:11:19 CEST 2008
+	- fix a 64 bit overflow issue in the select backend,
+          by using fd_mask instead of int for the mask.
+        - rename internal sighandler to avoid clash with very old perls.
+        - entering ev_loop will not clear the ONESHOT or NONBLOCKING
+          flags of any outer loops anymore.
+        - add ev_async_pending.
+
+3.1  Thu Mar 13 13:45:22 CET 2008
+	- implement ev_async watchers.
+        - only initialise signal pipe on demand.
+	- make use of sig_atomic_t configurable.
+        - improved documentation.
+
+3.0  Mon Jan 28 13:14:47 CET 2008
+	- API/ABI bump to version 3.0.
+	- ev++.h includes "ev.h" by default now, not <ev.h>.
+	- slightly improved documentation.
+	- speed up signal detection after a fork.
+        - only optionally return trace status changed in ev_child
+          watchers.
+        - experimental (and undocumented) loop wrappers for ev++.h.
+
+2.01 Tue Dec 25 08:04:41 CET 2007
+	- separate Changes file.
+	- fix ev_path_set => ev_stat_set typo.
+        - remove event_compat.h from the libev tarball.
+        - change how include files are found.
+        - doc updates.
+        - update licenses, explicitly allow for GPL relicensing.
+
+2.0  Sat Dec 22 17:47:03 CET 2007
+        - new ev_sleep, ev_set_(io|timeout)_collect_interval.
+        - removed epoll from embeddable fd set.
+        - fix embed watchers.
+	- renamed ev_embed.loop to other.
+	- added exported Symbol tables.
+        - undefine member wrapper macros at the end of ev.c.
+        - respect EV_H in ev++.h.
+
+1.86 Tue Dec 18 02:36:57 CET 2007
+	- fix memleak on loop destroy (not relevant for perl).
+
+1.85 Fri Dec 14 20:32:40 CET 2007
+        - fix some aliasing issues w.r.t. timers and periodics
+          (not relevant for perl).
+
+(for historic versions refer to EV/Changes, found in the Perl interface)
+
+0.1  Wed Oct 31 21:31:48 CET 2007
+	- original version; hacked together in <24h.
+
diff --git a/release/src/router/libev-4.22/LICENSE b/release/src/router/libev-4.22/LICENSE
new file mode 100644
index 0000000000..2fdabd48af
--- /dev/null
+++ b/release/src/router/libev-4.22/LICENSE
@@ -0,0 +1,37 @@
+All files in libev are
+Copyright (c)2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Alternatively, the contents of this package may be used under the terms
+of the GNU General Public License ("GPL") version 2 or any later version,
+in which case the provisions of the GPL are applicable instead of the
+above. If you wish to allow the use of your version of this package only
+under the terms of the GPL and not to allow others to use your version of
+this file under the BSD license, indicate your decision by deleting the
+provisions above and replace them with the notice and other provisions
+required by the GPL in this and the other files of this package. If you do
+not delete the provisions above, a recipient may use your version of this
+file under either the BSD or the GPL.
diff --git a/release/src/router/libev-4.22/Makefile.am b/release/src/router/libev-4.22/Makefile.am
new file mode 100644
index 0000000000..059305bc3d
--- /dev/null
+++ b/release/src/router/libev-4.22/Makefile.am
@@ -0,0 +1,20 @@
+AUTOMAKE_OPTIONS = foreign
+
+VERSION_INFO = 4:0:0
+
+EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \
+	     ev_vars.h ev_wrap.h \
+	     ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c \
+	     ev.3 ev.pod Symbols.ev Symbols.event
+
+man_MANS = ev.3
+
+include_HEADERS = ev.h ev++.h event.h
+
+lib_LTLIBRARIES = libev.la
+
+libev_la_SOURCES = ev.c event.c
+libev_la_LDFLAGS = -version-info $(VERSION_INFO)
+
+ev.3: ev.pod
+	pod2man -n LIBEV -r "libev-$(VERSION)" -c "libev - high performance full featured event loop" -s3 <$< >$@
diff --git a/release/src/router/libev-4.22/Makefile.in b/release/src/router/libev-4.22/Makefile.in
new file mode 100644
index 0000000000..f67b86de9e
--- /dev/null
+++ b/release/src/router/libev-4.22/Makefile.in
@@ -0,0 +1,909 @@
+# Makefile.in generated by automake 1.14.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2013 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+VPATH = @srcdir@
+am__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = .
+DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+	$(top_srcdir)/configure $(am__configure_deps) \
+	$(srcdir)/config.h.in mkinstalldirs depcomp $(include_HEADERS) \
+	README compile config.guess config.sub install-sh missing \
+	ltmain.sh
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/libev.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(libdir)" "$(DESTDIR)$(man3dir)" \
+	"$(DESTDIR)$(includedir)"
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libev_la_LIBADD =
+am_libev_la_OBJECTS = ev.lo event.lo
+libev_la_OBJECTS = $(am_libev_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libev_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libev_la_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libev_la_SOURCES)
+DIST_SOURCES = $(libev_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+man3dir = $(mandir)/man3
+NROFF = nroff
+MANS = $(man_MANS)
+HEADERS = $(include_HEADERS)
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) \
+	$(LISP)config.h.in
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+CSCOPE = cscope
+AM_RECURSIVE_TARGETS = cscope
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  if test -d "$(distdir)"; then \
+    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+      && rm -rf "$(distdir)" \
+      || { sleep 5 && rm -rf "$(distdir)"; }; \
+  else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+DIST_TARGETS = dist-gzip
+distuninstallcheck_listfiles = find . -type f -print
+am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
+  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FGREP = @FGREP@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign
+VERSION_INFO = 4:0:0
+EXTRA_DIST = LICENSE Changes libev.m4 autogen.sh \
+	     ev_vars.h ev_wrap.h \
+	     ev_epoll.c ev_select.c ev_poll.c ev_kqueue.c ev_port.c ev_win32.c \
+	     ev.3 ev.pod Symbols.ev Symbols.event
+
+man_MANS = ev.3
+include_HEADERS = ev.h ev++.h event.h
+lib_LTLIBRARIES = libev.la
+libev_la_SOURCES = ev.c event.c
+libev_la_LDFLAGS = -version-info $(VERSION_INFO)
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+am--refresh: Makefile
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+config.h: stamp-h1
+	@test -f $@ || rm -f stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
+
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status config.h
+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f config.h stamp-h1
+
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(libdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(libdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(libdir)"; \
+	}
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; test -n "$(libdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$f"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libev.la: $(libev_la_OBJECTS) $(libev_la_DEPENDENCIES) $(EXTRA_libev_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libev_la_LINK) -rpath $(libdir) $(libev_la_OBJECTS) $(libev_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ev.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/event.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+install-man3: $(man_MANS)
+	@$(NORMAL_INSTALL)
+	@list1=''; \
+	list2='$(man_MANS)'; \
+	test -n "$(man3dir)" \
+	  && test -n "`echo $$list1$$list2`" \
+	  || exit 0; \
+	echo " $(MKDIR_P) '$(DESTDIR)$(man3dir)'"; \
+	$(MKDIR_P) "$(DESTDIR)$(man3dir)" || exit 1; \
+	{ for i in $$list1; do echo "$$i"; done;  \
+	if test -n "$$list2"; then \
+	  for i in $$list2; do echo "$$i"; done \
+	    | sed -n '/\.3[a-z]*$$/p'; \
+	fi; \
+	} | while read p; do \
+	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; echo "$$p"; \
+	done | \
+	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,' | \
+	sed 'N;N;s,\n, ,g' | { \
+	list=; while read file base inst; do \
+	  if test "$$base" = "$$inst"; then list="$$list $$file"; else \
+	    echo " $(INSTALL_DATA) '$$file' '$(DESTDIR)$(man3dir)/$$inst'"; \
+	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man3dir)/$$inst" || exit $$?; \
+	  fi; \
+	done; \
+	for i in $$list; do echo "$$i"; done | $(am__base_list) | \
+	while read files; do \
+	  test -z "$$files" || { \
+	    echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(man3dir)'"; \
+	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man3dir)" || exit $$?; }; \
+	done; }
+
+uninstall-man3:
+	@$(NORMAL_UNINSTALL)
+	@list=''; test -n "$(man3dir)" || exit 0; \
+	files=`{ for i in $$list; do echo "$$i"; done; \
+	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
+	  sed -n '/\.3[a-z]*$$/p'; \
+	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
+	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
+	dir='$(DESTDIR)$(man3dir)'; $(am__uninstall_files_from_dir)
+install-includeHEADERS: $(include_HEADERS)
+	@$(NORMAL_INSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(includedir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(includedir)" || exit 1; \
+	fi; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'"; \
+	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(includedir)" || exit $$?; \
+	done
+
+uninstall-includeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(include_HEADERS)'; test -n "$(includedir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	dir='$(DESTDIR)$(includedir)'; $(am__uninstall_files_from_dir)
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
+
+distdir: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	$(am__post_remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
+	$(am__post_remove_distdir)
+
+dist-lzip: distdir
+	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
+	$(am__post_remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
+	$(am__post_remove_distdir)
+
+dist-tarZ: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__post_remove_distdir)
+
+dist-shar: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	$(am__post_remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__post_remove_distdir)
+
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lz*) \
+	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	esac
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build \
+	  && ../configure \
+	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	    --srcdir=.. --prefix="$$dc_install_base" \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__post_remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@test -n '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: trying to run $@ with an empty' \
+	       '$$(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	$(am__cd) '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	test `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES) $(MANS) $(HEADERS) config.h
+installdirs:
+	for dir in "$(DESTDIR)$(libdir)" "$(DESTDIR)$(man3dir)" "$(DESTDIR)$(includedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-includeHEADERS install-man
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man: install-man3
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-includeHEADERS uninstall-libLTLIBRARIES \
+	uninstall-man
+
+uninstall-man: uninstall-man3
+
+.MAKE: all install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am am--refresh check check-am clean \
+	clean-cscope clean-generic clean-libLTLIBRARIES clean-libtool \
+	cscope cscopelist-am ctags ctags-am dist dist-all dist-bzip2 \
+	dist-gzip dist-lzip dist-shar dist-tarZ dist-xz dist-zip \
+	distcheck distclean distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags distcleancheck \
+	distdir distuninstallcheck dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-includeHEADERS \
+	install-info install-info-am install-libLTLIBRARIES \
+	install-man install-man3 install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am uninstall-includeHEADERS uninstall-libLTLIBRARIES \
+	uninstall-man uninstall-man3
+
+
+ev.3: ev.pod
+	pod2man -n LIBEV -r "libev-$(VERSION)" -c "libev - high performance full featured event loop" -s3 <$< >$@
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/release/src/router/libev-4.22/README b/release/src/router/libev-4.22/README
new file mode 100644
index 0000000000..31f619387d
--- /dev/null
+++ b/release/src/router/libev-4.22/README
@@ -0,0 +1,58 @@
+libev is a high-performance event loop/event model with lots of features.
+(see benchmark at http://libev.schmorp.de/bench.html)
+
+
+ABOUT
+
+   Homepage: http://software.schmorp.de/pkg/libev
+   Mailinglist: libev@lists.schmorp.de
+                http://lists.schmorp.de/cgi-bin/mailman/listinfo/libev
+   Library Documentation: http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod
+
+   Libev is modelled (very losely) after libevent and the Event perl
+   module, but is faster, scales better and is more correct, and also more
+   featureful. And also smaller. Yay.
+
+   Some of the specialties of libev not commonly found elsewhere are:
+   
+   - extensive and detailed, readable documentation (not doxygen garbage).
+   - fully supports fork, can detect fork in various ways and automatically
+     re-arms kernel mechanisms that do not support fork.
+   - highly optimised select, poll, epoll, kqueue and event ports backends.
+   - filesystem object (path) watching (with optional linux inotify support).
+   - wallclock-based times (using absolute time, cron-like).
+   - relative timers/timeouts (handle time jumps).
+   - fast intra-thread communication between multiple
+     event loops (with optional fast linux eventfd backend).
+   - extremely easy to embed (fully documented, no dependencies,
+     autoconf supported but optional).
+   - very small codebase, no bloated library, simple code.
+   - fully extensible by being able to plug into the event loop,
+     integrate other event loops, integrate other event loop users.
+   - very little memory use (small watchers, small event loop data).
+   - optional C++ interface allowing method and function callbacks
+     at no extra memory or runtime overhead.
+   - optional Perl interface with similar characteristics (capable
+     of running Glib/Gtk2 on libev).
+   - support for other languages (multiple C++ interfaces, D, Ruby,
+     Python) available from third-parties.
+
+   Examples of programs that embed libev: the EV perl module, node.js,
+   auditd, rxvt-unicode, gvpe (GNU Virtual Private Ethernet), the
+   Deliantra MMORPG server (http://www.deliantra.net/), Rubinius (a
+   next-generation Ruby VM), the Ebb web server, the Rev event toolkit.
+
+
+CONTRIBUTORS
+
+   libev was written and designed by Marc Lehmann and Emanuele Giaquinta.
+
+   The following people sent in patches or made other noteworthy
+   contributions to the design (for minor patches, see the Changes
+   file. If I forgot to include you, please shout at me, it was an
+   accident):
+
+   W.C.A. Wijngaards
+   Christopher Layne
+   Chris Brody
+
diff --git a/release/src/router/libev-4.22/Symbols.ev b/release/src/router/libev-4.22/Symbols.ev
new file mode 100644
index 0000000000..7a29a75cba
--- /dev/null
+++ b/release/src/router/libev-4.22/Symbols.ev
@@ -0,0 +1,73 @@
+ev_async_send
+ev_async_start
+ev_async_stop
+ev_backend
+ev_break
+ev_check_start
+ev_check_stop
+ev_child_start
+ev_child_stop
+ev_cleanup_start
+ev_cleanup_stop
+ev_clear_pending
+ev_default_loop
+ev_default_loop_ptr
+ev_depth
+ev_embed_start
+ev_embed_stop
+ev_embed_sweep
+ev_embeddable_backends
+ev_feed_event
+ev_feed_fd_event
+ev_feed_signal
+ev_feed_signal_event
+ev_fork_start
+ev_fork_stop
+ev_idle_start
+ev_idle_stop
+ev_invoke
+ev_invoke_pending
+ev_io_start
+ev_io_stop
+ev_iteration
+ev_loop_destroy
+ev_loop_fork
+ev_loop_new
+ev_now
+ev_now_update
+ev_once
+ev_pending_count
+ev_periodic_again
+ev_periodic_start
+ev_periodic_stop
+ev_prepare_start
+ev_prepare_stop
+ev_recommended_backends
+ev_ref
+ev_resume
+ev_run
+ev_set_allocator
+ev_set_invoke_pending_cb
+ev_set_io_collect_interval
+ev_set_loop_release_cb
+ev_set_syserr_cb
+ev_set_timeout_collect_interval
+ev_set_userdata
+ev_signal_start
+ev_signal_stop
+ev_sleep
+ev_stat_start
+ev_stat_stat
+ev_stat_stop
+ev_supported_backends
+ev_suspend
+ev_time
+ev_timer_again
+ev_timer_remaining
+ev_timer_start
+ev_timer_stop
+ev_unref
+ev_userdata
+ev_verify
+ev_version_major
+ev_version_minor
diff --git a/release/src/router/libev-4.22/Symbols.event b/release/src/router/libev-4.22/Symbols.event
new file mode 100644
index 0000000000..799d4246e4
--- /dev/null
+++ b/release/src/router/libev-4.22/Symbols.event
@@ -0,0 +1,24 @@
+event_active
+event_add
+event_base_dispatch
+event_base_free
+event_base_get_method
+event_base_loop
+event_base_loopexit
+event_base_new
+event_base_once
+event_base_priority_init
+event_base_set
+event_del
+event_dispatch
+event_get_callback
+event_get_method
+event_get_version
+event_init
+event_loop
+event_loopexit
+event_once
+event_pending
+event_priority_init
+event_priority_set
+event_set
diff --git a/release/src/router/libev-4.22/aclocal.m4 b/release/src/router/libev-4.22/aclocal.m4
new file mode 100644
index 0000000000..186cbf17cf
--- /dev/null
+++ b/release/src/router/libev-4.22/aclocal.m4
@@ -0,0 +1,9787 @@
+# generated automatically by aclocal 1.14.1 -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,
+[m4_warning([this file was generated for autoconf 2.69.
+You have another version of autoconf.  It may work, but is not guaranteed to.
+If you have problems, you may need to regenerate the build system entirely.
+To do so, use the procedure documented by the package, typically 'autoreconf'.])])
+
+# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+#                 Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+m4_define([_LT_COPYING], [dnl
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+#                 Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+])
+
+# serial 57 LT_INIT
+
+
+# LT_PREREQ(VERSION)
+# ------------------
+# Complain and exit if this libtool version is less that VERSION.
+m4_defun([LT_PREREQ],
+[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,
+       [m4_default([$3],
+		   [m4_fatal([Libtool version $1 or higher is required],
+		             63)])],
+       [$2])])
+
+
+# _LT_CHECK_BUILDDIR
+# ------------------
+# Complain if the absolute build directory name contains unusual characters
+m4_defun([_LT_CHECK_BUILDDIR],
+[case `pwd` in
+  *\ * | *\	*)
+    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;
+esac
+])
+
+
+# LT_INIT([OPTIONS])
+# ------------------
+AC_DEFUN([LT_INIT],
+[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT
+AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+AC_BEFORE([$0], [LT_LANG])dnl
+AC_BEFORE([$0], [LT_OUTPUT])dnl
+AC_BEFORE([$0], [LTDL_INIT])dnl
+m4_require([_LT_CHECK_BUILDDIR])dnl
+
+dnl Autoconf doesn't catch unexpanded LT_ macros by default:
+m4_pattern_forbid([^_?LT_[A-Z_]+$])dnl
+m4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl
+dnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4
+dnl unless we require an AC_DEFUNed macro:
+AC_REQUIRE([LTOPTIONS_VERSION])dnl
+AC_REQUIRE([LTSUGAR_VERSION])dnl
+AC_REQUIRE([LTVERSION_VERSION])dnl
+AC_REQUIRE([LTOBSOLETE_VERSION])dnl
+m4_require([_LT_PROG_LTMAIN])dnl
+
+_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])
+
+dnl Parse OPTIONS
+_LT_SET_OPTIONS([$0], [$1])
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+AC_SUBST(LIBTOOL)dnl
+
+_LT_SETUP
+
+# Only expand once:
+m4_define([LT_INIT])
+])# LT_INIT
+
+# Old names:
+AU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])
+AU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PROG_LIBTOOL], [])
+dnl AC_DEFUN([AM_PROG_LIBTOOL], [])
+
+
+# _LT_CC_BASENAME(CC)
+# -------------------
+# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
+m4_defun([_LT_CC_BASENAME],
+[for cc_temp in $1""; do
+  case $cc_temp in
+    compile | *[[\\/]]compile | ccache | *[[\\/]]ccache ) ;;
+    distcc | *[[\\/]]distcc | purify | *[[\\/]]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+])
+
+
+# _LT_FILEUTILS_DEFAULTS
+# ----------------------
+# It is okay to use these file commands and assume they have been set
+# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.
+m4_defun([_LT_FILEUTILS_DEFAULTS],
+[: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+])# _LT_FILEUTILS_DEFAULTS
+
+
+# _LT_SETUP
+# ---------
+m4_defun([_LT_SETUP],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl
+
+_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl
+dnl
+_LT_DECL([], [host_alias], [0], [The host system])dnl
+_LT_DECL([], [host], [0])dnl
+_LT_DECL([], [host_os], [0])dnl
+dnl
+_LT_DECL([], [build_alias], [0], [The build system])dnl
+_LT_DECL([], [build], [0])dnl
+_LT_DECL([], [build_os], [0])dnl
+dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+dnl
+AC_REQUIRE([AC_PROG_LN_S])dnl
+test -z "$LN_S" && LN_S="ln -s"
+_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl
+dnl
+AC_REQUIRE([LT_CMD_MAX_LEN])dnl
+_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
+_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
+dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+m4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl
+m4_require([_LT_CMD_RELOAD])dnl
+m4_require([_LT_CHECK_MAGIC_METHOD])dnl
+m4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl
+m4_require([_LT_CMD_OLD_ARCHIVE])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_WITH_SYSROOT])dnl
+
+_LT_CONFIG_LIBTOOL_INIT([
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+])
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+_LT_CHECK_OBJDIR
+
+m4_require([_LT_TAG_COMPILER])dnl
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+_LT_CC_BASENAME([$compiler])
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    _LT_PATH_MAGIC
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+LT_SUPPORTED_TAG([CC])
+_LT_LANG_C_CONFIG
+_LT_LANG_DEFAULT_CONFIG
+_LT_CONFIG_COMMANDS
+])# _LT_SETUP
+
+
+# _LT_PREPARE_SED_QUOTE_VARS
+# --------------------------
+# Define a few sed substitution that help us do robust quoting.
+m4_defun([_LT_PREPARE_SED_QUOTE_VARS],
+[# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\([["`$\\]]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\([["`\\]]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+])
+
+# _LT_PROG_LTMAIN
+# ---------------
+# Note that this code is called both from `configure', and `config.status'
+# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,
+# `config.status' has no value for ac_aux_dir unless we are using Automake,
+# so we pass a copy along to make sure it has a sensible value anyway.
+m4_defun([_LT_PROG_LTMAIN],
+[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl
+_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
+ltmain="$ac_aux_dir/ltmain.sh"
+])# _LT_PROG_LTMAIN
+
+
+
+# So that we can recreate a full libtool script including additional
+# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS
+# in macros and then make a single call at the end using the `libtool'
+# label.
+
+
+# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])
+# ----------------------------------------
+# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL_INIT],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_INIT])
+
+
+# _LT_CONFIG_LIBTOOL([COMMANDS])
+# ------------------------------
+# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.
+m4_define([_LT_CONFIG_LIBTOOL],
+[m4_ifval([$1],
+          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],
+                     [$1
+])])])
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])
+
+
+# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])
+# -----------------------------------------------------
+m4_defun([_LT_CONFIG_SAVE_COMMANDS],
+[_LT_CONFIG_LIBTOOL([$1])
+_LT_CONFIG_LIBTOOL_INIT([$2])
+])
+
+
+# _LT_FORMAT_COMMENT([COMMENT])
+# -----------------------------
+# Add leading comment marks to the start of each line, and a trailing
+# full-stop to the whole comment if one is not present already.
+m4_define([_LT_FORMAT_COMMENT],
+[m4_ifval([$1], [
+m4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],
+              [['`$\]], [\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])
+)])
+
+
+
+
+
+# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])
+# -------------------------------------------------------------------
+# CONFIGNAME is the name given to the value in the libtool script.
+# VARNAME is the (base) name used in the configure script.
+# VALUE may be 0, 1 or 2 for a computed quote escaped value based on
+# VARNAME.  Any other value will be used directly.
+m4_define([_LT_DECL],
+[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],
+    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],
+	[m4_ifval([$1], [$1], [$2])])
+    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])
+    m4_ifval([$4],
+	[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])
+    lt_dict_add_subkey([lt_decl_dict], [$2],
+	[tagged?], [m4_ifval([$5], [yes], [no])])])
+])
+
+
+# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])
+# --------------------------------------------------------
+m4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])
+
+
+# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_tag_varnames],
+[_lt_decl_filter([tagged?], [yes], $@)])
+
+
+# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])
+# ---------------------------------------------------------
+m4_define([_lt_decl_filter],
+[m4_case([$#],
+  [0], [m4_fatal([$0: too few arguments: $#])],
+  [1], [m4_fatal([$0: too few arguments: $#: $1])],
+  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],
+  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],
+  [lt_dict_filter([lt_decl_dict], $@)])[]dnl
+])
+
+
+# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])
+# --------------------------------------------------
+m4_define([lt_decl_quote_varnames],
+[_lt_decl_filter([value], [1], $@)])
+
+
+# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_dquote_varnames],
+[_lt_decl_filter([value], [2], $@)])
+
+
+# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])
+# ---------------------------------------------------
+m4_define([lt_decl_varnames_tagged],
+[m4_assert([$# <= 2])dnl
+_$0(m4_quote(m4_default([$1], [[, ]])),
+    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),
+    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])
+m4_define([_lt_decl_varnames_tagged],
+[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])
+
+
+# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])
+# ------------------------------------------------
+m4_define([lt_decl_all_varnames],
+[_$0(m4_quote(m4_default([$1], [[, ]])),
+     m4_if([$2], [],
+	   m4_quote(lt_decl_varnames),
+	m4_quote(m4_shift($@))))[]dnl
+])
+m4_define([_lt_decl_all_varnames],
+[lt_join($@, lt_decl_varnames_tagged([$1],
+			lt_decl_tag_varnames([[, ]], m4_shift($@))))dnl
+])
+
+
+# _LT_CONFIG_STATUS_DECLARE([VARNAME])
+# ------------------------------------
+# Quote a variable value, and forward it to `config.status' so that its
+# declaration there will have the same value as in `configure'.  VARNAME
+# must have a single quote delimited value for this to work.
+m4_define([_LT_CONFIG_STATUS_DECLARE],
+[$1='`$ECHO "$][$1" | $SED "$delay_single_quote_subst"`'])
+
+
+# _LT_CONFIG_STATUS_DECLARATIONS
+# ------------------------------
+# We delimit libtool config variables with single quotes, so when
+# we write them to config.status, we have to be sure to quote all
+# embedded single quotes properly.  In configure, this macro expands
+# each variable declared with _LT_DECL (and _LT_TAGDECL) into:
+#
+#    <var>='`$ECHO "$<var>" | $SED "$delay_single_quote_subst"`'
+m4_defun([_LT_CONFIG_STATUS_DECLARATIONS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),
+    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAGS
+# ----------------
+# Output comment and list of tags supported by the script
+m4_defun([_LT_LIBTOOL_TAGS],
+[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl
+available_tags="_LT_TAGS"dnl
+])
+
+
+# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])
+# -----------------------------------
+# Extract the dictionary values for VARNAME (optionally with TAG) and
+# expand to a commented shell variable setting:
+#
+#    # Some comment about what VAR is for.
+#    visible_name=$lt_internal_name
+m4_define([_LT_LIBTOOL_DECLARE],
+[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],
+					   [description])))[]dnl
+m4_pushdef([_libtool_name],
+    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl
+m4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),
+    [0], [_libtool_name=[$]$1],
+    [1], [_libtool_name=$lt_[]$1],
+    [2], [_libtool_name=$lt_[]$1],
+    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl
+m4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl
+])
+
+
+# _LT_LIBTOOL_CONFIG_VARS
+# -----------------------
+# Produce commented declarations of non-tagged libtool config variables
+# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'
+# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG
+# section) are produced by _LT_LIBTOOL_TAG_VARS.
+m4_defun([_LT_LIBTOOL_CONFIG_VARS],
+[m4_foreach([_lt_var],
+    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])
+
+
+# _LT_LIBTOOL_TAG_VARS(TAG)
+# -------------------------
+m4_define([_LT_LIBTOOL_TAG_VARS],
+[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),
+    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])
+
+
+# _LT_TAGVAR(VARNAME, [TAGNAME])
+# ------------------------------
+m4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])
+
+
+# _LT_CONFIG_COMMANDS
+# -------------------
+# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of
+# variables for single and double quote escaping we saved from calls
+# to _LT_DECL, we can put quote escaped variables declarations
+# into `config.status', and then the shell code to quote escape them in
+# for loops in `config.status'.  Finally, any additional code accumulated
+# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
+m4_defun([_LT_CONFIG_COMMANDS],
+[AC_PROVIDE_IFELSE([LT_OUTPUT],
+	dnl If the libtool generation code has been placed in $CONFIG_LT,
+	dnl instead of duplicating it all over again into config.status,
+	dnl then we will have config.status run $CONFIG_LT later, so it
+	dnl needs to know what name is stored there:
+        [AC_CONFIG_COMMANDS([libtool],
+            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],
+    dnl If the libtool generation code is destined for config.status,
+    dnl expand the accumulated commands and init code now:
+    [AC_CONFIG_COMMANDS([libtool],
+        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])
+])#_LT_CONFIG_COMMANDS
+
+
+# Initialize.
+m4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],
+[
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+_LT_CONFIG_STATUS_DECLARATIONS
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$[]1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_quote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in lt_decl_all_varnames([[ \
+]], lt_decl_dquote_varnames); do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[[\\\\\\\`\\"\\\$]]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+_LT_OUTPUT_LIBTOOL_INIT
+])
+
+# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])
+# ------------------------------------
+# Generate a child script FILE with all initialization necessary to
+# reuse the environment learned by the parent script, and make the
+# file executable.  If COMMENT is supplied, it is inserted after the
+# `#!' sequence but before initialization text begins.  After this
+# macro, additional text can be appended to FILE to form the body of
+# the child script.  The macro ends with non-zero status if the
+# file could not be fully written (such as if the disk is full).
+m4_ifdef([AS_INIT_GENERATED],
+[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],
+[m4_defun([_LT_GENERATED_FILE_INIT],
+[m4_require([AS_PREPARE])]dnl
+[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl
+[lt_write_fail=0
+cat >$1 <<_ASEOF || lt_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+$2
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$1 <<\_ASEOF || lt_write_fail=1
+AS_SHELL_SANITIZE
+_AS_PREPARE
+exec AS_MESSAGE_FD>&1
+_ASEOF
+test $lt_write_fail = 0 && chmod +x $1[]dnl
+m4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT
+
+# LT_OUTPUT
+# ---------
+# This macro allows early generation of the libtool script (before
+# AC_OUTPUT is called), incase it is used in configure for compilation
+# tests.
+AC_DEFUN([LT_OUTPUT],
+[: ${CONFIG_LT=./config.lt}
+AC_MSG_NOTICE([creating $CONFIG_LT])
+_LT_GENERATED_FILE_INIT(["$CONFIG_LT"],
+[# Run this file to recreate a libtool stub with the current configuration.])
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+lt_cl_silent=false
+exec AS_MESSAGE_LOG_FD>>config.log
+{
+  echo
+  AS_BOX([Running $as_me.])
+} >&AS_MESSAGE_LOG_FD
+
+lt_cl_help="\
+\`$as_me' creates a local libtool stub from the current configuration,
+for use in further configure time tests before the real libtool is
+generated.
+
+Usage: $[0] [[OPTIONS]]
+
+  -h, --help      print this help, then exit
+  -V, --version   print version number, then exit
+  -q, --quiet     do not print progress messages
+  -d, --debug     don't remove temporary files
+
+Report bugs to <bug-libtool@gnu.org>."
+
+lt_cl_version="\
+m4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl
+m4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])
+configured by $[0], generated by m4_PACKAGE_STRING.
+
+Copyright (C) 2011 Free Software Foundation, Inc.
+This config.lt script is free software; the Free Software Foundation
+gives unlimited permision to copy, distribute and modify it."
+
+while test $[#] != 0
+do
+  case $[1] in
+    --version | --v* | -V )
+      echo "$lt_cl_version"; exit 0 ;;
+    --help | --h* | -h )
+      echo "$lt_cl_help"; exit 0 ;;
+    --debug | --d* | -d )
+      debug=: ;;
+    --quiet | --q* | --silent | --s* | -q )
+      lt_cl_silent=: ;;
+
+    -*) AC_MSG_ERROR([unrecognized option: $[1]
+Try \`$[0] --help' for more information.]) ;;
+
+    *) AC_MSG_ERROR([unrecognized argument: $[1]
+Try \`$[0] --help' for more information.]) ;;
+  esac
+  shift
+done
+
+if $lt_cl_silent; then
+  exec AS_MESSAGE_FD>/dev/null
+fi
+_LTEOF
+
+cat >>"$CONFIG_LT" <<_LTEOF
+_LT_OUTPUT_LIBTOOL_COMMANDS_INIT
+_LTEOF
+
+cat >>"$CONFIG_LT" <<\_LTEOF
+AC_MSG_NOTICE([creating $ofile])
+_LT_OUTPUT_LIBTOOL_COMMANDS
+AS_EXIT(0)
+_LTEOF
+chmod +x "$CONFIG_LT"
+
+# configure is writing to config.log, but config.lt does its own redirection,
+# appending to config.log, which fails on DOS, as config.log is still kept
+# open by configure.  Here we exec the FD to /dev/null, effectively closing
+# config.log, so it can be properly (re)opened and appended to by config.lt.
+lt_cl_success=:
+test "$silent" = yes &&
+  lt_config_lt_args="$lt_config_lt_args --quiet"
+exec AS_MESSAGE_LOG_FD>/dev/null
+$SHELL "$CONFIG_LT" $lt_config_lt_args || lt_cl_success=false
+exec AS_MESSAGE_LOG_FD>>config.log
+$lt_cl_success || AS_EXIT(1)
+])# LT_OUTPUT
+
+
+# _LT_CONFIG(TAG)
+# ---------------
+# If TAG is the built-in tag, create an initial libtool script with a
+# default configuration from the untagged config vars.  Otherwise add code
+# to config.status for appending the configuration named by TAG from the
+# matching tagged config vars.
+m4_defun([_LT_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_CONFIG_SAVE_COMMANDS([
+  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl
+  m4_if(_LT_TAG, [C], [
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+_LT_COPYING
+_LT_LIBTOOL_TAGS
+
+# ### BEGIN LIBTOOL CONFIG
+_LT_LIBTOOL_CONFIG_VARS
+_LT_LIBTOOL_TAG_VARS
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+  _LT_PROG_LTMAIN
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "$cfgfile" \
+     || (rm -f "$cfgfile"; exit 1)
+
+  _LT_PROG_REPLACE_SHELLFNS
+
+   mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+],
+[cat <<_LT_EOF >> "$ofile"
+
+dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
+dnl in a comment (ie after a #).
+# ### BEGIN LIBTOOL TAG CONFIG: $1
+_LT_LIBTOOL_TAG_VARS(_LT_TAG)
+# ### END LIBTOOL TAG CONFIG: $1
+_LT_EOF
+])dnl /m4_if
+],
+[m4_if([$1], [], [
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'], [])
+])dnl /_LT_CONFIG_SAVE_COMMANDS
+])# _LT_CONFIG
+
+
+# LT_SUPPORTED_TAG(TAG)
+# ---------------------
+# Trace this macro to discover what tags are supported by the libtool
+# --tag option, using:
+#    autoconf --trace 'LT_SUPPORTED_TAG:$1'
+AC_DEFUN([LT_SUPPORTED_TAG], [])
+
+
+# C support is built-in for now
+m4_define([_LT_LANG_C_enabled], [])
+m4_define([_LT_TAGS], [])
+
+
+# LT_LANG(LANG)
+# -------------
+# Enable libtool support for the given language if not already enabled.
+AC_DEFUN([LT_LANG],
+[AC_BEFORE([$0], [LT_OUTPUT])dnl
+m4_case([$1],
+  [C],			[_LT_LANG(C)],
+  [C++],		[_LT_LANG(CXX)],
+  [Go],			[_LT_LANG(GO)],
+  [Java],		[_LT_LANG(GCJ)],
+  [Fortran 77],		[_LT_LANG(F77)],
+  [Fortran],		[_LT_LANG(FC)],
+  [Windows Resource],	[_LT_LANG(RC)],
+  [m4_ifdef([_LT_LANG_]$1[_CONFIG],
+    [_LT_LANG($1)],
+    [m4_fatal([$0: unsupported language: "$1"])])])dnl
+])# LT_LANG
+
+
+# _LT_LANG(LANGNAME)
+# ------------------
+m4_defun([_LT_LANG],
+[m4_ifdef([_LT_LANG_]$1[_enabled], [],
+  [LT_SUPPORTED_TAG([$1])dnl
+  m4_append([_LT_TAGS], [$1 ])dnl
+  m4_define([_LT_LANG_]$1[_enabled], [])dnl
+  _LT_LANG_$1_CONFIG($1)])dnl
+])# _LT_LANG
+
+
+m4_ifndef([AC_PROG_GO], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_GO.  When it is available in    #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+m4_defun([AC_PROG_GO],
+[AC_LANG_PUSH(Go)dnl
+AC_ARG_VAR([GOC],     [Go compiler command])dnl
+AC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl
+_AC_ARG_VAR_LDFLAGS()dnl
+AC_CHECK_TOOL(GOC, gccgo)
+if test -z "$GOC"; then
+  if test -n "$ac_tool_prefix"; then
+    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])
+  fi
+fi
+if test -z "$GOC"; then
+  AC_CHECK_PROG(GOC, gccgo, gccgo, false)
+fi
+])#m4_defun
+])#m4_ifndef
+
+
+# _LT_LANG_DEFAULT_CONFIG
+# -----------------------
+m4_defun([_LT_LANG_DEFAULT_CONFIG],
+[AC_PROVIDE_IFELSE([AC_PROG_CXX],
+  [LT_LANG(CXX)],
+  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_F77],
+  [LT_LANG(F77)],
+  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])
+
+AC_PROVIDE_IFELSE([AC_PROG_FC],
+  [LT_LANG(FC)],
+  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])
+
+dnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal
+dnl pulling things in needlessly.
+AC_PROVIDE_IFELSE([AC_PROG_GCJ],
+  [LT_LANG(GCJ)],
+  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],
+    [LT_LANG(GCJ)],
+    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],
+      [LT_LANG(GCJ)],
+      [m4_ifdef([AC_PROG_GCJ],
+	[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([A][M_PROG_GCJ],
+	[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])
+       m4_ifdef([LT_PROG_GCJ],
+	[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])
+
+AC_PROVIDE_IFELSE([AC_PROG_GO],
+  [LT_LANG(GO)],
+  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])
+
+AC_PROVIDE_IFELSE([LT_PROG_RC],
+  [LT_LANG(RC)],
+  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])
+])# _LT_LANG_DEFAULT_CONFIG
+
+# Obsolete macros:
+AU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])
+AU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])
+AU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])
+AU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])
+AU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_CXX], [])
+dnl AC_DEFUN([AC_LIBTOOL_F77], [])
+dnl AC_DEFUN([AC_LIBTOOL_FC], [])
+dnl AC_DEFUN([AC_LIBTOOL_GCJ], [])
+dnl AC_DEFUN([AC_LIBTOOL_RC], [])
+
+
+# _LT_TAG_COMPILER
+# ----------------
+m4_defun([_LT_TAG_COMPILER],
+[AC_REQUIRE([AC_PROG_CC])dnl
+
+_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl
+_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl
+_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl
+_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+])# _LT_TAG_COMPILER
+
+
+# _LT_COMPILER_BOILERPLATE
+# ------------------------
+# Check for compiler boilerplate output or warnings with
+# the simple compiler test code.
+m4_defun([_LT_COMPILER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+])# _LT_COMPILER_BOILERPLATE
+
+
+# _LT_LINKER_BOILERPLATE
+# ----------------------
+# Check for linker boilerplate output or warnings with
+# the simple link test code.
+m4_defun([_LT_LINKER_BOILERPLATE],
+[m4_require([_LT_DECL_SED])dnl
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+])# _LT_LINKER_BOILERPLATE
+
+# _LT_REQUIRED_DARWIN_CHECKS
+# -------------------------
+m4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[
+  case $host_os in
+    rhapsody* | darwin*)
+    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])
+    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])
+    AC_CHECK_TOOL([LIPO], [lipo], [:])
+    AC_CHECK_TOOL([OTOOL], [otool], [:])
+    AC_CHECK_TOOL([OTOOL64], [otool64], [:])
+    _LT_DECL([], [DSYMUTIL], [1],
+      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])
+    _LT_DECL([], [NMEDIT], [1],
+      [Tool to change global to local symbols on Mac OS X])
+    _LT_DECL([], [LIPO], [1],
+      [Tool to manipulate fat objects and archives on Mac OS X])
+    _LT_DECL([], [OTOOL], [1],
+      [ldd/readelf like tool for Mach-O binaries on Mac OS X])
+    _LT_DECL([], [OTOOL64], [1],
+      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])
+
+    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],
+      [lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&AS_MESSAGE_LOG_FD
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	# If there is a non-empty error log, and "single_module"
+	# appears in it, assume the flag caused a linker warning
+        if test -s conftest.err && $GREP single_module conftest.err; then
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	# Otherwise, if the output was created with a 0 exit code from
+	# the compiler, it worked.
+	elif test -f libconftest.dylib && test $_lt_result -eq 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&AS_MESSAGE_LOG_FD
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi])
+
+    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
+      [lt_cv_ld_exported_symbols_list],
+      [lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+	[lt_cv_ld_exported_symbols_list=yes],
+	[lt_cv_ld_exported_symbols_list=no])
+	LDFLAGS="$save_LDFLAGS"
+    ])
+
+    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],
+      [lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD
+      echo "$AR cru libconftest.a conftest.o" >&AS_MESSAGE_LOG_FD
+      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD
+      echo "$RANLIB libconftest.a" >&AS_MESSAGE_LOG_FD
+      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&AS_MESSAGE_LOG_FD
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -s conftest.err && $GREP force_load conftest.err; then
+	cat conftest.err >&AS_MESSAGE_LOG_FD
+      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&AS_MESSAGE_LOG_FD
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+    ])
+    case $host_os in
+    rhapsody* | darwin1.[[012]])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[[012]]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+])
+
+
+# _LT_DARWIN_LINKER_FEATURES([TAG])
+# ---------------------------------
+# Checks for linker and compiler features on darwin
+m4_defun([_LT_DARWIN_LINKER_FEATURES],
+[
+  m4_require([_LT_REQUIRED_DARWIN_CHECKS])
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_automatic, $1)=yes
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],
+                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])
+  else
+    _LT_TAGVAR(whole_archive_flag_spec, $1)=''
+  fi
+  _LT_TAGVAR(link_all_deplibs, $1)=yes
+  _LT_TAGVAR(allow_undefined_flag, $1)="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    _LT_TAGVAR(archive_cmds, $1)="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    _LT_TAGVAR(module_cmds, $1)="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+    m4_if([$1], [CXX],
+[   if test "$lt_cv_apple_cc_single_mod" != "yes"; then
+      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
+      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
+    fi
+],[])
+  else
+  _LT_TAGVAR(ld_shlibs, $1)=no
+  fi
+])
+
+# _LT_SYS_MODULE_PATH_AIX([TAGNAME])
+# ----------------------------------
+# Links a minimal program and checks the executable
+# for the system default hardcoded library path. In most cases,
+# this is /usr/lib:/lib, but when the MPI compilers are used
+# the location of the communication and MPI libs are included too.
+# If we don't find anything, use the default library path according
+# to the aix ld manual.
+# Store the results from the different compilers for each TAGNAME.
+# Allow to override them for all tags through lt_cv_aix_libpath.
+m4_defun([_LT_SYS_MODULE_PATH_AIX],
+[m4_require([_LT_DECL_SED])dnl
+if test "${lt_cv_aix_libpath+set}" = set; then
+  aix_libpath=$lt_cv_aix_libpath
+else
+  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],
+  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[
+  lt_aix_libpath_sed='[
+      /Import File Strings/,/^$/ {
+	  /^0/ {
+	      s/^0  *\([^ ]*\) *$/\1/
+	      p
+	  }
+      }]'
+  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  # Check for a 64-bit object if we didn't find anything.
+  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
+    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  fi],[])
+  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
+    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])="/usr/lib:/lib"
+  fi
+  ])
+  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])
+fi
+])# _LT_SYS_MODULE_PATH_AIX
+
+
+# _LT_SHELL_INIT(ARG)
+# -------------------
+m4_define([_LT_SHELL_INIT],
+[m4_divert_text([M4SH-INIT], [$1
+])])# _LT_SHELL_INIT
+
+
+
+# _LT_PROG_ECHO_BACKSLASH
+# -----------------------
+# Find how we can fake an echo command that does not interpret backslash.
+# In particular, with Autoconf 2.60 or later we add some code to the start
+# of the generated configure script which will find a shell with a builtin
+# printf (which we can use as an echo command).
+m4_defun([_LT_PROG_ECHO_BACKSLASH],
+[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+AC_MSG_CHECKING([how to print strings])
+# Test print first, because it will be a builtin if present.
+if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$[]1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO "$*" 
+}
+
+case "$ECHO" in
+  printf*) AC_MSG_RESULT([printf]) ;;
+  print*) AC_MSG_RESULT([print -r]) ;;
+  *) AC_MSG_RESULT([cat]) ;;
+esac
+
+m4_ifdef([_AS_DETECT_SUGGESTED],
+[_AS_DETECT_SUGGESTED([
+  test -n "${ZSH_VERSION+set}${BASH_VERSION+set}" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test "X`printf %s $ECHO`" = "X$ECHO" \
+      || test "X`print -r -- $ECHO`" = "X$ECHO" )])])
+
+_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])
+_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])
+])# _LT_PROG_ECHO_BACKSLASH
+
+
+# _LT_WITH_SYSROOT
+# ----------------
+AC_DEFUN([_LT_WITH_SYSROOT],
+[AC_MSG_CHECKING([for sysroot])
+AC_ARG_WITH([sysroot],
+[  --with-sysroot[=DIR] Search for dependent libraries within DIR
+                        (or the compiler's sysroot if not specified).],
+[], [with_sysroot=no])
+
+dnl lt_sysroot will always be passed unquoted.  We quote it here
+dnl in case the user passed a directory name.
+lt_sysroot=
+case ${with_sysroot} in #(
+ yes)
+   if test "$GCC" = yes; then
+     lt_sysroot=`$CC --print-sysroot 2>/dev/null`
+   fi
+   ;; #(
+ /*)
+   lt_sysroot=`echo "$with_sysroot" | sed -e "$sed_quote_subst"`
+   ;; #(
+ no|'')
+   ;; #(
+ *)
+   AC_MSG_RESULT([${with_sysroot}])
+   AC_MSG_ERROR([The sysroot must be an absolute path.])
+   ;;
+esac
+
+ AC_MSG_RESULT([${lt_sysroot:-no}])
+_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl
+[dependent libraries, and in which our libraries should be installed.])])
+
+# _LT_ENABLE_LOCK
+# ---------------
+m4_defun([_LT_ENABLE_LOCK],
+[AC_ARG_ENABLE([libtool-lock],
+  [AS_HELP_STRING([--disable-libtool-lock],
+    [avoid locking (might break parallel builds)])])
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    case `/usr/bin/file conftest.o` in
+	      *x86-64*)
+		LD="${LD-ld} -m elf32_x86_64"
+		;;
+	      *)
+		LD="${LD-ld} -m elf_i386"
+		;;
+	    esac
+	    ;;
+	  powerpc64le-*)
+	    LD="${LD-ld} -m elf32lppclinux"
+	    ;;
+	  powerpc64-*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  powerpcle-*)
+	    LD="${LD-ld} -m elf64lppc"
+	    ;;
+	  powerpc-*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,
+    [AC_LANG_PUSH(C)
+     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])
+     AC_LANG_POP])
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if AC_TRY_EVAL(ac_compile); then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*)
+        case $host in
+        i?86-*-solaris*)
+          LD="${LD-ld} -m elf_x86_64"
+          ;;
+        sparc*-*-solaris*)
+          LD="${LD-ld} -m elf64_sparc"
+          ;;
+        esac
+        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.
+        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then
+          LD="${LD-ld}_sol2"
+        fi
+        ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+])# _LT_ENABLE_LOCK
+
+
+# _LT_PROG_AR
+# -----------
+m4_defun([_LT_PROG_AR],
+[AC_CHECK_TOOLS(AR, [ar], false)
+: ${AR=ar}
+: ${AR_FLAGS=cru}
+_LT_DECL([], [AR], [1], [The archiver])
+_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])
+
+AC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],
+  [lt_cv_ar_at_file=no
+   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],
+     [echo conftest.$ac_objext > conftest.lst
+      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'
+      AC_TRY_EVAL([lt_ar_try])
+      if test "$ac_status" -eq 0; then
+	# Ensure the archiver fails upon bogus file names.
+	rm -f conftest.$ac_objext libconftest.a
+	AC_TRY_EVAL([lt_ar_try])
+	if test "$ac_status" -ne 0; then
+          lt_cv_ar_at_file=@
+        fi
+      fi
+      rm -f conftest.* libconftest.a
+     ])
+  ])
+
+if test "x$lt_cv_ar_at_file" = xno; then
+  archiver_list_spec=
+else
+  archiver_list_spec=$lt_cv_ar_at_file
+fi
+_LT_DECL([], [archiver_list_spec], [1],
+  [How to feed a file listing to the archiver])
+])# _LT_PROG_AR
+
+
+# _LT_CMD_OLD_ARCHIVE
+# -------------------
+m4_defun([_LT_CMD_OLD_ARCHIVE],
+[_LT_PROG_AR
+
+AC_CHECK_TOOL(STRIP, strip, :)
+test -z "$STRIP" && STRIP=:
+_LT_DECL([], [STRIP], [1], [A symbol stripping program])
+
+AC_CHECK_TOOL(RANLIB, ranlib, :)
+test -z "$RANLIB" && RANLIB=:
+_LT_DECL([], [RANLIB], [1],
+    [Commands used to install an old-style archive])
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$tool_oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$tool_oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$tool_oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+_LT_DECL([], [old_postinstall_cmds], [2])
+_LT_DECL([], [old_postuninstall_cmds], [2])
+_LT_TAGDECL([], [old_archive_cmds], [2],
+    [Commands used to build an old-style archive])
+_LT_DECL([], [lock_old_archive_extraction], [0],
+    [Whether to use a lock for old archive extraction])
+])# _LT_CMD_OLD_ARCHIVE
+
+
+# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#		[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------------------
+# Check whether the given compiler option works
+AC_DEFUN([_LT_COMPILER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$3"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       $2=yes
+     fi
+   fi
+   $RM conftest*
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$5], , :, [$5])
+else
+    m4_if([$6], , :, [$6])
+fi
+])# _LT_COMPILER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])
+
+
+# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,
+#                  [ACTION-SUCCESS], [ACTION-FAILURE])
+# ----------------------------------------------------
+# Check whether the given linker option works
+AC_DEFUN([_LT_LINKER_OPTION],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_SED])dnl
+AC_CACHE_CHECK([$1], [$2],
+  [$2=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $3"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&AS_MESSAGE_LOG_FD
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         $2=yes
+       fi
+     else
+       $2=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+])
+
+if test x"[$]$2" = xyes; then
+    m4_if([$4], , :, [$4])
+else
+    m4_if([$5], , :, [$5])
+fi
+])# _LT_LINKER_OPTION
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])
+
+
+# LT_CMD_MAX_LEN
+#---------------
+AC_DEFUN([LT_CMD_MAX_LEN],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# find the maximum length of command line arguments
+AC_MSG_CHECKING([the maximum length of command line arguments])
+AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
+  i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  os2*)
+    # The test takes a long time on OS/2.
+    lt_cv_sys_max_cmd_len=8192
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len" && \
+	test undefined != "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`env echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+])
+if test -n $lt_cv_sys_max_cmd_len ; then
+  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
+else
+  AC_MSG_RESULT(none)
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+_LT_DECL([], [max_cmd_len], [0],
+    [What is the maximum length of a command?])
+])# LT_CMD_MAX_LEN
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])
+
+
+# _LT_HEADER_DLFCN
+# ----------------
+m4_defun([_LT_HEADER_DLFCN],
+[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl
+])# _LT_HEADER_DLFCN
+
+
+# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,
+#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)
+# ----------------------------------------------------------------
+m4_defun([_LT_TRY_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "$cross_compiling" = yes; then :
+  [$4]
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+[#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+int fnord () __attribute__((visibility("default")));
+#endif
+
+int fnord () { return 42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}]
+_LT_EOF
+  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) $1 ;;
+      x$lt_dlneed_uscore) $2 ;;
+      x$lt_dlunknown|x*) $3 ;;
+    esac
+  else :
+    # compilation failed
+    $3
+  fi
+fi
+rm -fr conftest*
+])# _LT_TRY_DLOPEN_SELF
+
+
+# LT_SYS_DLOPEN_SELF
+# ------------------
+AC_DEFUN([LT_SYS_DLOPEN_SELF],
+[m4_require([_LT_HEADER_DLFCN])dnl
+if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],[
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ])
+    ;;
+
+  *)
+    AC_CHECK_FUNC([shl_load],
+	  [lt_cv_dlopen="shl_load"],
+      [AC_CHECK_LIB([dld], [shl_load],
+	    [lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"],
+	[AC_CHECK_FUNC([dlopen],
+	      [lt_cv_dlopen="dlopen"],
+	  [AC_CHECK_LIB([dl], [dlopen],
+		[lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"],
+	    [AC_CHECK_LIB([svld], [dlopen],
+		  [lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"],
+	      [AC_CHECK_LIB([dld], [dld_link],
+		    [lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"])
+	      ])
+	    ])
+	  ])
+	])
+      ])
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    AC_CACHE_CHECK([whether a program can dlopen itself],
+	  lt_cv_dlopen_self, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,
+	    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)
+    ])
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],
+	  lt_cv_dlopen_self_static, [dnl
+	  _LT_TRY_DLOPEN_SELF(
+	    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,
+	    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)
+      ])
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+_LT_DECL([dlopen_support], [enable_dlopen], [0],
+	 [Whether dlopen is supported])
+_LT_DECL([dlopen_self], [enable_dlopen_self], [0],
+	 [Whether dlopen of programs is supported])
+_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],
+	 [Whether dlopen of statically linked programs is supported])
+])# LT_SYS_DLOPEN_SELF
+
+# Old name:
+AU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])
+
+
+# _LT_COMPILER_C_O([TAGNAME])
+# ---------------------------
+# Check to see if options -c and -o are simultaneously supported by compiler.
+# This macro does not hard code the compiler like AC_PROG_CC_C_O.
+m4_defun([_LT_COMPILER_C_O],
+[m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [[^ ]]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&AS_MESSAGE_LOG_FD)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&AS_MESSAGE_LOG_FD
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+     fi
+   fi
+   chmod u+w . 2>&AS_MESSAGE_LOG_FD
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+])
+_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],
+	[Does compiler simultaneously support -c and -o options?])
+])# _LT_COMPILER_C_O
+
+
+# _LT_COMPILER_FILE_LOCKS([TAGNAME])
+# ----------------------------------
+# Check to see if we can do hard links to lock some files if needed
+m4_defun([_LT_COMPILER_FILE_LOCKS],
+[m4_require([_LT_ENABLE_LOCK])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+_LT_COMPILER_C_O([$1])
+
+hard_links="nottested"
+if test "$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  AC_MSG_CHECKING([if we can lock with hard links])
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  AC_MSG_RESULT([$hard_links])
+  if test "$hard_links" = no; then
+    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])
+])# _LT_COMPILER_FILE_LOCKS
+
+
+# _LT_CHECK_OBJDIR
+# ----------------
+m4_defun([_LT_CHECK_OBJDIR],
+[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],
+[rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null])
+objdir=$lt_cv_objdir
+_LT_DECL([], [objdir], [0],
+         [The name of the directory that contains temporary libtool files])dnl
+m4_pattern_allow([LT_OBJDIR])dnl
+AC_DEFINE_UNQUOTED(LT_OBJDIR, "$lt_cv_objdir/",
+  [Define to the sub-directory in which libtool stores uninstalled libraries.])
+])# _LT_CHECK_OBJDIR
+
+
+# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])
+# --------------------------------------
+# Check hardcoding attributes.
+m4_defun([_LT_LINKER_HARDCODE_LIBPATH],
+[AC_MSG_CHECKING([how to hardcode library paths into programs])
+_LT_TAGVAR(hardcode_action, $1)=
+if test -n "$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)" ||
+   test -n "$_LT_TAGVAR(runpath_var, $1)" ||
+   test "X$_LT_TAGVAR(hardcode_automatic, $1)" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$_LT_TAGVAR(hardcode_direct, $1)" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, $1)" != no &&
+     test "$_LT_TAGVAR(hardcode_minus_L, $1)" != no; then
+    # Linking always hardcodes the temporary library directory.
+    _LT_TAGVAR(hardcode_action, $1)=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    _LT_TAGVAR(hardcode_action, $1)=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  _LT_TAGVAR(hardcode_action, $1)=unsupported
+fi
+AC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])
+
+if test "$_LT_TAGVAR(hardcode_action, $1)" = relink ||
+   test "$_LT_TAGVAR(inherit_rpath, $1)" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+_LT_TAGDECL([], [hardcode_action], [0],
+    [How to hardcode a shared library path into an executable])
+])# _LT_LINKER_HARDCODE_LIBPATH
+
+
+# _LT_CMD_STRIPLIB
+# ----------------
+m4_defun([_LT_CMD_STRIPLIB],
+[m4_require([_LT_DECL_EGREP])
+striplib=
+old_striplib=
+AC_MSG_CHECKING([whether stripping libraries is possible])
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  AC_MSG_RESULT([yes])
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      AC_MSG_RESULT([yes])
+    else
+      AC_MSG_RESULT([no])
+    fi
+    ;;
+  *)
+    AC_MSG_RESULT([no])
+    ;;
+  esac
+fi
+_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])
+_LT_DECL([], [striplib], [1])
+])# _LT_CMD_STRIPLIB
+
+
+# _LT_SYS_DYNAMIC_LINKER([TAG])
+# -----------------------------
+# PORTME Fill in your ld.so characteristics
+m4_defun([_LT_SYS_DYNAMIC_LINKER],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_OBJDUMP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CHECK_SHELL_FEATURES])dnl
+AC_MSG_CHECKING([dynamic linker characteristics])
+m4_if([$1],
+	[], [
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([[A-Za-z]]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[[lt_foo]]++; }
+  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([[A-Za-z]]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi])
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[[4-9]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[[01]] | aix4.[[01]].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[[45]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$cc_basename in
+  yes,*)
+    # gcc
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+m4_if([$1], [],[
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"])
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    dynamic_linker='Win32 ld.exe'
+    ;;
+
+  *,cl*)
+    # Native MSVC
+    libname_spec='$name'
+    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
+    library_names_spec='${libname}.dll.lib'
+
+    case $build_os in
+    mingw*)
+      sys_lib_search_path_spec=
+      lt_save_ifs=$IFS
+      IFS=';'
+      for lt_path in $LIB
+      do
+        IFS=$lt_save_ifs
+        # Let DOS variable expansion print the short 8.3 style file name.
+        lt_path=`cd "$lt_path" 2>/dev/null && cmd //C "for %i in (".") do @echo %~si"`
+        sys_lib_search_path_spec="$sys_lib_search_path_spec $lt_path"
+      done
+      IFS=$lt_save_ifs
+      # Convert to MSYS style.
+      sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | sed -e 's|\\\\|/|g' -e 's| \\([[a-zA-Z]]\\):| /\\1|g' -e 's|^ ||'`
+      ;;
+    cygwin*)
+      # Convert to unix form, then to dos form, then back to unix form
+      # but this time dos style (no spaces!) so that the unix form looks
+      # like /cygdrive/c/PROGRA~1:/cygdr...
+      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
+      sys_lib_search_path_spec=`cygpath --path --dos "$sys_lib_search_path_spec" 2>/dev/null`
+      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      ;;
+    *)
+      sys_lib_search_path_spec="$LIB"
+      if $ECHO "$sys_lib_search_path_spec" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then
+        # It is most probably a Windows format PATH.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      # FIXME: find the short name or the path components, as spaces are
+      # common. (e.g. "Program Files" -> "PROGRA~1")
+      ;;
+    esac
+
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+    dynamic_linker='Win32 link.exe'
+    ;;
+
+  *)
+    # Assume MSVC wrapper
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    dynamic_linker='Win32 ld.exe'
+    ;;
+  esac
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+m4_if([$1], [],[
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"])
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[[23]].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[[01]]* | freebsdelf3.[[01]]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \
+  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+haiku*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[[3-9]]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux # correct to gnu/linux during the next big refactor
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],
+    [lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\"; \
+	 LDFLAGS=\"\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\""
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],
+      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
+	 [lt_cv_shlibpath_overrides_runpath=yes])])
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+    ])
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[[89]] | openbsd2.[[89]].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux # correct to gnu/linux during the next big refactor
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+AC_MSG_RESULT([$dynamic_linker])
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+_LT_DECL([], [variables_saved_for_relink], [1],
+    [Variables whose values should be saved in libtool wrapper scripts and
+    restored at link time])
+_LT_DECL([], [need_lib_prefix], [0],
+    [Do we need the "lib" prefix for modules?])
+_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])
+_LT_DECL([], [version_type], [0], [Library versioning type])
+_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])
+_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])
+_LT_DECL([], [shlibpath_overrides_runpath], [0],
+    [Is shlibpath searched before the hard-coded library search path?])
+_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
+_LT_DECL([], [library_names_spec], [1],
+    [[List of archive names.  First name is the real one, the rest are links.
+    The last name is the one that the linker finds with -lNAME]])
+_LT_DECL([], [soname_spec], [1],
+    [[The coded name of the library, if different from the real name]])
+_LT_DECL([], [install_override_mode], [1],
+    [Permission mode override for installation of shared libraries])
+_LT_DECL([], [postinstall_cmds], [2],
+    [Command to use after installation of a shared archive])
+_LT_DECL([], [postuninstall_cmds], [2],
+    [Command to use after uninstallation of a shared archive])
+_LT_DECL([], [finish_cmds], [2],
+    [Commands used to finish a libtool library installation in a directory])
+_LT_DECL([], [finish_eval], [1],
+    [[As "finish_cmds", except a single script fragment to be evaled but
+    not shown]])
+_LT_DECL([], [hardcode_into_libs], [0],
+    [Whether we should hardcode library paths into libraries])
+_LT_DECL([], [sys_lib_search_path_spec], [2],
+    [Compile-time system search path for libraries])
+_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],
+    [Run-time system search path for libraries])
+])# _LT_SYS_DYNAMIC_LINKER
+
+
+# _LT_PATH_TOOL_PREFIX(TOOL)
+# --------------------------
+# find a file program which can recognize shared library
+AC_DEFUN([_LT_PATH_TOOL_PREFIX],
+[m4_require([_LT_DECL_EGREP])dnl
+AC_MSG_CHECKING([for $1])
+AC_CACHE_VAL(lt_cv_path_MAGIC_CMD,
+[case $MAGIC_CMD in
+[[\\/*] |  ?:[\\/]*])
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+dnl $ac_dummy forces splitting on constant user-supplied paths.
+dnl POSIX.2 word splitting is done only on the output of word expansions,
+dnl not every word.  This closes a longstanding sh security hole.
+  ac_dummy="m4_if([$2], , $PATH, [$2])"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$1; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/$1"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac])
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  AC_MSG_RESULT($MAGIC_CMD)
+else
+  AC_MSG_RESULT(no)
+fi
+_LT_DECL([], [MAGIC_CMD], [0],
+	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
+])# _LT_PATH_TOOL_PREFIX
+
+# Old name:
+AU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])
+
+
+# _LT_PATH_MAGIC
+# --------------
+# find a file program which can recognize a shared library
+m4_defun([_LT_PATH_MAGIC],
+[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)
+  else
+    MAGIC_CMD=:
+  fi
+fi
+])# _LT_PATH_MAGIC
+
+
+# LT_PATH_LD
+# ----------
+# find the pathname to the GNU or non-GNU linker
+AC_DEFUN([LT_PATH_LD],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_PROG_ECHO_BACKSLASH])dnl
+
+AC_ARG_WITH([gnu-ld],
+    [AS_HELP_STRING([--with-gnu-ld],
+	[assume the C compiler uses GNU ld @<:@default=no@:>@])],
+    [test "$withval" = no || with_gnu_ld=yes],
+    [with_gnu_ld=no])dnl
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by $CC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]]* | ?:[[\\/]]*)
+      re_direlt='/[[^/]][[^/]]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(lt_cv_path_LD,
+[if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+_LT_PATH_LD_GNU
+AC_SUBST([LD])
+
+_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])
+])# LT_PATH_LD
+
+# Old names:
+AU_ALIAS([AM_PROG_LD], [LT_PATH_LD])
+AU_ALIAS([AC_PROG_LD], [LT_PATH_LD])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_LD], [])
+dnl AC_DEFUN([AC_PROG_LD], [])
+
+
+# _LT_PATH_LD_GNU
+#- --------------
+m4_defun([_LT_PATH_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac])
+with_gnu_ld=$lt_cv_prog_gnu_ld
+])# _LT_PATH_LD_GNU
+
+
+# _LT_CMD_RELOAD
+# --------------
+# find reload flag for linker
+#   -- PORTME Some linkers may need a different reload flag.
+m4_defun([_LT_CMD_RELOAD],
+[AC_CACHE_CHECK([for $LD option to reload object files],
+  lt_cv_ld_reload_flag,
+  [lt_cv_ld_reload_flag='-r'])
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    if test "$GCC" != yes; then
+      reload_cmds=false
+    fi
+    ;;
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl
+_LT_TAGDECL([], [reload_cmds], [2])dnl
+])# _LT_CMD_RELOAD
+
+
+# _LT_CHECK_MAGIC_METHOD
+# ----------------------
+# how to check for library dependencies
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_MAGIC_METHOD],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+AC_CACHE_CHECK([how to recognize dependent libraries],
+lt_cv_deplibs_check_method,
+[lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[[4-9]]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[[45]]*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    # Keep this pattern in sync with the one in func_win32_libid.
+    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]']
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\.[[0-9]]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[[3-9]]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\.so\.[[0-9]]+\.[[0-9]]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+])
+
+file_magic_glob=
+want_nocaseglob=no
+if test "$build" = "$host"; then
+  case $host_os in
+  mingw* | pw32*)
+    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then
+      want_nocaseglob=yes
+    else
+      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[[\1]]\/[[\1]]\/g;/g"`
+    fi
+    ;;
+  esac
+fi
+
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+_LT_DECL([], [deplibs_check_method], [1],
+    [Method to check whether dependent libraries are shared objects])
+_LT_DECL([], [file_magic_cmd], [1],
+    [Command to use when deplibs_check_method = "file_magic"])
+_LT_DECL([], [file_magic_glob], [1],
+    [How to find potential files when deplibs_check_method = "file_magic"])
+_LT_DECL([], [want_nocaseglob], [1],
+    [Find potential files using nocaseglob when deplibs_check_method = "file_magic"])
+])# _LT_CHECK_MAGIC_METHOD
+
+
+# LT_PATH_NM
+# ----------
+# find the pathname to a BSD- or MS-compatible name lister
+AC_DEFUN([LT_PATH_NM],
+[AC_REQUIRE([AC_PROG_CC])dnl
+AC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,
+[if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi])
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    AC_CHECK_TOOLS(DUMPBIN, [dumpbin "link -dump"], :)
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+  AC_SUBST([DUMPBIN])
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+AC_SUBST([NM])
+_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl
+
+AC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],
+  [lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  (eval echo "\"\$as_me:$LINENO: output\"" >&AS_MESSAGE_LOG_FD)
+  cat conftest.out >&AS_MESSAGE_LOG_FD
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*])
+])# LT_PATH_NM
+
+# Old names:
+AU_ALIAS([AM_PROG_NM], [LT_PATH_NM])
+AU_ALIAS([AC_PROG_NM], [LT_PATH_NM])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_PROG_NM], [])
+dnl AC_DEFUN([AC_PROG_NM], [])
+
+# _LT_CHECK_SHAREDLIB_FROM_LINKLIB
+# --------------------------------
+# how to determine the name of the shared library
+# associated with a specific link library.
+#  -- PORTME fill in with the dynamic library characteristics
+m4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],
+[m4_require([_LT_DECL_EGREP])
+m4_require([_LT_DECL_OBJDUMP])
+m4_require([_LT_DECL_DLLTOOL])
+AC_CACHE_CHECK([how to associate runtime and link libraries],
+lt_cv_sharedlib_from_linklib_cmd,
+[lt_cv_sharedlib_from_linklib_cmd='unknown'
+
+case $host_os in
+cygwin* | mingw* | pw32* | cegcc*)
+  # two different shell functions defined in ltmain.sh
+  # decide which to use based on capabilities of $DLLTOOL
+  case `$DLLTOOL --help 2>&1` in
+  *--identify-strict*)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
+    ;;
+  *)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback
+    ;;
+  esac
+  ;;
+*)
+  # fallback: assume linklib IS sharedlib
+  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
+  ;;
+esac
+])
+sharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd
+test -z "$sharedlib_from_linklib_cmd" && sharedlib_from_linklib_cmd=$ECHO
+
+_LT_DECL([], [sharedlib_from_linklib_cmd], [1],
+    [Command to associate shared and link libraries])
+])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB
+
+
+# _LT_PATH_MANIFEST_TOOL
+# ----------------------
+# locate the manifest tool
+m4_defun([_LT_PATH_MANIFEST_TOOL],
+[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)
+test -z "$MANIFEST_TOOL" && MANIFEST_TOOL=mt
+AC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],
+  [lt_cv_path_mainfest_tool=no
+  echo "$as_me:$LINENO: $MANIFEST_TOOL '-?'" >&AS_MESSAGE_LOG_FD
+  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out
+  cat conftest.err >&AS_MESSAGE_LOG_FD
+  if $GREP 'Manifest Tool' conftest.out > /dev/null; then
+    lt_cv_path_mainfest_tool=yes
+  fi
+  rm -f conftest*])
+if test "x$lt_cv_path_mainfest_tool" != xyes; then
+  MANIFEST_TOOL=:
+fi
+_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl
+])# _LT_PATH_MANIFEST_TOOL
+
+
+# LT_LIB_M
+# --------
+# check for math library
+AC_DEFUN([LT_LIB_M],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+LIBM=
+case $host in
+*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)
+  # These system don't have libm, or don't need it
+  ;;
+*-ncr-sysv4.3*)
+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM="-lmw")
+  AC_CHECK_LIB(m, cos, LIBM="$LIBM -lm")
+  ;;
+*)
+  AC_CHECK_LIB(m, cos, LIBM="-lm")
+  ;;
+esac
+AC_SUBST([LIBM])
+])# LT_LIB_M
+
+# Old name:
+AU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_CHECK_LIBM], [])
+
+
+# _LT_COMPILER_NO_RTTI([TAGNAME])
+# -------------------------------
+m4_defun([_LT_COMPILER_NO_RTTI],
+[m4_require([_LT_TAG_COMPILER])dnl
+
+_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;
+  esac
+
+  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
+    lt_cv_prog_compiler_rtti_exceptions,
+    [-fno-rtti -fno-exceptions], [],
+    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
+fi
+_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],
+	[Compiler flag to turn off builtin functions])
+])# _LT_COMPILER_NO_RTTI
+
+
+# _LT_CMD_GLOBAL_SYMBOLS
+# ----------------------
+m4_defun([_LT_CMD_GLOBAL_SYMBOLS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+AC_REQUIRE([LT_PATH_LD])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+AC_MSG_CHECKING([command to parse $NM output from $compiler object])
+AC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],
+[
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[[BCDEGRST]]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([[_A-Za-z]][[_A-Za-z0-9]]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[[BCDT]]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[[ABCDGISTW]]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[[ABCDEGRST]]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[[BCDEGRST]]'
+  ;;
+osf*)
+  symcode='[[BCDEGQRST]]'
+  ;;
+solaris*)
+  symcode='[[BDRT]]'
+  ;;
+sco3.2v5*)
+  symcode='[[DT]]'
+  ;;
+sysv4.2uw2*)
+  symcode='[[DT]]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[[ABDT]]'
+  ;;
+sysv4)
+  symcode='[[DFNSTU]]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[[ABCDGIRSTW]]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK ['"\
+"     {last_section=section; section=\$ 3};"\
+"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx]"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+  lt_cv_sys_global_symbol_pipe="$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'"
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if AC_TRY_EVAL(ac_compile); then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if AC_TRY_EVAL(NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
+#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+/* DATA imports from DLLs on WIN32 con't be const, because runtime
+   relocations are performed -- see ld's documentation on pseudo-relocs.  */
+# define LT@&t@_DLSYM_CONST
+#elif defined(__osf__)
+/* This system does not cope well with relocations in const data.  */
+# define LT@&t@_DLSYM_CONST
+#else
+# define LT@&t@_DLSYM_CONST const
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+LT@&t@_DLSYM_CONST struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[[]] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_globsym_save_LIBS=$LIBS
+	  lt_globsym_save_CFLAGS=$CFLAGS
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)"
+	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS=$lt_globsym_save_LIBS
+	  CFLAGS=$lt_globsym_save_CFLAGS
+	else
+	  echo "cannot find nm_test_func in $nlist" >&AS_MESSAGE_LOG_FD
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&AS_MESSAGE_LOG_FD
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&AS_MESSAGE_LOG_FD
+    fi
+  else
+    echo "$progname: failed program was:" >&AS_MESSAGE_LOG_FD
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+])
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  AC_MSG_RESULT(failed)
+else
+  AC_MSG_RESULT(ok)
+fi
+
+# Response file support.
+if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+  nm_file_list_spec='@'
+elif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then
+  nm_file_list_spec='@'
+fi
+
+_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],
+    [Take the output of nm and produce a listing of raw symbols and C names])
+_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],
+    [Transform the output of nm in a proper C declaration])
+_LT_DECL([global_symbol_to_c_name_address],
+    [lt_cv_sys_global_symbol_to_c_name_address], [1],
+    [Transform the output of nm in a C name address pair])
+_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
+    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
+    [Transform the output of nm in a C name address pair when lib prefix is needed])
+_LT_DECL([], [nm_file_list_spec], [1],
+    [Specify filename containing input files for $NM])
+]) # _LT_CMD_GLOBAL_SYMBOLS
+
+
+# _LT_COMPILER_PIC([TAGNAME])
+# ---------------------------
+m4_defun([_LT_COMPILER_PIC],
+[m4_require([_LT_TAG_COMPILER])dnl
+_LT_TAGVAR(lt_prog_compiler_wl, $1)=
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+_LT_TAGVAR(lt_prog_compiler_static, $1)=
+
+m4_if([$1], [CXX], [
+  # C++ specific cases for pic, static, wl, etc.
+  if test "$GXX" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+    aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+    mingw* | cygwin* | os2* | pw32* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+    *djgpp*)
+      # DJGPP does not support shared libraries at all
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+      ;;
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+    *qnx* | *nto*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+  else
+    case $host_os in
+      aix[[4-9]]*)
+	# All AIX code is PIC.
+	if test "$host_cpu" = ia64; then
+	  # AIX 5 now supports IA64 processor
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	else
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+	fi
+	;;
+      chorus*)
+	case $cc_basename in
+	cxch68*)
+	  # Green Hills C++ Compiler
+	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
+	  ;;
+	esac
+	;;
+      mingw* | cygwin* | os2* | pw32* | cegcc*)
+	# This hack is so that the source file can tell whether it is being
+	# built for inclusion in a dll (and should export symbols for example).
+	m4_if([$1], [GCJ], [],
+	  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+	;;
+      dgux*)
+	case $cc_basename in
+	  ec++*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  ghcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      freebsd* | dragonfly*)
+	# FreeBSD uses GNU C++
+	;;
+      hpux9* | hpux10* | hpux11*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    if test "$host_cpu" != ia64; then
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	    fi
+	    ;;
+	  aCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+	    case $host_cpu in
+	    hppa*64*|ia64*)
+	      # +Z the default
+	      ;;
+	    *)
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	      ;;
+	    esac
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      interix*)
+	# This is c89, which is MS Visual C++ (no shared libs)
+	# Anyone wants to do a port?
+	;;
+      irix5* | irix6* | nonstopux*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    # CC pic flag -KPIC is the default.
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+	case $cc_basename in
+	  KCC*)
+	    # KAI C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    ;;
+	  ecpc* )
+	    # old Intel C++ for x86_64 which still supported -KPIC.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  icpc* )
+	    # Intel C++, used to be incompatible with GCC.
+	    # ICC 10 doesn't accept -KPIC any more.
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	    ;;
+	  pgCC* | pgcpp*)
+	    # Portland Group C++ compiler
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  cxx*)
+	    # Compaq C++
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)
+	    # IBM XL 8.0, 9.0 on PPC and BlueGene
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+      lynxos*)
+	;;
+      m88k*)
+	;;
+      mvs*)
+	case $cc_basename in
+	  cxx*)
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      netbsd* | netbsdelf*-gnu)
+	;;
+      *qnx* | *nto*)
+        # QNX uses GNU C++, but need to define -shared option too, otherwise
+        # it will coredump.
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+        ;;
+      osf3* | osf4* | osf5*)
+	case $cc_basename in
+	  KCC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'
+	    ;;
+	  RCC*)
+	    # Rational C++ 2.4.1
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  cxx*)
+	    # Digital/Compaq C++
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    # Make sure the PIC flag is empty.  It appears that all Alpha
+	    # Linux and Compaq Tru64 Unix objects are PIC.
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      psos*)
+	;;
+      solaris*)
+	case $cc_basename in
+	  CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	    ;;
+	  gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sunos4*)
+	case $cc_basename in
+	  CC*)
+	    # Sun C++ 4.x
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	  lcc*)
+	    # Lucid
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+	case $cc_basename in
+	  CC*)
+	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	    ;;
+	esac
+	;;
+      tandem*)
+	case $cc_basename in
+	  NCC*)
+	    # NonStop-UX NCC 3.20
+	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	    ;;
+	  *)
+	    ;;
+	esac
+	;;
+      vxworks*)
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+	;;
+    esac
+  fi
+],
+[
+  if test "$GCC" = yes; then
+    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[[3-9]]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '
+      if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+        _LT_TAGVAR(lt_prog_compiler_pic, $1)="-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)"
+      fi
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      else
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      m4_if([$1], [GCJ], [],
+	[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # PIC (with -KPIC) is the default.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'
+	;;
+      nagfor*)
+	# NAG Fortran compiler
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+        ;;
+      ccc*)
+        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+        # All Alpha code is PIC.
+        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ Ceres\ Fortran* | *Sun*Fortran*\ [[1-7]].* | *Sun*Fortran*\ 8.[[0-3]]*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''
+	  ;;
+	*Sun\ F* | *Sun*Fortran*)
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  ;;
+        *Intel*\ [[CF]]*Compiler*)
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'
+	  ;;
+	*Portland\ Group*)
+	  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+	  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'
+	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      # All OSF/1 code is PIC.
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    rdos*)
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;
+      *)
+	_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'
+	_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    unicos*)
+      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'
+      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'
+      ;;
+
+    *)
+      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no
+      ;;
+    esac
+  fi
+])
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)=
+    ;;
+  *)
+    _LT_TAGVAR(lt_prog_compiler_pic, $1)="$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])"
+    ;;
+esac
+
+AC_CACHE_CHECK([for $compiler option to produce PIC],
+  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],
+  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])
+_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$_LT_TAGVAR(lt_prog_compiler_pic, $1)"; then
+  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],
+    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],
+    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],
+    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in
+     "" | " "*) ;;
+     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=" $_LT_TAGVAR(lt_prog_compiler_pic, $1)" ;;
+     esac],
+    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=
+     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])
+fi
+_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],
+	[Additional compiler flags for building library objects])
+
+_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],
+	[How to pass a linker flag through the compiler])
+#
+# Check to make sure the static flag actually works.
+#
+wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\"
+_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],
+  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),
+  $lt_tmp_static_flag,
+  [],
+  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])
+_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],
+	[Compiler flag to prevent dynamic linking])
+])# _LT_COMPILER_PIC
+
+
+# _LT_LINKER_SHLIBS([TAGNAME])
+# ----------------------------
+# See if the linker supports building shared libraries.
+m4_defun([_LT_LINKER_SHLIBS],
+[AC_REQUIRE([LT_PATH_LD])dnl
+AC_REQUIRE([LT_PATH_NM])dnl
+m4_require([_LT_PATH_MANIFEST_TOOL])dnl
+m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_DECL_SED])dnl
+m4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl
+m4_require([_LT_TAG_COMPILER])dnl
+AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+m4_if([$1], [CXX], [
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  case $host_os in
+  aix[[4-9]]*)
+    # If we're using GNU nm, then we don't want the "-C" option.
+    # -C means demangle to AIX nm, but means don't demangle with GNU nm
+    # Also, AIX nm treats weak defined symbols like other global defined
+    # symbols, whereas GNU nm marks them as "W".
+    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    else
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+    fi
+    ;;
+  pw32*)
+    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
+    ;;
+  cygwin* | mingw* | cegcc*)
+    case $cc_basename in
+    cl*)
+      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
+      ;;
+    *)
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
+      ;;
+    esac
+    ;;
+  linux* | k*bsd*-gnu | gnu*)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+    ;;
+  *)
+    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+    ;;
+  esac
+], [
+  runpath_var=
+  _LT_TAGVAR(allow_undefined_flag, $1)=
+  _LT_TAGVAR(always_export_symbols, $1)=no
+  _LT_TAGVAR(archive_cmds, $1)=
+  _LT_TAGVAR(archive_expsym_cmds, $1)=
+  _LT_TAGVAR(compiler_needs_object, $1)=no
+  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  _LT_TAGVAR(hardcode_automatic, $1)=no
+  _LT_TAGVAR(hardcode_direct, $1)=no
+  _LT_TAGVAR(hardcode_direct_absolute, $1)=no
+  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+  _LT_TAGVAR(hardcode_minus_L, $1)=no
+  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+  _LT_TAGVAR(inherit_rpath, $1)=no
+  _LT_TAGVAR(link_all_deplibs, $1)=unknown
+  _LT_TAGVAR(module_cmds, $1)=
+  _LT_TAGVAR(module_expsym_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_new_cmds, $1)=
+  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
+  _LT_TAGVAR(thread_safe_flag_spec, $1)=
+  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  _LT_TAGVAR(include_expsyms, $1)=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+dnl Note also adjust exclude_expsyms for C++ above.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  linux* | k*bsd*-gnu | gnu*)
+    _LT_TAGVAR(link_all_deplibs, $1)=no
+    ;;
+  esac
+
+  _LT_TAGVAR(ld_shlibs, $1)=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[[2-9]]*) ;;
+	  *\ \(GNU\ Binutils\)\ [[3-9]]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[[3-9]]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+      # as there is no search path for DLLs.
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=no
+      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
+      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    haiku*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    interix[[3-9]]*)
+      _LT_TAGVAR(hardcode_direct, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=' $pic_flag'
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)=
+	  tmp_sharedflag='--shared' ;;
+	xl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  _LT_TAGVAR(compiler_needs_object, $1)=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	_LT_TAGVAR(archive_cmds, $1)='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        _LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [[01]].* | *\ 2.[[0-9]].* | *\ 2.1[[0-5]].*)
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+    esac
+
+    if test "$_LT_TAGVAR(ld_shlibs, $1)" = no; then
+      runpath_var=
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
+      _LT_TAGVAR(whole_archive_flag_spec, $1)=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	_LT_TAGVAR(hardcode_direct, $1)=unsupported
+      fi
+      ;;
+
+    aix[[4-9]]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      _LT_TAGVAR(archive_cmds, $1)=''
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[[012]]|aix4.[[012]].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	_LT_TAGVAR(link_all_deplibs, $1)=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      _LT_TAGVAR(always_export_symbols, $1)=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	_LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        _LT_SYS_MODULE_PATH_AIX([$1])
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	  _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 _LT_SYS_MODULE_PATH_AIX([$1])
+	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	  fi
+	  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            _LT_TAGVAR(archive_expsym_cmds, $1)=''
+        ;;
+      m68k)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[[45]]*)
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      case $cc_basename in
+      cl*)
+	# Native MSVC
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	_LT_TAGVAR(always_export_symbols, $1)=yes
+	_LT_TAGVAR(file_list_spec, $1)='@'
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
+	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
+	  else
+	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
+	  fi~
+	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+	  linknames='
+	# The linker will not automatically build a static lib if we build a DLL.
+	# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
+	_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1,DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
+	# Don't use ranlib
+	_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
+	_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
+	  lt_tool_outputfile="@TOOL_OUTPUT@"~
+	  case $lt_outputfile in
+	    *.exe|*.EXE) ;;
+	    *)
+	      lt_outputfile="$lt_outputfile.exe"
+	      lt_tool_outputfile="$lt_tool_outputfile.exe"
+	      ;;
+	  esac~
+	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
+	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+	    $RM "$lt_outputfile.manifest";
+	  fi'
+	;;
+      *)
+	# Assume MSVC wrapper
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	_LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+	# The linker will automatically build a .lib file if we build a DLL.
+	_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	# FIXME: Should let the user specify the lib program.
+	_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'
+	_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	;;
+      esac
+      ;;
+
+    darwin* | rhapsody*)
+      _LT_DARWIN_LINKER_FEATURES($1)
+      ;;
+
+    dgux*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2.*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	_LT_TAGVAR(hardcode_minus_L, $1)=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	m4_if($1, [], [
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  _LT_LINKER_OPTION([if $CC understands -b],
+	    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],
+	    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],
+	    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],
+	  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  ;;
+	*)
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+	# This should be the same for all languages, so no per-tag cache variable.
+	AC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],
+	  [lt_cv_irix_exported_symbol],
+	  [save_LDFLAGS="$LDFLAGS"
+	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+	   AC_LINK_IFELSE(
+	     [AC_LANG_SOURCE(
+	        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],
+			      [C++], [[int foo (void) { return 0; }]],
+			      [Fortran 77], [[
+      subroutine foo
+      end]],
+			      [Fortran], [[
+      subroutine foo
+      end]])])],
+	      [lt_cv_irix_exported_symbol=yes],
+	      [lt_cv_irix_exported_symbol=no])
+           LDFLAGS="$save_LDFLAGS"])
+	if test "$lt_cv_irix_exported_symbol" = yes; then
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+	fi
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(inherit_rpath, $1)=yes
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    newsos6)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	_LT_TAGVAR(hardcode_direct, $1)=yes
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)
+	     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	     ;;
+	   *)
+	     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	_LT_TAGVAR(ld_shlibs, $1)=no
+      fi
+      ;;
+
+    os2*)
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+      else
+	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+      fi
+      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+      ;;
+
+    solaris*)
+      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      case $host_os in
+      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_direct, $1)=yes
+      _LT_TAGVAR(hardcode_minus_L, $1)=yes
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'
+	  _LT_TAGVAR(hardcode_direct, $1)=no
+        ;;
+	motorola)
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    sysv4.3*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	_LT_TAGVAR(ld_shlibs, $1)=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+      _LT_TAGVAR(link_all_deplibs, $1)=yes
+      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      ;;
+
+    *)
+      _LT_TAGVAR(ld_shlibs, $1)=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+])
+AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld
+
+_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
+_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
+_LT_DECL([], [extract_expsyms_cmds], [2],
+    [The commands to extract the exported symbol list from a shared archive])
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
+x|xyes)
+  # Assume -lc should be added
+  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $_LT_TAGVAR(archive_cmds, $1) in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      AC_CACHE_CHECK([whether -lc should be explicitly linked in],
+	[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),
+	[$RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if AC_TRY_EVAL(ac_compile) 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)
+	  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)
+	  _LT_TAGVAR(allow_undefined_flag, $1)=
+	  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1)
+	  then
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	  else
+	    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	  fi
+	  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+	])
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],
+    [Whether or not to add -lc for building shared libraries])
+_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],
+    [enable_shared_with_static_runtimes], [0],
+    [Whether or not to disallow shared libs when runtime libs are static])
+_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
+    [Compiler flag to allow reflexive dlopens])
+_LT_TAGDECL([], [whole_archive_flag_spec], [1],
+    [Compiler flag to generate shared objects directly from archives])
+_LT_TAGDECL([], [compiler_needs_object], [1],
+    [Whether the compiler copes with passing no objects directly])
+_LT_TAGDECL([], [old_archive_from_new_cmds], [2],
+    [Create an old-style archive from a shared archive])
+_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
+    [Create a temporary old-style archive to link instead of a shared archive])
+_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])
+_LT_TAGDECL([], [archive_expsym_cmds], [2])
+_LT_TAGDECL([], [module_cmds], [2],
+    [Commands used to build a loadable module if different from building
+    a shared archive.])
+_LT_TAGDECL([], [module_expsym_cmds], [2])
+_LT_TAGDECL([], [with_gnu_ld], [1],
+    [Whether we are building with GNU ld or not])
+_LT_TAGDECL([], [allow_undefined_flag], [1],
+    [Flag that allows shared libraries with undefined symbols to be built])
+_LT_TAGDECL([], [no_undefined_flag], [1],
+    [Flag that enforces no undefined symbols])
+_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],
+    [Flag to hardcode $libdir into a binary during linking.
+    This must work even if $libdir does not exist])
+_LT_TAGDECL([], [hardcode_libdir_separator], [1],
+    [Whether we need a single "-rpath" flag with a separated argument])
+_LT_TAGDECL([], [hardcode_direct], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary])
+_LT_TAGDECL([], [hardcode_direct_absolute], [0],
+    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
+    DIR into the resulting binary and the resulting library dependency is
+    "absolute", i.e impossible to change by setting ${shlibpath_var} if the
+    library is relocated])
+_LT_TAGDECL([], [hardcode_minus_L], [0],
+    [Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_shlibpath_var], [0],
+    [Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+    into the resulting binary])
+_LT_TAGDECL([], [hardcode_automatic], [0],
+    [Set to "yes" if building a shared library automatically hardcodes DIR
+    into the library and all subsequent libraries and executables linked
+    against it])
+_LT_TAGDECL([], [inherit_rpath], [0],
+    [Set to yes if linker adds runtime paths of dependent libraries
+    to runtime path list])
+_LT_TAGDECL([], [link_all_deplibs], [0],
+    [Whether libtool must link a program against all its dependency libraries])
+_LT_TAGDECL([], [always_export_symbols], [0],
+    [Set to "yes" if exported symbols are required])
+_LT_TAGDECL([], [export_symbols_cmds], [2],
+    [The commands to list exported symbols])
+_LT_TAGDECL([], [exclude_expsyms], [1],
+    [Symbols that should not be listed in the preloaded symbols])
+_LT_TAGDECL([], [include_expsyms], [1],
+    [Symbols that must always be exported])
+_LT_TAGDECL([], [prelink_cmds], [2],
+    [Commands necessary for linking programs (against libraries) with templates])
+_LT_TAGDECL([], [postlink_cmds], [2],
+    [Commands necessary for finishing linking programs])
+_LT_TAGDECL([], [file_list_spec], [1],
+    [Specify filename containing input files])
+dnl FIXME: Not yet implemented
+dnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],
+dnl    [Compiler flag to generate thread safe objects])
+])# _LT_LINKER_SHLIBS
+
+
+# _LT_LANG_C_CONFIG([TAG])
+# ------------------------
+# Ensure that the configuration variables for a C compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_C_CONFIG],
+[m4_require([_LT_DECL_EGREP])dnl
+lt_save_CC="$CC"
+AC_LANG_PUSH(C)
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+_LT_TAG_COMPILER
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_SYS_DYNAMIC_LINKER($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+  LT_SYS_DLOPEN_SELF
+  _LT_CMD_STRIPLIB
+
+  # Report which library types will actually be built
+  AC_MSG_CHECKING([if libtool supports shared libraries])
+  AC_MSG_RESULT([$can_build_shared])
+
+  AC_MSG_CHECKING([whether to build shared libraries])
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[[4-9]]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  AC_MSG_RESULT([$enable_shared])
+
+  AC_MSG_CHECKING([whether to build static libraries])
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  AC_MSG_RESULT([$enable_static])
+
+  _LT_CONFIG($1)
+fi
+AC_LANG_POP
+CC="$lt_save_CC"
+])# _LT_LANG_C_CONFIG
+
+
+# _LT_LANG_CXX_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a C++ compiler are suitably
+# defined.  These variables are subsequently used by _LT_CONFIG to write
+# the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_CXX_CONFIG],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+m4_require([_LT_DECL_EGREP])dnl
+m4_require([_LT_PATH_MANIFEST_TOOL])dnl
+if test -n "$CXX" && ( test "X$CXX" != "Xno" &&
+    ( (test "X$CXX" = "Xg++" && `g++ -v >/dev/null 2>&1` ) ||
+    (test "X$CXX" != "Xg++"))) ; then
+  AC_PROG_CXXCPP
+else
+  _lt_caught_CXX_error=yes
+fi
+
+AC_LANG_PUSH(C++)
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(compiler_needs_object, $1)=no
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for C++ test sources.
+ac_ext=cpp
+
+# Object file extension for compiled C++ test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the CXX compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_caught_CXX_error" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="int some_variable = 0;"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC=$CC
+  lt_save_CFLAGS=$CFLAGS
+  lt_save_LD=$LD
+  lt_save_GCC=$GCC
+  GCC=$GXX
+  lt_save_with_gnu_ld=$with_gnu_ld
+  lt_save_path_LD=$lt_cv_path_LD
+  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
+    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
+  else
+    $as_unset lt_cv_prog_gnu_ld
+  fi
+  if test -n "${lt_cv_path_LDCXX+set}"; then
+    lt_cv_path_LD=$lt_cv_path_LDCXX
+  else
+    $as_unset lt_cv_path_LD
+  fi
+  test -z "${LDCXX+set}" || LD=$LDCXX
+  CC=${CXX-"c++"}
+  CFLAGS=$CXXFLAGS
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    # We don't want -fno-exception when compiling C++ code, so set the
+    # no_builtin_flag separately
+    if test "$GXX" = yes; then
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'
+    else
+      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=
+    fi
+
+    if test "$GXX" = yes; then
+      # Set up default GNU C++ configuration
+
+      LT_PATH_LD
+
+      # Check if GNU C++ uses GNU ld as the underlying linker, since the
+      # archiving commands below assume that GNU ld is being used.
+      if test "$with_gnu_ld" = yes; then
+        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+        # If archive_cmds runs LD, not CC, wlarc should be empty
+        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
+        #     investigate it a little bit more. (MM)
+        wlarc='${wl}'
+
+        # ancient GNU ld didn't support --whole-archive et. al.
+        if eval "`$CC -print-prog-name=ld` --help 2>&1" |
+	  $GREP 'no-whole-archive' > /dev/null; then
+          _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+        else
+          _LT_TAGVAR(whole_archive_flag_spec, $1)=
+        fi
+      else
+        with_gnu_ld=no
+        wlarc=
+
+        # A generic and very simple default shared library creation
+        # command for GNU C++ for the case where it uses the native
+        # linker, instead of GNU ld.  If possible, this setting should
+        # overridden to take advantage of the native linker features on
+        # the platform it is being used on.
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+      fi
+
+      # Commands to make compiler produce verbose output that lists
+      # what "hidden" libraries, object files and flags are used when
+      # linking a shared library.
+      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+    else
+      GXX=no
+      with_gnu_ld=no
+      wlarc=
+    fi
+
+    # PORTME: fill in a description of your system's C++ link characteristics
+    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])
+    _LT_TAGVAR(ld_shlibs, $1)=yes
+    case $host_os in
+      aix3*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+      aix[[4-9]]*)
+        if test "$host_cpu" = ia64; then
+          # On IA64, the linker does run time linking by default, so we don't
+          # have to do anything special.
+          aix_use_runtimelinking=no
+          exp_sym_flag='-Bexport'
+          no_entry_flag=""
+        else
+          aix_use_runtimelinking=no
+
+          # Test if we are trying to use run time linking or normal
+          # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+          # need to do runtime linking.
+          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
+	    for ld_flag in $LDFLAGS; do
+	      case $ld_flag in
+	      *-brtl*)
+	        aix_use_runtimelinking=yes
+	        break
+	        ;;
+	      esac
+	    done
+	    ;;
+          esac
+
+          exp_sym_flag='-bexport'
+          no_entry_flag='-bnoentry'
+        fi
+
+        # When large executables or shared objects are built, AIX ld can
+        # have problems creating the table of contents.  If linking a library
+        # or program results in "error TOC overflow" add -mminimal-toc to
+        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+        _LT_TAGVAR(archive_cmds, $1)=''
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'
+
+        if test "$GXX" = yes; then
+          case $host_os in aix4.[[012]]|aix4.[[012]].*)
+          # We only want to do this on AIX 4.2 and lower, the check
+          # below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	     strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	    # We have reworked collect2
+	    :
+	  else
+	    # We have old collect2
+	    _LT_TAGVAR(hardcode_direct, $1)=unsupported
+	    # It fails to find uninstalled libraries when the uninstalled
+	    # path is not listed in the libpath.  Setting hardcode_minus_L
+	    # to unsupported forces relinking
+	    _LT_TAGVAR(hardcode_minus_L, $1)=yes
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=
+	  fi
+          esac
+          shared_flag='-shared'
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag="$shared_flag "'${wl}-G'
+	  fi
+        else
+          # not using gcc
+          if test "$host_cpu" = ia64; then
+	  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	  # chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+          else
+	    if test "$aix_use_runtimelinking" = yes; then
+	      shared_flag='${wl}-G'
+	    else
+	      shared_flag='${wl}-bM:SRE'
+	    fi
+          fi
+        fi
+
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
+        # It seems that -bexpall does not export symbols beginning with
+        # underscore (_), so it is better to generate a list of symbols to
+	# export.
+        _LT_TAGVAR(always_export_symbols, $1)=yes
+        if test "$aix_use_runtimelinking" = yes; then
+          # Warning - without using the other runtime loading flags (-brtl),
+          # -berok will link without error, but may produce a broken library.
+          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'
+          # Determine the default libpath from the value encoded in an empty
+          # executable.
+          _LT_SYS_MODULE_PATH_AIX([$1])
+          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+
+          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+        else
+          if test "$host_cpu" = ia64; then
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'
+	    _LT_TAGVAR(allow_undefined_flag, $1)="-z nodefs"
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+          else
+	    # Determine the default libpath from the value encoded in an
+	    # empty executable.
+	    _LT_SYS_MODULE_PATH_AIX([$1])
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
+	    # Warning - without using the other run time loading flags,
+	    # -berok will link without error, but may produce a broken library.
+	    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'
+	    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'
+	    if test "$with_gnu_ld" = yes; then
+	      # We only use this code for GNU lds that support --whole-archive.
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    else
+	      # Exported symbols can be pulled into shared objects from archives
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'
+	    fi
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes
+	    # This is similar to how AIX traditionally builds its shared
+	    # libraries.
+	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+          fi
+        fi
+        ;;
+
+      beos*)
+	if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	  # support --undefined.  This deserves some investigation.  FIXME
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      chorus*)
+        case $cc_basename in
+          *)
+	  # FIXME: insert proper C++ library support
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	  ;;
+        esac
+        ;;
+
+      cygwin* | mingw* | pw32* | cegcc*)
+	case $GXX,$cc_basename in
+	,cl* | no,cl*)
+	  # Native MSVC
+	  # hardcode_libdir_flag_spec is actually meaningless, as there is
+	  # no search path for DLLs.
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  _LT_TAGVAR(always_export_symbols, $1)=yes
+	  _LT_TAGVAR(file_list_spec, $1)='@'
+	  # Tell ltmain to make .lib files, not .a files.
+	  libext=lib
+	  # Tell ltmain to make .dll files, not .so files.
+	  shrext_cmds=".dll"
+	  # FIXME: Setting linknames here is a bad hack.
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
+	    else
+	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
+	    fi~
+	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+	    linknames='
+	  # The linker will not automatically build a static lib if we build a DLL.
+	  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'
+	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+	  # Don't use ranlib
+	  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'
+	  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile="@OUTPUT@"~
+	    lt_tool_outputfile="@TOOL_OUTPUT@"~
+	    case $lt_outputfile in
+	      *.exe|*.EXE) ;;
+	      *)
+		lt_outputfile="$lt_outputfile.exe"
+		lt_tool_outputfile="$lt_tool_outputfile.exe"
+		;;
+	    esac~
+	    func_to_tool_file "$lt_outputfile"~
+	    if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
+	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+	      $RM "$lt_outputfile.manifest";
+	    fi'
+	  ;;
+	*)
+	  # g++
+	  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,
+	  # as there is no search path for DLLs.
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'
+	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
+	  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported
+	  _LT_TAGVAR(always_export_symbols, $1)=no
+	  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes
+
+	  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	    # If the export-symbols file already is a .def file (1st line
+	    # is EXPORTS), use it as is; otherwise, prepend...
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	      cp $export_symbols $output_objdir/$soname.def;
+	    else
+	      echo EXPORTS > $output_objdir/$soname.def;
+	      cat $export_symbols >> $output_objdir/$soname.def;
+	    fi~
+	    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	  else
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	  fi
+	  ;;
+	esac
+	;;
+      darwin* | rhapsody*)
+        _LT_DARWIN_LINKER_FEATURES($1)
+	;;
+
+      dgux*)
+        case $cc_basename in
+          ec++*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          ghcx*)
+	    # Green Hills C++ Compiler
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      freebsd2.*)
+        # C++ shared libraries reported to be fairly broken before
+	# switch to ELF
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      freebsd-elf*)
+        _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+        ;;
+
+      freebsd* | dragonfly*)
+        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF
+        # conventions
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+        ;;
+
+      haiku*)
+        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+        _LT_TAGVAR(link_all_deplibs, $1)=yes
+        ;;
+
+      hpux9*)
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+        _LT_TAGVAR(hardcode_direct, $1)=yes
+        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+				             # but as the default
+				             # location of the library.
+
+        case $cc_basename in
+          CC*)
+            # FIXME: insert proper C++ library support
+            _LT_TAGVAR(ld_shlibs, $1)=no
+            ;;
+          aCC*)
+            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            # Commands to make compiler produce verbose output that lists
+            # what "hidden" libraries, object files and flags are used when
+            # linking a shared library.
+            #
+            # There doesn't appear to be a way to prevent this compiler from
+            # explicitly linking system object files so we need to strip them
+            # from the output so that they don't get included in the library
+            # dependencies.
+            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+            ;;
+          *)
+            if test "$GXX" = yes; then
+              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+            else
+              # FIXME: insert proper C++ library support
+              _LT_TAGVAR(ld_shlibs, $1)=no
+            fi
+            ;;
+        esac
+        ;;
+
+      hpux10*|hpux11*)
+        if test $with_gnu_ld = no; then
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'
+	  _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+          case $host_cpu in
+            hppa*64*|ia64*)
+              ;;
+            *)
+	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+              ;;
+          esac
+        fi
+        case $host_cpu in
+          hppa*64*|ia64*)
+            _LT_TAGVAR(hardcode_direct, $1)=no
+            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+            ;;
+          *)
+            _LT_TAGVAR(hardcode_direct, $1)=yes
+            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,
+					         # but as the default
+					         # location of the library.
+            ;;
+        esac
+
+        case $cc_basename in
+          CC*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          aCC*)
+	    case $host_cpu in
+	      hppa*64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      ia64*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	      *)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	        ;;
+	    esac
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test $with_gnu_ld = no; then
+	        case $host_cpu in
+	          hppa*64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          ia64*)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	          *)
+	            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	            ;;
+	        esac
+	      fi
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      interix[[3-9]]*)
+	_LT_TAGVAR(hardcode_direct, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+	# Instead, shared libraries are loaded at an image base (0x10000000 by
+	# default) and relocated if they conflict, which is a slow very memory
+	# consuming and fragmenting process.  To avoid this, we pick a random,
+	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+	;;
+      irix5* | irix6*)
+        case $cc_basename in
+          CC*)
+	    # SGI C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -ar", where "CC" is the IRIX C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    if test "$GXX" = yes; then
+	      if test "$with_gnu_ld" = no; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	      else
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` -o $lib'
+	      fi
+	    fi
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+	    ;;
+        esac
+        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+        _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+        _LT_TAGVAR(inherit_rpath, $1)=yes
+        ;;
+
+      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -Bstatic", where "CC" is the KAI C++ compiler.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'
+	    ;;
+	  icpc* | ecpc* )
+	    # Intel C++
+	    with_gnu_ld=yes
+	    # version 8.0 and above of icpc choke on multiply defined symbols
+	    # if we add $predep_objects and $postdep_objects, however 7.1 and
+	    # earlier do not add the objects themselves.
+	    case `$CC -V 2>&1` in
+	      *"Version 7."*)
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	      *)  # Version 8.0 or newer
+	        tmp_idyn=
+	        case $host_cpu in
+		  ia64*) tmp_idyn=' -i_dynamic';;
+		esac
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+		;;
+	    esac
+	    _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	    ;;
+          pgCC* | pgcpp*)
+            # Portland Group C++ compiler
+	    case `$CC -V` in
+	    *pgCC\ [[1-5]].* | *pgcpp\ [[1-5]].*)
+	      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~
+		compile_command="$compile_command `find $tpldir -name \*.o | sort | $NL2SP`"'
+	      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~
+		$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \*.o | sort | $NL2SP`~
+		$RANLIB $oldlib'
+	      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
+		rm -rf $tpldir~
+		$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~
+		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    *) # Version 6 and above use weak symbols
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
+	      ;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+            ;;
+	  cxx*)
+	    # Compaq C++
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
+
+	    runpath_var=LD_RUN_PATH
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
+	    ;;
+	  xl* | mpixl* | bgxl*)
+	    # IBM XL 8.0 on PPC, with GNU ld
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    if test "x$supports_anon_versioning" = xyes; then
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
+		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+		echo "local: *; };" >> $output_objdir/$libname.ver~
+		$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+	    fi
+	    ;;
+	  *)
+	    case `$CC -V 2>&1 | sed 5q` in
+	    *Sun\ C*)
+	      # Sun C++ 5.9
+	      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	      _LT_TAGVAR(compiler_needs_object, $1)=yes
+
+	      # Not sure whether something based on
+	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
+	      # would be better.
+	      output_verbose_link_cmd='func_echo_all'
+
+	      # Archives containing C++ object files must be created using
+	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	      # necessary to make sure instantiated templates are included
+	      # in the archive.
+	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	      ;;
+	    esac
+	    ;;
+	esac
+	;;
+
+      lynxos*)
+        # FIXME: insert proper C++ library support
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      m88k*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      mvs*)
+        case $cc_basename in
+          cxx*)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	  *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+	esac
+	;;
+
+      netbsd*)
+        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'
+	  wlarc=
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	fi
+	# Workaround some broken pre-1.5 toolchains
+	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
+	;;
+
+      *nto* | *qnx*)
+        _LT_TAGVAR(ld_shlibs, $1)=yes
+	;;
+
+      openbsd2*)
+        # C++ shared libraries are fairly broken
+	_LT_TAGVAR(ld_shlibs, $1)=no
+	;;
+
+      openbsd*)
+	if test -f /usr/libexec/ld.so; then
+	  _LT_TAGVAR(hardcode_direct, $1)=yes
+	  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'
+	  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	  if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
+	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
+	    _LT_TAGVAR(whole_archive_flag_spec, $1)="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+	  fi
+	  output_verbose_link_cmd=func_echo_all
+	else
+	  _LT_TAGVAR(ld_shlibs, $1)=no
+	fi
+	;;
+
+      osf3* | osf4* | osf5*)
+        case $cc_basename in
+          KCC*)
+	    # Kuck and Associates, Inc. (KAI) C++ Compiler
+
+	    # KCC will only create a shared library if the output file
+	    # ends with ".so" (or ".sl" for HP-UX), so rename the library
+	    # to its proper name (with version) after linking.
+	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Archives containing C++ object files must be created using
+	    # the KAI C++ compiler.
+	    case $host in
+	      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;
+	      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;
+	    esac
+	    ;;
+          RCC*)
+	    # Rational C++ 2.4.1
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          cxx*)
+	    case $host in
+	      osf3*)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n "$verstring" && func_echo_all "${wl}-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+		;;
+	      *)
+	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
+	          echo "-hidden">> $lib.exp~
+	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
+	          $RM $lib.exp'
+	        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'
+		;;
+	    esac
+
+	    _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	    # Commands to make compiler produce verbose output that lists
+	    # what "hidden" libraries, object files and flags are used when
+	    # linking a shared library.
+	    #
+	    # There doesn't appear to be a way to prevent this compiler from
+	    # explicitly linking system object files so we need to strip them
+	    # from the output so that they don't get included in the library
+	    # dependencies.
+	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
+	    ;;
+	  *)
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
+	      case $host in
+	        osf3*)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	        *)
+	          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+		  ;;
+	      esac
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'
+	      _LT_TAGVAR(hardcode_libdir_separator, $1)=:
+
+	      # Commands to make compiler produce verbose output that lists
+	      # what "hidden" libraries, object files and flags are used when
+	      # linking a shared library.
+	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+
+	    else
+	      # FIXME: insert proper C++ library support
+	      _LT_TAGVAR(ld_shlibs, $1)=no
+	    fi
+	    ;;
+        esac
+        ;;
+
+      psos*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      sunos4*)
+        case $cc_basename in
+          CC*)
+	    # Sun C++ 4.x
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          lcc*)
+	    # Lucid
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      solaris*)
+        case $cc_basename in
+          CC* | sunCC*)
+	    # Sun C++ 4.2, 5.x and Centerline C++
+            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes
+	    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'
+	    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	    case $host_os in
+	      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+	      *)
+		# The compiler driver will combine and reorder linker options,
+		# but understands `-z linker_flag'.
+	        # Supported since Solaris 2.6 (maybe 2.5.1?)
+		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
+	        ;;
+	    esac
+	    _LT_TAGVAR(link_all_deplibs, $1)=yes
+
+	    output_verbose_link_cmd='func_echo_all'
+
+	    # Archives containing C++ object files must be created using
+	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
+	    # necessary to make sure instantiated templates are included
+	    # in the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
+	    ;;
+          gcx*)
+	    # Green Hills C++ Compiler
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+
+	    # The C++ compiler must be used to create the archive.
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'
+	    ;;
+          *)
+	    # GNU C++ compiler with Solaris linker
+	    if test "$GXX" = yes && test "$with_gnu_ld" = no; then
+	      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'
+	      if $CC --version | $GREP -v '^2\.7' > /dev/null; then
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      else
+	        # g++ 2.7 appears to require `-G' NOT `-shared' on this
+	        # platform.
+	        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'
+	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
+
+	        # Commands to make compiler produce verbose output that lists
+	        # what "hidden" libraries, object files and flags are used when
+	        # linking a shared library.
+	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
+	      fi
+
+	      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'
+	      case $host_os in
+		solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;
+		*)
+		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+		  ;;
+	      esac
+	    fi
+	    ;;
+        esac
+        ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
+      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+      _LT_TAGVAR(archive_cmds_need_lc, $1)=no
+      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+      runpath_var='LD_RUN_PATH'
+
+      case $cc_basename in
+        CC*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+      esac
+      ;;
+
+      sysv5* | sco3.2v5* | sco5v6*)
+	# Note: We can NOT use -z defs as we might desire, because we do not
+	# link with -lc, and that would cause any symbols used from libc to
+	# always be unresolved, which means just about no library would
+	# ever link correctly.  If we're not using GNU ld we use -z text
+	# though, which does catch some bad symbols but isn't as heavy-handed
+	# as -z defs.
+	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
+	_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'
+	_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+	_LT_TAGVAR(hardcode_shlibpath_var, $1)=no
+	_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'
+	_LT_TAGVAR(hardcode_libdir_separator, $1)=':'
+	_LT_TAGVAR(link_all_deplibs, $1)=yes
+	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
+	runpath_var='LD_RUN_PATH'
+
+	case $cc_basename in
+          CC*)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~
+	      '"$_LT_TAGVAR(old_archive_cmds, $1)"
+	    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~
+	      '"$_LT_TAGVAR(reload_cmds, $1)"
+	    ;;
+	  *)
+	    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	    ;;
+	esac
+      ;;
+
+      tandem*)
+        case $cc_basename in
+          NCC*)
+	    # NonStop-UX NCC 3.20
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+          *)
+	    # FIXME: insert proper C++ library support
+	    _LT_TAGVAR(ld_shlibs, $1)=no
+	    ;;
+        esac
+        ;;
+
+      vxworks*)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+
+      *)
+        # FIXME: insert proper C++ library support
+        _LT_TAGVAR(ld_shlibs, $1)=no
+        ;;
+    esac
+
+    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])
+    test "$_LT_TAGVAR(ld_shlibs, $1)" = no && can_build_shared=no
+
+    _LT_TAGVAR(GCC, $1)="$GXX"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  CC=$lt_save_CC
+  CFLAGS=$lt_save_CFLAGS
+  LDCXX=$LD
+  LD=$lt_save_LD
+  GCC=$lt_save_GCC
+  with_gnu_ld=$lt_save_with_gnu_ld
+  lt_cv_path_LDCXX=$lt_cv_path_LD
+  lt_cv_path_LD=$lt_save_path_LD
+  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
+  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld
+fi # test "$_lt_caught_CXX_error" != yes
+
+AC_LANG_POP
+])# _LT_LANG_CXX_CONFIG
+
+
+# _LT_FUNC_STRIPNAME_CNF
+# ----------------------
+# func_stripname_cnf prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+#
+# This function is identical to the (non-XSI) version of func_stripname,
+# except this one can be used by m4 code that may be executed by configure,
+# rather than the libtool script.
+m4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl
+AC_REQUIRE([_LT_DECL_SED])
+AC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])
+func_stripname_cnf ()
+{
+  case ${2} in
+  .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+  *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+  esac
+} # func_stripname_cnf
+])# _LT_FUNC_STRIPNAME_CNF
+
+# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])
+# ---------------------------------
+# Figure out "hidden" library dependencies from verbose
+# compiler output when linking a shared library.
+# Parse the compiler output and extract the necessary
+# objects, libraries and library flags.
+m4_defun([_LT_SYS_HIDDEN_LIBDEPS],
+[m4_require([_LT_FILEUTILS_DEFAULTS])dnl
+AC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl
+# Dependencies to place before and after the object being linked:
+_LT_TAGVAR(predep_objects, $1)=
+_LT_TAGVAR(postdep_objects, $1)=
+_LT_TAGVAR(predeps, $1)=
+_LT_TAGVAR(postdeps, $1)=
+_LT_TAGVAR(compiler_lib_search_path, $1)=
+
+dnl we can't use the lt_simple_compile_test_code here,
+dnl because it contains code intended for an executable,
+dnl not a library.  It's possible we should let each
+dnl tag define a new lt_????_link_test_code variable,
+dnl but it's only used here...
+m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
+int a;
+void foo (void) { a = 0; }
+_LT_EOF
+], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
+class Foo
+{
+public:
+  Foo (void) { a = 0; }
+private:
+  int a;
+};
+_LT_EOF
+], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer*4 a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
+      subroutine foo
+      implicit none
+      integer a
+      a=0
+      return
+      end
+_LT_EOF
+], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
+public class foo {
+  private int a;
+  public void bar (void) {
+    a = 0;
+  }
+};
+_LT_EOF
+], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF
+package foo
+func foo() {
+}
+_LT_EOF
+])
+
+_lt_libdeps_save_CFLAGS=$CFLAGS
+case "$CC $CFLAGS " in #(
+*\ -flto*\ *) CFLAGS="$CFLAGS -fno-lto" ;;
+*\ -fwhopr*\ *) CFLAGS="$CFLAGS -fno-whopr" ;;
+*\ -fuse-linker-plugin*\ *) CFLAGS="$CFLAGS -fno-use-linker-plugin" ;;
+esac
+
+dnl Parse the compiler output and extract the necessary
+dnl objects, libraries and library flags.
+if AC_TRY_EVAL(ac_compile); then
+  # Parse the compiler output and extract the necessary
+  # objects, libraries and library flags.
+
+  # Sentinel used to keep track of whether or not we are before
+  # the conftest object file.
+  pre_test_object_deps_done=no
+
+  for p in `eval "$output_verbose_link_cmd"`; do
+    case ${prev}${p} in
+
+    -L* | -R* | -l*)
+       # Some compilers place space between "-{L,R}" and the path.
+       # Remove the space.
+       if test $p = "-L" ||
+          test $p = "-R"; then
+	 prev=$p
+	 continue
+       fi
+
+       # Expand the sysroot to ease extracting the directories later.
+       if test -z "$prev"; then
+         case $p in
+         -L*) func_stripname_cnf '-L' '' "$p"; prev=-L; p=$func_stripname_result ;;
+         -R*) func_stripname_cnf '-R' '' "$p"; prev=-R; p=$func_stripname_result ;;
+         -l*) func_stripname_cnf '-l' '' "$p"; prev=-l; p=$func_stripname_result ;;
+         esac
+       fi
+       case $p in
+       =*) func_stripname_cnf '=' '' "$p"; p=$lt_sysroot$func_stripname_result ;;
+       esac
+       if test "$pre_test_object_deps_done" = no; then
+	 case ${prev} in
+	 -L | -R)
+	   # Internal compiler library paths should come after those
+	   # provided the user.  The postdeps already come after the
+	   # user supplied libs so there is no need to process them.
+	   if test -z "$_LT_TAGVAR(compiler_lib_search_path, $1)"; then
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${prev}${p}"
+	   else
+	     _LT_TAGVAR(compiler_lib_search_path, $1)="${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}"
+	   fi
+	   ;;
+	 # The "-l" case would never come before the object being
+	 # linked, so don't bother handling this case.
+	 esac
+       else
+	 if test -z "$_LT_TAGVAR(postdeps, $1)"; then
+	   _LT_TAGVAR(postdeps, $1)="${prev}${p}"
+	 else
+	   _LT_TAGVAR(postdeps, $1)="${_LT_TAGVAR(postdeps, $1)} ${prev}${p}"
+	 fi
+       fi
+       prev=
+       ;;
+
+    *.lto.$objext) ;; # Ignore GCC LTO objects
+    *.$objext)
+       # This assumes that the test object file only shows up
+       # once in the compiler output.
+       if test "$p" = "conftest.$objext"; then
+	 pre_test_object_deps_done=yes
+	 continue
+       fi
+
+       if test "$pre_test_object_deps_done" = no; then
+	 if test -z "$_LT_TAGVAR(predep_objects, $1)"; then
+	   _LT_TAGVAR(predep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(predep_objects, $1)="$_LT_TAGVAR(predep_objects, $1) $p"
+	 fi
+       else
+	 if test -z "$_LT_TAGVAR(postdep_objects, $1)"; then
+	   _LT_TAGVAR(postdep_objects, $1)="$p"
+	 else
+	   _LT_TAGVAR(postdep_objects, $1)="$_LT_TAGVAR(postdep_objects, $1) $p"
+	 fi
+       fi
+       ;;
+
+    *) ;; # Ignore the rest.
+
+    esac
+  done
+
+  # Clean up.
+  rm -f a.out a.exe
+else
+  echo "libtool.m4: error: problem compiling $1 test program"
+fi
+
+$RM -f confest.$objext
+CFLAGS=$_lt_libdeps_save_CFLAGS
+
+# PORTME: override above test on systems where it is broken
+m4_if([$1], [CXX],
+[case $host_os in
+interix[[3-9]]*)
+  # Interix 3.5 installs completely hosed .la files for C++, so rather than
+  # hack all around it, let's just trust "g++" to DTRT.
+  _LT_TAGVAR(predep_objects,$1)=
+  _LT_TAGVAR(postdep_objects,$1)=
+  _LT_TAGVAR(postdeps,$1)=
+  ;;
+
+linux*)
+  case `$CC -V 2>&1 | sed 5q` in
+  *Sun\ C*)
+    # Sun C++ 5.9
+
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+
+solaris*)
+  case $cc_basename in
+  CC* | sunCC*)
+    # The more standards-conforming stlport4 library is
+    # incompatible with the Cstd library. Avoid specifying
+    # it if it's in CXXFLAGS. Ignore libCrun as
+    # -library=stlport4 depends on it.
+    case " $CXX $CXXFLAGS " in
+    *" -library=stlport4 "*)
+      solaris_use_stlport4=yes
+      ;;
+    esac
+
+    # Adding this requires a known-good setup of shared libraries for
+    # Sun compiler versions before 5.6, else PIC objects from an old
+    # archive will be linked into the output, leading to subtle bugs.
+    if test "$solaris_use_stlport4" != yes; then
+      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'
+    fi
+    ;;
+  esac
+  ;;
+esac
+])
+
+case " $_LT_TAGVAR(postdeps, $1) " in
+*" -lc "*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;
+esac
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=
+if test -n "${_LT_TAGVAR(compiler_lib_search_path, $1)}"; then
+ _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo " ${_LT_TAGVAR(compiler_lib_search_path, $1)}" | ${SED} -e 's! -L! !g' -e 's!^ !!'`
+fi
+_LT_TAGDECL([], [compiler_lib_search_dirs], [1],
+    [The directories searched by this compiler when creating a shared library])
+_LT_TAGDECL([], [predep_objects], [1],
+    [Dependencies to place before and after the objects being linked to
+    create a shared library])
+_LT_TAGDECL([], [postdep_objects], [1])
+_LT_TAGDECL([], [predeps], [1])
+_LT_TAGDECL([], [postdeps], [1])
+_LT_TAGDECL([], [compiler_lib_search_path], [1],
+    [The library search path used internally by the compiler when linking
+    a shared library])
+])# _LT_SYS_HIDDEN_LIBDEPS
+
+
+# _LT_LANG_F77_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for a Fortran 77 compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_F77_CONFIG],
+[AC_LANG_PUSH(Fortran 77)
+if test -z "$F77" || test "X$F77" = "Xno"; then
+  _lt_disable_F77=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for f77 test sources.
+ac_ext=f
+
+# Object file extension for compiled f77 test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the F77 compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_F77" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  lt_save_CFLAGS=$CFLAGS
+  CC=${F77-"f77"}
+  CFLAGS=$FFLAGS
+  compiler=$CC
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+  GCC=$G77
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$G77"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC="$lt_save_CC"
+  CFLAGS="$lt_save_CFLAGS"
+fi # test "$_lt_disable_F77" != yes
+
+AC_LANG_POP
+])# _LT_LANG_F77_CONFIG
+
+
+# _LT_LANG_FC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for a Fortran compiler are
+# suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_FC_CONFIG],
+[AC_LANG_PUSH(Fortran)
+
+if test -z "$FC" || test "X$FC" = "Xno"; then
+  _lt_disable_FC=yes
+fi
+
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+_LT_TAGVAR(allow_undefined_flag, $1)=
+_LT_TAGVAR(always_export_symbols, $1)=no
+_LT_TAGVAR(archive_expsym_cmds, $1)=
+_LT_TAGVAR(export_dynamic_flag_spec, $1)=
+_LT_TAGVAR(hardcode_direct, $1)=no
+_LT_TAGVAR(hardcode_direct_absolute, $1)=no
+_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=
+_LT_TAGVAR(hardcode_libdir_separator, $1)=
+_LT_TAGVAR(hardcode_minus_L, $1)=no
+_LT_TAGVAR(hardcode_automatic, $1)=no
+_LT_TAGVAR(inherit_rpath, $1)=no
+_LT_TAGVAR(module_cmds, $1)=
+_LT_TAGVAR(module_expsym_cmds, $1)=
+_LT_TAGVAR(link_all_deplibs, $1)=unknown
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+_LT_TAGVAR(no_undefined_flag, $1)=
+_LT_TAGVAR(whole_archive_flag_spec, $1)=
+_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no
+
+# Source file extension for fc test sources.
+ac_ext=${ac_fc_srcext-f}
+
+# Object file extension for compiled fc test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# No sense in running all these tests if we already determined that
+# the FC compiler isn't working.  Some variables (like enable_shared)
+# are currently assumed to apply to all compilers on this platform,
+# and will be corrupted by setting them based on a non-working compiler.
+if test "$_lt_disable_FC" != yes; then
+  # Code to be used in simple compile tests
+  lt_simple_compile_test_code="\
+      subroutine t
+      return
+      end
+"
+
+  # Code to be used in simple link tests
+  lt_simple_link_test_code="\
+      program t
+      end
+"
+
+  # ltmain only uses $CC for tagged configurations so make sure $CC is set.
+  _LT_TAG_COMPILER
+
+  # save warnings/boilerplate of simple test code
+  _LT_COMPILER_BOILERPLATE
+  _LT_LINKER_BOILERPLATE
+
+  # Allow CC to be a program name with arguments.
+  lt_save_CC="$CC"
+  lt_save_GCC=$GCC
+  lt_save_CFLAGS=$CFLAGS
+  CC=${FC-"f95"}
+  CFLAGS=$FCFLAGS
+  compiler=$CC
+  GCC=$ac_cv_fc_compiler_gnu
+
+  _LT_TAGVAR(compiler, $1)=$CC
+  _LT_CC_BASENAME([$compiler])
+
+  if test -n "$compiler"; then
+    AC_MSG_CHECKING([if libtool supports shared libraries])
+    AC_MSG_RESULT([$can_build_shared])
+
+    AC_MSG_CHECKING([whether to build shared libraries])
+    test "$can_build_shared" = "no" && enable_shared=no
+
+    # On AIX, shared libraries and static libraries use the same namespace, and
+    # are all built from PIC.
+    case $host_os in
+      aix3*)
+        test "$enable_shared" = yes && enable_static=no
+        if test -n "$RANLIB"; then
+          archive_cmds="$archive_cmds~\$RANLIB \$lib"
+          postinstall_cmds='$RANLIB $lib'
+        fi
+        ;;
+      aix[[4-9]]*)
+	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+	  test "$enable_shared" = yes && enable_static=no
+	fi
+        ;;
+    esac
+    AC_MSG_RESULT([$enable_shared])
+
+    AC_MSG_CHECKING([whether to build static libraries])
+    # Make sure either enable_shared or enable_static is yes.
+    test "$enable_shared" = yes || enable_static=yes
+    AC_MSG_RESULT([$enable_static])
+
+    _LT_TAGVAR(GCC, $1)="$ac_cv_fc_compiler_gnu"
+    _LT_TAGVAR(LD, $1)="$LD"
+
+    ## CAVEAT EMPTOR:
+    ## There is no encapsulation within the following macros, do not change
+    ## the running order or otherwise move them around unless you know exactly
+    ## what you are doing...
+    _LT_SYS_HIDDEN_LIBDEPS($1)
+    _LT_COMPILER_PIC($1)
+    _LT_COMPILER_C_O($1)
+    _LT_COMPILER_FILE_LOCKS($1)
+    _LT_LINKER_SHLIBS($1)
+    _LT_SYS_DYNAMIC_LINKER($1)
+    _LT_LINKER_HARDCODE_LIBPATH($1)
+
+    _LT_CONFIG($1)
+  fi # test -n "$compiler"
+
+  GCC=$lt_save_GCC
+  CC=$lt_save_CC
+  CFLAGS=$lt_save_CFLAGS
+fi # test "$_lt_disable_FC" != yes
+
+AC_LANG_POP
+])# _LT_LANG_FC_CONFIG
+
+
+# _LT_LANG_GCJ_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Java Compiler compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GCJ_CONFIG],
+[AC_REQUIRE([LT_PROG_GCJ])dnl
+AC_LANG_SAVE
+
+# Source file extension for Java test sources.
+ac_ext=java
+
+# Object file extension for compiled Java test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="class foo {}"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC=$CC
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GCJ-"gcj"}
+CFLAGS=$GCJFLAGS
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# GCJ did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_GCJ_CONFIG
+
+
+# _LT_LANG_GO_CONFIG([TAG])
+# --------------------------
+# Ensure that the configuration variables for the GNU Go compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_GO_CONFIG],
+[AC_REQUIRE([LT_PROG_GO])dnl
+AC_LANG_SAVE
+
+# Source file extension for Go test sources.
+ac_ext=go
+
+# Object file extension for compiled Go test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="package main; func main() { }"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='package main; func main() { }'
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC=$CC
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=yes
+CC=${GOC-"gccgo"}
+CFLAGS=$GOFLAGS
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_TAGVAR(LD, $1)="$LD"
+_LT_CC_BASENAME([$compiler])
+
+# Go did not exist at the time GCC didn't implicitly link libc in.
+_LT_TAGVAR(archive_cmds_need_lc, $1)=no
+
+_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds
+_LT_TAGVAR(reload_flag, $1)=$reload_flag
+_LT_TAGVAR(reload_cmds, $1)=$reload_cmds
+
+if test -n "$compiler"; then
+  _LT_COMPILER_NO_RTTI($1)
+  _LT_COMPILER_PIC($1)
+  _LT_COMPILER_C_O($1)
+  _LT_COMPILER_FILE_LOCKS($1)
+  _LT_LINKER_SHLIBS($1)
+  _LT_LINKER_HARDCODE_LIBPATH($1)
+
+  _LT_CONFIG($1)
+fi
+
+AC_LANG_RESTORE
+
+GCC=$lt_save_GCC
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_GO_CONFIG
+
+
+# _LT_LANG_RC_CONFIG([TAG])
+# -------------------------
+# Ensure that the configuration variables for the Windows resource compiler
+# are suitably defined.  These variables are subsequently used by _LT_CONFIG
+# to write the compiler configuration to `libtool'.
+m4_defun([_LT_LANG_RC_CONFIG],
+[AC_REQUIRE([LT_PROG_RC])dnl
+AC_LANG_SAVE
+
+# Source file extension for RC test sources.
+ac_ext=rc
+
+# Object file extension for compiled RC test sources.
+objext=o
+_LT_TAGVAR(objext, $1)=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code='sample MENU { MENUITEM "&Soup", 100, CHECKED }'
+
+# Code to be used in simple link tests
+lt_simple_link_test_code="$lt_simple_compile_test_code"
+
+# ltmain only uses $CC for tagged configurations so make sure $CC is set.
+_LT_TAG_COMPILER
+
+# save warnings/boilerplate of simple test code
+_LT_COMPILER_BOILERPLATE
+_LT_LINKER_BOILERPLATE
+
+# Allow CC to be a program name with arguments.
+lt_save_CC="$CC"
+lt_save_CFLAGS=$CFLAGS
+lt_save_GCC=$GCC
+GCC=
+CC=${RC-"windres"}
+CFLAGS=
+compiler=$CC
+_LT_TAGVAR(compiler, $1)=$CC
+_LT_CC_BASENAME([$compiler])
+_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes
+
+if test -n "$compiler"; then
+  :
+  _LT_CONFIG($1)
+fi
+
+GCC=$lt_save_GCC
+AC_LANG_RESTORE
+CC=$lt_save_CC
+CFLAGS=$lt_save_CFLAGS
+])# _LT_LANG_RC_CONFIG
+
+
+# LT_PROG_GCJ
+# -----------
+AC_DEFUN([LT_PROG_GCJ],
+[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],
+  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],
+    [AC_CHECK_TOOL(GCJ, gcj,)
+      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
+      AC_SUBST(GCJFLAGS)])])[]dnl
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_GCJ], [])
+
+
+# LT_PROG_GO
+# ----------
+AC_DEFUN([LT_PROG_GO],
+[AC_CHECK_TOOL(GOC, gccgo,)
+])
+
+
+# LT_PROG_RC
+# ----------
+AC_DEFUN([LT_PROG_RC],
+[AC_CHECK_TOOL(RC, windres,)
+])
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_RC], [])
+
+
+# _LT_DECL_EGREP
+# --------------
+# If we don't have a new enough Autoconf to choose the best grep
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_EGREP],
+[AC_REQUIRE([AC_PROG_EGREP])dnl
+AC_REQUIRE([AC_PROG_FGREP])dnl
+test -z "$GREP" && GREP=grep
+_LT_DECL([], [GREP], [1], [A grep program that handles long lines])
+_LT_DECL([], [EGREP], [1], [An ERE matcher])
+_LT_DECL([], [FGREP], [1], [A literal string matcher])
+dnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too
+AC_SUBST([GREP])
+])
+
+
+# _LT_DECL_OBJDUMP
+# --------------
+# If we don't have a new enough Autoconf to choose the best objdump
+# available, choose the one first in the user's PATH.
+m4_defun([_LT_DECL_OBJDUMP],
+[AC_CHECK_TOOL(OBJDUMP, objdump, false)
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])
+AC_SUBST([OBJDUMP])
+])
+
+# _LT_DECL_DLLTOOL
+# ----------------
+# Ensure DLLTOOL variable is set.
+m4_defun([_LT_DECL_DLLTOOL],
+[AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [1], [DLL creation program])
+AC_SUBST([DLLTOOL])
+])
+
+# _LT_DECL_SED
+# ------------
+# Check for a fully-functional sed program, that truncates
+# as few characters as possible.  Prefer GNU sed if found.
+m4_defun([_LT_DECL_SED],
+[AC_PROG_SED
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+_LT_DECL([], [SED], [1], [A sed program that does not truncate output])
+_LT_DECL([], [Xsed], ["\$SED -e 1s/^X//"],
+    [Sed that helps us avoid accidentally triggering echo(1) options like -n])
+])# _LT_DECL_SED
+
+m4_ifndef([AC_PROG_SED], [
+# NOTE: This macro has been submitted for inclusion into   #
+#  GNU Autoconf as AC_PROG_SED.  When it is available in   #
+#  a released version of Autoconf we should remove this    #
+#  macro and use it instead.                               #
+
+m4_defun([AC_PROG_SED],
+[AC_MSG_CHECKING([for a sed that does not truncate output])
+AC_CACHE_VAL(lt_cv_path_SED,
+[# Loop through the user's path and test for sed and gsed.
+# Then use that list of sed's as ones to test for truncation.
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for lt_ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
+        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
+      fi
+    done
+  done
+done
+IFS=$as_save_IFS
+lt_ac_max=0
+lt_ac_count=0
+# Add /usr/xpg4/bin/sed as it is typically found on Solaris
+# along with /bin/sed that truncates output.
+for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
+  test ! -f $lt_ac_sed && continue
+  cat /dev/null > conftest.in
+  lt_ac_count=0
+  echo $ECHO_N "0123456789$ECHO_C" >conftest.in
+  # Check for GNU sed and select it if it is found.
+  if "$lt_ac_sed" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then
+    lt_cv_path_SED=$lt_ac_sed
+    break
+  fi
+  while true; do
+    cat conftest.in conftest.in >conftest.tmp
+    mv conftest.tmp conftest.in
+    cp conftest.in conftest.nl
+    echo >>conftest.nl
+    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break
+    cmp -s conftest.out conftest.nl || break
+    # 10000 chars as input seems more than enough
+    test $lt_ac_count -gt 10 && break
+    lt_ac_count=`expr $lt_ac_count + 1`
+    if test $lt_ac_count -gt $lt_ac_max; then
+      lt_ac_max=$lt_ac_count
+      lt_cv_path_SED=$lt_ac_sed
+    fi
+  done
+done
+])
+SED=$lt_cv_path_SED
+AC_SUBST([SED])
+AC_MSG_RESULT([$SED])
+])#AC_PROG_SED
+])#m4_ifndef
+
+# Old name:
+AU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([LT_AC_PROG_SED], [])
+
+
+# _LT_CHECK_SHELL_FEATURES
+# ------------------------
+# Find out whether the shell is Bourne or XSI compatible,
+# or has some other useful features.
+m4_defun([_LT_CHECK_SHELL_FEATURES],
+[AC_MSG_CHECKING([whether the shell understands some XSI constructs])
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,b/c, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+AC_MSG_RESULT([$xsi_shell])
+_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
+
+AC_MSG_CHECKING([whether the shell understands "+="])
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$[1]+=\$[2]" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+AC_MSG_RESULT([$lt_shell_append])
+_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+_LT_DECL([], [lt_unset], [0], [whether the shell understands "unset"])dnl
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl
+_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl
+])# _LT_CHECK_SHELL_FEATURES
+
+
+# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)
+# ------------------------------------------------------
+# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and
+# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.
+m4_defun([_LT_PROG_FUNCTION_REPLACE],
+[dnl {
+sed -e '/^$1 ()$/,/^} # $1 /c\
+$1 ()\
+{\
+m4_bpatsubsts([$2], [$], [\\], [^\([	 ]\)], [\\\1])
+} # Extended-shell $1 implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+])
+
+
+# _LT_PROG_REPLACE_SHELLFNS
+# -------------------------
+# Replace existing portable implementations of several shell functions with
+# equivalent extended shell implementations where those features are available..
+m4_defun([_LT_PROG_REPLACE_SHELLFNS],
+[if test x"$xsi_shell" = xyes; then
+  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl
+    case ${1} in
+      */*) func_dirname_result="${1%/*}${2}" ;;
+      *  ) func_dirname_result="${3}" ;;
+    esac])
+
+  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl
+    func_basename_result="${1##*/}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl
+    case ${1} in
+      */*) func_dirname_result="${1%/*}${2}" ;;
+      *  ) func_dirname_result="${3}" ;;
+    esac
+    func_basename_result="${1##*/}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl
+    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are
+    # positional parameters, so assign one to ordinary parameter first.
+    func_stripname_result=${3}
+    func_stripname_result=${func_stripname_result#"${1}"}
+    func_stripname_result=${func_stripname_result%"${2}"}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl
+    func_split_long_opt_name=${1%%=*}
+    func_split_long_opt_arg=${1#*=}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl
+    func_split_short_opt_arg=${1#??}
+    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}])
+
+  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl
+    case ${1} in
+      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
+      *)    func_lo2o_result=${1} ;;
+    esac])
+
+  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])
+
+  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])
+
+  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])
+fi
+
+if test x"$lt_shell_append" = xyes; then
+  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval "${1}+=\\${2}"])
+
+  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl
+    func_quote_for_eval "${2}"
+dnl m4 expansion turns \\\\ into \\, and then the shell eval turns that into \
+    eval "${1}+=\\\\ \\$func_quote_for_eval_result"])
+
+  # Save a `func_append' function call where possible by direct use of '+='
+  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+else
+  # Save a `func_append' function call even when '+=' is not available
+  sed -e 's%func_append \([[a-zA-Z_]]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+fi
+
+if test x"$_lt_function_replace_fail" = x":"; then
+  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])
+fi
+])
+
+# _LT_PATH_CONVERSION_FUNCTIONS
+# -----------------------------
+# Determine which file name conversion functions should be used by
+# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed
+# for certain cross-compile configurations and native mingw.
+m4_defun([_LT_PATH_CONVERSION_FUNCTIONS],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+AC_REQUIRE([AC_CANONICAL_BUILD])dnl
+AC_MSG_CHECKING([how to convert $build file names to $host format])
+AC_CACHE_VAL(lt_cv_to_host_file_cmd,
+[case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
+        ;;
+    esac
+    ;;
+  *-*-cygwin* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_noop
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
+        ;;
+    esac
+    ;;
+  * ) # unhandled hosts (and "normal" native builds)
+    lt_cv_to_host_file_cmd=func_convert_file_noop
+    ;;
+esac
+])
+to_host_file_cmd=$lt_cv_to_host_file_cmd
+AC_MSG_RESULT([$lt_cv_to_host_file_cmd])
+_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],
+         [0], [convert $build file names to $host format])dnl
+
+AC_MSG_CHECKING([how to convert $build file names to toolchain format])
+AC_CACHE_VAL(lt_cv_to_tool_file_cmd,
+[#assume ordinary cross tools, or native build.
+lt_cv_to_tool_file_cmd=func_convert_file_noop
+case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32
+        ;;
+    esac
+    ;;
+esac
+])
+to_tool_file_cmd=$lt_cv_to_tool_file_cmd
+AC_MSG_RESULT([$lt_cv_to_tool_file_cmd])
+_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],
+         [0], [convert $build files to toolchain format])dnl
+])# _LT_PATH_CONVERSION_FUNCTIONS
+
+# Helper functions for option handling.                    -*- Autoconf -*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,
+#   Inc.
+#   Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 7 ltoptions.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])
+
+
+# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)
+# ------------------------------------------
+m4_define([_LT_MANGLE_OPTION],
+[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])
+
+
+# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)
+# ---------------------------------------
+# Set option OPTION-NAME for macro MACRO-NAME, and if there is a
+# matching handler defined, dispatch to it.  Other OPTION-NAMEs are
+# saved as a flag.
+m4_define([_LT_SET_OPTION],
+[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl
+m4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),
+        _LT_MANGLE_DEFUN([$1], [$2]),
+    [m4_warning([Unknown $1 option `$2'])])[]dnl
+])
+
+
+# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])
+# ------------------------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+m4_define([_LT_IF_OPTION],
+[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])
+
+
+# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)
+# -------------------------------------------------------
+# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
+# are set.
+m4_define([_LT_UNLESS_OPTIONS],
+[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+	    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),
+		      [m4_define([$0_found])])])[]dnl
+m4_ifdef([$0_found], [m4_undefine([$0_found])], [$3
+])[]dnl
+])
+
+
+# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)
+# ----------------------------------------
+# OPTION-LIST is a space-separated list of Libtool options associated
+# with MACRO-NAME.  If any OPTION has a matching handler declared with
+# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about
+# the unknown option and exit.
+m4_defun([_LT_SET_OPTIONS],
+[# Set options
+m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),
+    [_LT_SET_OPTION([$1], _LT_Option)])
+
+m4_if([$1],[LT_INIT],[
+  dnl
+  dnl Simply set some default values (i.e off) if boolean options were not
+  dnl specified:
+  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no
+  ])
+  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no
+  ])
+  dnl
+  dnl If no reference was made to various pairs of opposing options, then
+  dnl we run the default mode handler for the pair.  For example, if neither
+  dnl `shared' nor `disable-shared' was passed, we enable building of shared
+  dnl archives by default:
+  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])
+  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])
+  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],
+  		   [_LT_ENABLE_FAST_INSTALL])
+  ])
+])# _LT_SET_OPTIONS
+
+
+
+# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)
+# -----------------------------------------
+m4_define([_LT_MANGLE_DEFUN],
+[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])
+
+
+# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)
+# -----------------------------------------------
+m4_define([LT_OPTION_DEFINE],
+[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl
+])# LT_OPTION_DEFINE
+
+
+# dlopen
+# ------
+LT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes
+])
+
+AU_DEFUN([AC_LIBTOOL_DLOPEN],
+[_LT_SET_OPTION([LT_INIT], [dlopen])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `dlopen' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])
+
+
+# win32-dll
+# ---------
+# Declare package support for building win32 dll's.
+LT_OPTION_DEFINE([LT_INIT], [win32-dll],
+[enable_win32_dll=yes
+
+case $host in
+*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)
+  AC_CHECK_TOOL(AS, as, false)
+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)
+  AC_CHECK_TOOL(OBJDUMP, objdump, false)
+  ;;
+esac
+
+test -z "$AS" && AS=as
+_LT_DECL([], [AS],      [1], [Assembler program])dnl
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl
+])# win32-dll
+
+AU_DEFUN([AC_LIBTOOL_WIN32_DLL],
+[AC_REQUIRE([AC_CANONICAL_HOST])dnl
+_LT_SET_OPTION([LT_INIT], [win32-dll])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `win32-dll' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])
+
+
+# _LT_ENABLE_SHARED([DEFAULT])
+# ----------------------------
+# implement the --enable-shared flag, and supports the `shared' and
+# `disable-shared' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_SHARED],
+[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([shared],
+    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],
+	[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)
+
+    _LT_DECL([build_libtool_libs], [enable_shared], [0],
+	[Whether or not to build shared libraries])
+])# _LT_ENABLE_SHARED
+
+LT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])
+])
+
+AC_DEFUN([AC_DISABLE_SHARED],
+[_LT_SET_OPTION([LT_INIT], [disable-shared])
+])
+
+AU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])
+AU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_SHARED], [])
+dnl AC_DEFUN([AM_DISABLE_SHARED], [])
+
+
+
+# _LT_ENABLE_STATIC([DEFAULT])
+# ----------------------------
+# implement the --enable-static flag, and support the `static' and
+# `disable-static' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_STATIC],
+[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([static],
+    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],
+	[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)
+
+    _LT_DECL([build_old_libs], [enable_static], [0],
+	[Whether or not to build static libraries])
+])# _LT_ENABLE_STATIC
+
+LT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])
+
+# Old names:
+AC_DEFUN([AC_ENABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])
+])
+
+AC_DEFUN([AC_DISABLE_STATIC],
+[_LT_SET_OPTION([LT_INIT], [disable-static])
+])
+
+AU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])
+AU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AM_ENABLE_STATIC], [])
+dnl AC_DEFUN([AM_DISABLE_STATIC], [])
+
+
+
+# _LT_ENABLE_FAST_INSTALL([DEFAULT])
+# ----------------------------------
+# implement the --enable-fast-install flag, and support the `fast-install'
+# and `disable-fast-install' LT_INIT options.
+# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.
+m4_define([_LT_ENABLE_FAST_INSTALL],
+[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl
+AC_ARG_ENABLE([fast-install],
+    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],
+    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],
+    [p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)
+
+_LT_DECL([fast_install], [enable_fast_install], [0],
+	 [Whether or not to optimize for fast installation])dnl
+])# _LT_ENABLE_FAST_INSTALL
+
+LT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])
+LT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])
+
+# Old names:
+AU_DEFUN([AC_ENABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `fast-install' option into LT_INIT's first parameter.])
+])
+
+AU_DEFUN([AC_DISABLE_FAST_INSTALL],
+[_LT_SET_OPTION([LT_INIT], [disable-fast-install])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you put
+the `disable-fast-install' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])
+dnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])
+
+
+# _LT_WITH_PIC([MODE])
+# --------------------
+# implement the --with-pic flag, and support the `pic-only' and `no-pic'
+# LT_INIT options.
+# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.
+m4_define([_LT_WITH_PIC],
+[AC_ARG_WITH([pic],
+    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],
+	[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],
+    [lt_p=${PACKAGE-default}
+    case $withval in
+    yes|no) pic_mode=$withval ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for lt_pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$lt_pkg" = "X$lt_p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac],
+    [pic_mode=default])
+
+test -z "$pic_mode" && pic_mode=m4_default([$1], [default])
+
+_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl
+])# _LT_WITH_PIC
+
+LT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])
+LT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])
+
+# Old name:
+AU_DEFUN([AC_LIBTOOL_PICMODE],
+[_LT_SET_OPTION([LT_INIT], [pic-only])
+AC_DIAGNOSE([obsolete],
+[$0: Remove this warning and the call to _LT_SET_OPTION when you
+put the `pic-only' option into LT_INIT's first parameter.])
+])
+
+dnl aclocal-1.4 backwards compatibility:
+dnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])
+
+
+m4_define([_LTDL_MODE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],
+		 [m4_define([_LTDL_MODE], [nonrecursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [recursive],
+		 [m4_define([_LTDL_MODE], [recursive])])
+LT_OPTION_DEFINE([LTDL_INIT], [subproject],
+		 [m4_define([_LTDL_MODE], [subproject])])
+
+m4_define([_LTDL_TYPE], [])
+LT_OPTION_DEFINE([LTDL_INIT], [installable],
+		 [m4_define([_LTDL_TYPE], [installable])])
+LT_OPTION_DEFINE([LTDL_INIT], [convenience],
+		 [m4_define([_LTDL_TYPE], [convenience])])
+
+# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-
+#
+# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
+# Written by Gary V. Vaughan, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 6 ltsugar.m4
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])
+
+
+# lt_join(SEP, ARG1, [ARG2...])
+# -----------------------------
+# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their
+# associated separator.
+# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier
+# versions in m4sugar had bugs.
+m4_define([lt_join],
+[m4_if([$#], [1], [],
+       [$#], [2], [[$2]],
+       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])
+m4_define([_lt_join],
+[m4_if([$#$2], [2], [],
+       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])
+
+
+# lt_car(LIST)
+# lt_cdr(LIST)
+# ------------
+# Manipulate m4 lists.
+# These macros are necessary as long as will still need to support
+# Autoconf-2.59 which quotes differently.
+m4_define([lt_car], [[$1]])
+m4_define([lt_cdr],
+[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],
+       [$#], 1, [],
+       [m4_dquote(m4_shift($@))])])
+m4_define([lt_unquote], $1)
+
+
+# lt_append(MACRO-NAME, STRING, [SEPARATOR])
+# ------------------------------------------
+# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.
+# Note that neither SEPARATOR nor STRING are expanded; they are appended
+# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
+# No SEPARATOR is output if MACRO-NAME was previously undefined (different
+# than defined and empty).
+#
+# This macro is needed until we can rely on Autoconf 2.62, since earlier
+# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
+m4_define([lt_append],
+[m4_define([$1],
+	   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])
+
+
+
+# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])
+# ----------------------------------------------------------
+# Produce a SEP delimited list of all paired combinations of elements of
+# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list
+# has the form PREFIXmINFIXSUFFIXn.
+# Needed until we can rely on m4_combine added in Autoconf 2.62.
+m4_define([lt_combine],
+[m4_if(m4_eval([$# > 3]), [1],
+       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl
+[[m4_foreach([_Lt_prefix], [$2],
+	     [m4_foreach([_Lt_suffix],
+		]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,
+	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
+
+
+# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])
+# -----------------------------------------------------------------------
+# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited
+# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
+m4_define([lt_if_append_uniq],
+[m4_ifdef([$1],
+	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
+		 [lt_append([$1], [$2], [$3])$4],
+		 [$5])],
+	  [lt_append([$1], [$2], [$3])$4])])
+
+
+# lt_dict_add(DICT, KEY, VALUE)
+# -----------------------------
+m4_define([lt_dict_add],
+[m4_define([$1($2)], [$3])])
+
+
+# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)
+# --------------------------------------------
+m4_define([lt_dict_add_subkey],
+[m4_define([$1($2:$3)], [$4])])
+
+
+# lt_dict_fetch(DICT, KEY, [SUBKEY])
+# ----------------------------------
+m4_define([lt_dict_fetch],
+[m4_ifval([$3],
+	m4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),
+    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])
+
+
+# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])
+# -----------------------------------------------------------------
+m4_define([lt_if_dict_fetch],
+[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],
+	[$5],
+    [$6])])
+
+
+# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])
+# --------------------------------------------------------------
+m4_define([lt_dict_filter],
+[m4_if([$5], [], [],
+  [lt_join(m4_quote(m4_default([$4], [[, ]])),
+           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),
+		      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl
+])
+
+# ltversion.m4 -- version numbers			-*- Autoconf -*-
+#
+#   Copyright (C) 2004 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# @configure_input@
+
+# serial 3337 ltversion.m4
+# This file is part of GNU Libtool
+
+m4_define([LT_PACKAGE_VERSION], [2.4.2])
+m4_define([LT_PACKAGE_REVISION], [1.3337])
+
+AC_DEFUN([LTVERSION_VERSION],
+[macro_version='2.4.2'
+macro_revision='1.3337'
+_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])
+_LT_DECL(, macro_revision, 0)
+])
+
+# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-
+#
+#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.
+#   Written by Scott James Remnant, 2004.
+#
+# This file is free software; the Free Software Foundation gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+
+# serial 5 lt~obsolete.m4
+
+# These exist entirely to fool aclocal when bootstrapping libtool.
+#
+# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)
+# which have later been changed to m4_define as they aren't part of the
+# exported API, or moved to Autoconf or Automake where they belong.
+#
+# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN
+# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us
+# using a macro with the same name in our local m4/libtool.m4 it'll
+# pull the old libtool.m4 in (it doesn't see our shiny new m4_define
+# and doesn't know about Autoconf macros at all.)
+#
+# So we provide this file, which has a silly filename so it's always
+# included after everything else.  This provides aclocal with the
+# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything
+# because those macros already exist, or will be overwritten later.
+# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. 
+#
+# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.
+# Yes, that means every name once taken will need to remain here until
+# we give up compatibility with versions before 1.7, at which point
+# we need to keep only those names which we still refer to.
+
+# This is to help aclocal find these macros, as it can't see m4_define.
+AC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])
+
+m4_ifndef([AC_LIBTOOL_LINKER_OPTION],	[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])
+m4_ifndef([AC_PROG_EGREP],		[AC_DEFUN([AC_PROG_EGREP])])
+m4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_AC_SHELL_INIT],		[AC_DEFUN([_LT_AC_SHELL_INIT])])
+m4_ifndef([_LT_AC_SYS_LIBPATH_AIX],	[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])
+m4_ifndef([_LT_PROG_LTMAIN],		[AC_DEFUN([_LT_PROG_LTMAIN])])
+m4_ifndef([_LT_AC_TAGVAR],		[AC_DEFUN([_LT_AC_TAGVAR])])
+m4_ifndef([AC_LTDL_ENABLE_INSTALL],	[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])
+m4_ifndef([AC_LTDL_PREOPEN],		[AC_DEFUN([AC_LTDL_PREOPEN])])
+m4_ifndef([_LT_AC_SYS_COMPILER],	[AC_DEFUN([_LT_AC_SYS_COMPILER])])
+m4_ifndef([_LT_AC_LOCK],		[AC_DEFUN([_LT_AC_LOCK])])
+m4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],	[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])
+m4_ifndef([_LT_AC_TRY_DLOPEN_SELF],	[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])
+m4_ifndef([AC_LIBTOOL_PROG_CC_C_O],	[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])
+m4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])
+m4_ifndef([AC_LIBTOOL_OBJDIR],		[AC_DEFUN([AC_LIBTOOL_OBJDIR])])
+m4_ifndef([AC_LTDL_OBJDIR],		[AC_DEFUN([AC_LTDL_OBJDIR])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])
+m4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],	[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])
+m4_ifndef([AC_PATH_MAGIC],		[AC_DEFUN([AC_PATH_MAGIC])])
+m4_ifndef([AC_PROG_LD_GNU],		[AC_DEFUN([AC_PROG_LD_GNU])])
+m4_ifndef([AC_PROG_LD_RELOAD_FLAG],	[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])
+m4_ifndef([AC_DEPLIBS_CHECK_METHOD],	[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])
+m4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])
+m4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])
+m4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],	[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])
+m4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],	[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])
+m4_ifndef([LT_AC_PROG_EGREP],		[AC_DEFUN([LT_AC_PROG_EGREP])])
+m4_ifndef([LT_AC_PROG_SED],		[AC_DEFUN([LT_AC_PROG_SED])])
+m4_ifndef([_LT_CC_BASENAME],		[AC_DEFUN([_LT_CC_BASENAME])])
+m4_ifndef([_LT_COMPILER_BOILERPLATE],	[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])
+m4_ifndef([_LT_LINKER_BOILERPLATE],	[AC_DEFUN([_LT_LINKER_BOILERPLATE])])
+m4_ifndef([_AC_PROG_LIBTOOL],		[AC_DEFUN([_AC_PROG_LIBTOOL])])
+m4_ifndef([AC_LIBTOOL_SETUP],		[AC_DEFUN([AC_LIBTOOL_SETUP])])
+m4_ifndef([_LT_AC_CHECK_DLFCN],		[AC_DEFUN([_LT_AC_CHECK_DLFCN])])
+m4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],	[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])
+m4_ifndef([_LT_AC_TAGCONFIG],		[AC_DEFUN([_LT_AC_TAGCONFIG])])
+m4_ifndef([AC_DISABLE_FAST_INSTALL],	[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])
+m4_ifndef([_LT_AC_LANG_CXX],		[AC_DEFUN([_LT_AC_LANG_CXX])])
+m4_ifndef([_LT_AC_LANG_F77],		[AC_DEFUN([_LT_AC_LANG_F77])])
+m4_ifndef([_LT_AC_LANG_GCJ],		[AC_DEFUN([_LT_AC_LANG_GCJ])])
+m4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])
+m4_ifndef([_LT_AC_LANG_C_CONFIG],	[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])
+m4_ifndef([_LT_AC_LANG_CXX_CONFIG],	[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])
+m4_ifndef([_LT_AC_LANG_F77_CONFIG],	[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])
+m4_ifndef([_LT_AC_LANG_GCJ_CONFIG],	[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])
+m4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],	[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])
+m4_ifndef([_LT_AC_LANG_RC_CONFIG],	[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])
+m4_ifndef([AC_LIBTOOL_CONFIG],		[AC_DEFUN([AC_LIBTOOL_CONFIG])])
+m4_ifndef([_LT_AC_FILE_LTDLL_C],	[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])
+m4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],	[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])
+m4_ifndef([_LT_AC_PROG_CXXCPP],		[AC_DEFUN([_LT_AC_PROG_CXXCPP])])
+m4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],	[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])
+m4_ifndef([_LT_PROG_ECHO_BACKSLASH],	[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])
+m4_ifndef([_LT_PROG_F77],		[AC_DEFUN([_LT_PROG_F77])])
+m4_ifndef([_LT_PROG_FC],		[AC_DEFUN([_LT_PROG_FC])])
+m4_ifndef([_LT_PROG_CXX],		[AC_DEFUN([_LT_PROG_CXX])])
+
+# Copyright (C) 2002-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+# (This private macro should not be called outside this file.)
+AC_DEFUN([AM_AUTOMAKE_VERSION],
+[am__api_version='1.14'
+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
+dnl require some minimum version.  Point them to the right macro.
+m4_if([$1], [1.14.1], [],
+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
+])
+
+# _AM_AUTOCONF_VERSION(VERSION)
+# -----------------------------
+# aclocal traces this macro to find the Autoconf version.
+# This is a private macro too.  Using m4_define simplifies
+# the logic in aclocal, which can simply ignore this definition.
+m4_define([_AM_AUTOCONF_VERSION], [])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+[AM_AUTOMAKE_VERSION([1.14.1])dnl
+m4_ifndef([AC_AUTOCONF_VERSION],
+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is '.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl
+# Expand $ac_aux_dir to an absolute path.
+am_aux_dir=`cd "$ac_aux_dir" && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ([2.52])dnl
+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])dnl
+AC_SUBST([$1_FALSE])dnl
+_AM_SUBST_NOTMAKE([$1_TRUE])dnl
+_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+m4_define([_AM_COND_VALUE_$1], [$2])dnl
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+
+# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "OBJC", "OBJCXX", "UPC", or "GJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
+      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
+      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+      [$1], [OBJCXX], [depcc="$OBJCXX" am_compiler_list='gcc3 gcc'],
+      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
+      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                    [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  am__universal=false
+  m4_case([$1], [CC],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac],
+    [CXX],
+    [case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac])
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+      # This compiler won't grok '-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE([dependency-tracking], [dnl
+AS_HELP_STRING(
+  [--enable-dependency-tracking],
+  [do not reject slow dependency extractors])
+AS_HELP_STRING(
+  [--disable-dependency-tracking],
+  [speeds up one-time build])])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+  am__nodep='_no'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+AC_SUBST([am__nodep])dnl
+_AM_SUBST_NOTMAKE([am__nodep])dnl
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[{
+  # Older Autoconf quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named 'Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`AS_DIRNAME("$mf")`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running 'make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "$am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`AS_DIRNAME(["$file"])`
+      AS_MKDIR_P([$dirpart/$fdir])
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each '.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.
+m4_define([AC_PROG_CC],
+m4_defn([AC_PROG_CC])
+[_AM_PROG_CC_C_O
+])
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.65])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[AC_DIAGNOSE([obsolete],
+             [$0: two- and three-arguments forms are deprecated.])
+m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
+m4_if(
+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  [ok:ok],,
+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
+ AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
+AM_MISSING_PROG([AUTOCONF], [autoconf])
+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
+AM_MISSING_PROG([AUTOHEADER], [autoheader])
+AM_MISSING_PROG([MAKEINFO], [makeinfo])
+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
+AC_REQUIRE([AC_PROG_MKDIR_P])dnl
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+AC_SUBST([mkdir_p], ['$(MKDIR_P)'])
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+			     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+		  [_AM_DEPENDENCIES([CC])],
+		  [m4_define([AC_PROG_CC],
+			     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+		  [_AM_DEPENDENCIES([CXX])],
+		  [m4_define([AC_PROG_CXX],
+			     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJC],
+		  [_AM_DEPENDENCIES([OBJC])],
+		  [m4_define([AC_PROG_OBJC],
+			     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],
+		  [_AM_DEPENDENCIES([OBJCXX])],
+		  [m4_define([AC_PROG_OBJCXX],
+			     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl
+])
+AC_REQUIRE([AM_SILENT_RULES])dnl
+dnl The testsuite driver may need to know about EXEEXT, so add the
+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This
+dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.
+AC_CONFIG_COMMANDS_PRE(dnl
+[m4_provide_if([_AM_COMPILER_EXEEXT],
+  [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
+
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])
+  fi
+fi
+])
+
+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
+dnl mangled by Autoconf and run in a shell conditional statement.
+m4_define([_AC_COMPILER_EXEEXT],
+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_arg=$1
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+AC_SUBST([install_sh])])
+
+# Copyright (C) 2003-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_MAINTAINER_MODE([DEFAULT-MODE])
+# ----------------------------------
+# Control maintainer-specific portions of Makefiles.
+# Default is to disable them, unless 'enable' is passed literally.
+# For symmetry, 'disable' may be passed as well.  Anyway, the user
+# can override the default with the --enable/--disable switch.
+AC_DEFUN([AM_MAINTAINER_MODE],
+[m4_case(m4_default([$1], [disable]),
+       [enable], [m4_define([am_maintainer_other], [disable])],
+       [disable], [m4_define([am_maintainer_other], [enable])],
+       [m4_define([am_maintainer_other], [enable])
+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed
+  AC_ARG_ENABLE([maintainer-mode],
+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],
+      am_maintainer_other[ make rules and dependencies not useful
+      (and sometimes confusing) to the casual installer])],
+    [USE_MAINTAINER_MODE=$enableval],
+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST([MAINT])dnl
+]
+)
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from 'make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it is modern enough.
+# If it is, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([missing])dnl
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
+else
+  am_missing_run=
+  AC_MSG_WARN(['missing' script is too old or missing])
+fi
+])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# --------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_PROG_CC_C_O
+# ---------------
+# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC
+# to automatically call this.
+AC_DEFUN([_AM_PROG_CC_C_O],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+AC_REQUIRE_AUX_FILE([compile])dnl
+AC_LANG_PUSH([C])dnl
+AC_CACHE_CHECK(
+  [whether $CC understands -c and -o together],
+  [am_cv_prog_cc_c_o],
+  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i])
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+AC_LANG_POP([C])])
+
+# For backward compatibility.
+AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_RUN_LOG(COMMAND)
+# -------------------
+# Run COMMAND, save the exit status in ac_status, and log it.
+# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)
+AC_DEFUN([AM_RUN_LOG],
+[{ echo "$as_me:$LINENO: $1" >&AS_MESSAGE_LOG_FD
+   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&AS_MESSAGE_LOG_FD
+   (exit $ac_status); }])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[[\\\"\#\$\&\'\`$am_lf]]*)
+    AC_MSG_ERROR([unsafe absolute working directory name]);;
+esac
+case $srcdir in
+  *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
+esac
+
+# Do 'set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$[*]" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$[*]" != "X $srcdir/configure conftest.file" \
+	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment])
+     fi
+     if test "$[2]" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT([yes])
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+AC_CONFIG_COMMANDS_PRE(
+  [AC_MSG_CHECKING([that generated files are newer than configure])
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   AC_MSG_RESULT([done])])
+rm -f conftest.file
+])
+
+# Copyright (C) 2009-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_SILENT_RULES([DEFAULT])
+# --------------------------
+# Enable less verbose build rules; with the default set to DEFAULT
+# ("yes" being less verbose, "no" or empty being verbose).
+AC_DEFUN([AM_SILENT_RULES],
+[AC_ARG_ENABLE([silent-rules], [dnl
+AS_HELP_STRING(
+  [--enable-silent-rules],
+  [less verbose build output (undo: "make V=1")])
+AS_HELP_STRING(
+  [--disable-silent-rules],
+  [verbose build output (undo: "make V=0")])dnl
+])
+case $enable_silent_rules in @%:@ (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;
+esac
+dnl
+dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
+dnl do not support nested variable expansions.
+dnl See automake bug#9928 and bug#10237.
+am_make=${MAKE-make}
+AC_CACHE_CHECK([whether $am_make supports nested variables],
+   [am_cv_make_support_nested_variables],
+   [if AS_ECHO([['TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi])
+if test $am_cv_make_support_nested_variables = yes; then
+  dnl Using '$V' instead of '$(V)' breaks IRIX make.
+  AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AC_SUBST([AM_V])dnl
+AM_SUBST_NOTMAKE([AM_V])dnl
+AC_SUBST([AM_DEFAULT_V])dnl
+AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl
+AC_SUBST([AM_DEFAULT_VERBOSITY])dnl
+AM_BACKSLASH='\'
+AC_SUBST([AM_BACKSLASH])dnl
+_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl
+])
+
+# Copyright (C) 2001-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor 'install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in "make install-strip", and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the 'STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Copyright (C) 2006-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_SUBST_NOTMAKE(VARIABLE)
+# ---------------------------
+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
+# This macro is traced by Automake.
+AC_DEFUN([_AM_SUBST_NOTMAKE])
+
+# AM_SUBST_NOTMAKE(VARIABLE)
+# --------------------------
+# Public sister of _AM_SUBST_NOTMAKE.
+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004-2013 Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of 'v7', 'ustar', or 'pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+#
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AC_SUBST([AMTAR], ['$${TAR-tar}'])
+
+# We'll loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+
+m4_if([$1], [v7],
+  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
+
+  [m4_case([$1],
+    [ustar],
+     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
+      # There is notably a 21 bits limit for the UID and the GID.  In fact,
+      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
+      # and bug#13588).
+      am_max_uid=2097151 # 2^21 - 1
+      am_max_gid=$am_max_uid
+      # The $UID and $GID variables are not portable, so we need to resort
+      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls
+      # below are definitely unexpected, so allow the users to see them
+      # (that is, avoid stderr redirection).
+      am_uid=`id -u || echo unknown`
+      am_gid=`id -g || echo unknown`
+      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])
+      if test $am_uid -le $am_max_uid; then
+         AC_MSG_RESULT([yes])
+      else
+         AC_MSG_RESULT([no])
+         _am_tools=none
+      fi
+      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])
+      if test $am_gid -le $am_max_gid; then
+         AC_MSG_RESULT([yes])
+      else
+        AC_MSG_RESULT([no])
+        _am_tools=none
+      fi],
+
+  [pax],
+    [],
+
+  [m4_fatal([Unknown tar format])])
+
+  AC_MSG_CHECKING([how to create a $1 tar archive])
+
+  # Go ahead even if we have the value already cached.  We do so because we
+  # need to set the values for the 'am__tar' and 'am__untar' variables.
+  _am_tools=${am_cv_prog_tar_$1-$_am_tools}
+
+  for _am_tool in $_am_tools; do
+    case $_am_tool in
+    gnutar)
+      for _am_tar in tar gnutar gtar; do
+        AM_RUN_LOG([$_am_tar --version]) && break
+      done
+      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+      am__untar="$_am_tar -xf -"
+      ;;
+    plaintar)
+      # Must skip GNU tar: if it does not support --format= it doesn't create
+      # ustar tarball either.
+      (tar --version) >/dev/null 2>&1 && continue
+      am__tar='tar chf - "$$tardir"'
+      am__tar_='tar chf - "$tardir"'
+      am__untar='tar xf -'
+      ;;
+    pax)
+      am__tar='pax -L -x $1 -w "$$tardir"'
+      am__tar_='pax -L -x $1 -w "$tardir"'
+      am__untar='pax -r'
+      ;;
+    cpio)
+      am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+      am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+      am__untar='cpio -i -H $1 -d'
+      ;;
+    none)
+      am__tar=false
+      am__tar_=false
+      am__untar=false
+      ;;
+    esac
+
+    # If the value was cached, stop now.  We just wanted to have am__tar
+    # and am__untar set.
+    test -n "${am_cv_prog_tar_$1}" && break
+
+    # tar/untar a dummy directory, and stop if the command works.
+    rm -rf conftest.dir
+    mkdir conftest.dir
+    echo GrepMe > conftest.dir/file
+    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+    rm -rf conftest.dir
+    if test -s conftest.tar; then
+      AM_RUN_LOG([$am__untar <conftest.tar])
+      AM_RUN_LOG([cat conftest.dir/file])
+      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+    fi
+  done
+  rm -rf conftest.dir
+
+  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+  AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
diff --git a/release/src/router/libev-4.22/autogen.sh b/release/src/router/libev-4.22/autogen.sh
new file mode 100644
index 0000000000..8056ee7f9b
--- /dev/null
+++ b/release/src/router/libev-4.22/autogen.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+autoreconf --install --symlink --force
diff --git a/release/src/router/libev-4.22/compile b/release/src/router/libev-4.22/compile
new file mode 100755
index 0000000000..531136b068
--- /dev/null
+++ b/release/src/router/libev-4.22/compile
@@ -0,0 +1,347 @@
+#! /bin/sh
+# Wrapper for compilers which do not understand '-c -o'.
+
+scriptversion=2012-10-14.11; # UTC
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+# Written by Tom Tromey <tromey@cygnus.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+nl='
+'
+
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent tools from complaining about whitespace usage.
+IFS=" ""	$nl"
+
+file_conv=
+
+# func_file_conv build_file lazy
+# Convert a $build file to $host form and store it in $file
+# Currently only supports Windows hosts. If the determined conversion
+# type is listed in (the comma separated) LAZY, no conversion will
+# take place.
+func_file_conv ()
+{
+  file=$1
+  case $file in
+    / | /[!/]*) # absolute file, and not a UNC file
+      if test -z "$file_conv"; then
+	# lazily determine how to convert abs files
+	case `uname -s` in
+	  MINGW*)
+	    file_conv=mingw
+	    ;;
+	  CYGWIN*)
+	    file_conv=cygwin
+	    ;;
+	  *)
+	    file_conv=wine
+	    ;;
+	esac
+      fi
+      case $file_conv/,$2, in
+	*,$file_conv,*)
+	  ;;
+	mingw/*)
+	  file=`cmd //C echo "$file " | sed -e 's/"\(.*\) " *$/\1/'`
+	  ;;
+	cygwin/*)
+	  file=`cygpath -m "$file" || echo "$file"`
+	  ;;
+	wine/*)
+	  file=`winepath -w "$file" || echo "$file"`
+	  ;;
+      esac
+      ;;
+  esac
+}
+
+# func_cl_dashL linkdir
+# Make cl look for libraries in LINKDIR
+func_cl_dashL ()
+{
+  func_file_conv "$1"
+  if test -z "$lib_path"; then
+    lib_path=$file
+  else
+    lib_path="$lib_path;$file"
+  fi
+  linker_opts="$linker_opts -LIBPATH:$file"
+}
+
+# func_cl_dashl library
+# Do a library search-path lookup for cl
+func_cl_dashl ()
+{
+  lib=$1
+  found=no
+  save_IFS=$IFS
+  IFS=';'
+  for dir in $lib_path $LIB
+  do
+    IFS=$save_IFS
+    if $shared && test -f "$dir/$lib.dll.lib"; then
+      found=yes
+      lib=$dir/$lib.dll.lib
+      break
+    fi
+    if test -f "$dir/$lib.lib"; then
+      found=yes
+      lib=$dir/$lib.lib
+      break
+    fi
+    if test -f "$dir/lib$lib.a"; then
+      found=yes
+      lib=$dir/lib$lib.a
+      break
+    fi
+  done
+  IFS=$save_IFS
+
+  if test "$found" != yes; then
+    lib=$lib.lib
+  fi
+}
+
+# func_cl_wrapper cl arg...
+# Adjust compile command to suit cl
+func_cl_wrapper ()
+{
+  # Assume a capable shell
+  lib_path=
+  shared=:
+  linker_opts=
+  for arg
+  do
+    if test -n "$eat"; then
+      eat=
+    else
+      case $1 in
+	-o)
+	  # configure might choose to run compile as 'compile cc -o foo foo.c'.
+	  eat=1
+	  case $2 in
+	    *.o | *.[oO][bB][jJ])
+	      func_file_conv "$2"
+	      set x "$@" -Fo"$file"
+	      shift
+	      ;;
+	    *)
+	      func_file_conv "$2"
+	      set x "$@" -Fe"$file"
+	      shift
+	      ;;
+	  esac
+	  ;;
+	-I)
+	  eat=1
+	  func_file_conv "$2" mingw
+	  set x "$@" -I"$file"
+	  shift
+	  ;;
+	-I*)
+	  func_file_conv "${1#-I}" mingw
+	  set x "$@" -I"$file"
+	  shift
+	  ;;
+	-l)
+	  eat=1
+	  func_cl_dashl "$2"
+	  set x "$@" "$lib"
+	  shift
+	  ;;
+	-l*)
+	  func_cl_dashl "${1#-l}"
+	  set x "$@" "$lib"
+	  shift
+	  ;;
+	-L)
+	  eat=1
+	  func_cl_dashL "$2"
+	  ;;
+	-L*)
+	  func_cl_dashL "${1#-L}"
+	  ;;
+	-static)
+	  shared=false
+	  ;;
+	-Wl,*)
+	  arg=${1#-Wl,}
+	  save_ifs="$IFS"; IFS=','
+	  for flag in $arg; do
+	    IFS="$save_ifs"
+	    linker_opts="$linker_opts $flag"
+	  done
+	  IFS="$save_ifs"
+	  ;;
+	-Xlinker)
+	  eat=1
+	  linker_opts="$linker_opts $2"
+	  ;;
+	-*)
+	  set x "$@" "$1"
+	  shift
+	  ;;
+	*.cc | *.CC | *.cxx | *.CXX | *.[cC]++)
+	  func_file_conv "$1"
+	  set x "$@" -Tp"$file"
+	  shift
+	  ;;
+	*.c | *.cpp | *.CPP | *.lib | *.LIB | *.Lib | *.OBJ | *.obj | *.[oO])
+	  func_file_conv "$1" mingw
+	  set x "$@" "$file"
+	  shift
+	  ;;
+	*)
+	  set x "$@" "$1"
+	  shift
+	  ;;
+      esac
+    fi
+    shift
+  done
+  if test -n "$linker_opts"; then
+    linker_opts="-link$linker_opts"
+  fi
+  exec "$@" $linker_opts
+  exit 1
+}
+
+eat=
+
+case $1 in
+  '')
+     echo "$0: No command.  Try '$0 --help' for more information." 1>&2
+     exit 1;
+     ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: compile [--help] [--version] PROGRAM [ARGS]
+
+Wrapper for compilers which do not understand '-c -o'.
+Remove '-o dest.o' from ARGS, run PROGRAM with the remaining
+arguments, and rename the output as expected.
+
+If you are trying to build a whole package this is not the
+right script to run: please start by reading the file 'INSTALL'.
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "compile $scriptversion"
+    exit $?
+    ;;
+  cl | *[/\\]cl | cl.exe | *[/\\]cl.exe )
+    func_cl_wrapper "$@"      # Doesn't return...
+    ;;
+esac
+
+ofile=
+cfile=
+
+for arg
+do
+  if test -n "$eat"; then
+    eat=
+  else
+    case $1 in
+      -o)
+	# configure might choose to run compile as 'compile cc -o foo foo.c'.
+	# So we strip '-o arg' only if arg is an object.
+	eat=1
+	case $2 in
+	  *.o | *.obj)
+	    ofile=$2
+	    ;;
+	  *)
+	    set x "$@" -o "$2"
+	    shift
+	    ;;
+	esac
+	;;
+      *.c)
+	cfile=$1
+	set x "$@" "$1"
+	shift
+	;;
+      *)
+	set x "$@" "$1"
+	shift
+	;;
+    esac
+  fi
+  shift
+done
+
+if test -z "$ofile" || test -z "$cfile"; then
+  # If no '-o' option was seen then we might have been invoked from a
+  # pattern rule where we don't need one.  That is ok -- this is a
+  # normal compilation that the losing compiler can handle.  If no
+  # '.c' file was seen then we are probably linking.  That is also
+  # ok.
+  exec "$@"
+fi
+
+# Name of file we expect compiler to create.
+cofile=`echo "$cfile" | sed 's|^.*[\\/]||; s|^[a-zA-Z]:||; s/\.c$/.o/'`
+
+# Create the lock directory.
+# Note: use '[/\\:.-]' here to ensure that we don't use the same name
+# that we are using for the .o file.  Also, base the name on the expected
+# object file name, since that is what matters with a parallel build.
+lockdir=`echo "$cofile" | sed -e 's|[/\\:.-]|_|g'`.d
+while true; do
+  if mkdir "$lockdir" >/dev/null 2>&1; then
+    break
+  fi
+  sleep 1
+done
+# FIXME: race condition here if user kills between mkdir and trap.
+trap "rmdir '$lockdir'; exit 1" 1 2 15
+
+# Run the compile.
+"$@"
+ret=$?
+
+if test -f "$cofile"; then
+  test "$cofile" = "$ofile" || mv "$cofile" "$ofile"
+elif test -f "${cofile}bj"; then
+  test "${cofile}bj" = "$ofile" || mv "${cofile}bj" "$ofile"
+fi
+
+rmdir "$lockdir"
+exit $ret
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/release/src/router/libev-4.22/config.guess b/release/src/router/libev-4.22/config.guess
new file mode 100755
index 0000000000..1f5c50c0d1
--- /dev/null
+++ b/release/src/router/libev-4.22/config.guess
@@ -0,0 +1,1420 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
+
+timestamp='2014-03-23'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner.
+#
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+#
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright 1992-2014 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+trap 'exit 1' 1 2 15
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+set_cc_for_build='
+trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
+trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
+: ${TMPDIR=/tmp} ;
+ { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+ { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+ { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
+dummy=$tmp/dummy ;
+tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
+case $CC_FOR_BUILD,$HOST_CC,$CC in
+ ,,)    echo "int x;" > $dummy.c ;
+	for c in cc gcc c89 c99 ; do
+	  if ($c -c -o $dummy.o $dummy.c) >/dev/null 2>&1 ; then
+	     CC_FOR_BUILD="$c"; break ;
+	  fi ;
+	done ;
+	if test x"$CC_FOR_BUILD" = x ; then
+	  CC_FOR_BUILD=no_compiler_found ;
+	fi
+	;;
+ ,,*)   CC_FOR_BUILD=$CC ;;
+ ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+esac ; set_cc_for_build= ;'
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+case "${UNAME_SYSTEM}" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	eval $set_cc_for_build
+	cat <<-EOF > $dummy.c
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`
+	;;
+esac
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(/sbin/$sysctl 2>/dev/null || \
+	    /usr/sbin/$sysctl 2>/dev/null || echo unknown)`
+	case "${UNAME_MACHINE_ARCH}" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently, or will in the future.
+	case "${UNAME_MACHINE_ARCH}" in
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		eval $set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep -q __ELF__
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+		os=netbsd
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "${UNAME_VERSION}" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "${machine}-${os}${release}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-bitrig${UNAME_RELEASE}
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo ${UNAME_MACHINE_ARCH}-unknown-openbsd${UNAME_RELEASE}
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-ekkobsd${UNAME_RELEASE}
+	exit ;;
+    *:SolidBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-solidbsd${UNAME_RELEASE}
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    *:MirBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-mirbsd${UNAME_RELEASE}
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
+    Alpha\ *:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# Should we change UNAME_MACHINE based on the output of uname instead
+	# of the specific Alpha model?
+	echo alpha-pc-interix
+	exit ;;
+    21064:Windows_NT:50:3)
+	echo alpha-dec-winnt3.5
+	exit ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo ${UNAME_MACHINE}-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+	echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix${UNAME_RELEASE}
+	exit ;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    s390x:SunOS:*:*)
+	echo ${UNAME_MACHINE}-ibm-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux${UNAME_RELEASE}
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	eval $set_cc_for_build
+	SUN_ARCH="i386"
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH="x86_64"
+	    fi
+	fi
+	echo ${SUN_ARCH}-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos`echo ${UNAME_RELEASE}|sed -e 's/-/_/'`
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos${UNAME_RELEASE}
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos${UNAME_RELEASE}
+		;;
+	    sun4)
+		echo sparc-sun-sunos${UNAME_RELEASE}
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos${UNAME_RELEASE}
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+	echo m68k-atari-mint${UNAME_RELEASE}
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+	echo m68k-milan-mint${UNAME_RELEASE}
+	exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+	echo m68k-hades-mint${UNAME_RELEASE}
+	exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+	echo m68k-unknown-mint${UNAME_RELEASE}
+	exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten${UNAME_RELEASE}
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten${UNAME_RELEASE}
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix${UNAME_RELEASE}
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix${UNAME_RELEASE}
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c &&
+	  dummyarg=`echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`$dummy $dummyarg` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos${UNAME_RELEASE}
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
+	then
+	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
+	       [ ${TARGET_BINARY_INTERFACE}x = x ]
+	    then
+		echo m88k-dg-dgux${UNAME_RELEASE}
+	    else
+		echo m88k-dg-dguxbcs${UNAME_RELEASE}
+	    fi
+	else
+	    echo i586-dg-dgux${UNAME_RELEASE}
+	fi
+	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		eval $set_cc_for_build
+		sed 's/^		//' << EOF >$dummy.c
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[4567])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+	fi
+	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	case "${UNAME_MACHINE}" in
+	    9000/31? )            HP_ARCH=m68000 ;;
+	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case "${sc_cpu_version}" in
+		      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case "${sc_kernel_bits}" in
+			  32) HP_ARCH="hppa2.0n" ;;
+			  64) HP_ARCH="hppa2.0w" ;;
+			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
+			esac ;;
+		    esac
+		fi
+		if [ "${HP_ARCH}" = "" ]; then
+		    eval $set_cc_for_build
+		    sed 's/^		//' << EOF >$dummy.c
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
+EOF
+		    (CCOPTS= $CC_FOR_BUILD -o $dummy $dummy.c 2>/dev/null) && HP_ARCH=`$dummy`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ ${HP_ARCH} = "hppa2.0w" ]
+	then
+	    eval $set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
+	    then
+		HP_ARCH="hppa2.0w"
+	    else
+		HP_ARCH="hppa64"
+	    fi
+	fi
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux${HPUX_REV}
+	exit ;;
+    3050*:HI-UX:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o $dummy $dummy.c && SYSTEM_NAME=`$dummy` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:* )
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo ${UNAME_MACHINE}-unknown-osf1mk
+	else
+	    echo ${UNAME_MACHINE}-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+	exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+	exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+	exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+	exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    5000:UNIX_System_V:4.*:*)
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
+	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:BSD/OS:*:*)
+	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+	exit ;;
+    *:FreeBSD:*:*)
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case ${UNAME_PROCESSOR} in
+	    amd64)
+		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	    *)
+		echo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
+	esac
+	exit ;;
+    i*:CYGWIN*:*)
+	echo ${UNAME_MACHINE}-pc-cygwin
+	exit ;;
+    *:MINGW64*:*)
+	echo ${UNAME_MACHINE}-pc-mingw64
+	exit ;;
+    *:MINGW*:*)
+	echo ${UNAME_MACHINE}-pc-mingw32
+	exit ;;
+    *:MSYS*:*)
+	echo ${UNAME_MACHINE}-pc-msys
+	exit ;;
+    i*:windows32*:*)
+	# uname -m includes "-pc" on this system.
+	echo ${UNAME_MACHINE}-mingw32
+	exit ;;
+    i*:PW*:*)
+	echo ${UNAME_MACHINE}-pc-pw32
+	exit ;;
+    *:Interix*:*)
+	case ${UNAME_MACHINE} in
+	    x86)
+		echo i586-pc-interix${UNAME_RELEASE}
+		exit ;;
+	    authenticamd | genuineintel | EM64T)
+		echo x86_64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix${UNAME_RELEASE}
+		exit ;;
+	esac ;;
+    [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
+	echo i${UNAME_MACHINE}-pc-mks
+	exit ;;
+    8664:Windows_NT:*)
+	echo x86_64-pc-mks
+	exit ;;
+    i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
+	# How do we know it's Interix rather than the generic POSIX subsystem?
+	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+	# UNAME_MACHINE based on the output of uname instead of i386?
+	echo i586-pc-interix
+	exit ;;
+    i*:UWIN*:*)
+	echo ${UNAME_MACHINE}-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-unknown-cygwin
+	exit ;;
+    p*:CYGWIN*:*)
+	echo powerpcle-unknown-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-${LIBC}`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo ${UNAME_MACHINE}-unknown-`echo ${UNAME_SYSTEM} | sed 's,^[^/]*/,,' | tr '[A-Z]' '[a-z]'``echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`-${LIBC}
+	exit ;;
+    i*86:Minix:*:*)
+	echo ${UNAME_MACHINE}-pc-minix
+	exit ;;
+    aarch64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC="gnulibc1" ; fi
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    arm*:Linux:*:*)
+	eval $set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
+	    else
+		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
+	    fi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    cris:Linux:*:*)
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
+    crisv32:Linux:*:*)
+	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
+	exit ;;
+    frv:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    hexagon:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    i*86:Linux:*:*)
+	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
+	exit ;;
+    ia64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    m32r*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    m68*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	eval $set_cc_for_build
+	sed 's/^	//' << EOF >$dummy.c
+	#undef CPU
+	#undef ${UNAME_MACHINE}
+	#undef ${UNAME_MACHINE}el
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	CPU=${UNAME_MACHINE}el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	CPU=${UNAME_MACHINE}
+	#else
+	CPU=
+	#endif
+	#endif
+EOF
+	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep '^CPU'`
+	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
+	;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-${LIBC}
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    padre:Linux:*:*)
+	echo sparc-unknown-linux-${LIBC}
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-${LIBC}
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
+	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
+	  *)    echo hppa-unknown-linux-${LIBC} ;;
+	esac
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-${LIBC}
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-${LIBC}
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-${LIBC}
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-${LIBC}
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
+	exit ;;
+    sh64*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    sh*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    tile*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    vax:Linux:*:*)
+	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
+	exit ;;
+    x86_64:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    xtensa*:Linux:*:*)
+	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
+	exit ;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+	# Use sysv4.2uw... so that sysv4* matches it.
+	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo ${UNAME_MACHINE}-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo ${UNAME_MACHINE}-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo ${UNAME_MACHINE}-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo ${UNAME_MACHINE}-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	echo i386-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    i*86:*DOS:*:*)
+	echo ${UNAME_MACHINE}-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
+	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+	else
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo ${UNAME_MACHINE}-pc-sco$UNAME_REL
+	else
+		echo ${UNAME_MACHINE}-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configury will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
+	exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv${UNAME_RELEASE} # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv${UNAME_RELEASE}  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv${UNAME_RELEASE}
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo ${UNAME_MACHINE}-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo ${UNAME_MACHINE}-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux${UNAME_RELEASE}
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+		echo mips-nec-sysv${UNAME_RELEASE}
+	else
+		echo mips-unknown-sysv${UNAME_RELEASE}
+	fi
+	exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	echo i586-pc-haiku
+	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux${UNAME_RELEASE}
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux${UNAME_RELEASE}
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Rhapsody:*:*)
+	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown
+	eval $set_cc_for_build
+	if test "$UNAME_PROCESSOR" = unknown ; then
+	    UNAME_PROCESSOR=powerpc
+	fi
+	if test `echo "$UNAME_RELEASE" | sed -e 's/\..*//'` -le 10 ; then
+	    if [ "$CC_FOR_BUILD" != 'no_compiler_found' ]; then
+		if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		    (CCOPTS= $CC_FOR_BUILD -E - 2>/dev/null) | \
+		    grep IS_64BIT_ARCH >/dev/null
+		then
+		    case $UNAME_PROCESSOR in
+			i386) UNAME_PROCESSOR=x86_64 ;;
+			powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		    esac
+		fi
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # Avoid executing cc on OS X 10.9, as it ships with a stub
+	    # that puts up a graphical alert prompting to install
+	    # developer tools.  Any system running Mac OS X 10.7 or
+	    # later (Darwin 11 and later) is required to have a 64-bit
+	    # processor. This is not true of the ARM version of Darwin
+	    # that Apple uses in portable devices.
+	    UNAME_PROCESSOR=x86_64
+	fi
+	echo ${UNAME_PROCESSOR}-apple-darwin${UNAME_RELEASE}
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = "x86"; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NEO-?:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    NSR-?:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk${UNAME_RELEASE}
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	if test "$cputype" = "386"; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo ${UNAME_MACHINE}-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+	echo mips-sei-seiux${UNAME_RELEASE}
+	exit ;;
+    *:DragonFly:*:*)
+	echo ${UNAME_MACHINE}-unknown-dragonfly`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	exit ;;
+    *:*VMS:*:*)
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "${UNAME_MACHINE}" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo ${UNAME_MACHINE}-pc-skyos`echo ${UNAME_RELEASE}` | sed -e 's/ .*$//'
+	exit ;;
+    i*86:rdos:*:*)
+	echo ${UNAME_MACHINE}-pc-rdos
+	exit ;;
+    i*86:AROS:*:*)
+	echo ${UNAME_MACHINE}-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo ${UNAME_MACHINE}-unknown-esx
+	exit ;;
+esac
+
+cat >&2 <<EOF
+$0: unable to guess system type
+
+This script, last modified $timestamp, has failed to recognize
+the operating system you are using. It is advised that you
+download the most up to date version of the config scripts from
+
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD
+and
+  http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
+If the version you run ($0) is already up to date, please
+send the following data and any information you think might be
+pertinent to <config-patches@gnu.org> in order to provide the needed
+information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = ${UNAME_MACHINE}
+UNAME_RELEASE = ${UNAME_RELEASE}
+UNAME_SYSTEM  = ${UNAME_SYSTEM}
+UNAME_VERSION = ${UNAME_VERSION}
+EOF
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff --git a/release/src/router/libev-4.22/config.h.in b/release/src/router/libev-4.22/config.h.in
new file mode 100644
index 0000000000..508542b5e5
--- /dev/null
+++ b/release/src/router/libev-4.22/config.h.in
@@ -0,0 +1,125 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#undef HAVE_CLOCK_GETTIME
+
+/* Define to 1 to use the syscall interface for clock_gettime */
+#undef HAVE_CLOCK_SYSCALL
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+#undef HAVE_EPOLL_CTL
+
+/* Define to 1 if you have the `eventfd' function. */
+#undef HAVE_EVENTFD
+
+/* Define to 1 if the floor function is available */
+#undef HAVE_FLOOR
+
+/* Define to 1 if you have the `inotify_init' function. */
+#undef HAVE_INOTIFY_INIT
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `kqueue' function. */
+#undef HAVE_KQUEUE
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+#undef HAVE_LIBRT
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `nanosleep' function. */
+#undef HAVE_NANOSLEEP
+
+/* Define to 1 if you have the `poll' function. */
+#undef HAVE_POLL
+
+/* Define to 1 if you have the <poll.h> header file. */
+#undef HAVE_POLL_H
+
+/* Define to 1 if you have the `port_create' function. */
+#undef HAVE_PORT_CREATE
+
+/* Define to 1 if you have the <port.h> header file. */
+#undef HAVE_PORT_H
+
+/* Define to 1 if you have the `select' function. */
+#undef HAVE_SELECT
+
+/* Define to 1 if you have the `signalfd' function. */
+#undef HAVE_SIGNALFD
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+#undef HAVE_SYS_EPOLL_H
+
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+#undef HAVE_SYS_EVENT_H
+
+/* Define to 1 if you have the <sys/inotify.h> header file. */
+#undef HAVE_SYS_INOTIFY_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/signalfd.h> header file. */
+#undef HAVE_SYS_SIGNALFD_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
diff --git a/release/src/router/libev-4.22/config.sub b/release/src/router/libev-4.22/config.sub
new file mode 100755
index 0000000000..bba4efb805
--- /dev/null
+++ b/release/src/router/libev-4.22/config.sub
@@ -0,0 +1,1799 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright 1992-2014 Free Software Foundation, Inc.
+
+timestamp='2014-09-11'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+
+
+# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# You can get the latest version of this script from:
+# http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS
+       $0 [OPTION] ALIAS
+
+Canonicalize a configuration name.
+
+Operation modes:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright 1992-2014 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help"
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo $1
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
+# Here we must recognize all the valid KERNEL-OS combinations.
+maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
+case $maybe_os in
+  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
+  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | \
+  kopensolaris*-gnu* | \
+  storm-chaos* | os2-emx* | rtmk-nova*)
+    os=-$maybe_os
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
+    ;;
+  android-linux)
+    os=-linux-android
+    basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`-unknown
+    ;;
+  *)
+    basic_machine=`echo $1 | sed 's/-[^-]*$//'`
+    if [ $basic_machine != $1 ]
+    then os=`echo $1 | sed 's/.*-/-/'`
+    else os=; fi
+    ;;
+esac
+
+### Let's recognize common machines as not being operating systems so
+### that things like config.sub decstation-3100 work.  We also
+### recognize some manufacturers as not being operating systems, so we
+### can provide default operating systems below.
+case $os in
+	-sun*os*)
+		# Prevent following clause from handling this invalid input.
+		;;
+	-dec* | -mips* | -sequent* | -encore* | -pc532* | -sgi* | -sony* | \
+	-att* | -7300* | -3300* | -delta* | -motorola* | -sun[234]* | \
+	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
+	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
+	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
+	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
+	-apple | -axis | -knuth | -cray | -microblaze*)
+		os=
+		basic_machine=$1
+		;;
+	-bluegene*)
+		os=-cnk
+		;;
+	-sim | -cisco | -oki | -wec | -winbond)
+		os=
+		basic_machine=$1
+		;;
+	-scout)
+		;;
+	-wrs)
+		os=-vxworks
+		basic_machine=$1
+		;;
+	-chorusos*)
+		os=-chorusos
+		basic_machine=$1
+		;;
+	-chorusrdb)
+		os=-chorusrdb
+		basic_machine=$1
+		;;
+	-hiux*)
+		os=-hiuxwe2
+		;;
+	-sco6)
+		os=-sco5v6
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5)
+		os=-sco3.2v5
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco4)
+		os=-sco3.2v4
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco3.2v[4-9]*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-sco*)
+		os=-sco3.2v2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-udk*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-isc)
+		os=-isc2.2
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-clix*)
+		basic_machine=clipper-intergraph
+		;;
+	-isc*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-pc/'`
+		;;
+	-lynx*178)
+		os=-lynxos178
+		;;
+	-lynx*5)
+		os=-lynxos5
+		;;
+	-lynx*)
+		os=-lynxos
+		;;
+	-ptx*)
+		basic_machine=`echo $1 | sed -e 's/86-.*/86-sequent/'`
+		;;
+	-windowsnt*)
+		os=`echo $os | sed -e 's/windowsnt/winnt/'`
+		;;
+	-psos*)
+		os=-psos
+		;;
+	-mint | -mint[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+esac
+
+# Decode aliases for certain CPU-COMPANY combinations.
+case $basic_machine in
+	# Recognize the basic CPU types without company name.
+	# Some are omitted here because they have special meanings below.
+	1750a | 580 \
+	| a29k \
+	| aarch64 | aarch64_be \
+	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
+	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
+	| arc | arceb \
+	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
+	| avr | avr32 \
+	| be32 | be64 \
+	| bfin \
+	| c4x | c8051 | clipper \
+	| d10v | d30v | dlx | dsp16xx \
+	| epiphany \
+	| fido | fr30 | frv \
+	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+	| hexagon \
+	| i370 | i860 | i960 | ia64 \
+	| ip2k | iq2000 \
+	| k1om \
+	| le32 | le64 \
+	| lm32 \
+	| m32c | m32r | m32rle | m68000 | m68k | m88k \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
+	| mips | mipsbe | mipseb | mipsel | mipsle \
+	| mips16 \
+	| mips64 | mips64el \
+	| mips64octeon | mips64octeonel \
+	| mips64orion | mips64orionel \
+	| mips64r5900 | mips64r5900el \
+	| mips64vr | mips64vrel \
+	| mips64vr4100 | mips64vr4100el \
+	| mips64vr4300 | mips64vr4300el \
+	| mips64vr5000 | mips64vr5000el \
+	| mips64vr5900 | mips64vr5900el \
+	| mipsisa32 | mipsisa32el \
+	| mipsisa32r2 | mipsisa32r2el \
+	| mipsisa32r6 | mipsisa32r6el \
+	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
+	| mipsisa64r6 | mipsisa64r6el \
+	| mipsisa64sb1 | mipsisa64sb1el \
+	| mipsisa64sr71k | mipsisa64sr71kel \
+	| mipsr5900 | mipsr5900el \
+	| mipstx39 | mipstx39el \
+	| mn10200 | mn10300 \
+	| moxie \
+	| mt \
+	| msp430 \
+	| nds32 | nds32le | nds32be \
+	| nios | nios2 | nios2eb | nios2el \
+	| ns16k | ns32k \
+	| open8 | or1k | or1knd | or32 \
+	| pdp10 | pdp11 | pj | pjl \
+	| powerpc | powerpc64 | powerpc64le | powerpcle \
+	| pyramid \
+	| riscv32 | riscv64 \
+	| rl78 | rx \
+	| score \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh64 | sh64le \
+	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
+	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
+	| spu \
+	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
+	| ubicom32 \
+	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| we32k \
+	| x86 | xc16x | xstormy16 | xtensa \
+	| z8k | z80)
+		basic_machine=$basic_machine-unknown
+		;;
+	c54x)
+		basic_machine=tic54x-unknown
+		;;
+	c55x)
+		basic_machine=tic55x-unknown
+		;;
+	c6x)
+		basic_machine=tic6x-unknown
+		;;
+	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+		;;
+	ms1)
+		basic_machine=mt-unknown
+		;;
+
+	strongarm | thumb | xscale)
+		basic_machine=arm-unknown
+		;;
+	xgate)
+		basic_machine=$basic_machine-unknown
+		os=-none
+		;;
+	xscaleeb)
+		basic_machine=armeb-unknown
+		;;
+
+	xscaleel)
+		basic_machine=armel-unknown
+		;;
+
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+	  basic_machine=$basic_machine-pc
+	  ;;
+	# Object if more than one company name word.
+	*-*-*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+	# Recognize the basic CPU types with company name.
+	580-* \
+	| a29k-* \
+	| aarch64-* | aarch64_be-* \
+	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
+	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
+	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
+	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
+	| avr-* | avr32-* \
+	| be32-* | be64-* \
+	| bfin-* | bs2000-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* \
+	| c8051-* | clipper-* | craynv-* | cydra-* \
+	| d10v-* | d30v-* | dlx-* \
+	| elxsi-* \
+	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
+	| h8300-* | h8500-* \
+	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
+	| hexagon-* \
+	| i*86-* | i860-* | i960-* | ia64-* \
+	| ip2k-* | iq2000-* \
+	| k1om-* \
+	| le32-* | le64-* \
+	| lm32-* \
+	| m32c-* | m32r-* | m32rle-* \
+	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
+	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
+	| mips16-* \
+	| mips64-* | mips64el-* \
+	| mips64octeon-* | mips64octeonel-* \
+	| mips64orion-* | mips64orionel-* \
+	| mips64r5900-* | mips64r5900el-* \
+	| mips64vr-* | mips64vrel-* \
+	| mips64vr4100-* | mips64vr4100el-* \
+	| mips64vr4300-* | mips64vr4300el-* \
+	| mips64vr5000-* | mips64vr5000el-* \
+	| mips64vr5900-* | mips64vr5900el-* \
+	| mipsisa32-* | mipsisa32el-* \
+	| mipsisa32r2-* | mipsisa32r2el-* \
+	| mipsisa32r6-* | mipsisa32r6el-* \
+	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
+	| mipsisa64r6-* | mipsisa64r6el-* \
+	| mipsisa64sb1-* | mipsisa64sb1el-* \
+	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
+	| mipsr5900-* | mipsr5900el-* \
+	| mipstx39-* | mipstx39el-* \
+	| mmix-* \
+	| mt-* \
+	| msp430-* \
+	| nds32-* | nds32le-* | nds32be-* \
+	| nios-* | nios2-* | nios2eb-* | nios2el-* \
+	| none-* | np1-* | ns16k-* | ns32k-* \
+	| open8-* \
+	| or1k*-* \
+	| orion-* \
+	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
+	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
+	| pyramid-* \
+	| rl78-* | romp-* | rs6000-* | rx-* \
+	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
+	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
+	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
+	| sparclite-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| tahoe-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tile*-* \
+	| tron-* \
+	| ubicom32-* \
+	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
+	| vax-* \
+	| we32k-* \
+	| x86-* | x86_64-* | xc16x-* | xps100-* \
+	| xstormy16-* | xtensa*-* \
+	| ymp-* \
+	| z8k-* | z80-*)
+		;;
+	# Recognize the basic CPU types without company name, with glob match.
+	xtensa*)
+		basic_machine=$basic_machine-unknown
+		;;
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	386bsd)
+		basic_machine=i386-unknown
+		os=-bsd
+		;;
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		basic_machine=m68000-att
+		;;
+	3b*)
+		basic_machine=we32k-att
+		;;
+	a29khif)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	abacus)
+		basic_machine=abacus-unknown
+		;;
+	adobe68k)
+		basic_machine=m68010-adobe
+		os=-scout
+		;;
+	alliant | fx80)
+		basic_machine=fx80-alliant
+		;;
+	altos | altos3068)
+		basic_machine=m68k-altos
+		;;
+	am29k)
+		basic_machine=a29k-none
+		os=-bsd
+		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
+	amd64-*)
+		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	amdahl)
+		basic_machine=580-amdahl
+		os=-sysv
+		;;
+	amiga | amiga-*)
+		basic_machine=m68k-unknown
+		;;
+	amigaos | amigados)
+		basic_machine=m68k-unknown
+		os=-amigaos
+		;;
+	amigaunix | amix)
+		basic_machine=m68k-unknown
+		os=-sysv4
+		;;
+	apollo68)
+		basic_machine=m68k-apollo
+		os=-sysv
+		;;
+	apollo68bsd)
+		basic_machine=m68k-apollo
+		os=-bsd
+		;;
+	aros)
+		basic_machine=i386-pc
+		os=-aros
+		;;
+	aux)
+		basic_machine=m68k-apple
+		os=-aux
+		;;
+	balance)
+		basic_machine=ns32k-sequent
+		os=-dynix
+		;;
+	blackfin)
+		basic_machine=bfin-unknown
+		os=-linux
+		;;
+	blackfin-*)
+		basic_machine=bfin-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	bluegene*)
+		basic_machine=powerpc-ibm
+		os=-cnk
+		;;
+	c54x-*)
+		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c55x-*)
+		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c6x-*)
+		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	c90)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
+	cegcc)
+		basic_machine=arm-unknown
+		os=-cegcc
+		;;
+	convex-c1)
+		basic_machine=c1-convex
+		os=-bsd
+		;;
+	convex-c2)
+		basic_machine=c2-convex
+		os=-bsd
+		;;
+	convex-c32)
+		basic_machine=c32-convex
+		os=-bsd
+		;;
+	convex-c34)
+		basic_machine=c34-convex
+		os=-bsd
+		;;
+	convex-c38)
+		basic_machine=c38-convex
+		os=-bsd
+		;;
+	cray | j90)
+		basic_machine=j90-cray
+		os=-unicos
+		;;
+	craynv)
+		basic_machine=craynv-cray
+		os=-unicosmp
+		;;
+	cr16 | cr16-*)
+		basic_machine=cr16-unknown
+		os=-elf
+		;;
+	crds | unos)
+		basic_machine=m68k-crds
+		;;
+	crisv32 | crisv32-* | etraxfs*)
+		basic_machine=crisv32-axis
+		;;
+	cris | cris-* | etrax*)
+		basic_machine=cris-axis
+		;;
+	crx)
+		basic_machine=crx-unknown
+		os=-elf
+		;;
+	da30 | da30-*)
+		basic_machine=m68k-da30
+		;;
+	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
+		basic_machine=mips-dec
+		;;
+	decsystem10* | dec10*)
+		basic_machine=pdp10-dec
+		os=-tops10
+		;;
+	decsystem20* | dec20*)
+		basic_machine=pdp10-dec
+		os=-tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		basic_machine=m68k-motorola
+		;;
+	delta88)
+		basic_machine=m88k-motorola
+		os=-sysv3
+		;;
+	dicos)
+		basic_machine=i686-pc
+		os=-dicos
+		;;
+	djgpp)
+		basic_machine=i586-pc
+		os=-msdosdjgpp
+		;;
+	dpx20 | dpx20-*)
+		basic_machine=rs6000-bull
+		os=-bosx
+		;;
+	dpx2* | dpx2*-bull)
+		basic_machine=m68k-bull
+		os=-sysv3
+		;;
+	ebmon29k)
+		basic_machine=a29k-amd
+		os=-ebmon
+		;;
+	elxsi)
+		basic_machine=elxsi-elxsi
+		os=-bsd
+		;;
+	encore | umax | mmax)
+		basic_machine=ns32k-encore
+		;;
+	es1800 | OSE68k | ose68k | ose | OSE)
+		basic_machine=m68k-ericsson
+		os=-ose
+		;;
+	fx2800)
+		basic_machine=i860-alliant
+		;;
+	genix)
+		basic_machine=ns32k-ns
+		;;
+	gmicro)
+		basic_machine=tron-gmicro
+		os=-sysv
+		;;
+	go32)
+		basic_machine=i386-pc
+		os=-go32
+		;;
+	h3050r* | hiux*)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	h8300hms)
+		basic_machine=h8300-hitachi
+		os=-hms
+		;;
+	h8300xray)
+		basic_machine=h8300-hitachi
+		os=-xray
+		;;
+	h8500hms)
+		basic_machine=h8500-hitachi
+		os=-hms
+		;;
+	harris)
+		basic_machine=m88k-harris
+		os=-sysv3
+		;;
+	hp300-*)
+		basic_machine=m68k-hp
+		;;
+	hp300bsd)
+		basic_machine=m68k-hp
+		os=-bsd
+		;;
+	hp300hpux)
+		basic_machine=m68k-hp
+		os=-hpux
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		basic_machine=m68000-hp
+		;;
+	hp9k3[2-9][0-9])
+		basic_machine=m68k-hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		basic_machine=hppa1.1-hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		basic_machine=hppa1.0-hp
+		;;
+	hppa-next)
+		os=-nextstep3
+		;;
+	hppaosf)
+		basic_machine=hppa1.1-hp
+		os=-osf
+		;;
+	hppro)
+		basic_machine=hppa1.1-hp
+		os=-proelf
+		;;
+	i370-ibm* | ibm*)
+		basic_machine=i370-ibm
+		;;
+	i*86v32)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv32
+		;;
+	i*86v4*)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv4
+		;;
+	i*86v)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-sysv
+		;;
+	i*86sol2)
+		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
+		os=-solaris2
+		;;
+	i386mach)
+		basic_machine=i386-mach
+		os=-mach
+		;;
+	i386-vsta | vsta)
+		basic_machine=i386-unknown
+		os=-vsta
+		;;
+	iris | iris4d)
+		basic_machine=mips-sgi
+		case $os in
+		    -irix*)
+			;;
+		    *)
+			os=-irix4
+			;;
+		esac
+		;;
+	isi68 | isi)
+		basic_machine=m68k-isi
+		os=-sysv
+		;;
+	m68knommu)
+		basic_machine=m68k-unknown
+		os=-linux
+		;;
+	m68knommu-*)
+		basic_machine=m68k-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	m88k-omron*)
+		basic_machine=m88k-omron
+		;;
+	magnum | m3230)
+		basic_machine=mips-mips
+		os=-sysv
+		;;
+	merlin)
+		basic_machine=ns32k-utek
+		os=-sysv
+		;;
+	microblaze*)
+		basic_machine=microblaze-xilinx
+		;;
+	mingw64)
+		basic_machine=x86_64-pc
+		os=-mingw64
+		;;
+	mingw32)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	mingw32ce)
+		basic_machine=arm-unknown
+		os=-mingw32ce
+		;;
+	miniframe)
+		basic_machine=m68000-convergent
+		;;
+	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		basic_machine=m68k-atari
+		os=-mint
+		;;
+	mips3*-*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
+		;;
+	mips3*)
+		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
+		;;
+	monitor)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	morphos)
+		basic_machine=powerpc-unknown
+		os=-morphos
+		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
+	msdos)
+		basic_machine=i386-pc
+		os=-msdos
+		;;
+	ms1-*)
+		basic_machine=`echo $basic_machine | sed -e 's/ms1-/mt-/'`
+		;;
+	msys)
+		basic_machine=i686-pc
+		os=-msys
+		;;
+	mvs)
+		basic_machine=i370-ibm
+		os=-mvs
+		;;
+	nacl)
+		basic_machine=le32-unknown
+		os=-nacl
+		;;
+	ncr3000)
+		basic_machine=i486-ncr
+		os=-sysv4
+		;;
+	netbsd386)
+		basic_machine=i386-unknown
+		os=-netbsd
+		;;
+	netwinder)
+		basic_machine=armv4l-rebel
+		os=-linux
+		;;
+	news | news700 | news800 | news900)
+		basic_machine=m68k-sony
+		os=-newsos
+		;;
+	news1000)
+		basic_machine=m68030-sony
+		os=-newsos
+		;;
+	news-3600 | risc-news)
+		basic_machine=mips-sony
+		os=-newsos
+		;;
+	necv70)
+		basic_machine=v70-nec
+		os=-sysv
+		;;
+	next | m*-next )
+		basic_machine=m68k-next
+		case $os in
+		    -nextstep* )
+			;;
+		    -ns2*)
+		      os=-nextstep2
+			;;
+		    *)
+		      os=-nextstep3
+			;;
+		esac
+		;;
+	nh3000)
+		basic_machine=m68k-harris
+		os=-cxux
+		;;
+	nh[45]000)
+		basic_machine=m88k-harris
+		os=-cxux
+		;;
+	nindy960)
+		basic_machine=i960-intel
+		os=-nindy
+		;;
+	mon960)
+		basic_machine=i960-intel
+		os=-mon960
+		;;
+	nonstopux)
+		basic_machine=mips-compaq
+		os=-nonstopux
+		;;
+	np1)
+		basic_machine=np1-gould
+		;;
+	neo-tandem)
+		basic_machine=neo-tandem
+		;;
+	nse-tandem)
+		basic_machine=nse-tandem
+		;;
+	nsr-tandem)
+		basic_machine=nsr-tandem
+		;;
+	op50n-* | op60c-*)
+		basic_machine=hppa1.1-oki
+		os=-proelf
+		;;
+	openrisc | openrisc-*)
+		basic_machine=or32-unknown
+		;;
+	os400)
+		basic_machine=powerpc-ibm
+		os=-os400
+		;;
+	OSE68000 | ose68000)
+		basic_machine=m68000-ericsson
+		os=-ose
+		;;
+	os68k)
+		basic_machine=m68k-none
+		os=-os68k
+		;;
+	pa-hitachi)
+		basic_machine=hppa1.1-hitachi
+		os=-hiuxwe2
+		;;
+	paragon)
+		basic_machine=i860-intel
+		os=-osf
+		;;
+	parisc)
+		basic_machine=hppa-unknown
+		os=-linux
+		;;
+	parisc-*)
+		basic_machine=hppa-`echo $basic_machine | sed 's/^[^-]*-//'`
+		os=-linux
+		;;
+	pbd)
+		basic_machine=sparc-tti
+		;;
+	pbb)
+		basic_machine=m68k-tti
+		;;
+	pc532 | pc532-*)
+		basic_machine=ns32k-pc532
+		;;
+	pc98)
+		basic_machine=i386-pc
+		;;
+	pc98-*)
+		basic_machine=i386-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium | p5 | k5 | k6 | nexgen | viac3)
+		basic_machine=i586-pc
+		;;
+	pentiumpro | p6 | 6x86 | athlon | athlon_*)
+		basic_machine=i686-pc
+		;;
+	pentiumii | pentium2 | pentiumiii | pentium3)
+		basic_machine=i686-pc
+		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	pn)
+		basic_machine=pn-gould
+		;;
+	power)	basic_machine=power-ibm
+		;;
+	ppc | ppcbe)	basic_machine=powerpc-unknown
+		;;
+	ppc-* | ppcbe-*)
+		basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppcle | powerpclittle | ppc-le | powerpc-little)
+		basic_machine=powerpcle-unknown
+		;;
+	ppcle-* | powerpclittle-*)
+		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64)	basic_machine=powerpc64-unknown
+		;;
+	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
+		basic_machine=powerpc64le-unknown
+		;;
+	ppc64le-* | powerpc64little-*)
+		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	ps2)
+		basic_machine=i386-ibm
+		;;
+	pw32)
+		basic_machine=i586-unknown
+		os=-pw32
+		;;
+	rdos | rdos64)
+		basic_machine=x86_64-pc
+		os=-rdos
+		;;
+	rdos32)
+		basic_machine=i386-pc
+		os=-rdos
+		;;
+	rom68k)
+		basic_machine=m68k-rom68k
+		os=-coff
+		;;
+	rm[46]00)
+		basic_machine=mips-siemens
+		;;
+	rtpc | rtpc-*)
+		basic_machine=romp-ibm
+		;;
+	s390 | s390-*)
+		basic_machine=s390-ibm
+		;;
+	s390x | s390x-*)
+		basic_machine=s390x-ibm
+		;;
+	sa29200)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	sb1)
+		basic_machine=mipsisa64sb1-unknown
+		;;
+	sb1el)
+		basic_machine=mipsisa64sb1el-unknown
+		;;
+	sde)
+		basic_machine=mipsisa32-sde
+		os=-elf
+		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
+	sequent)
+		basic_machine=i386-sequent
+		;;
+	sh)
+		basic_machine=sh-hitachi
+		os=-hms
+		;;
+	sh5el)
+		basic_machine=sh5le-unknown
+		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
+	sparclite-wrs | simso-wrs)
+		basic_machine=sparclite-wrs
+		os=-vxworks
+		;;
+	sps7)
+		basic_machine=m68k-bull
+		os=-sysv2
+		;;
+	spur)
+		basic_machine=spur-unknown
+		;;
+	st2000)
+		basic_machine=m68k-tandem
+		;;
+	stratus)
+		basic_machine=i860-stratus
+		os=-sysv4
+		;;
+	strongarm-* | thumb-*)
+		basic_machine=arm-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
+	sun2)
+		basic_machine=m68000-sun
+		;;
+	sun2os3)
+		basic_machine=m68000-sun
+		os=-sunos3
+		;;
+	sun2os4)
+		basic_machine=m68000-sun
+		os=-sunos4
+		;;
+	sun3os3)
+		basic_machine=m68k-sun
+		os=-sunos3
+		;;
+	sun3os4)
+		basic_machine=m68k-sun
+		os=-sunos4
+		;;
+	sun4os3)
+		basic_machine=sparc-sun
+		os=-sunos3
+		;;
+	sun4os4)
+		basic_machine=sparc-sun
+		os=-sunos4
+		;;
+	sun4sol2)
+		basic_machine=sparc-sun
+		os=-solaris2
+		;;
+	sun3 | sun3-*)
+		basic_machine=m68k-sun
+		;;
+	sun4)
+		basic_machine=sparc-sun
+		;;
+	sun386 | sun386i | roadrunner)
+		basic_machine=i386-sun
+		;;
+	sv1)
+		basic_machine=sv1-cray
+		os=-unicos
+		;;
+	symmetry)
+		basic_machine=i386-sequent
+		os=-dynix
+		;;
+	t3e)
+		basic_machine=alphaev5-cray
+		os=-unicos
+		;;
+	t90)
+		basic_machine=t90-cray
+		os=-unicos
+		;;
+	tile*)
+		basic_machine=$basic_machine-unknown
+		os=-linux-gnu
+		;;
+	tx39)
+		basic_machine=mipstx39-unknown
+		;;
+	tx39el)
+		basic_machine=mipstx39el-unknown
+		;;
+	toad1)
+		basic_machine=pdp10-xkl
+		os=-tops20
+		;;
+	tower | tower-32)
+		basic_machine=m68k-ncr
+		;;
+	tpf)
+		basic_machine=s390x-ibm
+		os=-tpf
+		;;
+	udi29k)
+		basic_machine=a29k-amd
+		os=-udi
+		;;
+	ultra3)
+		basic_machine=a29k-nyu
+		os=-sym1
+		;;
+	v810 | necv810)
+		basic_machine=v810-nec
+		os=-none
+		;;
+	vaxv)
+		basic_machine=vax-dec
+		os=-sysv
+		;;
+	vms)
+		basic_machine=vax-dec
+		os=-vms
+		;;
+	vpp*|vx|vx-*)
+		basic_machine=f301-fujitsu
+		;;
+	vxworks960)
+		basic_machine=i960-wrs
+		os=-vxworks
+		;;
+	vxworks68)
+		basic_machine=m68k-wrs
+		os=-vxworks
+		;;
+	vxworks29k)
+		basic_machine=a29k-wrs
+		os=-vxworks
+		;;
+	w65*)
+		basic_machine=w65-wdc
+		os=-none
+		;;
+	w89k-*)
+		basic_machine=hppa1.1-winbond
+		os=-proelf
+		;;
+	xbox)
+		basic_machine=i686-pc
+		os=-mingw32
+		;;
+	xps | xps100)
+		basic_machine=xps100-honeywell
+		;;
+	xscale-* | xscalee[bl]-*)
+		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
+		;;
+	ymp)
+		basic_machine=ymp-cray
+		os=-unicos
+		;;
+	z8k-*-coff)
+		basic_machine=z8k-unknown
+		os=-sim
+		;;
+	z80-*-coff)
+		basic_machine=z80-unknown
+		os=-sim
+		;;
+	none)
+		basic_machine=none-none
+		os=-none
+		;;
+
+# Here we handle the default manufacturer of certain CPU types.  It is in
+# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		basic_machine=hppa1.1-winbond
+		;;
+	op50n)
+		basic_machine=hppa1.1-oki
+		;;
+	op60c)
+		basic_machine=hppa1.1-oki
+		;;
+	romp)
+		basic_machine=romp-ibm
+		;;
+	mmix)
+		basic_machine=mmix-knuth
+		;;
+	rs6000)
+		basic_machine=rs6000-ibm
+		;;
+	vax)
+		basic_machine=vax-dec
+		;;
+	pdp10)
+		# there are many clones, so DEC is not a safe bet
+		basic_machine=pdp10-unknown
+		;;
+	pdp11)
+		basic_machine=pdp11-dec
+		;;
+	we32k)
+		basic_machine=we32k-att
+		;;
+	sh[1234] | sh[24]a | sh[24]aeb | sh[34]eb | sh[1234]le | sh[23]ele)
+		basic_machine=sh-unknown
+		;;
+	sparc | sparcv8 | sparcv9 | sparcv9b | sparcv9v)
+		basic_machine=sparc-sun
+		;;
+	cydra)
+		basic_machine=cydra-cydrome
+		;;
+	orion)
+		basic_machine=orion-highlevel
+		;;
+	orion105)
+		basic_machine=clipper-highlevel
+		;;
+	mac | mpw | mac-mpw)
+		basic_machine=m68k-apple
+		;;
+	pmac | pmac-mpw)
+		basic_machine=powerpc-apple
+		;;
+	*-unknown)
+		# Make sure to match an already-canonicalized machine name.
+		;;
+	*)
+		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $basic_machine in
+	*-digital*)
+		basic_machine=`echo $basic_machine | sed 's/digital.*/dec/'`
+		;;
+	*-commodore*)
+		basic_machine=`echo $basic_machine | sed 's/commodore.*/cbm/'`
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x"$os" != x"" ]
+then
+case $os in
+	# First match some system type aliases
+	# that might get confused with valid system types.
+	# -solaris* is a basic system type, with this one exception.
+	-auroraux)
+		os=-auroraux
+		;;
+	-solaris1 | -solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	-solaris)
+		os=-solaris2
+		;;
+	-svr4*)
+		os=-sysv4
+		;;
+	-unixware*)
+		os=-sysv4.2uw
+		;;
+	-gnu/linux*)
+		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
+		;;
+	# First accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST END IN A *, to match a version number.
+	# -sysv* is not here because it comes later, after sysvr4.
+	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
+	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
+	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
+	      | -sym* | -kopensolaris* | -plan9* \
+	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
+	      | -aos* | -aros* \
+	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
+	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
+	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
+	      | -bitrig* | -openbsd* | -solidbsd* \
+	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
+	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
+	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
+	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
+	      | -chorusos* | -chorusrdb* | -cegcc* \
+	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
+	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
+	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
+	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
+	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
+	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
+	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
+	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
+	      | -skyos* | -haiku* | -rdos* | -toppers* | -drops* | -es* | -tirtos*)
+	# Remember, each alternative MUST END IN *, to match a version number.
+		;;
+	-qnx*)
+		case $basic_machine in
+		    x86-* | i*86-*)
+			;;
+		    *)
+			os=-nto$os
+			;;
+		esac
+		;;
+	-nto-qnx*)
+		;;
+	-nto*)
+		os=`echo $os | sed -e 's|nto|nto-qnx|'`
+		;;
+	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
+	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+		;;
+	-mac*)
+		os=`echo $os | sed -e 's|mac|macos|'`
+		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
+	-linux*)
+		os=`echo $os | sed -e 's|linux|linux-gnu|'`
+		;;
+	-sunos5*)
+		os=`echo $os | sed -e 's|sunos5|solaris2|'`
+		;;
+	-sunos6*)
+		os=`echo $os | sed -e 's|sunos6|solaris3|'`
+		;;
+	-opened*)
+		os=-openedition
+		;;
+	-os400*)
+		os=-os400
+		;;
+	-wince*)
+		os=-wince
+		;;
+	-osfrose*)
+		os=-osfrose
+		;;
+	-osf*)
+		os=-osf
+		;;
+	-utek*)
+		os=-bsd
+		;;
+	-dynix*)
+		os=-bsd
+		;;
+	-acis*)
+		os=-aos
+		;;
+	-atheos*)
+		os=-atheos
+		;;
+	-syllable*)
+		os=-syllable
+		;;
+	-386bsd)
+		os=-bsd
+		;;
+	-ctix* | -uts*)
+		os=-sysv
+		;;
+	-nova*)
+		os=-rtmk-nova
+		;;
+	-ns2 )
+		os=-nextstep2
+		;;
+	-nsk*)
+		os=-nsk
+		;;
+	# Preserve the version number of sinix5.
+	-sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	-sinix*)
+		os=-sysv4
+		;;
+	-tpf*)
+		os=-tpf
+		;;
+	-triton*)
+		os=-sysv3
+		;;
+	-oss*)
+		os=-sysv3
+		;;
+	-svr4)
+		os=-sysv4
+		;;
+	-svr3)
+		os=-sysv3
+		;;
+	-sysvr4)
+		os=-sysv4
+		;;
+	# This must come after -sysvr4.
+	-sysv*)
+		;;
+	-ose*)
+		os=-ose
+		;;
+	-es1800*)
+		os=-ose
+		;;
+	-xenix)
+		os=-xenix
+		;;
+	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+		os=-mint
+		;;
+	-aros*)
+		os=-aros
+		;;
+	-zvmoe)
+		os=-zvmoe
+		;;
+	-dicos*)
+		os=-dicos
+		;;
+	-nacl*)
+		;;
+	-none)
+		;;
+	*)
+		# Get rid of the `-' at the beginning of $os.
+		os=`echo $os | sed 's/[^-]*-//'`
+		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
+		exit 1
+		;;
+esac
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+case $basic_machine in
+	score-*)
+		os=-elf
+		;;
+	spu-*)
+		os=-elf
+		;;
+	*-acorn)
+		os=-riscix1.2
+		;;
+	arm*-rebel)
+		os=-linux
+		;;
+	arm*-semi)
+		os=-aout
+		;;
+	c4x-* | tic4x-*)
+		os=-coff
+		;;
+	c8051-*)
+		os=-elf
+		;;
+	hexagon-*)
+		os=-elf
+		;;
+	tic54x-*)
+		os=-coff
+		;;
+	tic55x-*)
+		os=-coff
+		;;
+	tic6x-*)
+		os=-coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=-tops20
+		;;
+	pdp11-*)
+		os=-none
+		;;
+	*-dec | vax-*)
+		os=-ultrix4.2
+		;;
+	m68*-apollo)
+		os=-domain
+		;;
+	i386-sun)
+		os=-sunos4.0.2
+		;;
+	m68000-sun)
+		os=-sunos3
+		;;
+	m68*-cisco)
+		os=-aout
+		;;
+	mep-*)
+		os=-elf
+		;;
+	mips*-cisco)
+		os=-elf
+		;;
+	mips*-*)
+		os=-elf
+		;;
+	or32-*)
+		os=-coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=-sysv3
+		;;
+	sparc-* | *-sun)
+		os=-sunos4.1.1
+		;;
+	*-be)
+		os=-beos
+		;;
+	*-haiku)
+		os=-haiku
+		;;
+	*-ibm)
+		os=-aix
+		;;
+	*-knuth)
+		os=-mmixware
+		;;
+	*-wec)
+		os=-proelf
+		;;
+	*-winbond)
+		os=-proelf
+		;;
+	*-oki)
+		os=-proelf
+		;;
+	*-hp)
+		os=-hpux
+		;;
+	*-hitachi)
+		os=-hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=-sysv
+		;;
+	*-cbm)
+		os=-amigaos
+		;;
+	*-dg)
+		os=-dgux
+		;;
+	*-dolphin)
+		os=-sysv3
+		;;
+	m68k-ccur)
+		os=-rtu
+		;;
+	m88k-omron*)
+		os=-luna
+		;;
+	*-next )
+		os=-nextstep
+		;;
+	*-sequent)
+		os=-ptx
+		;;
+	*-crds)
+		os=-unos
+		;;
+	*-ns)
+		os=-genix
+		;;
+	i370-*)
+		os=-mvs
+		;;
+	*-next)
+		os=-nextstep3
+		;;
+	*-gould)
+		os=-sysv
+		;;
+	*-highlevel)
+		os=-bsd
+		;;
+	*-encore)
+		os=-bsd
+		;;
+	*-sgi)
+		os=-irix
+		;;
+	*-siemens)
+		os=-sysv4
+		;;
+	*-masscomp)
+		os=-rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=-uxpv
+		;;
+	*-rom68k)
+		os=-coff
+		;;
+	*-*bug)
+		os=-coff
+		;;
+	*-apple)
+		os=-macos
+		;;
+	*-atari*)
+		os=-mint
+		;;
+	*)
+		os=-none
+		;;
+esac
+fi
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+vendor=unknown
+case $basic_machine in
+	*-unknown)
+		case $os in
+			-riscix*)
+				vendor=acorn
+				;;
+			-sunos*)
+				vendor=sun
+				;;
+			-cnk*|-aix*)
+				vendor=ibm
+				;;
+			-beos*)
+				vendor=be
+				;;
+			-hpux*)
+				vendor=hp
+				;;
+			-mpeix*)
+				vendor=hp
+				;;
+			-hiux*)
+				vendor=hitachi
+				;;
+			-unos*)
+				vendor=crds
+				;;
+			-dgux*)
+				vendor=dg
+				;;
+			-luna*)
+				vendor=omron
+				;;
+			-genix*)
+				vendor=ns
+				;;
+			-mvs* | -opened*)
+				vendor=ibm
+				;;
+			-os400*)
+				vendor=ibm
+				;;
+			-ptx*)
+				vendor=sequent
+				;;
+			-tpf*)
+				vendor=ibm
+				;;
+			-vxsim* | -vxworks* | -windiss*)
+				vendor=wrs
+				;;
+			-aux*)
+				vendor=apple
+				;;
+			-hms*)
+				vendor=hitachi
+				;;
+			-mpw* | -macos*)
+				vendor=apple
+				;;
+			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
+				vendor=atari
+				;;
+			-vos*)
+				vendor=stratus
+				;;
+		esac
+		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
+		;;
+esac
+
+echo $basic_machine$os
+exit
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff --git a/release/src/router/libev-4.22/configure b/release/src/router/libev-4.22/configure
new file mode 100755
index 0000000000..aa114ac64b
--- /dev/null
+++ b/release/src/router/libev-4.22/configure
@@ -0,0 +1,14121 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.69.
+#
+#
+# Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+# Use a proper internal environment variable to ensure we don't fall
+  # into an infinite loop, continuously re-executing ourselves.
+  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
+    _as_can_reexec=no; export _as_can_reexec;
+    # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+as_fn_exit 255
+  fi
+  # We don't want this to propagate to other subprocesses.
+          { _as_can_reexec=; unset _as_can_reexec;}
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1
+test -x / || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
+
+  test -n \"\${ZSH_VERSION+set}\${BASH_VERSION+set}\" || (
+    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    ECHO=\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO\$ECHO
+    PATH=/empty FPATH=/empty; export PATH FPATH
+    test \"X\`printf %s \$ECHO\`\" = \"X\$ECHO\" \\
+      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1
+test \$(( 1 + 1 )) = 2 || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  export CONFIG_SHELL
+             # We cannot yet assume a decent shell, so we have to provide a
+# neutralization value for shells without unset; and this also
+# works around shells that cannot unset nonexistent variables.
+# Preserve -v and -x to the replacement shell.
+BASH_ENV=/dev/null
+ENV=/dev/null
+(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+case $- in # ((((
+  *v*x* | *x*v* ) as_opts=-vx ;;
+  *v* ) as_opts=-v ;;
+  *x* ) as_opts=-x ;;
+  * ) as_opts= ;;
+esac
+exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
+# Admittedly, this is quite paranoid, since all the known shells bail
+# out after a failed `exec'.
+$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
+exit 255
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
+  # already done that, so ensure we don't try to do so again and fall
+  # in an infinite loop.  This has already happened in practice.
+  _as_can_reexec=no; export _as_can_reexec
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+SHELL=${CONFIG_SHELL-/bin/sh}
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME=
+PACKAGE_TARNAME=
+PACKAGE_VERSION=
+PACKAGE_STRING=
+PACKAGE_BUGREPORT=
+PACKAGE_URL=
+
+ac_unique_file="ev_epoll.c"
+# Factoring default headers for most tests.
+ac_includes_default="\
+#include <stdio.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif"
+
+ac_subst_vars='am__EXEEXT_FALSE
+am__EXEEXT_TRUE
+LTLIBOBJS
+LIBOBJS
+CPP
+OTOOL64
+OTOOL
+LIPO
+NMEDIT
+DSYMUTIL
+MANIFEST_TOOL
+RANLIB
+ac_ct_AR
+AR
+DLLTOOL
+OBJDUMP
+LN_S
+NM
+ac_ct_DUMPBIN
+DUMPBIN
+LD
+FGREP
+EGREP
+GREP
+SED
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+LIBTOOL
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+am__nodep
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+OBJEXT
+EXEEXT
+ac_ct_CC
+CPPFLAGS
+LDFLAGS
+CFLAGS
+CC
+MAINT
+MAINTAINER_MODE_FALSE
+MAINTAINER_MODE_TRUE
+AM_BACKSLASH
+AM_DEFAULT_VERBOSITY
+AM_DEFAULT_V
+AM_V
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_silent_rules
+enable_maintainer_mode
+enable_dependency_tracking
+enable_shared
+enable_static
+with_pic
+enable_fast_install
+with_gnu_ld
+with_sysroot
+enable_libtool_lock
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CC
+CFLAGS
+LDFLAGS
+LIBS
+CPPFLAGS
+CPP'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures this package to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/PACKAGE]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-silent-rules   less verbose build output (undo: "make V=1")
+  --disable-silent-rules  verbose build output (undo: "make V=0")
+  --enable-maintainer-mode
+                          enable make rules and dependencies not useful (and
+                          sometimes confusing) to the casual installer
+  --enable-dependency-tracking
+                          do not reject slow dependency extractors
+  --disable-dependency-tracking
+                          speeds up one-time build
+  --enable-shared[=PKGS]  build shared libraries [default=yes]
+  --enable-static[=PKGS]  build static libraries [default=yes]
+  --enable-fast-install[=PKGS]
+                          optimize for fast installation [default=yes]
+  --disable-libtool-lock  avoid locking (might break parallel builds)
+
+Optional Packages:
+  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
+  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
+  --with-pic[=PKGS]       try to use only PIC/non-PIC objects [default=use
+                          both]
+  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
+  --with-sysroot=DIR Search for dependent libraries within DIR
+                        (or the compiler's sysroot if not specified).
+
+Some influential environment variables:
+  CC          C compiler command
+  CFLAGS      C compiler flags
+  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
+              nonstandard directory <lib dir>
+  LIBS        libraries to pass to the linker, e.g. -l<library>
+  CPPFLAGS    (Objective) C/C++ preprocessor flags, e.g. -I<include dir> if
+              you have headers in a nonstandard directory <include dir>
+  CPP         C preprocessor
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+configure
+generated by GNU Autoconf 2.69
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+
+# ac_fn_c_try_link LINENO
+# -----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_link ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext conftest$ac_exeext
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest$ac_exeext && {
+	 test "$cross_compiling" = yes ||
+	 test -x conftest$ac_exeext
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  # Delete the IPA/IPO (Inter Procedural Analysis/Optimization) information
+  # created by the PGI compiler (conftest_ipa8_conftest.oo), as it would
+  # interfere with the next link command; also delete a directory that is
+  # left behind by Apple's compiler.  We do this before executing the actions.
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_link
+
+# ac_fn_c_check_header_compile LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists and can be compiled using the include files in
+# INCLUDES, setting the cache variable VAR accordingly.
+ac_fn_c_check_header_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_header_compile
+
+# ac_fn_c_try_cpp LINENO
+# ----------------------
+# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_cpp ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_cpp conftest.$ac_ext"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } > conftest.i && {
+	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+    ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_cpp
+
+# ac_fn_c_try_run LINENO
+# ----------------------
+# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
+# that executables *can* be run.
+ac_fn_c_try_run ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: program exited with status $ac_status" >&5
+       $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+       ac_retval=$ac_status
+fi
+  rm -rf conftest.dSYM conftest_ipa8_conftest.oo
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_run
+
+# ac_fn_c_check_func LINENO FUNC VAR
+# ----------------------------------
+# Tests whether FUNC exists, setting the cache variable VAR accordingly
+ac_fn_c_check_func ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+/* Define $2 to an innocuous variant, in case <limits.h> declares $2.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $2 innocuous_$2
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $2 (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $2
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char $2 ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined __stub_$2 || defined __stub___$2
+choke me
+#endif
+
+int
+main ()
+{
+return $2 ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  eval "$3=yes"
+else
+  eval "$3=no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_func
+
+# ac_fn_c_check_header_mongrel LINENO HEADER VAR INCLUDES
+# -------------------------------------------------------
+# Tests whether HEADER exists, giving a warning if it cannot be compiled using
+# the include files in INCLUDES and setting the cache variable VAR
+# accordingly.
+ac_fn_c_check_header_mongrel ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  if eval \${$3+:} false; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+else
+  # Is the header compilable?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 usability" >&5
+$as_echo_n "checking $2 usability... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+$4
+#include <$2>
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_header_compiler=yes
+else
+  ac_header_compiler=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_compiler" >&5
+$as_echo "$ac_header_compiler" >&6; }
+
+# Is the header present?
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking $2 presence" >&5
+$as_echo_n "checking $2 presence... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <$2>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  ac_header_preproc=yes
+else
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_header_preproc" >&5
+$as_echo "$ac_header_preproc" >&6; }
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in #((
+  yes:no: )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&5
+$as_echo "$as_me: WARNING: $2: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+  no:yes:* )
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: present but cannot be compiled" >&5
+$as_echo "$as_me: WARNING: $2: present but cannot be compiled" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     check for missing prerequisite headers?" >&5
+$as_echo "$as_me: WARNING: $2:     check for missing prerequisite headers?" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: see the Autoconf documentation" >&5
+$as_echo "$as_me: WARNING: $2: see the Autoconf documentation" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&5
+$as_echo "$as_me: WARNING: $2:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $2: proceeding with the compiler's result" >&5
+$as_echo "$as_me: WARNING: $2: proceeding with the compiler's result" >&2;}
+    ;;
+esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $2" >&5
+$as_echo_n "checking for $2... " >&6; }
+if eval \${$3+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  eval "$3=\$ac_header_compiler"
+fi
+eval ac_res=\$$3
+	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
+$as_echo "$ac_res" >&6; }
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+
+} # ac_fn_c_check_header_mongrel
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+orig_CFLAGS="$CFLAGS"
+
+
+
+am__api_version='1.14'
+
+ac_aux_dir=
+for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if ${ac_cv_path_install+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error $? "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
+esac
+
+# Do 'set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$*" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$*" != "X $srcdir/configure conftest.file" \
+	&& test "$*" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment" "$LINENO" 5
+     fi
+     if test "$2" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error $? "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+
+rm -f conftest.file
+
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# Expand $ac_aux_dir to an absolute path.
+am_aux_dir=`cd "$ac_aux_dir" && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --is-lightweight"; then
+  am_missing_run="$MISSING "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the 'STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if ${ac_cv_path_mkdir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext" || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  test -d ./--version && rmdir ./--version
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AWK+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+# Check whether --enable-silent-rules was given.
+if test "${enable_silent_rules+set}" = set; then :
+  enableval=$enable_silent_rules;
+fi
+
+case $enable_silent_rules in # (((
+  yes) AM_DEFAULT_VERBOSITY=0;;
+   no) AM_DEFAULT_VERBOSITY=1;;
+    *) AM_DEFAULT_VERBOSITY=1;;
+esac
+am_make=${MAKE-make}
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $am_make supports nested variables" >&5
+$as_echo_n "checking whether $am_make supports nested variables... " >&6; }
+if ${am_cv_make_support_nested_variables+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if $as_echo 'TRUE=$(BAR$(V))
+BAR0=false
+BAR1=true
+V=1
+am__doit:
+	@$(TRUE)
+.PHONY: am__doit' | $am_make -f - >/dev/null 2>&1; then
+  am_cv_make_support_nested_variables=yes
+else
+  am_cv_make_support_nested_variables=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_make_support_nested_variables" >&5
+$as_echo "$am_cv_make_support_nested_variables" >&6; }
+if test $am_cv_make_support_nested_variables = yes; then
+    AM_V='$(V)'
+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
+else
+  AM_V=$AM_DEFAULT_VERBOSITY
+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY
+fi
+AM_BACKSLASH='\'
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+
+ PACKAGE=libev
+ VERSION=4.22
+
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE "$PACKAGE"
+_ACEOF
+
+
+cat >>confdefs.h <<_ACEOF
+#define VERSION "$VERSION"
+_ACEOF
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# For better backward compatibility.  To be removed once Automake 1.9.x
+# dies out for good.  For more background, see:
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>
+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>
+mkdir_p='$(MKDIR_P)'
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AMTAR='$${TAR-tar}'
+
+
+# We'll loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar  pax cpio none'
+
+am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
+
+
+
+
+
+
+# POSIX will say in a future version that running "rm -f" with no argument
+# is OK; and we want to be able to make that assumption in our Makefile
+# recipes.  So use an aggressive probe to check that the usage we want is
+# actually supported "in the wild" to an acceptable degree.
+# See automake bug#10828.
+# To make any issue more visible, cause the running configure to be aborted
+# by default if the 'rm' program in use doesn't match our expectations; the
+# user can still override this though.
+if rm -f && rm -fr && rm -rf; then : OK; else
+  cat >&2 <<'END'
+Oops!
+
+Your 'rm' program seems unable to run without file operands specified
+on the command line, even when the '-f' option is present.  This is contrary
+to the behaviour of most rm programs out there, and not conforming with
+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>
+
+Please tell bug-automake@gnu.org about your system, including the value
+of your $PATH and any error possibly output before this message.  This
+can help us improve future automake versions.
+
+END
+  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
+    echo 'Configuration will proceed anyway, since you have set the' >&2
+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to "yes"' >&2
+    echo >&2
+  else
+    cat >&2 <<'END'
+Aborting the configuration process, to ensure you take notice of the issue.
+
+You can download and install GNU coreutils to get an 'rm' implementation
+that behaves properly: <http://www.gnu.org/software/coreutils/>.
+
+If you want to complete the configuration process using your problematic
+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
+to "yes", and re-run configure.
+
+END
+    as_fn_error $? "Your 'rm' program is bad, sorry." "$LINENO" 5
+  fi
+fi
+
+ac_config_headers="$ac_config_headers config.h"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then :
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
+$as_echo "$USE_MAINTAINER_MODE" >&6; }
+   if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+else
+  CC="$ac_cv_prog_CC"
+fi
+
+if test -z "$CC"; then
+          if test -n "$ac_tool_prefix"; then
+    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+set dummy ${ac_tool_prefix}cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="${ac_tool_prefix}cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  fi
+fi
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$CC"; then
+  if test -n "$ac_tool_prefix"; then
+  for ac_prog in cl.exe
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$CC" && break
+  done
+fi
+if test -z "$CC"; then
+  ac_ct_CC=$CC
+  for ac_prog in cl.exe
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_CC" >&5
+$as_echo "$ac_ct_CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_CC" && break
+done
+
+  if test "x$ac_ct_CC" = x; then
+    CC=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    CC=$ac_ct_CC
+  fi
+fi
+
+fi
+
+
+test -z "$CC" && { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "no acceptable C compiler found in \$PATH
+See \`config.log' for more details" "$LINENO" 5; }
+
+# Provide some information about the compiler.
+$as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler version" >&5
+set X $ac_compile
+ac_compiler=$2
+for ac_option in --version -v -V -qversion; do
+  { { ac_try="$ac_compiler $ac_option >&5"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compiler $ac_option >&5") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    sed '10a\
+... rest of stderr output deleted ...
+         10q' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+  fi
+  rm -f conftest.er1 conftest.err
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+done
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
+# Try to create an executable without -o first, disregard a.out.
+# It will help us diagnose broken compilers, and finding out an intuition
+# of exeext.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler works" >&5
+$as_echo_n "checking whether the C compiler works... " >&6; }
+ac_link_default=`$as_echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
+
+# The possible output files:
+ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
+
+ac_rmfiles=
+for ac_file in $ac_files
+do
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
+  esac
+done
+rm -f $ac_rmfiles
+
+if { { ac_try="$ac_link_default"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link_default") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
+# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
+# in a Makefile.  We should not override ac_cv_exeext if it was cached,
+# so that the user can short-circuit this test for compilers unknown to
+# Autoconf.
+for ac_file in $ac_files ''
+do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
+	;;
+    [ab].out )
+	# We found the default executable, but exeext='' is most
+	# certainly right.
+	break;;
+    *.* )
+	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
+	then :; else
+	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	fi
+	# We set ac_cv_exeext here because the later test for it is not
+	# safe: cross compilers may not add the suffix if given an `-o'
+	# argument, so we may need to know it at that point already.
+	# Even if this section looks crufty: it has the advantage of
+	# actually working.
+	break;;
+    * )
+	break;;
+  esac
+done
+test "$ac_cv_exeext" = no && ac_cv_exeext=
+
+else
+  ac_file=''
+fi
+if test -z "$ac_file"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+$as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error 77 "C compiler cannot create executables
+See \`config.log' for more details" "$LINENO" 5; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for C compiler default output file name" >&5
+$as_echo_n "checking for C compiler default output file name... " >&6; }
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_file" >&5
+$as_echo "$ac_file" >&6; }
+ac_exeext=$ac_cv_exeext
+
+rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
+$as_echo_n "checking for suffix of executables... " >&6; }
+if { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  # If both `conftest.exe' and `conftest' are `present' (well, observable)
+# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
+# work properly (i.e., refer to `conftest.exe'), while it won't with
+# `rm'.
+for ac_file in conftest.exe conftest conftest.*; do
+  test -f "$ac_file" || continue
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
+    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  break;;
+    * ) break;;
+  esac
+done
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of executables: cannot compile and link
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+rm -f conftest conftest$ac_cv_exeext
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
+$as_echo "$ac_cv_exeext" >&6; }
+
+rm -f conftest.$ac_ext
+EXEEXT=$ac_cv_exeext
+ac_exeext=$EXEEXT
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdio.h>
+int
+main ()
+{
+FILE *f = fopen ("conftest.out", "w");
+ return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+ac_clean_files="$ac_clean_files conftest.out"
+# Check that the compiler produces executables we can run.  If not, either
+# the compiler is broken, or we cross compile.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are cross compiling" >&5
+$as_echo_n "checking whether we are cross compiling... " >&6; }
+if test "$cross_compiling" != yes; then
+  { { ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+  if { ac_try='./conftest$ac_cv_exeext'
+  { { case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; }; then
+    cross_compiling=no
+  else
+    if test "$cross_compiling" = maybe; then
+	cross_compiling=yes
+    else
+	{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot run C compiled programs.
+If you meant to cross compile, use \`--host'.
+See \`config.log' for more details" "$LINENO" 5; }
+    fi
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $cross_compiling" >&5
+$as_echo "$cross_compiling" >&6; }
+
+rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
+ac_clean_files=$ac_clean_files_save
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
+$as_echo_n "checking for suffix of object files... " >&6; }
+if ${ac_cv_objext+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.o conftest.obj
+if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then :
+  for ac_file in conftest.o conftest.obj conftest.*; do
+  test -f "$ac_file" || continue;
+  case $ac_file in
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
+    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
+       break;;
+  esac
+done
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+{ { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "cannot compute suffix of object files: cannot compile
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+rm -f conftest.$ac_cv_objext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
+$as_echo "$ac_cv_objext" >&6; }
+OBJEXT=$ac_cv_objext
+ac_objext=$OBJEXT
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using the GNU C compiler" >&5
+$as_echo_n "checking whether we are using the GNU C compiler... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+#ifndef __GNUC__
+       choke me
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_compiler_gnu=yes
+else
+  ac_compiler_gnu=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_c_compiler_gnu=$ac_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+if test $ac_compiler_gnu = yes; then
+  GCC=yes
+else
+  GCC=
+fi
+ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $CC option to accept ISO C89" >&5
+$as_echo_n "checking for $CC option to accept ISO C89... " >&6; }
+if ${ac_cv_prog_cc_c89+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_prog_cc_c89=no
+ac_save_CC=$CC
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdarg.h>
+#include <stdio.h>
+struct stat;
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
+/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
+   inside strings and character constants.  */
+#define FOO(x) 'x'
+int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
+
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
+int
+main ()
+{
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+  ;
+  return 0;
+}
+_ACEOF
+for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
+	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_c89=$ac_arg
+fi
+rm -f core conftest.err conftest.$ac_objext
+  test "x$ac_cv_prog_cc_c89" != "xno" && break
+done
+rm -f conftest.$ac_ext
+CC=$ac_save_CC
+
+fi
+# AC_CACHE_VAL
+case "x$ac_cv_prog_cc_c89" in
+  x)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: none needed" >&5
+$as_echo "none needed" >&6; } ;;
+  xno)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: unsupported" >&5
+$as_echo "unsupported" >&6; } ;;
+  *)
+    CC="$CC $ac_cv_prog_cc_c89"
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_c89" >&5
+$as_echo "$ac_cv_prog_cc_c89" >&6; } ;;
+esac
+if test "x$ac_cv_prog_cc_c89" != xno; then :
+
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC understands -c and -o together" >&5
+$as_echo_n "checking whether $CC understands -c and -o together... " >&6; }
+if ${am_cv_prog_cc_c_o+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+  # Make sure it works both with $CC and with simple cc.
+  # Following AC_PROG_CC_C_O, we do the test twice because some
+  # compilers refuse to overwrite an existing .o file with -o,
+  # though they will create one.
+  am_cv_prog_cc_c_o=yes
+  for am_i in 1 2; do
+    if { echo "$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext" >&5
+   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5
+   ac_status=$?
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   (exit $ac_status); } \
+         && test -f conftest2.$ac_objext; then
+      : OK
+    else
+      am_cv_prog_cc_c_o=no
+      break
+    fi
+  done
+  rm -f core conftest*
+  unset am_i
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_prog_cc_c_o" >&5
+$as_echo "$am_cv_prog_cc_c_o" >&6; }
+if test "$am_cv_prog_cc_c_o" != yes; then
+   # Losing compiler, so override with the script.
+   # FIXME: It is wrong to rewrite CC.
+   # But if we don't then we get into trouble of one sort or another.
+   # A longer-term fix would be to have automake use am__CC in this case,
+   # and then we could set am__CC="\$(top_srcdir)/compile \$(CC)"
+   CC="$am_aux_dir/compile $CC"
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from 'make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+  am__nodep='_no'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if ${am_cv_CC_dependencies_compiler_type+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+      # This compiler won't grok '-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+
+if test -z "$orig_CFLAGS"; then
+  if test x$GCC = xyes; then
+    CFLAGS="-g -O3"
+  fi
+fi
+
+
+case `pwd` in
+  *\ * | *\	*)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&5
+$as_echo "$as_me: WARNING: Libtool does not cope well with whitespace in \`pwd\`" >&2;} ;;
+esac
+
+
+
+macro_version='2.4.2'
+macro_revision='1.3337'
+
+
+
+
+
+
+
+
+
+
+
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if ${ac_cv_build+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if ${ac_cv_host+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+# Backslashify metacharacters that are still active within
+# double-quoted strings.
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution to delay expansion of an escaped shell variable in a
+# double_quote_subst'ed string.
+delay_variable_subst='s/\\\\\\\\\\\$/\\\\\\$/g'
+
+# Sed substitution to delay expansion of an escaped single quote.
+delay_single_quote_subst='s/'\''/'\'\\\\\\\'\''/g'
+
+# Sed substitution to avoid accidental globbing in evaled expressions
+no_glob_subst='s/\*/\\\*/g'
+
+ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO
+ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to print strings" >&5
+$as_echo_n "checking how to print strings... " >&6; }
+# Test print first, because it will be a builtin if present.
+if test "X`( print -r -- -n ) 2>/dev/null`" = X-n && \
+   test "X`print -r -- $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='print -r --'
+elif test "X`printf %s $ECHO 2>/dev/null`" = "X$ECHO"; then
+  ECHO='printf %s\n'
+else
+  # Use this function as a fallback that always works.
+  func_fallback_echo ()
+  {
+    eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+  }
+  ECHO='func_fallback_echo'
+fi
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO ""
+}
+
+case "$ECHO" in
+  printf*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: printf" >&5
+$as_echo "printf" >&6; } ;;
+  print*) { $as_echo "$as_me:${as_lineno-$LINENO}: result: print -r" >&5
+$as_echo "print -r" >&6; } ;;
+  *) { $as_echo "$as_me:${as_lineno-$LINENO}: result: cat" >&5
+$as_echo "cat" >&6; } ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a sed that does not truncate output" >&5
+$as_echo_n "checking for a sed that does not truncate output... " >&6; }
+if ${ac_cv_path_SED+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+            ac_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/
+     for ac_i in 1 2 3 4 5 6 7; do
+       ac_script="$ac_script$as_nl$ac_script"
+     done
+     echo "$ac_script" 2>/dev/null | sed 99q >conftest.sed
+     { ac_script=; unset ac_script;}
+     if test -z "$SED"; then
+  ac_path_SED_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in sed gsed; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_SED" || continue
+# Check for GNU ac_path_SED and select it if it is found.
+  # Check for GNU $ac_path_SED
+case `"$ac_path_SED" --version 2>&1` in
+*GNU*)
+  ac_cv_path_SED="$ac_path_SED" ac_path_SED_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo '' >> "conftest.nl"
+    "$ac_path_SED" -f conftest.sed < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_SED_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_SED="$ac_path_SED"
+      ac_path_SED_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_SED_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_SED"; then
+    as_fn_error $? "no acceptable sed could be found in \$PATH" "$LINENO" 5
+  fi
+else
+  ac_cv_path_SED=$SED
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_SED" >&5
+$as_echo "$ac_cv_path_SED" >&6; }
+ SED="$ac_cv_path_SED"
+  rm -f conftest.sed
+
+test -z "$SED" && SED=sed
+Xsed="$SED -e 1s/^X//"
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if ${ac_cv_path_GREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_GREP" || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if ${ac_cv_path_EGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_EGREP" || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for fgrep" >&5
+$as_echo_n "checking for fgrep... " >&6; }
+if ${ac_cv_path_FGREP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo 'ab*c' | $GREP -F 'ab*c' >/dev/null 2>&1
+   then ac_cv_path_FGREP="$GREP -F"
+   else
+     if test -z "$FGREP"; then
+  ac_path_FGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in fgrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
+      as_fn_executable_p "$ac_path_FGREP" || continue
+# Check for GNU ac_path_FGREP and select it if it is found.
+  # Check for GNU $ac_path_FGREP
+case `"$ac_path_FGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_FGREP="$ac_path_FGREP" ac_path_FGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'FGREP' >> "conftest.nl"
+    "$ac_path_FGREP" FGREP < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_FGREP="$ac_path_FGREP"
+      ac_path_FGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_FGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_FGREP"; then
+    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_FGREP=$FGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_FGREP" >&5
+$as_echo "$ac_cv_path_FGREP" >&6; }
+ FGREP="$ac_cv_path_FGREP"
+
+
+test -z "$GREP" && GREP=grep
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then :
+  withval=$with_gnu_ld; test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi
+
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ld used by $CC" >&5
+$as_echo_n "checking for ld used by $CC... " >&6; }
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | ?:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the pathname of ld
+      ac_prog=`$ECHO "$ac_prog"| $SED 's%\\\\%/%g'`
+      while $ECHO "$ac_prog" | $GREP "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`$ECHO $ac_prog| $SED "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for GNU ld" >&5
+$as_echo_n "checking for GNU ld... " >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for non-GNU ld" >&5
+$as_echo_n "checking for non-GNU ld... " >&6; }
+fi
+if ${lt_cv_path_LD+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$LD"; then
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  for ac_dir in $PATH; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      lt_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some variants of GNU ld only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$lt_cv_path_LD" -v 2>&1 </dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break
+	;;
+      *)
+	test "$with_gnu_ld" != yes && break
+	;;
+      esac
+    fi
+  done
+  IFS="$lt_save_ifs"
+else
+  lt_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$lt_cv_path_LD"
+if test -n "$LD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LD" >&5
+$as_echo "$LD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+test -z "$LD" && as_fn_error $? "no acceptable ld found in \$PATH" "$LINENO" 5
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if the linker ($LD) is GNU ld" >&5
+$as_echo_n "checking if the linker ($LD) is GNU ld... " >&6; }
+if ${lt_cv_prog_gnu_ld+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  # I'd rather use --version here, but apparently some GNU lds only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  lt_cv_prog_gnu_ld=yes
+  ;;
+*)
+  lt_cv_prog_gnu_ld=no
+  ;;
+esac
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_gnu_ld" >&5
+$as_echo "$lt_cv_prog_gnu_ld" >&6; }
+with_gnu_ld=$lt_cv_prog_gnu_ld
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for BSD- or MS-compatible name lister (nm)" >&5
+$as_echo_n "checking for BSD- or MS-compatible name lister (nm)... " >&6; }
+if ${lt_cv_path_NM+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NM"; then
+  # Let the user override the test.
+  lt_cv_path_NM="$NM"
+else
+  lt_nm_to_check="${ac_tool_prefix}nm"
+  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
+    lt_nm_to_check="$lt_nm_to_check nm"
+  fi
+  for lt_tmp_nm in $lt_nm_to_check; do
+    lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do
+      IFS="$lt_save_ifs"
+      test -z "$ac_dir" && ac_dir=.
+      tmp_nm="$ac_dir/$lt_tmp_nm"
+      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
+	# Check to see if the nm accepts a BSD-compat flag.
+	# Adding the `sed 1q' prevents false positives on HP-UX, which says:
+	#   nm: unknown option "B" ignored
+	# Tru64's nm complains that /dev/null is an invalid object file
+	case `"$tmp_nm" -B /dev/null 2>&1 | sed '1q'` in
+	*/dev/null* | *'Invalid file or object type'*)
+	  lt_cv_path_NM="$tmp_nm -B"
+	  break
+	  ;;
+	*)
+	  case `"$tmp_nm" -p /dev/null 2>&1 | sed '1q'` in
+	  */dev/null*)
+	    lt_cv_path_NM="$tmp_nm -p"
+	    break
+	    ;;
+	  *)
+	    lt_cv_path_NM=${lt_cv_path_NM="$tmp_nm"} # keep the first match, but
+	    continue # so that we can try to find one that supports BSD flags
+	    ;;
+	  esac
+	  ;;
+	esac
+      fi
+    done
+    IFS="$lt_save_ifs"
+  done
+  : ${lt_cv_path_NM=no}
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_NM" >&5
+$as_echo "$lt_cv_path_NM" >&6; }
+if test "$lt_cv_path_NM" != "no"; then
+  NM="$lt_cv_path_NM"
+else
+  # Didn't find any BSD compatible name lister, look for dumpbin.
+  if test -n "$DUMPBIN"; then :
+    # Let the user override the test.
+  else
+    if test -n "$ac_tool_prefix"; then
+  for ac_prog in dumpbin "link -dump"
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_DUMPBIN+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DUMPBIN"; then
+  ac_cv_prog_DUMPBIN="$DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DUMPBIN=$ac_cv_prog_DUMPBIN
+if test -n "$DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DUMPBIN" >&5
+$as_echo "$DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$DUMPBIN" && break
+  done
+fi
+if test -z "$DUMPBIN"; then
+  ac_ct_DUMPBIN=$DUMPBIN
+  for ac_prog in dumpbin "link -dump"
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_DUMPBIN+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DUMPBIN"; then
+  ac_cv_prog_ac_ct_DUMPBIN="$ac_ct_DUMPBIN" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_DUMPBIN="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DUMPBIN=$ac_cv_prog_ac_ct_DUMPBIN
+if test -n "$ac_ct_DUMPBIN"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DUMPBIN" >&5
+$as_echo "$ac_ct_DUMPBIN" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_DUMPBIN" && break
+done
+
+  if test "x$ac_ct_DUMPBIN" = x; then
+    DUMPBIN=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DUMPBIN=$ac_ct_DUMPBIN
+  fi
+fi
+
+    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in
+    *COFF*)
+      DUMPBIN="$DUMPBIN -symbols"
+      ;;
+    *)
+      DUMPBIN=:
+      ;;
+    esac
+  fi
+
+  if test "$DUMPBIN" != ":"; then
+    NM="$DUMPBIN"
+  fi
+fi
+test -z "$NM" && NM=nm
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the name lister ($NM) interface" >&5
+$as_echo_n "checking the name lister ($NM) interface... " >&6; }
+if ${lt_cv_nm_interface+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_nm_interface="BSD nm"
+  echo "int some_variable = 0;" > conftest.$ac_ext
+  (eval echo "\"\$as_me:$LINENO: $ac_compile\"" >&5)
+  (eval "$ac_compile" 2>conftest.err)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
+  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
+  cat conftest.err >&5
+  (eval echo "\"\$as_me:$LINENO: output\"" >&5)
+  cat conftest.out >&5
+  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
+    lt_cv_nm_interface="MS dumpbin"
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_nm_interface" >&5
+$as_echo "$lt_cv_nm_interface" >&6; }
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ln -s works" >&5
+$as_echo_n "checking whether ln -s works... " >&6; }
+LN_S=$as_ln_s
+if test "$LN_S" = "ln -s"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no, using $LN_S" >&5
+$as_echo "no, using $LN_S" >&6; }
+fi
+
+# find the maximum length of command line arguments
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
+$as_echo_n "checking the maximum length of command line arguments... " >&6; }
+if ${lt_cv_sys_max_cmd_len+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+    i=0
+  teststring="ABCD"
+
+  case $build_os in
+  msdosdjgpp*)
+    # On DJGPP, this test can blow up pretty badly due to problems in libc
+    # (any single argument exceeding 2000 bytes causes a buffer overrun
+    # during glob expansion).  Even if it were fixed, the result of this
+    # check would be larger than it should be.
+    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
+    ;;
+
+  gnu*)
+    # Under GNU Hurd, this test is not required because there is
+    # no limit to the length of command line arguments.
+    # Libtool will interpret -1 as no limit whatsoever
+    lt_cv_sys_max_cmd_len=-1;
+    ;;
+
+  cygwin* | mingw* | cegcc*)
+    # On Win9x/ME, this test blows up -- it succeeds, but takes
+    # about 5 minutes as the teststring grows exponentially.
+    # Worse, since 9x/ME are not pre-emptively multitasking,
+    # you end up with a "frozen" computer, even though with patience
+    # the test eventually succeeds (with a max line length of 256k).
+    # Instead, let's just punt: use the minimum linelength reported by
+    # all of the supported platforms: 8192 (on NT/2K/XP).
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  mint*)
+    # On MiNT this can take a long time and run out of memory.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  amigaos*)
+    # On AmigaOS with pdksh, this test takes hours, literally.
+    # So we just punt and use a minimum line length of 8192.
+    lt_cv_sys_max_cmd_len=8192;
+    ;;
+
+  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)
+    # This has been around since 386BSD, at least.  Likely further.
+    if test -x /sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
+    elif test -x /usr/sbin/sysctl; then
+      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
+    else
+      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
+    fi
+    # And add a safety zone
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    ;;
+
+  interix*)
+    # We know the value 262144 and hardcode it with a safety zone (like BSD)
+    lt_cv_sys_max_cmd_len=196608
+    ;;
+
+  os2*)
+    # The test takes a long time on OS/2.
+    lt_cv_sys_max_cmd_len=8192
+    ;;
+
+  osf*)
+    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure
+    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
+    # nice to cause kernel panics so lets avoid the loop below.
+    # First set a reasonable default.
+    lt_cv_sys_max_cmd_len=16384
+    #
+    if test -x /sbin/sysconfig; then
+      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
+        *1*) lt_cv_sys_max_cmd_len=-1 ;;
+      esac
+    fi
+    ;;
+  sco3.2v5*)
+    lt_cv_sys_max_cmd_len=102400
+    ;;
+  sysv5* | sco5v6* | sysv4.2uw2*)
+    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
+    if test -n "$kargmax"; then
+      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
+    else
+      lt_cv_sys_max_cmd_len=32768
+    fi
+    ;;
+  *)
+    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
+    if test -n "$lt_cv_sys_max_cmd_len" && \
+	test undefined != "$lt_cv_sys_max_cmd_len"; then
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
+    else
+      # Make teststring a little bigger before we do anything with it.
+      # a 1K string should be a reasonable start.
+      for i in 1 2 3 4 5 6 7 8 ; do
+        teststring=$teststring$teststring
+      done
+      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}
+      # If test is not a shell built-in, we'll probably end up computing a
+      # maximum length that is only half of the actual maximum length, but
+      # we can't tell.
+      while { test "X"`env echo "$teststring$teststring" 2>/dev/null` \
+	         = "X$teststring$teststring"; } >/dev/null 2>&1 &&
+	      test $i != 17 # 1/2 MB should be enough
+      do
+        i=`expr $i + 1`
+        teststring=$teststring$teststring
+      done
+      # Only check the string length outside the loop.
+      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
+      teststring=
+      # Add a significant safety factor because C++ compilers can tack on
+      # massive amounts of additional arguments before passing them to the
+      # linker.  It appears as though 1/2 is a usable value.
+      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
+    fi
+    ;;
+  esac
+
+fi
+
+if test -n $lt_cv_sys_max_cmd_len ; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
+$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: none" >&5
+$as_echo "none" >&6; }
+fi
+max_cmd_len=$lt_cv_sys_max_cmd_len
+
+
+
+
+
+
+: ${CP="cp -f"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands some XSI constructs" >&5
+$as_echo_n "checking whether the shell understands some XSI constructs... " >&6; }
+# Try some XSI features
+xsi_shell=no
+( _lt_dummy="a/b/c"
+  test "${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}"${_lt_dummy%"$_lt_dummy"}, \
+      = c,a/b,b/c, \
+    && eval 'test $(( 1 + 1 )) -eq 2 \
+    && test "${#_lt_dummy}" -eq 5' ) >/dev/null 2>&1 \
+  && xsi_shell=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
+$as_echo "$xsi_shell" >&6; }
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the shell understands \"+=\"" >&5
+$as_echo_n "checking whether the shell understands \"+=\"... " >&6; }
+lt_shell_append=no
+( foo=bar; set foo baz; eval "$1+=\$2" && test "$foo" = barbaz ) \
+    >/dev/null 2>&1 \
+  && lt_shell_append=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_shell_append" >&5
+$as_echo "$lt_shell_append" >&6; }
+
+
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
+  lt_unset=unset
+else
+  lt_unset=false
+fi
+
+
+
+
+
+# test EBCDIC or ASCII
+case `echo X|tr X '\101'` in
+ A) # ASCII based system
+    # \n is not interpreted correctly by Solaris 8 /usr/ucb/tr
+  lt_SP2NL='tr \040 \012'
+  lt_NL2SP='tr \015\012 \040\040'
+  ;;
+ *) # EBCDIC based system
+  lt_SP2NL='tr \100 \n'
+  lt_NL2SP='tr \r\n \100\100'
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to convert $build file names to $host format" >&5
+$as_echo_n "checking how to convert $build file names to $host format... " >&6; }
+if ${lt_cv_to_host_file_cmd+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
+        ;;
+    esac
+    ;;
+  *-*-cygwin* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin
+        ;;
+      *-*-cygwin* )
+        lt_cv_to_host_file_cmd=func_convert_file_noop
+        ;;
+      * ) # otherwise, assume *nix
+        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
+        ;;
+    esac
+    ;;
+  * ) # unhandled hosts (and "normal" native builds)
+    lt_cv_to_host_file_cmd=func_convert_file_noop
+    ;;
+esac
+
+fi
+
+to_host_file_cmd=$lt_cv_to_host_file_cmd
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_to_host_file_cmd" >&5
+$as_echo "$lt_cv_to_host_file_cmd" >&6; }
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to convert $build file names to toolchain format" >&5
+$as_echo_n "checking how to convert $build file names to toolchain format... " >&6; }
+if ${lt_cv_to_tool_file_cmd+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  #assume ordinary cross tools, or native build.
+lt_cv_to_tool_file_cmd=func_convert_file_noop
+case $host in
+  *-*-mingw* )
+    case $build in
+      *-*-mingw* ) # actually msys
+        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32
+        ;;
+    esac
+    ;;
+esac
+
+fi
+
+to_tool_file_cmd=$lt_cv_to_tool_file_cmd
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_to_tool_file_cmd" >&5
+$as_echo "$lt_cv_to_tool_file_cmd" >&6; }
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $LD option to reload object files" >&5
+$as_echo_n "checking for $LD option to reload object files... " >&6; }
+if ${lt_cv_ld_reload_flag+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_reload_flag='-r'
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_reload_flag" >&5
+$as_echo "$lt_cv_ld_reload_flag" >&6; }
+reload_flag=$lt_cv_ld_reload_flag
+case $reload_flag in
+"" | " "*) ;;
+*) reload_flag=" $reload_flag" ;;
+esac
+reload_cmds='$LD$reload_flag -o $output$reload_objs'
+case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    if test "$GCC" != yes; then
+      reload_cmds=false
+    fi
+    ;;
+  darwin*)
+    if test "$GCC" = yes; then
+      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'
+    else
+      reload_cmds='$LD$reload_flag -o $output$reload_objs'
+    fi
+    ;;
+esac
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_OBJDUMP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OBJDUMP" >&5
+$as_echo "$OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_OBJDUMP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_OBJDUMP="objdump"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OBJDUMP" >&5
+$as_echo "$ac_ct_OBJDUMP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OBJDUMP" = x; then
+    OBJDUMP="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OBJDUMP=$ac_ct_OBJDUMP
+  fi
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+test -z "$OBJDUMP" && OBJDUMP=objdump
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to recognize dependent libraries" >&5
+$as_echo_n "checking how to recognize dependent libraries... " >&6; }
+if ${lt_cv_deplibs_check_method+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_file_magic_cmd='$MAGIC_CMD'
+lt_cv_file_magic_test_file=
+lt_cv_deplibs_check_method='unknown'
+# Need to set the preceding variable on all platforms that support
+# interlibrary dependencies.
+# 'none' -- dependencies not supported.
+# `unknown' -- same as none, but documents that we really don't know.
+# 'pass_all' -- all dependencies passed with no checks.
+# 'test_compile' -- check by making test program.
+# 'file_magic [[regex]]' -- check by looking for files in library path
+# which responds to the $file_magic_cmd with a given extended regex.
+# If you have `file' or equivalent on your system and you're not sure
+# whether `pass_all' will *always* work, you probably want this one.
+
+case $host_os in
+aix[4-9]*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+beos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+bsdi[45]*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib)'
+  lt_cv_file_magic_cmd='/usr/bin/file -L'
+  lt_cv_file_magic_test_file=/shlib/libc.so
+  ;;
+
+cygwin*)
+  # func_win32_libid is a shell function defined in ltmain.sh
+  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+  lt_cv_file_magic_cmd='func_win32_libid'
+  ;;
+
+mingw* | pw32*)
+  # Base MSYS/MinGW do not provide the 'file' command needed by
+  # func_win32_libid shell function, so use a weaker test based on 'objdump',
+  # unless we find 'file', for example because we are cross-compiling.
+  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.
+  if ( test "$lt_cv_nm_interface" = "BSD nm" && file / ) >/dev/null 2>&1; then
+    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
+    lt_cv_file_magic_cmd='func_win32_libid'
+  else
+    # Keep this pattern in sync with the one in func_win32_libid.
+    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
+    lt_cv_file_magic_cmd='$OBJDUMP -f'
+  fi
+  ;;
+
+cegcc*)
+  # use the weaker test based on 'objdump'. See mingw*.
+  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'
+  lt_cv_file_magic_cmd='$OBJDUMP -f'
+  ;;
+
+darwin* | rhapsody*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+freebsd* | dragonfly*)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    case $host_cpu in
+    i*86 )
+      # Not sure whether the presence of OpenBSD here was a mistake.
+      # Let's accept both of them until this is cleared up.
+      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[3-9]86 (compact )?demand paged shared library'
+      lt_cv_file_magic_cmd=/usr/bin/file
+      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`
+      ;;
+    esac
+  else
+    lt_cv_deplibs_check_method=pass_all
+  fi
+  ;;
+
+haiku*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+hpux10.20* | hpux11*)
+  lt_cv_file_magic_cmd=/usr/bin/file
+  case $host_cpu in
+  ia64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - IA64'
+    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
+    ;;
+  hppa*64*)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\.[0-9]'
+    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl
+    ;;
+  *)
+    lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|PA-RISC[0-9]\.[0-9]) shared library'
+    lt_cv_file_magic_test_file=/usr/lib/libc.sl
+    ;;
+  esac
+  ;;
+
+interix[3-9]*)
+  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
+  lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|\.a)$'
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $LD in
+  *-32|*"-32 ") libmagic=32-bit;;
+  *-n32|*"-n32 ") libmagic=N32;;
+  *-64|*"-64 ") libmagic=64-bit;;
+  *) libmagic=never-match;;
+  esac
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+netbsd* | netbsdelf*-gnu)
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so|_pic\.a)$'
+  fi
+  ;;
+
+newos6*)
+  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
+  lt_cv_file_magic_cmd=/usr/bin/file
+  lt_cv_file_magic_test_file=/usr/lib/libnls.so
+  ;;
+
+*nto* | *qnx*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+openbsd*)
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|\.so|_pic\.a)$'
+  else
+    lt_cv_deplibs_check_method='match_pattern /lib[^/]+(\.so\.[0-9]+\.[0-9]+|_pic\.a)$'
+  fi
+  ;;
+
+osf3* | osf4* | osf5*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+rdos*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+solaris*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+
+sysv4 | sysv4.3*)
+  case $host_vendor in
+  motorola)
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (shared object|dynamic lib) M[0-9][0-9]* Version [0-9]'
+    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`
+    ;;
+  ncr)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  sequent)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [LM]SB (shared object|dynamic lib )'
+    ;;
+  sni)
+    lt_cv_file_magic_cmd='/bin/file'
+    lt_cv_deplibs_check_method="file_magic ELF [0-9][0-9]*-bit [LM]SB dynamic lib"
+    lt_cv_file_magic_test_file=/lib/libc.so
+    ;;
+  siemens)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  pc)
+    lt_cv_deplibs_check_method=pass_all
+    ;;
+  esac
+  ;;
+
+tpf*)
+  lt_cv_deplibs_check_method=pass_all
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_deplibs_check_method" >&5
+$as_echo "$lt_cv_deplibs_check_method" >&6; }
+
+file_magic_glob=
+want_nocaseglob=no
+if test "$build" = "$host"; then
+  case $host_os in
+  mingw* | pw32*)
+    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then
+      want_nocaseglob=yes
+    else
+      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[\1]\/[\1]\/g;/g"`
+    fi
+    ;;
+  esac
+fi
+
+file_magic_cmd=$lt_cv_file_magic_cmd
+deplibs_check_method=$lt_cv_deplibs_check_method
+test -z "$deplibs_check_method" && deplibs_check_method=unknown
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dlltool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_DLLTOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DLLTOOL"; then
+  ac_cv_prog_DLLTOOL="$DLLTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DLLTOOL=$ac_cv_prog_DLLTOOL
+if test -n "$DLLTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DLLTOOL" >&5
+$as_echo "$DLLTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DLLTOOL"; then
+  ac_ct_DLLTOOL=$DLLTOOL
+  # Extract the first word of "dlltool", so it can be a program name with args.
+set dummy dlltool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_DLLTOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DLLTOOL"; then
+  ac_cv_prog_ac_ct_DLLTOOL="$ac_ct_DLLTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_DLLTOOL="dlltool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DLLTOOL=$ac_cv_prog_ac_ct_DLLTOOL
+if test -n "$ac_ct_DLLTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DLLTOOL" >&5
+$as_echo "$ac_ct_DLLTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DLLTOOL" = x; then
+    DLLTOOL="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DLLTOOL=$ac_ct_DLLTOOL
+  fi
+else
+  DLLTOOL="$ac_cv_prog_DLLTOOL"
+fi
+
+test -z "$DLLTOOL" && DLLTOOL=dlltool
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to associate runtime and link libraries" >&5
+$as_echo_n "checking how to associate runtime and link libraries... " >&6; }
+if ${lt_cv_sharedlib_from_linklib_cmd+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_sharedlib_from_linklib_cmd='unknown'
+
+case $host_os in
+cygwin* | mingw* | pw32* | cegcc*)
+  # two different shell functions defined in ltmain.sh
+  # decide which to use based on capabilities of $DLLTOOL
+  case `$DLLTOOL --help 2>&1` in
+  *--identify-strict*)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib
+    ;;
+  *)
+    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback
+    ;;
+  esac
+  ;;
+*)
+  # fallback: assume linklib IS sharedlib
+  lt_cv_sharedlib_from_linklib_cmd="$ECHO"
+  ;;
+esac
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sharedlib_from_linklib_cmd" >&5
+$as_echo "$lt_cv_sharedlib_from_linklib_cmd" >&6; }
+sharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd
+test -z "$sharedlib_from_linklib_cmd" && sharedlib_from_linklib_cmd=$ECHO
+
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in ar
+  do
+    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
+set dummy $ac_tool_prefix$ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+    test -n "$AR" && break
+  done
+fi
+if test -z "$AR"; then
+  ac_ct_AR=$AR
+  for ac_prog in ar
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_AR="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$ac_ct_AR" && break
+done
+
+  if test "x$ac_ct_AR" = x; then
+    AR="false"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+fi
+
+: ${AR=ar}
+: ${AR_FLAGS=cru}
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for archiver @FILE support" >&5
+$as_echo_n "checking for archiver @FILE support... " >&6; }
+if ${lt_cv_ar_at_file+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ar_at_file=no
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  echo conftest.$ac_objext > conftest.lst
+      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&5'
+      { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$lt_ar_try\""; } >&5
+  (eval $lt_ar_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+      if test "$ac_status" -eq 0; then
+	# Ensure the archiver fails upon bogus file names.
+	rm -f conftest.$ac_objext libconftest.a
+	{ { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$lt_ar_try\""; } >&5
+  (eval $lt_ar_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	if test "$ac_status" -ne 0; then
+          lt_cv_ar_at_file=@
+        fi
+      fi
+      rm -f conftest.* libconftest.a
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ar_at_file" >&5
+$as_echo "$lt_cv_ar_at_file" >&6; }
+
+if test "x$lt_cv_ar_at_file" = xno; then
+  archiver_list_spec=
+else
+  archiver_list_spec=$lt_cv_ar_at_file
+fi
+
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+test -z "$STRIP" && STRIP=:
+
+
+
+
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+test -z "$RANLIB" && RANLIB=:
+
+
+
+
+
+
+# Determine commands to create old-style static archives.
+old_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'
+old_postinstall_cmds='chmod 644 $oldlib'
+old_postuninstall_cmds=
+
+if test -n "$RANLIB"; then
+  case $host_os in
+  openbsd*)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB -t \$tool_oldlib"
+    ;;
+  *)
+    old_postinstall_cmds="$old_postinstall_cmds~\$RANLIB \$tool_oldlib"
+    ;;
+  esac
+  old_archive_cmds="$old_archive_cmds~\$RANLIB \$tool_oldlib"
+fi
+
+case $host_os in
+  darwin*)
+    lock_old_archive_extraction=yes ;;
+  *)
+    lock_old_archive_extraction=no ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+
+# Check for command to grab the raw symbol name followed by C symbol from nm.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking command to parse $NM output from $compiler object" >&5
+$as_echo_n "checking command to parse $NM output from $compiler object... " >&6; }
+if ${lt_cv_sys_global_symbol_pipe+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+
+# These are sane defaults that work on at least a few old systems.
+# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
+
+# Character class describing NM global symbol codes.
+symcode='[BCDEGRST]'
+
+# Regexp to match symbols that can be accessed directly from C.
+sympat='\([_A-Za-z][_A-Za-z0-9]*\)'
+
+# Define system-specific variables.
+case $host_os in
+aix*)
+  symcode='[BCDT]'
+  ;;
+cygwin* | mingw* | pw32* | cegcc*)
+  symcode='[ABCDGISTW]'
+  ;;
+hpux*)
+  if test "$host_cpu" = ia64; then
+    symcode='[ABCDEGRST]'
+  fi
+  ;;
+irix* | nonstopux*)
+  symcode='[BCDEGRST]'
+  ;;
+osf*)
+  symcode='[BCDEGQRST]'
+  ;;
+solaris*)
+  symcode='[BDRT]'
+  ;;
+sco3.2v5*)
+  symcode='[DT]'
+  ;;
+sysv4.2uw2*)
+  symcode='[DT]'
+  ;;
+sysv5* | sco5v6* | unixware* | OpenUNIX*)
+  symcode='[ABDT]'
+  ;;
+sysv4)
+  symcode='[DFNSTU]'
+  ;;
+esac
+
+# If we're using GNU nm, then use its standard symbol codes.
+case `$NM -V 2>&1` in
+*GNU* | *'with BFD'*)
+  symcode='[ABCDGIRSTW]' ;;
+esac
+
+# Transform an extracted symbol line into a proper C declaration.
+# Some systems (esp. on ia64) link data and code symbols differently,
+# so use this general approach.
+lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
+
+# Transform an extracted symbol line into symbol name and symbol address
+lt_cv_sys_global_symbol_to_c_name_address="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"\2\", (void *) \&\2},/p'"
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
+
+# Handle CRLF in mingw tool chain
+opt_cr=
+case $build_os in
+mingw*)
+  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
+  ;;
+esac
+
+# Try without a prefix underscore, then with it.
+for ac_symprfx in "" "_"; do
+
+  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
+  symxfrm="\\1 $ac_symprfx\\2 \\2"
+
+  # Write the raw and C identifiers.
+  if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+    # Fake it for dumpbin and say T for any non-static function
+    # and D for any global variable.
+    # Also find C++ and __fastcall symbols from MSVC++,
+    # which start with @ or ?.
+    lt_cv_sys_global_symbol_pipe="$AWK '"\
+"     {last_section=section; section=\$ 3};"\
+"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};"\
+"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};"\
+"     \$ 0!~/External *\|/{next};"\
+"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
+"     {if(hide[section]) next};"\
+"     {f=0}; \$ 0~/\(\).*\|/{f=1}; {printf f ? \"T \" : \"D \"};"\
+"     {split(\$ 0, a, /\||\r/); split(a[2], s)};"\
+"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
+"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
+"     ' prfx=^$ac_symprfx"
+  else
+    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
+  fi
+  lt_cv_sys_global_symbol_pipe="$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'"
+
+  # Check to see that the pipe works correctly.
+  pipe_works=no
+
+  rm -f conftest*
+  cat > conftest.$ac_ext <<_LT_EOF
+#ifdef __cplusplus
+extern "C" {
+#endif
+char nm_test_var;
+void nm_test_func(void);
+void nm_test_func(void){}
+#ifdef __cplusplus
+}
+#endif
+int main(){nm_test_var='a';nm_test_func();return(0);}
+_LT_EOF
+
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    # Now try to grab the symbols.
+    nlist=conftest.nm
+    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
+  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s "$nlist"; then
+      # Try sorting and uniquifying the output.
+      if sort "$nlist" | uniq > "$nlist"T; then
+	mv -f "$nlist"T "$nlist"
+      else
+	rm -f "$nlist"T
+      fi
+
+      # Make sure that we snagged all the symbols we need.
+      if $GREP ' nm_test_var$' "$nlist" >/dev/null; then
+	if $GREP ' nm_test_func$' "$nlist" >/dev/null; then
+	  cat <<_LT_EOF > conftest.$ac_ext
+/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
+#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+/* DATA imports from DLLs on WIN32 con't be const, because runtime
+   relocations are performed -- see ld's documentation on pseudo-relocs.  */
+# define LT_DLSYM_CONST
+#elif defined(__osf__)
+/* This system does not cope well with relocations in const data.  */
+# define LT_DLSYM_CONST
+#else
+# define LT_DLSYM_CONST const
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+_LT_EOF
+	  # Now generate the symbol file.
+	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
+
+	  cat <<_LT_EOF >> conftest.$ac_ext
+
+/* The mapping between symbol names and symbols.  */
+LT_DLSYM_CONST struct {
+  const char *name;
+  void       *address;
+}
+lt__PROGRAM__LTX_preloaded_symbols[] =
+{
+  { "@PROGRAM@", (void *) 0 },
+_LT_EOF
+	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
+	  cat <<\_LT_EOF >> conftest.$ac_ext
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt__PROGRAM__LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+_LT_EOF
+	  # Now try linking the two files.
+	  mv conftest.$ac_objext conftstm.$ac_objext
+	  lt_globsym_save_LIBS=$LIBS
+	  lt_globsym_save_CFLAGS=$CFLAGS
+	  LIBS="conftstm.$ac_objext"
+	  CFLAGS="$CFLAGS$lt_prog_compiler_no_builtin_flag"
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
+	    pipe_works=yes
+	  fi
+	  LIBS=$lt_globsym_save_LIBS
+	  CFLAGS=$lt_globsym_save_CFLAGS
+	else
+	  echo "cannot find nm_test_func in $nlist" >&5
+	fi
+      else
+	echo "cannot find nm_test_var in $nlist" >&5
+      fi
+    else
+      echo "cannot run $lt_cv_sys_global_symbol_pipe" >&5
+    fi
+  else
+    echo "$progname: failed program was:" >&5
+    cat conftest.$ac_ext >&5
+  fi
+  rm -rf conftest* conftst*
+
+  # Do not use the global_symbol_pipe unless it works.
+  if test "$pipe_works" = yes; then
+    break
+  else
+    lt_cv_sys_global_symbol_pipe=
+  fi
+done
+
+fi
+
+if test -z "$lt_cv_sys_global_symbol_pipe"; then
+  lt_cv_sys_global_symbol_to_cdecl=
+fi
+if test -z "$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: failed" >&5
+$as_echo "failed" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+fi
+
+# Response file support.
+if test "$lt_cv_nm_interface" = "MS dumpbin"; then
+  nm_file_list_spec='@'
+elif $NM --help 2>/dev/null | grep '[@]FILE' >/dev/null; then
+  nm_file_list_spec='@'
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sysroot" >&5
+$as_echo_n "checking for sysroot... " >&6; }
+
+# Check whether --with-sysroot was given.
+if test "${with_sysroot+set}" = set; then :
+  withval=$with_sysroot;
+else
+  with_sysroot=no
+fi
+
+
+lt_sysroot=
+case ${with_sysroot} in #(
+ yes)
+   if test "$GCC" = yes; then
+     lt_sysroot=`$CC --print-sysroot 2>/dev/null`
+   fi
+   ;; #(
+ /*)
+   lt_sysroot=`echo "$with_sysroot" | sed -e "$sed_quote_subst"`
+   ;; #(
+ no|'')
+   ;; #(
+ *)
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${with_sysroot}" >&5
+$as_echo "${with_sysroot}" >&6; }
+   as_fn_error $? "The sysroot must be an absolute path." "$LINENO" 5
+   ;;
+esac
+
+ { $as_echo "$as_me:${as_lineno-$LINENO}: result: ${lt_sysroot:-no}" >&5
+$as_echo "${lt_sysroot:-no}" >&6; }
+
+
+
+
+
+# Check whether --enable-libtool-lock was given.
+if test "${enable_libtool_lock+set}" = set; then :
+  enableval=$enable_libtool_lock;
+fi
+
+test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
+
+# Some flags need to be propagated to the compiler or linker for good
+# libtool support.
+case $host in
+ia64-*-hpux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.$ac_objext` in
+      *ELF-32*)
+	HPUX_IA64_MODE="32"
+	;;
+      *ELF-64*)
+	HPUX_IA64_MODE="64"
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+*-*-irix6*)
+  # Find out which ABI we are using.
+  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    if test "$lt_cv_prog_gnu_ld" = yes; then
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -melf32bsmip"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -melf32bmipn32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -melf64bmip"
+	;;
+      esac
+    else
+      case `/usr/bin/file conftest.$ac_objext` in
+	*32-bit*)
+	  LD="${LD-ld} -32"
+	  ;;
+	*N32*)
+	  LD="${LD-ld} -n32"
+	  ;;
+	*64-bit*)
+	  LD="${LD-ld} -64"
+	  ;;
+      esac
+    fi
+  fi
+  rm -rf conftest*
+  ;;
+
+x86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \
+s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+      *32-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_i386_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    case `/usr/bin/file conftest.o` in
+	      *x86-64*)
+		LD="${LD-ld} -m elf32_x86_64"
+		;;
+	      *)
+		LD="${LD-ld} -m elf_i386"
+		;;
+	    esac
+	    ;;
+	  powerpc64le-*)
+	    LD="${LD-ld} -m elf32lppclinux"
+	    ;;
+	  powerpc64-*)
+	    LD="${LD-ld} -m elf32ppclinux"
+	    ;;
+	  s390x-*linux*)
+	    LD="${LD-ld} -m elf_s390"
+	    ;;
+	  sparc64-*linux*)
+	    LD="${LD-ld} -m elf32_sparc"
+	    ;;
+	esac
+	;;
+      *64-bit*)
+	case $host in
+	  x86_64-*kfreebsd*-gnu)
+	    LD="${LD-ld} -m elf_x86_64_fbsd"
+	    ;;
+	  x86_64-*linux*)
+	    LD="${LD-ld} -m elf_x86_64"
+	    ;;
+	  powerpcle-*)
+	    LD="${LD-ld} -m elf64lppc"
+	    ;;
+	  powerpc-*)
+	    LD="${LD-ld} -m elf64ppc"
+	    ;;
+	  s390*-*linux*|s390*-*tpf*)
+	    LD="${LD-ld} -m elf64_s390"
+	    ;;
+	  sparc*-*linux*)
+	    LD="${LD-ld} -m elf64_sparc"
+	    ;;
+	esac
+	;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+
+*-*-sco3.2v5*)
+  # On SCO OpenServer 5, we need -belf to get full-featured binaries.
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS -belf"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the C compiler needs -belf" >&5
+$as_echo_n "checking whether the C compiler needs -belf... " >&6; }
+if ${lt_cv_cc_needs_belf+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_cc_needs_belf=yes
+else
+  lt_cv_cc_needs_belf=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+     ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_cc_needs_belf" >&5
+$as_echo "$lt_cv_cc_needs_belf" >&6; }
+  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
+    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
+    CFLAGS="$SAVE_CFLAGS"
+  fi
+  ;;
+*-*solaris*)
+  # Find out which ABI we are using.
+  echo 'int i;' > conftest.$ac_ext
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; then
+    case `/usr/bin/file conftest.o` in
+    *64-bit*)
+      case $lt_cv_prog_gnu_ld in
+      yes*)
+        case $host in
+        i?86-*-solaris*)
+          LD="${LD-ld} -m elf_x86_64"
+          ;;
+        sparc*-*-solaris*)
+          LD="${LD-ld} -m elf64_sparc"
+          ;;
+        esac
+        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.
+        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then
+          LD="${LD-ld}_sol2"
+        fi
+        ;;
+      *)
+	if ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then
+	  LD="${LD-ld} -64"
+	fi
+	;;
+      esac
+      ;;
+    esac
+  fi
+  rm -rf conftest*
+  ;;
+esac
+
+need_locks="$enable_libtool_lock"
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}mt", so it can be a program name with args.
+set dummy ${ac_tool_prefix}mt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_MANIFEST_TOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$MANIFEST_TOOL"; then
+  ac_cv_prog_MANIFEST_TOOL="$MANIFEST_TOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_MANIFEST_TOOL="${ac_tool_prefix}mt"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+MANIFEST_TOOL=$ac_cv_prog_MANIFEST_TOOL
+if test -n "$MANIFEST_TOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MANIFEST_TOOL" >&5
+$as_echo "$MANIFEST_TOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_MANIFEST_TOOL"; then
+  ac_ct_MANIFEST_TOOL=$MANIFEST_TOOL
+  # Extract the first word of "mt", so it can be a program name with args.
+set dummy mt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_MANIFEST_TOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_MANIFEST_TOOL"; then
+  ac_cv_prog_ac_ct_MANIFEST_TOOL="$ac_ct_MANIFEST_TOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_MANIFEST_TOOL="mt"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_MANIFEST_TOOL=$ac_cv_prog_ac_ct_MANIFEST_TOOL
+if test -n "$ac_ct_MANIFEST_TOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_MANIFEST_TOOL" >&5
+$as_echo "$ac_ct_MANIFEST_TOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_MANIFEST_TOOL" = x; then
+    MANIFEST_TOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    MANIFEST_TOOL=$ac_ct_MANIFEST_TOOL
+  fi
+else
+  MANIFEST_TOOL="$ac_cv_prog_MANIFEST_TOOL"
+fi
+
+test -z "$MANIFEST_TOOL" && MANIFEST_TOOL=mt
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $MANIFEST_TOOL is a manifest tool" >&5
+$as_echo_n "checking if $MANIFEST_TOOL is a manifest tool... " >&6; }
+if ${lt_cv_path_mainfest_tool+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_path_mainfest_tool=no
+  echo "$as_me:$LINENO: $MANIFEST_TOOL '-?'" >&5
+  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out
+  cat conftest.err >&5
+  if $GREP 'Manifest Tool' conftest.out > /dev/null; then
+    lt_cv_path_mainfest_tool=yes
+  fi
+  rm -f conftest*
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_path_mainfest_tool" >&5
+$as_echo "$lt_cv_path_mainfest_tool" >&6; }
+if test "x$lt_cv_path_mainfest_tool" != xyes; then
+  MANIFEST_TOOL=:
+fi
+
+
+
+
+
+
+  case $host_os in
+    rhapsody* | darwin*)
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_DSYMUTIL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$DSYMUTIL"; then
+  ac_cv_prog_DSYMUTIL="$DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+DSYMUTIL=$ac_cv_prog_DSYMUTIL
+if test -n "$DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $DSYMUTIL" >&5
+$as_echo "$DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_DSYMUTIL"; then
+  ac_ct_DSYMUTIL=$DSYMUTIL
+  # Extract the first word of "dsymutil", so it can be a program name with args.
+set dummy dsymutil; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_DSYMUTIL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_DSYMUTIL"; then
+  ac_cv_prog_ac_ct_DSYMUTIL="$ac_ct_DSYMUTIL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_DSYMUTIL="dsymutil"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_DSYMUTIL=$ac_cv_prog_ac_ct_DSYMUTIL
+if test -n "$ac_ct_DSYMUTIL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_DSYMUTIL" >&5
+$as_echo "$ac_ct_DSYMUTIL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_DSYMUTIL" = x; then
+    DSYMUTIL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    DSYMUTIL=$ac_ct_DSYMUTIL
+  fi
+else
+  DSYMUTIL="$ac_cv_prog_DSYMUTIL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
+set dummy ${ac_tool_prefix}nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_NMEDIT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$NMEDIT"; then
+  ac_cv_prog_NMEDIT="$NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+NMEDIT=$ac_cv_prog_NMEDIT
+if test -n "$NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $NMEDIT" >&5
+$as_echo "$NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_NMEDIT"; then
+  ac_ct_NMEDIT=$NMEDIT
+  # Extract the first word of "nmedit", so it can be a program name with args.
+set dummy nmedit; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_NMEDIT+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_NMEDIT"; then
+  ac_cv_prog_ac_ct_NMEDIT="$ac_ct_NMEDIT" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_NMEDIT="nmedit"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_NMEDIT=$ac_cv_prog_ac_ct_NMEDIT
+if test -n "$ac_ct_NMEDIT"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_NMEDIT" >&5
+$as_echo "$ac_ct_NMEDIT" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_NMEDIT" = x; then
+    NMEDIT=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    NMEDIT=$ac_ct_NMEDIT
+  fi
+else
+  NMEDIT="$ac_cv_prog_NMEDIT"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
+set dummy ${ac_tool_prefix}lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_LIPO+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$LIPO"; then
+  ac_cv_prog_LIPO="$LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+LIPO=$ac_cv_prog_LIPO
+if test -n "$LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $LIPO" >&5
+$as_echo "$LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_LIPO"; then
+  ac_ct_LIPO=$LIPO
+  # Extract the first word of "lipo", so it can be a program name with args.
+set dummy lipo; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_LIPO+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_LIPO"; then
+  ac_cv_prog_ac_ct_LIPO="$ac_ct_LIPO" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_LIPO="lipo"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_LIPO=$ac_cv_prog_ac_ct_LIPO
+if test -n "$ac_ct_LIPO"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_LIPO" >&5
+$as_echo "$ac_ct_LIPO" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_LIPO" = x; then
+    LIPO=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    LIPO=$ac_ct_LIPO
+  fi
+else
+  LIPO="$ac_cv_prog_LIPO"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_OTOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL"; then
+  ac_cv_prog_OTOOL="$OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL=$ac_cv_prog_OTOOL
+if test -n "$OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL" >&5
+$as_echo "$OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL"; then
+  ac_ct_OTOOL=$OTOOL
+  # Extract the first word of "otool", so it can be a program name with args.
+set dummy otool; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_OTOOL+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL"; then
+  ac_cv_prog_ac_ct_OTOOL="$ac_ct_OTOOL" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_OTOOL="otool"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL=$ac_cv_prog_ac_ct_OTOOL
+if test -n "$ac_ct_OTOOL"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL" >&5
+$as_echo "$ac_ct_OTOOL" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL" = x; then
+    OTOOL=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL=$ac_ct_OTOOL
+  fi
+else
+  OTOOL="$ac_cv_prog_OTOOL"
+fi
+
+    if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
+set dummy ${ac_tool_prefix}otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_OTOOL64+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$OTOOL64"; then
+  ac_cv_prog_OTOOL64="$OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+OTOOL64=$ac_cv_prog_OTOOL64
+if test -n "$OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $OTOOL64" >&5
+$as_echo "$OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_OTOOL64"; then
+  ac_ct_OTOOL64=$OTOOL64
+  # Extract the first word of "otool64", so it can be a program name with args.
+set dummy otool64; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_OTOOL64+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_OTOOL64"; then
+  ac_cv_prog_ac_ct_OTOOL64="$ac_ct_OTOOL64" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_OTOOL64="otool64"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_OTOOL64=$ac_cv_prog_ac_ct_OTOOL64
+if test -n "$ac_ct_OTOOL64"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_OTOOL64" >&5
+$as_echo "$ac_ct_OTOOL64" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_OTOOL64" = x; then
+    OTOOL64=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    OTOOL64=$ac_ct_OTOOL64
+  fi
+else
+  OTOOL64="$ac_cv_prog_OTOOL64"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -single_module linker flag" >&5
+$as_echo_n "checking for -single_module linker flag... " >&6; }
+if ${lt_cv_apple_cc_single_mod+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_apple_cc_single_mod=no
+      if test -z "${LT_MULTI_MODULE}"; then
+	# By default we will add the -single_module flag. You can override
+	# by either setting the environment variable LT_MULTI_MODULE
+	# non-empty at configure time, or by adding -multi_module to the
+	# link flags.
+	rm -rf libconftest.dylib*
+	echo "int foo(void){return 1;}" > conftest.c
+	echo "$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+-dynamiclib -Wl,-single_module conftest.c" >&5
+	$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \
+	  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err
+        _lt_result=$?
+	# If there is a non-empty error log, and "single_module"
+	# appears in it, assume the flag caused a linker warning
+        if test -s conftest.err && $GREP single_module conftest.err; then
+	  cat conftest.err >&5
+	# Otherwise, if the output was created with a 0 exit code from
+	# the compiler, it worked.
+	elif test -f libconftest.dylib && test $_lt_result -eq 0; then
+	  lt_cv_apple_cc_single_mod=yes
+	else
+	  cat conftest.err >&5
+	fi
+	rm -rf libconftest.dylib*
+	rm -f conftest.*
+      fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_apple_cc_single_mod" >&5
+$as_echo "$lt_cv_apple_cc_single_mod" >&6; }
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
+$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
+if ${lt_cv_ld_exported_symbols_list+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_exported_symbols_list=no
+      save_LDFLAGS=$LDFLAGS
+      echo "_main" > conftest.sym
+      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_ld_exported_symbols_list=yes
+else
+  lt_cv_ld_exported_symbols_list=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+	LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
+$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -force_load linker flag" >&5
+$as_echo_n "checking for -force_load linker flag... " >&6; }
+if ${lt_cv_ld_force_load+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_ld_force_load=no
+      cat > conftest.c << _LT_EOF
+int forced_loaded() { return 2;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS -c -o conftest.o conftest.c" >&5
+      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&5
+      echo "$AR cru libconftest.a conftest.o" >&5
+      $AR cru libconftest.a conftest.o 2>&5
+      echo "$RANLIB libconftest.a" >&5
+      $RANLIB libconftest.a 2>&5
+      cat > conftest.c << _LT_EOF
+int main() { return 0;}
+_LT_EOF
+      echo "$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a" >&5
+      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err
+      _lt_result=$?
+      if test -s conftest.err && $GREP force_load conftest.err; then
+	cat conftest.err >&5
+      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then
+	lt_cv_ld_force_load=yes
+      else
+	cat conftest.err >&5
+      fi
+        rm -f conftest.err libconftest.a conftest conftest.c
+        rm -rf conftest.dSYM
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_force_load" >&5
+$as_echo "$lt_cv_ld_force_load" >&6; }
+    case $host_os in
+    rhapsody* | darwin1.[012])
+      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;
+    darwin1.*)
+      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+    darwin*) # darwin 5.x on
+      # if running on 10.5 or later, the deployment target defaults
+      # to the OS version, if on x86, and 10.4, the deployment
+      # target defaults to 10.4. Don't you love it?
+      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in
+	10.0,*86*-darwin8*|10.0,*-darwin[91]*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+	10.[012]*)
+	  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;
+	10.*)
+	  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;
+      esac
+    ;;
+  esac
+    if test "$lt_cv_apple_cc_single_mod" = "yes"; then
+      _lt_dar_single_mod='$single_module'
+    fi
+    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
+      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
+    else
+      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
+    fi
+    if test "$DSYMUTIL" != ":" && test "$lt_cv_ld_force_load" = "no"; then
+      _lt_dsymutil='~$DSYMUTIL $lib || :'
+    else
+      _lt_dsymutil=
+    fi
+    ;;
+  esac
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking how to run the C preprocessor" >&5
+$as_echo_n "checking how to run the C preprocessor... " >&6; }
+# On Suns, sometimes $CPP names a directory.
+if test -n "$CPP" && test -d "$CPP"; then
+  CPP=
+fi
+if test -z "$CPP"; then
+  if ${ac_cv_prog_CPP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+      # Double quotes because CPP needs to be expanded
+    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+  break
+fi
+
+    done
+    ac_cv_prog_CPP=$CPP
+
+fi
+  CPP=$ac_cv_prog_CPP
+else
+  ac_cv_prog_CPP=$CPP
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $CPP" >&5
+$as_echo "$CPP" >&6; }
+ac_preproc_ok=false
+for ac_c_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+
+else
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether nonexistent headers
+  # can be detected and how.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if ac_fn_c_try_cpp "$LINENO"; then :
+  # Broken: success on invalid input.
+continue
+else
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.i conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.i conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then :
+
+else
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "C preprocessor \"$CPP\" fails sanity check
+See \`config.log' for more details" "$LINENO" 5; }
+fi
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for ANSI C header files" >&5
+$as_echo_n "checking for ANSI C header files... " >&6; }
+if ${ac_cv_header_stdc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_header_stdc=yes
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <string.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then :
+  :
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <ctype.h>
+#include <stdlib.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) \
+		   (('a' <= (c) && (c) <= 'i') \
+		     || ('j' <= (c) && (c) <= 'r') \
+		     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+	|| toupper (i) != TOUPPER (i))
+      return 2;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+
+else
+  ac_cv_header_stdc=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_header_stdc" >&5
+$as_echo "$ac_cv_header_stdc" >&6; }
+if test $ac_cv_header_stdc = yes; then
+
+$as_echo "#define STDC_HEADERS 1" >>confdefs.h
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+		  inttypes.h stdint.h unistd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_compile "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default
+"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_header in dlfcn.h
+do :
+  ac_fn_c_check_header_compile "$LINENO" "dlfcn.h" "ac_cv_header_dlfcn_h" "$ac_includes_default
+"
+if test "x$ac_cv_header_dlfcn_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DLFCN_H 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+# Set options
+
+
+
+        enable_dlopen=no
+
+
+  enable_win32_dll=no
+
+
+            # Check whether --enable-shared was given.
+if test "${enable_shared+set}" = set; then :
+  enableval=$enable_shared; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_shared=yes ;;
+    no) enable_shared=no ;;
+    *)
+      enable_shared=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_shared=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_shared=yes
+fi
+
+
+
+
+
+
+
+
+
+  # Check whether --enable-static was given.
+if test "${enable_static+set}" = set; then :
+  enableval=$enable_static; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_static=yes ;;
+    no) enable_static=no ;;
+    *)
+     enable_static=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_static=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_static=yes
+fi
+
+
+
+
+
+
+
+
+
+
+# Check whether --with-pic was given.
+if test "${with_pic+set}" = set; then :
+  withval=$with_pic; lt_p=${PACKAGE-default}
+    case $withval in
+    yes|no) pic_mode=$withval ;;
+    *)
+      pic_mode=default
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for lt_pkg in $withval; do
+	IFS="$lt_save_ifs"
+	if test "X$lt_pkg" = "X$lt_p"; then
+	  pic_mode=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  pic_mode=default
+fi
+
+
+test -z "$pic_mode" && pic_mode=default
+
+
+
+
+
+
+
+  # Check whether --enable-fast-install was given.
+if test "${enable_fast_install+set}" = set; then :
+  enableval=$enable_fast_install; p=${PACKAGE-default}
+    case $enableval in
+    yes) enable_fast_install=yes ;;
+    no) enable_fast_install=no ;;
+    *)
+      enable_fast_install=no
+      # Look at the argument we got.  We use all the common list separators.
+      lt_save_ifs="$IFS"; IFS="${IFS}$PATH_SEPARATOR,"
+      for pkg in $enableval; do
+	IFS="$lt_save_ifs"
+	if test "X$pkg" = "X$p"; then
+	  enable_fast_install=yes
+	fi
+      done
+      IFS="$lt_save_ifs"
+      ;;
+    esac
+else
+  enable_fast_install=yes
+fi
+
+
+
+
+
+
+
+
+
+
+
+# This can be used to rebuild libtool when needed
+LIBTOOL_DEPS="$ltmain"
+
+# Always use our own libtool.
+LIBTOOL='$(SHELL) $(top_builddir)/libtool'
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+test -z "$LN_S" && LN_S="ln -s"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+if test -n "${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for objdir" >&5
+$as_echo_n "checking for objdir... " >&6; }
+if ${lt_cv_objdir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  rm -f .libs 2>/dev/null
+mkdir .libs 2>/dev/null
+if test -d .libs; then
+  lt_cv_objdir=.libs
+else
+  # MS-DOS does not allow filenames that begin with a dot.
+  lt_cv_objdir=_libs
+fi
+rmdir .libs 2>/dev/null
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_objdir" >&5
+$as_echo "$lt_cv_objdir" >&6; }
+objdir=$lt_cv_objdir
+
+
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define LT_OBJDIR "$lt_cv_objdir/"
+_ACEOF
+
+
+
+
+case $host_os in
+aix3*)
+  # AIX sometimes has problems with the GCC collect2 program.  For some
+  # reason, if we set the COLLECT_NAMES environment variable, the problems
+  # vanish in a puff of smoke.
+  if test "X${COLLECT_NAMES+set}" != Xset; then
+    COLLECT_NAMES=
+    export COLLECT_NAMES
+  fi
+  ;;
+esac
+
+# Global variables:
+ofile=libtool
+can_build_shared=yes
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+
+with_gnu_ld="$lt_cv_prog_gnu_ld"
+
+old_CC="$CC"
+old_CFLAGS="$CFLAGS"
+
+# Set sane defaults for various variables
+test -z "$CC" && CC=cc
+test -z "$LTCC" && LTCC=$CC
+test -z "$LTCFLAGS" && LTCFLAGS=$CFLAGS
+test -z "$LD" && LD=ld
+test -z "$ac_objext" && ac_objext=o
+
+for cc_temp in $compiler""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`$ECHO "$cc_temp" | $SED "s%.*/%%; s%^$host_alias-%%"`
+
+
+# Only perform the check for file, if the check method requires it
+test -z "$MAGIC_CMD" && MAGIC_CMD=file
+case $deplibs_check_method in
+file_magic*)
+  if test "$file_magic_cmd" = '$MAGIC_CMD'; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
+$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
+if ${lt_cv_path_MAGIC_CMD+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/${ac_tool_prefix}file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+
+
+if test -z "$lt_cv_path_MAGIC_CMD"; then
+  if test -n "$ac_tool_prefix"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for file" >&5
+$as_echo_n "checking for file... " >&6; }
+if ${lt_cv_path_MAGIC_CMD+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  case $MAGIC_CMD in
+[\\/*] |  ?:[\\/]*)
+  lt_cv_path_MAGIC_CMD="$MAGIC_CMD" # Let the user override the test with a path.
+  ;;
+*)
+  lt_save_MAGIC_CMD="$MAGIC_CMD"
+  lt_save_ifs="$IFS"; IFS=$PATH_SEPARATOR
+  ac_dummy="/usr/bin$PATH_SEPARATOR$PATH"
+  for ac_dir in $ac_dummy; do
+    IFS="$lt_save_ifs"
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/file; then
+      lt_cv_path_MAGIC_CMD="$ac_dir/file"
+      if test -n "$file_magic_test_file"; then
+	case $deplibs_check_method in
+	"file_magic "*)
+	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
+	  MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+	  if eval $file_magic_cmd \$file_magic_test_file 2> /dev/null |
+	    $EGREP "$file_magic_regex" > /dev/null; then
+	    :
+	  else
+	    cat <<_LT_EOF 1>&2
+
+*** Warning: the command libtool uses to detect shared libraries,
+*** $file_magic_cmd, produces output that libtool cannot recognize.
+*** The result is that libtool may fail to recognize shared libraries
+*** as such.  This will affect the creation of libtool libraries that
+*** depend on shared libraries, but programs linked with such libtool
+*** libraries will work regardless of this problem.  Nevertheless, you
+*** may want to report the problem to your system manager and/or to
+*** bug-libtool@gnu.org
+
+_LT_EOF
+	  fi ;;
+	esac
+      fi
+      break
+    fi
+  done
+  IFS="$lt_save_ifs"
+  MAGIC_CMD="$lt_save_MAGIC_CMD"
+  ;;
+esac
+fi
+
+MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
+if test -n "$MAGIC_CMD"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $MAGIC_CMD" >&5
+$as_echo "$MAGIC_CMD" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  else
+    MAGIC_CMD=:
+  fi
+fi
+
+  fi
+  ;;
+esac
+
+# Use C for the default configuration in the libtool script
+
+lt_save_CC="$CC"
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+# Source file extension for C test sources.
+ac_ext=c
+
+# Object file extension for compiled C test sources.
+objext=o
+objext=$objext
+
+# Code to be used in simple compile tests
+lt_simple_compile_test_code="int some_variable = 0;"
+
+# Code to be used in simple link tests
+lt_simple_link_test_code='int main(){return(0);}'
+
+
+
+
+
+
+
+# If no C compiler was specified, use CC.
+LTCC=${LTCC-"$CC"}
+
+# If no C compiler flags were specified, use CFLAGS.
+LTCFLAGS=${LTCFLAGS-"$CFLAGS"}
+
+# Allow CC to be a program name with arguments.
+compiler=$CC
+
+# Save the default compiler, since it gets overwritten when the other
+# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.
+compiler_DEFAULT=$CC
+
+# save warnings/boilerplate of simple test code
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_compile_test_code" >conftest.$ac_ext
+eval "$ac_compile" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_compiler_boilerplate=`cat conftest.err`
+$RM conftest*
+
+ac_outfile=conftest.$ac_objext
+echo "$lt_simple_link_test_code" >conftest.$ac_ext
+eval "$ac_link" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err
+_lt_linker_boilerplate=`cat conftest.err`
+$RM -r conftest*
+
+
+if test -n "$compiler"; then
+
+lt_prog_compiler_no_builtin_flag=
+
+if test "$GCC" = yes; then
+  case $cc_basename in
+  nvcc*)
+    lt_prog_compiler_no_builtin_flag=' -Xcompiler -fno-builtin' ;;
+  *)
+    lt_prog_compiler_no_builtin_flag=' -fno-builtin' ;;
+  esac
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
+if ${lt_cv_prog_compiler_rtti_exceptions+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_rtti_exceptions=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="-fno-rtti -fno-exceptions"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_rtti_exceptions=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
+$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
+
+if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
+    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
+else
+    :
+fi
+
+fi
+
+
+
+
+
+
+  lt_prog_compiler_wl=
+lt_prog_compiler_pic=
+lt_prog_compiler_static=
+
+
+  if test "$GCC" = yes; then
+    lt_prog_compiler_wl='-Wl,'
+    lt_prog_compiler_static='-static'
+
+    case $host_os in
+      aix*)
+      # All AIX code is PIC.
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            lt_prog_compiler_pic='-fPIC'
+        ;;
+      m68k)
+            # FIXME: we need at least 68020 code to build shared libraries, but
+            # adding the `-m68020' flag to GCC prevents building anything better,
+            # like `-m68040'.
+            lt_prog_compiler_pic='-m68020 -resident32 -malways-restore-a4'
+        ;;
+      esac
+      ;;
+
+    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
+      # PIC is the default for these OSes.
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      # Although the cygwin gcc ignores -fPIC, still need this for old-style
+      # (--disable-auto-import) libraries
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    darwin* | rhapsody*)
+      # PIC is the default on this platform
+      # Common symbols not allowed in MH_DYLIB files
+      lt_prog_compiler_pic='-fno-common'
+      ;;
+
+    haiku*)
+      # PIC is the default for Haiku.
+      # The "-static" flag exists, but is broken.
+      lt_prog_compiler_static=
+      ;;
+
+    hpux*)
+      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit
+      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag
+      # sets the default TLS model and affects inlining.
+      case $host_cpu in
+      hppa*64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='-fPIC'
+	;;
+      esac
+      ;;
+
+    interix[3-9]*)
+      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
+      # Instead, we relocate shared libraries at runtime.
+      ;;
+
+    msdosdjgpp*)
+      # Just because we use GCC doesn't mean we suddenly get shared libraries
+      # on systems that don't support them.
+      lt_prog_compiler_can_build_shared=no
+      enable_shared=no
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	lt_prog_compiler_pic=-Kconform_pic
+      fi
+      ;;
+
+    *)
+      lt_prog_compiler_pic='-fPIC'
+      ;;
+    esac
+
+    case $cc_basename in
+    nvcc*) # Cuda Compiler Driver 2.2
+      lt_prog_compiler_wl='-Xlinker '
+      if test -n "$lt_prog_compiler_pic"; then
+        lt_prog_compiler_pic="-Xcompiler $lt_prog_compiler_pic"
+      fi
+      ;;
+    esac
+  else
+    # PORTME Check for flag to pass linker flags through the system compiler.
+    case $host_os in
+    aix*)
+      lt_prog_compiler_wl='-Wl,'
+      if test "$host_cpu" = ia64; then
+	# AIX 5 now supports IA64 processor
+	lt_prog_compiler_static='-Bstatic'
+      else
+	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
+      fi
+      ;;
+
+    mingw* | cygwin* | pw32* | os2* | cegcc*)
+      # This hack is so that the source file can tell whether it is being
+      # built for inclusion in a dll (and should export symbols for example).
+      lt_prog_compiler_pic='-DDLL_EXPORT'
+      ;;
+
+    hpux9* | hpux10* | hpux11*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but
+      # not for PA HP-UX.
+      case $host_cpu in
+      hppa*64*|ia64*)
+	# +Z the default
+	;;
+      *)
+	lt_prog_compiler_pic='+Z'
+	;;
+      esac
+      # Is there a better lt_prog_compiler_static that works with the bundled CC?
+      lt_prog_compiler_static='${wl}-a ${wl}archive'
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      lt_prog_compiler_wl='-Wl,'
+      # PIC (with -KPIC) is the default.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+      case $cc_basename in
+      # old Intel for x86_64 which still supported -KPIC.
+      ecc*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-KPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # icc used to be incompatible with GCC.
+      # ICC 10 doesn't accept -KPIC any more.
+      icc* | ifort*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fPIC'
+	lt_prog_compiler_static='-static'
+        ;;
+      # Lahey Fortran 8.1.
+      lf95*)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='--shared'
+	lt_prog_compiler_static='--static'
+	;;
+      nagfor*)
+	# NAG Fortran compiler
+	lt_prog_compiler_wl='-Wl,-Wl,,'
+	lt_prog_compiler_pic='-PIC'
+	lt_prog_compiler_static='-Bstatic'
+	;;
+      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)
+        # Portland Group compilers (*not* the Pentium gcc compiler,
+	# which looks to be a dead project)
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-fpic'
+	lt_prog_compiler_static='-Bstatic'
+        ;;
+      ccc*)
+        lt_prog_compiler_wl='-Wl,'
+        # All Alpha code is PIC.
+        lt_prog_compiler_static='-non_shared'
+        ;;
+      xl* | bgxl* | bgf* | mpixl*)
+	# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene
+	lt_prog_compiler_wl='-Wl,'
+	lt_prog_compiler_pic='-qpic'
+	lt_prog_compiler_static='-qstaticlink'
+	;;
+      *)
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ Ceres\ Fortran* | *Sun*Fortran*\ [1-7].* | *Sun*Fortran*\ 8.[0-3]*)
+	  # Sun Fortran 8.3 passes all unrecognized flags to the linker
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl=''
+	  ;;
+	*Sun\ F* | *Sun*Fortran*)
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Qoption ld '
+	  ;;
+	*Sun\ C*)
+	  # Sun C 5.9
+	  lt_prog_compiler_pic='-KPIC'
+	  lt_prog_compiler_static='-Bstatic'
+	  lt_prog_compiler_wl='-Wl,'
+	  ;;
+        *Intel*\ [CF]*Compiler*)
+	  lt_prog_compiler_wl='-Wl,'
+	  lt_prog_compiler_pic='-fPIC'
+	  lt_prog_compiler_static='-static'
+	  ;;
+	*Portland\ Group*)
+	  lt_prog_compiler_wl='-Wl,'
+	  lt_prog_compiler_pic='-fpic'
+	  lt_prog_compiler_static='-Bstatic'
+	  ;;
+	esac
+	;;
+      esac
+      ;;
+
+    newsos6)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *nto* | *qnx*)
+      # QNX uses GNU C++, but need to define -shared option too, otherwise
+      # it will coredump.
+      lt_prog_compiler_pic='-fPIC -shared'
+      ;;
+
+    osf3* | osf4* | osf5*)
+      lt_prog_compiler_wl='-Wl,'
+      # All OSF/1 code is PIC.
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    rdos*)
+      lt_prog_compiler_static='-non_shared'
+      ;;
+
+    solaris*)
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      case $cc_basename in
+      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)
+	lt_prog_compiler_wl='-Qoption ld ';;
+      *)
+	lt_prog_compiler_wl='-Wl,';;
+      esac
+      ;;
+
+    sunos4*)
+      lt_prog_compiler_wl='-Qoption ld '
+      lt_prog_compiler_pic='-PIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec ;then
+	lt_prog_compiler_pic='-Kconform_pic'
+	lt_prog_compiler_static='-Bstatic'
+      fi
+      ;;
+
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_pic='-KPIC'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    unicos*)
+      lt_prog_compiler_wl='-Wl,'
+      lt_prog_compiler_can_build_shared=no
+      ;;
+
+    uts4*)
+      lt_prog_compiler_pic='-pic'
+      lt_prog_compiler_static='-Bstatic'
+      ;;
+
+    *)
+      lt_prog_compiler_can_build_shared=no
+      ;;
+    esac
+  fi
+
+case $host_os in
+  # For platforms which do not support PIC, -DPIC is meaningless:
+  *djgpp*)
+    lt_prog_compiler_pic=
+    ;;
+  *)
+    lt_prog_compiler_pic="$lt_prog_compiler_pic -DPIC"
+    ;;
+esac
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $compiler option to produce PIC" >&5
+$as_echo_n "checking for $compiler option to produce PIC... " >&6; }
+if ${lt_cv_prog_compiler_pic+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic=$lt_prog_compiler_pic
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic" >&5
+$as_echo "$lt_cv_prog_compiler_pic" >&6; }
+lt_prog_compiler_pic=$lt_cv_prog_compiler_pic
+
+#
+# Check to make sure the PIC flag actually works.
+#
+if test -n "$lt_prog_compiler_pic"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler PIC flag $lt_prog_compiler_pic works" >&5
+$as_echo_n "checking if $compiler PIC flag $lt_prog_compiler_pic works... " >&6; }
+if ${lt_cv_prog_compiler_pic_works+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_pic_works=no
+   ac_outfile=conftest.$ac_objext
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+   lt_compiler_flag="$lt_prog_compiler_pic -DPIC"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   # The option is referenced via a variable to avoid confusing sed.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>conftest.err)
+   ac_status=$?
+   cat conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s "$ac_outfile"; then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings other than the usual output.
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
+     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_pic_works=yes
+     fi
+   fi
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_pic_works" >&5
+$as_echo "$lt_cv_prog_compiler_pic_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
+    case $lt_prog_compiler_pic in
+     "" | " "*) ;;
+     *) lt_prog_compiler_pic=" $lt_prog_compiler_pic" ;;
+     esac
+else
+    lt_prog_compiler_pic=
+     lt_prog_compiler_can_build_shared=no
+fi
+
+fi
+
+
+
+
+
+
+
+
+
+
+
+#
+# Check to make sure the static flag actually works.
+#
+wl=$lt_prog_compiler_wl eval lt_tmp_static_flag=\"$lt_prog_compiler_static\"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler static flag $lt_tmp_static_flag works" >&5
+$as_echo_n "checking if $compiler static flag $lt_tmp_static_flag works... " >&6; }
+if ${lt_cv_prog_compiler_static_works+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_static_works=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS $lt_tmp_static_flag"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler_static_works=yes
+       fi
+     else
+       lt_cv_prog_compiler_static_works=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_static_works" >&5
+$as_echo "$lt_cv_prog_compiler_static_works" >&6; }
+
+if test x"$lt_cv_prog_compiler_static_works" = xyes; then
+    :
+else
+    lt_prog_compiler_static=
+fi
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if ${lt_cv_prog_compiler_c_o+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
+$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
+if ${lt_cv_prog_compiler_c_o+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler_c_o=no
+   $RM -r conftest 2>/dev/null
+   mkdir conftest
+   cd conftest
+   mkdir out
+   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+   lt_compiler_flag="-o out/conftest2.$ac_objext"
+   # Insert the option either (1) after the last *FLAGS variable, or
+   # (2) before a word containing "conftest.", or (3) at the end.
+   # Note that $ac_compile itself does not contain backslashes and begins
+   # with a dollar sign (not a hyphen), so the echo should work correctly.
+   lt_compile=`echo "$ac_compile" | $SED \
+   -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
+   -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
+   -e 's:$: $lt_compiler_flag:'`
+   (eval echo "\"\$as_me:$LINENO: $lt_compile\"" >&5)
+   (eval "$lt_compile" 2>out/conftest.err)
+   ac_status=$?
+   cat out/conftest.err >&5
+   echo "$as_me:$LINENO: \$? = $ac_status" >&5
+   if (exit $ac_status) && test -s out/conftest2.$ac_objext
+   then
+     # The compiler can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
+     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
+     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
+       lt_cv_prog_compiler_c_o=yes
+     fi
+   fi
+   chmod u+w . 2>&5
+   $RM conftest*
+   # SGI C++ compiler will create directory out/ii_files/ for
+   # template instantiation
+   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files
+   $RM out/* && rmdir out
+   cd ..
+   $RM -r conftest
+   $RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_c_o" >&5
+$as_echo "$lt_cv_prog_compiler_c_o" >&6; }
+
+
+
+
+hard_links="nottested"
+if test "$lt_cv_prog_compiler_c_o" = no && test "$need_locks" != no; then
+  # do not overwrite the value of need_locks provided by the user
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can lock with hard links" >&5
+$as_echo_n "checking if we can lock with hard links... " >&6; }
+  hard_links=yes
+  $RM conftest*
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  touch conftest.a
+  ln conftest.a conftest.b 2>&5 || hard_links=no
+  ln conftest.a conftest.b 2>/dev/null && hard_links=no
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $hard_links" >&5
+$as_echo "$hard_links" >&6; }
+  if test "$hard_links" = no; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+$as_echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
+    need_locks=warn
+  fi
+else
+  need_locks=no
+fi
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $compiler linker ($LD) supports shared libraries" >&5
+$as_echo_n "checking whether the $compiler linker ($LD) supports shared libraries... " >&6; }
+
+  runpath_var=
+  allow_undefined_flag=
+  always_export_symbols=no
+  archive_cmds=
+  archive_expsym_cmds=
+  compiler_needs_object=no
+  enable_shared_with_static_runtimes=no
+  export_dynamic_flag_spec=
+  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
+  hardcode_automatic=no
+  hardcode_direct=no
+  hardcode_direct_absolute=no
+  hardcode_libdir_flag_spec=
+  hardcode_libdir_separator=
+  hardcode_minus_L=no
+  hardcode_shlibpath_var=unsupported
+  inherit_rpath=no
+  link_all_deplibs=unknown
+  module_cmds=
+  module_expsym_cmds=
+  old_archive_from_new_cmds=
+  old_archive_from_expsyms_cmds=
+  thread_safe_flag_spec=
+  whole_archive_flag_spec=
+  # include_expsyms should be a list of space-separated symbols to be *always*
+  # included in the symbol list
+  include_expsyms=
+  # exclude_expsyms can be an extended regexp of symbols to exclude
+  # it will be wrapped by ` (' and `)$', so one must not match beginning or
+  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
+  # as well as any symbol that contains `d'.
+  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
+  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out
+  # platforms (ab)use it in PIC code, but their linkers get confused if
+  # the symbol is explicitly referenced.  Since portable code cannot
+  # rely on this symbol name, it's probably fine to never include it in
+  # preloaded symbol tables.
+  # Exclude shared library initialization/finalization symbols.
+  extract_expsyms_cmds=
+
+  case $host_os in
+  cygwin* | mingw* | pw32* | cegcc*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+  linux* | k*bsd*-gnu | gnu*)
+    link_all_deplibs=no
+    ;;
+  esac
+
+  ld_shlibs=yes
+
+  # On some targets, GNU ld is compatible enough with the native linker
+  # that we're better off using the native interface for both.
+  lt_use_gnu_ld_interface=no
+  if test "$with_gnu_ld" = yes; then
+    case $host_os in
+      aix*)
+	# The AIX port of GNU ld has always aspired to compatibility
+	# with the native linker.  However, as the warning in the GNU ld
+	# block says, versions before 2.19.5* couldn't really create working
+	# shared libraries, regardless of the interface used.
+	case `$LD -v 2>&1` in
+	  *\ \(GNU\ Binutils\)\ 2.19.5*) ;;
+	  *\ \(GNU\ Binutils\)\ 2.[2-9]*) ;;
+	  *\ \(GNU\ Binutils\)\ [3-9]*) ;;
+	  *)
+	    lt_use_gnu_ld_interface=yes
+	    ;;
+	esac
+	;;
+      *)
+	lt_use_gnu_ld_interface=yes
+	;;
+    esac
+  fi
+
+  if test "$lt_use_gnu_ld_interface" = yes; then
+    # If archive_cmds runs LD, not CC, wlarc should be empty
+    wlarc='${wl}'
+
+    # Set some defaults for GNU ld with shared library support. These
+    # are reset later if shared libraries are not supported. Putting them
+    # here allows them to be overridden if necessary.
+    runpath_var=LD_RUN_PATH
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+    export_dynamic_flag_spec='${wl}--export-dynamic'
+    # ancient GNU ld didn't support --whole-archive et. al.
+    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then
+      whole_archive_flag_spec="$wlarc"'--whole-archive$convenience '"$wlarc"'--no-whole-archive'
+    else
+      whole_archive_flag_spec=
+    fi
+    supports_anon_versioning=no
+    case `$LD -v 2>&1` in
+      *GNU\ gold*) supports_anon_versioning=yes ;;
+      *\ [01].* | *\ 2.[0-9].* | *\ 2.10.*) ;; # catch versions < 2.11
+      *\ 2.11.93.0.2\ *) supports_anon_versioning=yes ;; # RH7.3 ...
+      *\ 2.11.92.0.12\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...
+      *\ 2.11.*) ;; # other 2.11 versions
+      *) supports_anon_versioning=yes ;;
+    esac
+
+    # See if GNU ld supports shared libraries.
+    case $host_os in
+    aix[3-9]*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: the GNU linker, at least up to release 2.19, is reported
+*** to be unable to reliably create shared libraries on AIX.
+*** Therefore, libtool is disabling shared libraries support.  If you
+*** really care for shared libraries, you may want to install binutils
+*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.
+*** You will then need to restart the configuration process.
+
+_LT_EOF
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    beos*)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	allow_undefined_flag=unsupported
+	# Joseph Beckenbach <jrb3@best.com> says some releases of gcc
+	# support --undefined.  This deserves some investigation.  FIXME
+	archive_cmds='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # _LT_TAGVAR(hardcode_libdir_flag_spec, ) is actually meaningless,
+      # as there is no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      export_dynamic_flag_spec='${wl}--export-all-symbols'
+      allow_undefined_flag=unsupported
+      always_export_symbols=no
+      enable_shared_with_static_runtimes=yes
+      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
+      exclude_expsyms='[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname'
+
+      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then
+        archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+	# If the export-symbols file already is a .def file (1st line
+	# is EXPORTS), use it as is; otherwise, prepend...
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	  cp $export_symbols $output_objdir/$soname.def;
+	else
+	  echo EXPORTS > $output_objdir/$soname.def;
+	  cat $export_symbols >> $output_objdir/$soname.def;
+	fi~
+	$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    haiku*)
+      archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+      link_all_deplibs=yes
+      ;;
+
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      export_dynamic_flag_spec='${wl}-E'
+      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
+      # Instead, shared libraries are loaded at an image base (0x10000000 by
+      # default) and relocated if they conflict, which is a slow very memory
+      # consuming and fragmenting process.  To avoid this, we pick a random,
+      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
+      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
+      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
+      ;;
+
+    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
+      tmp_diet=no
+      if test "$host_os" = linux-dietlibc; then
+	case $cc_basename in
+	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
+	esac
+      fi
+      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \
+	 && test "$tmp_diet" = no
+      then
+	tmp_addflag=' $pic_flag'
+	tmp_sharedflag='-shared'
+	case $cc_basename,$host_cpu in
+        pgcc*)				# Portland Group C compiler
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag'
+	  ;;
+	pgf77* | pgf90* | pgf95* | pgfortran*)
+					# Portland Group f77 and f90 compilers
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  tmp_addflag=' $pic_flag -Mnomain' ;;
+	ecc*,ia64* | icc*,ia64*)	# Intel C compiler on ia64
+	  tmp_addflag=' -i_dynamic' ;;
+	efc*,ia64* | ifort*,ia64*)	# Intel Fortran compiler on ia64
+	  tmp_addflag=' -i_dynamic -nofor_main' ;;
+	ifc* | ifort*)			# Intel Fortran compiler
+	  tmp_addflag=' -nofor_main' ;;
+	lf95*)				# Lahey Fortran 8.1
+	  whole_archive_flag_spec=
+	  tmp_sharedflag='--shared' ;;
+	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
+	  tmp_sharedflag='-qmkshrobj'
+	  tmp_addflag= ;;
+	nvcc*)	# Cuda Compiler Driver 2.2
+	  whole_archive_flag_spec='${wl}--whole-archive`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  ;;
+	esac
+	case `$CC -V 2>&1 | sed 5q` in
+	*Sun\ C*)			# Sun C 5.9
+	  whole_archive_flag_spec='${wl}--whole-archive`new_convenience=; for conv in $convenience\"\"; do test -z \"$conv\" || new_convenience=\"$new_convenience,$conv\"; done; func_echo_all \"$new_convenience\"` ${wl}--no-whole-archive'
+	  compiler_needs_object=yes
+	  tmp_sharedflag='-G' ;;
+	*Sun\ F*)			# Sun Fortran 8.3
+	  tmp_sharedflag='-G' ;;
+	esac
+	archive_cmds='$CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+
+        if test "x$supports_anon_versioning" = xyes; then
+          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	    echo "local: *; };" >> $output_objdir/$libname.ver~
+	    $CC '"$tmp_sharedflag""$tmp_addflag"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'
+        fi
+
+	case $cc_basename in
+	xlf* | bgf* | bgxlf* | mpixlf*)
+	  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself
+	  whole_archive_flag_spec='--whole-archive$convenience --no-whole-archive'
+	  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	  archive_cmds='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'
+	  if test "x$supports_anon_versioning" = xyes; then
+	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
+	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
+	      echo "local: *; };" >> $output_objdir/$libname.ver~
+	      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'
+	  fi
+	  ;;
+	esac
+      else
+        ld_shlibs=no
+      fi
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'
+	wlarc=
+      else
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      fi
+      ;;
+
+    solaris*)
+      if $LD -v 2>&1 | $GREP 'BFD 2\.8' > /dev/null; then
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: The releases 2.8.* of the GNU linker cannot reliably
+*** create shared libraries on Solaris systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.9.1 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+	ld_shlibs=no
+	cat <<_LT_EOF 1>&2
+
+*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not
+*** reliably create shared libraries on SCO systems.  Therefore, libtool
+*** is disabling shared libraries support.  We urge you to upgrade GNU
+*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify
+*** your PATH or compiler configuration so that the native linker is
+*** used, and then restart.
+
+_LT_EOF
+	;;
+	*)
+	  # For security reasons, it is highly recommended that you always
+	  # use absolute paths for naming shared libraries, and exclude the
+	  # DT_RUNPATH tag from executables and libraries.  But doing so
+	  # requires that you compile everything twice, which is a pain.
+	  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+	    archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+	  else
+	    ld_shlibs=no
+	  fi
+	;;
+      esac
+      ;;
+
+    sunos4*)
+      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      wlarc=
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
+      else
+	ld_shlibs=no
+      fi
+      ;;
+    esac
+
+    if test "$ld_shlibs" = no; then
+      runpath_var=
+      hardcode_libdir_flag_spec=
+      export_dynamic_flag_spec=
+      whole_archive_flag_spec=
+    fi
+  else
+    # PORTME fill in a description of your system's linker (not GNU ld)
+    case $host_os in
+    aix3*)
+      allow_undefined_flag=unsupported
+      always_export_symbols=yes
+      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes && test -z "$lt_prog_compiler_static"; then
+	# Neither direct hardcoding nor static linking is supported with a
+	# broken collect2.
+	hardcode_direct=unsupported
+      fi
+      ;;
+
+    aix[4-9]*)
+      if test "$host_cpu" = ia64; then
+	# On IA64, the linker does run time linking by default, so we don't
+	# have to do anything special.
+	aix_use_runtimelinking=no
+	exp_sym_flag='-Bexport'
+	no_entry_flag=""
+      else
+	# If we're using GNU nm, then we don't want the "-C" option.
+	# -C means demangle to AIX nm, but means don't demangle with GNU nm
+	# Also, AIX nm treats weak defined symbols like other global
+	# defined symbols, whereas GNU nm marks them as "W".
+	if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then
+	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	else
+	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
+	fi
+	aix_use_runtimelinking=no
+
+	# Test if we are trying to use run time linking or normal
+	# AIX style linking. If -brtl is somewhere in LDFLAGS, we
+	# need to do runtime linking.
+	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
+	  for ld_flag in $LDFLAGS; do
+	  if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+	    aix_use_runtimelinking=yes
+	    break
+	  fi
+	  done
+	  ;;
+	esac
+
+	exp_sym_flag='-bexport'
+	no_entry_flag='-bnoentry'
+      fi
+
+      # When large executables or shared objects are built, AIX ld can
+      # have problems creating the table of contents.  If linking a library
+      # or program results in "error TOC overflow" add -mminimal-toc to
+      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not
+      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
+
+      archive_cmds=''
+      hardcode_direct=yes
+      hardcode_direct_absolute=yes
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      file_list_spec='${wl}-f,'
+
+      if test "$GCC" = yes; then
+	case $host_os in aix4.[012]|aix4.[012].*)
+	# We only want to do this on AIX 4.2 and lower, the check
+	# below for broken collect2 doesn't work under 4.3+
+	  collect2name=`${CC} -print-prog-name=collect2`
+	  if test -f "$collect2name" &&
+	   strings "$collect2name" | $GREP resolve_lib_name >/dev/null
+	  then
+	  # We have reworked collect2
+	  :
+	  else
+	  # We have old collect2
+	  hardcode_direct=unsupported
+	  # It fails to find uninstalled libraries when the uninstalled
+	  # path is not listed in the libpath.  Setting hardcode_minus_L
+	  # to unsupported forces relinking
+	  hardcode_minus_L=yes
+	  hardcode_libdir_flag_spec='-L$libdir'
+	  hardcode_libdir_separator=
+	  fi
+	  ;;
+	esac
+	shared_flag='-shared'
+	if test "$aix_use_runtimelinking" = yes; then
+	  shared_flag="$shared_flag "'${wl}-G'
+	fi
+	link_all_deplibs=no
+      else
+	# not using gcc
+	if test "$host_cpu" = ia64; then
+	# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release
+	# chokes on -Wl,-G. The following line is correct:
+	  shared_flag='-G'
+	else
+	  if test "$aix_use_runtimelinking" = yes; then
+	    shared_flag='${wl}-G'
+	  else
+	    shared_flag='${wl}-bM:SRE'
+	  fi
+	fi
+      fi
+
+      export_dynamic_flag_spec='${wl}-bexpall'
+      # It seems that -bexpall does not export symbols beginning with
+      # underscore (_), so it is better to generate a list of symbols to export.
+      always_export_symbols=yes
+      if test "$aix_use_runtimelinking" = yes; then
+	# Warning - without using the other runtime loading flags (-brtl),
+	# -berok will link without error, but may produce a broken library.
+	allow_undefined_flag='-berok'
+        # Determine the default libpath from the value encoded in an
+        # empty executable.
+        if test "${lt_cv_aix_libpath+set}" = set; then
+  aix_libpath=$lt_cv_aix_libpath
+else
+  if ${lt_cv_aix_libpath_+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+  lt_aix_libpath_sed='
+      /Import File Strings/,/^$/ {
+	  /^0/ {
+	      s/^0  *\([^ ]*\) *$/\1/
+	      p
+	  }
+      }'
+  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  # Check for a 64-bit object if we didn't find anything.
+  if test -z "$lt_cv_aix_libpath_"; then
+    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  if test -z "$lt_cv_aix_libpath_"; then
+    lt_cv_aix_libpath_="/usr/lib:/lib"
+  fi
+
+fi
+
+  aix_libpath=$lt_cv_aix_libpath_
+fi
+
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
+      else
+	if test "$host_cpu" = ia64; then
+	  hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+	  allow_undefined_flag="-z nodefs"
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
+	else
+	 # Determine the default libpath from the value encoded in an
+	 # empty executable.
+	 if test "${lt_cv_aix_libpath+set}" = set; then
+  aix_libpath=$lt_cv_aix_libpath
+else
+  if ${lt_cv_aix_libpath_+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+
+  lt_aix_libpath_sed='
+      /Import File Strings/,/^$/ {
+	  /^0/ {
+	      s/^0  *\([^ ]*\) *$/\1/
+	      p
+	  }
+      }'
+  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  # Check for a 64-bit object if we didn't find anything.
+  if test -z "$lt_cv_aix_libpath_"; then
+    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
+  fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  if test -z "$lt_cv_aix_libpath_"; then
+    lt_cv_aix_libpath_="/usr/lib:/lib"
+  fi
+
+fi
+
+  aix_libpath=$lt_cv_aix_libpath_
+fi
+
+	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+	  # Warning - without using the other run time loading flags,
+	  # -berok will link without error, but may produce a broken library.
+	  no_undefined_flag=' ${wl}-bernotok'
+	  allow_undefined_flag=' ${wl}-berok'
+	  if test "$with_gnu_ld" = yes; then
+	    # We only use this code for GNU lds that support --whole-archive.
+	    whole_archive_flag_spec='${wl}--whole-archive$convenience ${wl}--no-whole-archive'
+	  else
+	    # Exported symbols can be pulled into shared objects from archives
+	    whole_archive_flag_spec='$convenience'
+	  fi
+	  archive_cmds_need_lc=yes
+	  # This is similar to how AIX traditionally builds its shared libraries.
+	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
+	fi
+      fi
+      ;;
+
+    amigaos*)
+      case $host_cpu in
+      powerpc)
+            # see comment about AmigaOS4 .so support
+            archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'
+            archive_expsym_cmds=''
+        ;;
+      m68k)
+            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_minus_L=yes
+        ;;
+      esac
+      ;;
+
+    bsdi[45]*)
+      export_dynamic_flag_spec=-rdynamic
+      ;;
+
+    cygwin* | mingw* | pw32* | cegcc*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      case $cc_basename in
+      cl*)
+	# Native MSVC
+	hardcode_libdir_flag_spec=' '
+	allow_undefined_flag=unsupported
+	always_export_symbols=yes
+	file_list_spec='@'
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	archive_cmds='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='
+	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
+	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
+	  else
+	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
+	  fi~
+	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
+	  linknames='
+	# The linker will not automatically build a static lib if we build a DLL.
+	# _LT_TAGVAR(old_archive_from_new_cmds, )='true'
+	enable_shared_with_static_runtimes=yes
+	exclude_expsyms='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
+	export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1,DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
+	# Don't use ranlib
+	old_postinstall_cmds='chmod 644 $oldlib'
+	postlink_cmds='lt_outputfile="@OUTPUT@"~
+	  lt_tool_outputfile="@TOOL_OUTPUT@"~
+	  case $lt_outputfile in
+	    *.exe|*.EXE) ;;
+	    *)
+	      lt_outputfile="$lt_outputfile.exe"
+	      lt_tool_outputfile="$lt_tool_outputfile.exe"
+	      ;;
+	  esac~
+	  if test "$MANIFEST_TOOL" != ":" && test -f "$lt_outputfile.manifest"; then
+	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
+	    $RM "$lt_outputfile.manifest";
+	  fi'
+	;;
+      *)
+	# Assume MSVC wrapper
+	hardcode_libdir_flag_spec=' '
+	allow_undefined_flag=unsupported
+	# Tell ltmain to make .lib files, not .a files.
+	libext=lib
+	# Tell ltmain to make .dll files, not .so files.
+	shrext_cmds=".dll"
+	# FIXME: Setting linknames here is a bad hack.
+	archive_cmds='$CC -o $lib $libobjs $compiler_flags `func_echo_all "$deplibs" | $SED '\''s/ -lc$//'\''` -link -dll~linknames='
+	# The linker will automatically build a .lib file if we build a DLL.
+	old_archive_from_new_cmds='true'
+	# FIXME: Should let the user specify the lib program.
+	old_archive_cmds='lib -OUT:$oldlib$oldobjs$old_deplibs'
+	enable_shared_with_static_runtimes=yes
+	;;
+      esac
+      ;;
+
+    darwin* | rhapsody*)
+
+
+  archive_cmds_need_lc=no
+  hardcode_direct=no
+  hardcode_automatic=yes
+  hardcode_shlibpath_var=unsupported
+  if test "$lt_cv_ld_force_load" = "yes"; then
+    whole_archive_flag_spec='`for conv in $convenience\"\"; do test  -n \"$conv\" && new_convenience=\"$new_convenience ${wl}-force_load,$conv\"; done; func_echo_all \"$new_convenience\"`'
+
+  else
+    whole_archive_flag_spec=''
+  fi
+  link_all_deplibs=yes
+  allow_undefined_flag="$_lt_dar_allow_undefined"
+  case $cc_basename in
+     ifort*) _lt_dar_can_shared=yes ;;
+     *) _lt_dar_can_shared=$GCC ;;
+  esac
+  if test "$_lt_dar_can_shared" = "yes"; then
+    output_verbose_link_cmd=func_echo_all
+    archive_cmds="\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring $_lt_dar_single_mod${_lt_dsymutil}"
+    module_cmds="\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dsymutil}"
+    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
+    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
+
+  else
+  ld_shlibs=no
+  fi
+
+      ;;
+
+    dgux*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor
+    # support.  Future versions do this automatically, but an explicit c++rt0.o
+    # does not break anything, and helps significantly (at the cost of a little
+    # extra space).
+    freebsd2.2*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # Unfortunately, older versions of FreeBSD 2 do not have this feature.
+    freebsd2.*)
+      archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.
+    freebsd* | dragonfly*)
+      archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    hpux9*)
+      if test "$GCC" = yes; then
+	archive_cmds='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      else
+	archive_cmds='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'
+      fi
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      export_dynamic_flag_spec='${wl}-E'
+      ;;
+
+    hpux10*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+	hardcode_direct=yes
+	hardcode_direct_absolute=yes
+	export_dynamic_flag_spec='${wl}-E'
+	# hardcode_minus_L: Not really in the search PATH,
+	# but as the default location of the library.
+	hardcode_minus_L=yes
+      fi
+      ;;
+
+    hpux11*)
+      if test "$GCC" = yes && test "$with_gnu_ld" = no; then
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+	  archive_cmds='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	esac
+      else
+	case $host_cpu in
+	hppa*64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	ia64*)
+	  archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'
+	  ;;
+	*)
+
+	  # Older versions of the 11.00 compiler do not understand -b yet
+	  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $CC understands -b" >&5
+$as_echo_n "checking if $CC understands -b... " >&6; }
+if ${lt_cv_prog_compiler__b+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_prog_compiler__b=no
+   save_LDFLAGS="$LDFLAGS"
+   LDFLAGS="$LDFLAGS -b"
+   echo "$lt_simple_link_test_code" > conftest.$ac_ext
+   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
+     # The linker can only warn and ignore the option if not recognized
+     # So say no if there are warnings
+     if test -s conftest.err; then
+       # Append any errors to the config.log.
+       cat conftest.err 1>&5
+       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
+       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
+       if diff conftest.exp conftest.er2 >/dev/null; then
+         lt_cv_prog_compiler__b=yes
+       fi
+     else
+       lt_cv_prog_compiler__b=yes
+     fi
+   fi
+   $RM -r conftest*
+   LDFLAGS="$save_LDFLAGS"
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler__b" >&5
+$as_echo "$lt_cv_prog_compiler__b" >&6; }
+
+if test x"$lt_cv_prog_compiler__b" = xyes; then
+    archive_cmds='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'
+else
+    archive_cmds='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'
+fi
+
+	  ;;
+	esac
+      fi
+      if test "$with_gnu_ld" = no; then
+	hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+	hardcode_libdir_separator=:
+
+	case $host_cpu in
+	hppa*64*|ia64*)
+	  hardcode_direct=no
+	  hardcode_shlibpath_var=no
+	  ;;
+	*)
+	  hardcode_direct=yes
+	  hardcode_direct_absolute=yes
+	  export_dynamic_flag_spec='${wl}-E'
+
+	  # hardcode_minus_L: Not really in the search PATH,
+	  # but as the default location of the library.
+	  hardcode_minus_L=yes
+	  ;;
+	esac
+      fi
+      ;;
+
+    irix5* | irix6* | nonstopux*)
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	# Try to use the -exported_symbol ld option, if it does not
+	# work, assume that -exports_file does not work either and
+	# implicitly export all symbols.
+	# This should be the same for all languages, so no per-tag cache variable.
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $host_os linker accepts -exported_symbol" >&5
+$as_echo_n "checking whether the $host_os linker accepts -exported_symbol... " >&6; }
+if ${lt_cv_irix_exported_symbol+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  save_LDFLAGS="$LDFLAGS"
+	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
+	   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+int foo (void) { return 0; }
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  lt_cv_irix_exported_symbol=yes
+else
+  lt_cv_irix_exported_symbol=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+           LDFLAGS="$save_LDFLAGS"
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_irix_exported_symbol" >&5
+$as_echo "$lt_cv_irix_exported_symbol" >&6; }
+	if test "$lt_cv_irix_exported_symbol" = yes; then
+          archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
+	fi
+      else
+	archive_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      inherit_rpath=yes
+      link_all_deplibs=yes
+      ;;
+
+    netbsd* | netbsdelf*-gnu)
+      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+	archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out
+      else
+	archive_cmds='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    newsos6)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_shlibpath_var=no
+      ;;
+
+    *nto* | *qnx*)
+      ;;
+
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+	hardcode_direct=yes
+	hardcode_shlibpath_var=no
+	hardcode_direct_absolute=yes
+	if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+	  archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
+	  hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	  export_dynamic_flag_spec='${wl}-E'
+	else
+	  case $host_os in
+	   openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+	     archive_cmds='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'
+	     hardcode_libdir_flag_spec='-R$libdir'
+	     ;;
+	   *)
+	     archive_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'
+	     hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+	     ;;
+	  esac
+	fi
+      else
+	ld_shlibs=no
+      fi
+      ;;
+
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      allow_undefined_flag=unsupported
+      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
+      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
+      ;;
+
+    osf3*)
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+
+    osf4* | osf5*)	# as osf3* with the addition of -msym flag
+      if test "$GCC" = yes; then
+	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'
+	hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+	allow_undefined_flag=' -expect_unresolved \*'
+	archive_cmds='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib'
+	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
+	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
+
+	# Both c and cxx compiler support -rpath directly
+	hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      archive_cmds_need_lc='no'
+      hardcode_libdir_separator=:
+      ;;
+
+    solaris*)
+      no_undefined_flag=' -z defs'
+      if test "$GCC" = yes; then
+	wlarc='${wl}'
+	archive_cmds='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+      else
+	case `$CC -V 2>&1` in
+	*"Compilers 5.0"*)
+	  wlarc=''
+	  archive_cmds='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
+	  ;;
+	*)
+	  wlarc='${wl}'
+	  archive_cmds='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'
+	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
+	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
+	  ;;
+	esac
+      fi
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_shlibpath_var=no
+      case $host_os in
+      solaris2.[0-5] | solaris2.[0-5].*) ;;
+      *)
+	# The compiler driver will combine and reorder linker options,
+	# but understands `-z linker_flag'.  GCC discards it without `$wl',
+	# but is careful enough not to reorder.
+	# Supported since Solaris 2.6 (maybe 2.5.1?)
+	if test "$GCC" = yes; then
+	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
+	else
+	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
+	fi
+	;;
+      esac
+      link_all_deplibs=yes
+      ;;
+
+    sunos4*)
+      if test "x$host_vendor" = xsequent; then
+	# Use $CC to link under sequent, because it throws in some extra .o
+	# files that make .init and .fini sections work.
+	archive_cmds='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
+      fi
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4)
+      case $host_vendor in
+	sni)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=yes # is this really true???
+	;;
+	siemens)
+	  ## LD is ld it makes a PLAMLIB
+	  ## CC just makes a GrossModule.
+	  archive_cmds='$LD -G -o $lib $libobjs $deplibs $linker_flags'
+	  reload_cmds='$CC -r -o $output$reload_objs'
+	  hardcode_direct=no
+        ;;
+	motorola)
+	  archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	  hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+	;;
+      esac
+      runpath_var='LD_RUN_PATH'
+      hardcode_shlibpath_var=no
+      ;;
+
+    sysv4.3*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_shlibpath_var=no
+      export_dynamic_flag_spec='-Bexport'
+      ;;
+
+    sysv4*MP*)
+      if test -d /usr/nec; then
+	archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+	hardcode_shlibpath_var=no
+	runpath_var=LD_RUN_PATH
+	hardcode_runpath_var=yes
+	ld_shlibs=yes
+      fi
+      ;;
+
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      no_undefined_flag='${wl}-z,text'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    sysv5* | sco3.2v5* | sco5v6*)
+      # Note: We can NOT use -z defs as we might desire, because we do not
+      # link with -lc, and that would cause any symbols used from libc to
+      # always be unresolved, which means just about no library would
+      # ever link correctly.  If we're not using GNU ld we use -z text
+      # though, which does catch some bad symbols but isn't as heavy-handed
+      # as -z defs.
+      no_undefined_flag='${wl}-z,text'
+      allow_undefined_flag='${wl}-z,nodefs'
+      archive_cmds_need_lc=no
+      hardcode_shlibpath_var=no
+      hardcode_libdir_flag_spec='${wl}-R,$libdir'
+      hardcode_libdir_separator=':'
+      link_all_deplibs=yes
+      export_dynamic_flag_spec='${wl}-Bexport'
+      runpath_var='LD_RUN_PATH'
+
+      if test "$GCC" = yes; then
+	archive_cmds='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      else
+	archive_cmds='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
+      fi
+      ;;
+
+    uts4*)
+      archive_cmds='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_shlibpath_var=no
+      ;;
+
+    *)
+      ld_shlibs=no
+      ;;
+    esac
+
+    if test x$host_vendor = xsni; then
+      case $host in
+      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+	export_dynamic_flag_spec='${wl}-Blargedynsym'
+	;;
+      esac
+    fi
+  fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ld_shlibs" >&5
+$as_echo "$ld_shlibs" >&6; }
+test "$ld_shlibs" = no && can_build_shared=no
+
+with_gnu_ld=$with_gnu_ld
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#
+# Do we need to explicitly link libc?
+#
+case "x$archive_cmds_need_lc" in
+x|xyes)
+  # Assume -lc should be added
+  archive_cmds_need_lc=yes
+
+  if test "$enable_shared" = yes && test "$GCC" = yes; then
+    case $archive_cmds in
+    *'~'*)
+      # FIXME: we may have to deal with multi-command sequences.
+      ;;
+    '$CC '*)
+      # Test whether the compiler implicitly links with -lc since on some
+      # systems, -lgcc has to come before -lc. If gcc already passes -lc
+      # to ld, don't add -lc before -lgcc.
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
+$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
+if ${lt_cv_archive_cmds_need_lc+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  $RM conftest*
+	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
+
+	if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_compile\""; } >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } 2>conftest.err; then
+	  soname=conftest
+	  lib=conftest
+	  libobjs=conftest.$ac_objext
+	  deplibs=
+	  wl=$lt_prog_compiler_wl
+	  pic_flag=$lt_prog_compiler_pic
+	  compiler_flags=-v
+	  linker_flags=-v
+	  verstring=
+	  output_objdir=.
+	  libname=conftest
+	  lt_save_allow_undefined_flag=$allow_undefined_flag
+	  allow_undefined_flag=
+	  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1\""; } >&5
+  (eval $archive_cmds 2\>\&1 \| $GREP \" -lc \" \>/dev/null 2\>\&1) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }
+	  then
+	    lt_cv_archive_cmds_need_lc=no
+	  else
+	    lt_cv_archive_cmds_need_lc=yes
+	  fi
+	  allow_undefined_flag=$lt_save_allow_undefined_flag
+	else
+	  cat conftest.err 1>&5
+	fi
+	$RM conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_archive_cmds_need_lc" >&5
+$as_echo "$lt_cv_archive_cmds_need_lc" >&6; }
+      archive_cmds_need_lc=$lt_cv_archive_cmds_need_lc
+      ;;
+    esac
+  fi
+  ;;
+esac
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking dynamic linker characteristics" >&5
+$as_echo_n "checking dynamic linker characteristics... " >&6; }
+
+if test "$GCC" = yes; then
+  case $host_os in
+    darwin*) lt_awk_arg="/^libraries:/,/LR/" ;;
+    *) lt_awk_arg="/^libraries:/" ;;
+  esac
+  case $host_os in
+    mingw* | cegcc*) lt_sed_strip_eq="s,=\([A-Za-z]:\),\1,g" ;;
+    *) lt_sed_strip_eq="s,=/,/,g" ;;
+  esac
+  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e "s/^libraries://" -e $lt_sed_strip_eq`
+  case $lt_search_path_spec in
+  *\;*)
+    # if the path contains ";" then we assume it to be the separator
+    # otherwise default to the standard path separator (i.e. ":") - it is
+    # assumed that no part of a normal pathname contains ";" but that should
+    # okay in the real world where ";" in dirpaths is itself problematic.
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED 's/;/ /g'`
+    ;;
+  *)
+    lt_search_path_spec=`$ECHO "$lt_search_path_spec" | $SED "s/$PATH_SEPARATOR/ /g"`
+    ;;
+  esac
+  # Ok, now we have the path, separated by spaces, we can step through it
+  # and add multilib dir if necessary.
+  lt_tmp_lt_search_path_spec=
+  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`
+  for lt_sys_path in $lt_search_path_spec; do
+    if test -d "$lt_sys_path/$lt_multi_os_dir"; then
+      lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir"
+    else
+      test -d "$lt_sys_path" && \
+	lt_tmp_lt_search_path_spec="$lt_tmp_lt_search_path_spec $lt_sys_path"
+    fi
+  done
+  lt_search_path_spec=`$ECHO "$lt_tmp_lt_search_path_spec" | awk '
+BEGIN {RS=" "; FS="/|\n";} {
+  lt_foo="";
+  lt_count=0;
+  for (lt_i = NF; lt_i > 0; lt_i--) {
+    if ($lt_i != "" && $lt_i != ".") {
+      if ($lt_i == "..") {
+        lt_count++;
+      } else {
+        if (lt_count == 0) {
+          lt_foo="/" $lt_i lt_foo;
+        } else {
+          lt_count--;
+        }
+      }
+    }
+  }
+  if (lt_foo != "") { lt_freq[lt_foo]++; }
+  if (lt_freq[lt_foo] == 1) { print lt_foo; }
+}'`
+  # AWK program above erroneously prepends '/' to C:/dos/paths
+  # for these hosts.
+  case $host_os in
+    mingw* | cegcc*) lt_search_path_spec=`$ECHO "$lt_search_path_spec" |\
+      $SED 's,/\([A-Za-z]:\),\1,g'` ;;
+  esac
+  sys_lib_search_path_spec=`$ECHO "$lt_search_path_spec" | $lt_NL2SP`
+else
+  sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+fi
+library_names_spec=
+libname_spec='lib$name'
+soname_spec=
+shrext_cmds=".so"
+postinstall_cmds=
+postuninstall_cmds=
+finish_cmds=
+finish_eval=
+shlibpath_var=
+shlibpath_overrides_runpath=unknown
+version_type=none
+dynamic_linker="$host_os ld.so"
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+need_lib_prefix=unknown
+hardcode_into_libs=no
+
+# when you set need_version to no, make sure it does not cause -set_version
+# flags to be left without arguments
+need_version=unknown
+
+case $host_os in
+aix3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
+  shlibpath_var=LIBPATH
+
+  # AIX 3 has no versioning support, so we append a major version to the name.
+  soname_spec='${libname}${release}${shared_ext}$major'
+  ;;
+
+aix[4-9]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  hardcode_into_libs=yes
+  if test "$host_cpu" = ia64; then
+    # AIX 5 supports IA64
+    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
+    shlibpath_var=LD_LIBRARY_PATH
+  else
+    # With GCC up to 2.95.x, collect2 would create an import file
+    # for dependence libraries.  The import file would start with
+    # the line `#! .'.  This would cause the generated library to
+    # depend on `.', always an invalid library.  This was fixed in
+    # development snapshots of GCC prior to 3.0.
+    case $host_os in
+      aix4 | aix4.[01] | aix4.[01].*)
+      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'
+	   echo ' yes '
+	   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then
+	:
+      else
+	can_build_shared=no
+      fi
+      ;;
+    esac
+    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct
+    # soname into executable. Probably we can add versioning support to
+    # collect2, so additional links can be useful in future.
+    if test "$aix_use_runtimelinking" = yes; then
+      # If using run time linking (on AIX 4.2 or later) use lib<name>.so
+      # instead of lib<name>.a to let people know that these are not
+      # typical AIX shared libraries.
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    else
+      # We preserve .a as extension for shared libraries through AIX4.2
+      # and later when we are not doing run time linking.
+      library_names_spec='${libname}${release}.a $libname.a'
+      soname_spec='${libname}${release}${shared_ext}$major'
+    fi
+    shlibpath_var=LIBPATH
+  fi
+  ;;
+
+amigaos*)
+  case $host_cpu in
+  powerpc)
+    # Since July 2007 AmigaOS4 officially supports .so libraries.
+    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    ;;
+  m68k)
+    library_names_spec='$libname.ixlibrary $libname.a'
+    # Create ${libname}_ixlibrary.a entries in /sys/libs.
+    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
+    ;;
+  esac
+  ;;
+
+beos*)
+  library_names_spec='${libname}${shared_ext}'
+  dynamic_linker="$host_os ld.so"
+  shlibpath_var=LIBRARY_PATH
+  ;;
+
+bsdi[45]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+  sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+  # the default ld.so.conf also contains /usr/contrib/lib and
+  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow
+  # libtool to hard-code these into programs
+  ;;
+
+cygwin* | mingw* | pw32* | cegcc*)
+  version_type=windows
+  shrext_cmds=".dll"
+  need_version=no
+  need_lib_prefix=no
+
+  case $GCC,$cc_basename in
+  yes,*)
+    # gcc
+    library_names_spec='$libname.dll.a'
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname~
+      chmod a+x \$dldir/$dlname~
+      if test -n '\''$stripme'\'' && test -n '\''$striplib'\''; then
+        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
+      fi'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+
+    case $host_os in
+    cygwin*)
+      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
+      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+
+      sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/lib/w32api"
+      ;;
+    mingw* | cegcc*)
+      # MinGW DLLs use traditional 'lib' prefix
+      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    pw32*)
+      # pw32 DLLs use 'pw' prefix rather than 'lib'
+      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+      ;;
+    esac
+    dynamic_linker='Win32 ld.exe'
+    ;;
+
+  *,cl*)
+    # Native MSVC
+    libname_spec='$name'
+    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
+    library_names_spec='${libname}.dll.lib'
+
+    case $build_os in
+    mingw*)
+      sys_lib_search_path_spec=
+      lt_save_ifs=$IFS
+      IFS=';'
+      for lt_path in $LIB
+      do
+        IFS=$lt_save_ifs
+        # Let DOS variable expansion print the short 8.3 style file name.
+        lt_path=`cd "$lt_path" 2>/dev/null && cmd //C "for %i in (".") do @echo %~si"`
+        sys_lib_search_path_spec="$sys_lib_search_path_spec $lt_path"
+      done
+      IFS=$lt_save_ifs
+      # Convert to MSYS style.
+      sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | sed -e 's|\\\\|/|g' -e 's| \\([a-zA-Z]\\):| /\\1|g' -e 's|^ ||'`
+      ;;
+    cygwin*)
+      # Convert to unix form, then to dos form, then back to unix form
+      # but this time dos style (no spaces!) so that the unix form looks
+      # like /cygdrive/c/PROGRA~1:/cygdr...
+      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
+      sys_lib_search_path_spec=`cygpath --path --dos "$sys_lib_search_path_spec" 2>/dev/null`
+      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      ;;
+    *)
+      sys_lib_search_path_spec="$LIB"
+      if $ECHO "$sys_lib_search_path_spec" | $GREP ';[c-zC-Z]:/' >/dev/null; then
+        # It is most probably a Windows format PATH.
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's/;/ /g'`
+      else
+        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
+      fi
+      # FIXME: find the short name or the path components, as spaces are
+      # common. (e.g. "Program Files" -> "PROGRA~1")
+      ;;
+    esac
+
+    # DLL is installed to $(libdir)/../bin by postinstall_cmds
+    postinstall_cmds='base_file=`basename \${file}`~
+      dlpath=`$SHELL 2>&1 -c '\''. $dir/'\''\${base_file}'\''i; echo \$dlname'\''`~
+      dldir=$destdir/`dirname \$dlpath`~
+      test -d \$dldir || mkdir -p \$dldir~
+      $install_prog $dir/$dlname \$dldir/$dlname'
+    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\''. $file; echo \$dlname'\''`~
+      dlpath=$dir/\$dldll~
+       $RM \$dlpath'
+    shlibpath_overrides_runpath=yes
+    dynamic_linker='Win32 link.exe'
+    ;;
+
+  *)
+    # Assume MSVC wrapper
+    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
+    dynamic_linker='Win32 ld.exe'
+    ;;
+  esac
+  # FIXME: first we should search . and the directory the executable is in
+  shlibpath_var=PATH
+  ;;
+
+darwin* | rhapsody*)
+  dynamic_linker="$host_os dyld"
+  version_type=darwin
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
+  soname_spec='${libname}${release}${major}$shared_ext'
+  shlibpath_overrides_runpath=yes
+  shlibpath_var=DYLD_LIBRARY_PATH
+  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
+
+  sys_lib_search_path_spec="$sys_lib_search_path_spec /usr/local/lib"
+  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'
+  ;;
+
+dgux*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+freebsd* | dragonfly*)
+  # DragonFly does not have aout.  When/if they implement a new
+  # versioning mechanism, adjust this.
+  if test -x /usr/bin/objformat; then
+    objformat=`/usr/bin/objformat`
+  else
+    case $host_os in
+    freebsd[23].*) objformat=aout ;;
+    *) objformat=elf ;;
+    esac
+  fi
+  version_type=freebsd-$objformat
+  case $version_type in
+    freebsd-elf*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+      need_version=no
+      need_lib_prefix=no
+      ;;
+    freebsd-*)
+      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
+      need_version=yes
+      ;;
+  esac
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_os in
+  freebsd2.*)
+    shlibpath_overrides_runpath=yes
+    ;;
+  freebsd3.[01]* | freebsdelf3.[01]*)
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  freebsd3.[2-9]* | freebsdelf3.[2-9]* | \
+  freebsd4.[0-5] | freebsdelf4.[0-5] | freebsd4.1.1 | freebsdelf4.1.1)
+    shlibpath_overrides_runpath=no
+    hardcode_into_libs=yes
+    ;;
+  *) # from 4.6 on, and DragonFly
+    shlibpath_overrides_runpath=yes
+    hardcode_into_libs=yes
+    ;;
+  esac
+  ;;
+
+haiku*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  dynamic_linker="$host_os runtime_loader"
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'
+  hardcode_into_libs=yes
+  ;;
+
+hpux9* | hpux10* | hpux11*)
+  # Give a soname corresponding to the major version so that dld.sl refuses to
+  # link against other versions.
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  case $host_cpu in
+  ia64*)
+    shrext_cmds='.so'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.so"
+    shlibpath_var=LD_LIBRARY_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    if test "X$HPUX_IA64_MODE" = X32; then
+      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
+    else
+      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
+    fi
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  hppa*64*)
+    shrext_cmds='.sl'
+    hardcode_into_libs=yes
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH
+    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    sys_lib_search_path_spec="/usr/lib/pa20_64 /usr/ccs/lib/pa20_64"
+    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec
+    ;;
+  *)
+    shrext_cmds='.sl'
+    dynamic_linker="$host_os dld.sl"
+    shlibpath_var=SHLIB_PATH
+    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    ;;
+  esac
+  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...
+  postinstall_cmds='chmod 555 $lib'
+  # or fails outright, so override atomically:
+  install_override_mode=555
+  ;;
+
+interix[3-9]*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+irix5* | irix6* | nonstopux*)
+  case $host_os in
+    nonstopux*) version_type=nonstopux ;;
+    *)
+	if test "$lt_cv_prog_gnu_ld" = yes; then
+		version_type=linux # correct to gnu/linux during the next big refactor
+	else
+		version_type=irix
+	fi ;;
+  esac
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
+  case $host_os in
+  irix5* | nonstopux*)
+    libsuff= shlibsuff=
+    ;;
+  *)
+    case $LD in # libtool.m4 will add one of these switches to LD
+    *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ")
+      libsuff= shlibsuff= libmagic=32-bit;;
+    *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ")
+      libsuff=32 shlibsuff=N32 libmagic=N32;;
+    *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ")
+      libsuff=64 shlibsuff=64 libmagic=64-bit;;
+    *) libsuff= shlibsuff= libmagic=never-match;;
+    esac
+    ;;
+  esac
+  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH
+  shlibpath_overrides_runpath=no
+  sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+  sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+  hardcode_into_libs=yes
+  ;;
+
+# No shared lib support for Linux oldld, aout, or coff.
+linux*oldld* | linux*aout* | linux*coff*)
+  dynamic_linker=no
+  ;;
+
+# This must be glibc/ELF.
+linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -n $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+
+  # Some binutils ld are patched to set DT_RUNPATH
+  if ${lt_cv_shlibpath_overrides_runpath+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  lt_cv_shlibpath_overrides_runpath=no
+    save_LDFLAGS=$LDFLAGS
+    save_libdir=$libdir
+    eval "libdir=/foo; wl=\"$lt_prog_compiler_wl\"; \
+	 LDFLAGS=\"\$LDFLAGS $hardcode_libdir_flag_spec\""
+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
+  lt_cv_shlibpath_overrides_runpath=yes
+fi
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+    LDFLAGS=$save_LDFLAGS
+    libdir=$save_libdir
+
+fi
+
+  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath
+
+  # This implies no fast_install, which is unacceptable.
+  # Some rework will be needed to allow for fast_install
+  # before this can be enabled.
+  hardcode_into_libs=yes
+
+  # Append ld.so.conf contents to the search path
+  if test -f /etc/ld.so.conf; then
+    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
+    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
+  fi
+
+  # We used to test for /lib/ld.so.1 and disable shared libraries on
+  # powerpc, because MkLinux only supported shared libraries with the
+  # GNU dynamic linker.  Since this was broken with cross compilers,
+  # most powerpc-linux boxes support dynamic linking these days and
+  # people can always --disable-shared, the test was removed, and we
+  # assume the GNU/Linux dynamic linker is in use.
+  dynamic_linker='GNU/Linux ld.so'
+  ;;
+
+netbsdelf*-gnu)
+  version_type=linux
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='NetBSD ld.elf_so'
+  ;;
+
+netbsd*)
+  version_type=sunos
+  need_lib_prefix=no
+  need_version=no
+  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+    finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+    dynamic_linker='NetBSD (a.out) ld.so'
+  else
+    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
+    soname_spec='${libname}${release}${shared_ext}$major'
+    dynamic_linker='NetBSD ld.elf_so'
+  fi
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  ;;
+
+newsos6)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  ;;
+
+*nto* | *qnx*)
+  version_type=qnx
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  dynamic_linker='ldqnx.so'
+  ;;
+
+openbsd*)
+  version_type=sunos
+  sys_lib_dlsearch_path_spec="/usr/lib"
+  need_lib_prefix=no
+  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.
+  case $host_os in
+    openbsd3.3 | openbsd3.3.*)	need_version=yes ;;
+    *)				need_version=no  ;;
+  esac
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/sbin" ldconfig -m $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  if test -z "`echo __ELF__ | $CC -E - | $GREP __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+    case $host_os in
+      openbsd2.[89] | openbsd2.[89].*)
+	shlibpath_overrides_runpath=no
+	;;
+      *)
+	shlibpath_overrides_runpath=yes
+	;;
+      esac
+  else
+    shlibpath_overrides_runpath=yes
+  fi
+  ;;
+
+os2*)
+  libname_spec='$name'
+  shrext_cmds=".dll"
+  need_lib_prefix=no
+  library_names_spec='$libname${shared_ext} $libname.a'
+  dynamic_linker='OS/2 ld.exe'
+  shlibpath_var=LIBPATH
+  ;;
+
+osf3* | osf4* | osf5*)
+  version_type=osf
+  need_lib_prefix=no
+  need_version=no
+  soname_spec='${libname}${release}${shared_ext}$major'
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+  sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+  ;;
+
+rdos*)
+  dynamic_linker=no
+  ;;
+
+solaris*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  # ldd complains unless libraries are executable
+  postinstall_cmds='chmod +x $lib'
+  ;;
+
+sunos4*)
+  version_type=sunos
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
+  finish_cmds='PATH="\$PATH:/usr/etc" ldconfig $libdir'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  if test "$with_gnu_ld" = yes; then
+    need_lib_prefix=no
+  fi
+  need_version=yes
+  ;;
+
+sysv4 | sysv4.3*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  case $host_vendor in
+    sni)
+      shlibpath_overrides_runpath=no
+      need_lib_prefix=no
+      runpath_var=LD_RUN_PATH
+      ;;
+    siemens)
+      need_lib_prefix=no
+      ;;
+    motorola)
+      need_lib_prefix=no
+      need_version=no
+      shlibpath_overrides_runpath=no
+      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+      ;;
+  esac
+  ;;
+
+sysv4*MP*)
+  if test -d /usr/nec ;then
+    version_type=linux # correct to gnu/linux during the next big refactor
+    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
+    soname_spec='$libname${shared_ext}.$major'
+    shlibpath_var=LD_LIBRARY_PATH
+  fi
+  ;;
+
+sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+  version_type=freebsd-elf
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=yes
+  hardcode_into_libs=yes
+  if test "$with_gnu_ld" = yes; then
+    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'
+  else
+    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'
+    case $host_os in
+      sco3.2v5*)
+        sys_lib_search_path_spec="$sys_lib_search_path_spec /lib"
+	;;
+    esac
+  fi
+  sys_lib_dlsearch_path_spec='/usr/lib'
+  ;;
+
+tpf*)
+  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
+  version_type=linux # correct to gnu/linux during the next big refactor
+  need_lib_prefix=no
+  need_version=no
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  shlibpath_var=LD_LIBRARY_PATH
+  shlibpath_overrides_runpath=no
+  hardcode_into_libs=yes
+  ;;
+
+uts4*)
+  version_type=linux # correct to gnu/linux during the next big refactor
+  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
+  soname_spec='${libname}${release}${shared_ext}$major'
+  shlibpath_var=LD_LIBRARY_PATH
+  ;;
+
+*)
+  dynamic_linker=no
+  ;;
+esac
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $dynamic_linker" >&5
+$as_echo "$dynamic_linker" >&6; }
+test "$dynamic_linker" = no && can_build_shared=no
+
+variables_saved_for_relink="PATH $shlibpath_var $runpath_var"
+if test "$GCC" = yes; then
+  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"
+fi
+
+if test "${lt_cv_sys_lib_search_path_spec+set}" = set; then
+  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"
+fi
+if test "${lt_cv_sys_lib_dlsearch_path_spec+set}" = set; then
+  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking how to hardcode library paths into programs" >&5
+$as_echo_n "checking how to hardcode library paths into programs... " >&6; }
+hardcode_action=
+if test -n "$hardcode_libdir_flag_spec" ||
+   test -n "$runpath_var" ||
+   test "X$hardcode_automatic" = "Xyes" ; then
+
+  # We can hardcode non-existent directories.
+  if test "$hardcode_direct" != no &&
+     # If the only mechanism to avoid hardcoding is shlibpath_var, we
+     # have to relink, otherwise we might link with an installed library
+     # when we should be linking with a yet-to-be-installed one
+     ## test "$_LT_TAGVAR(hardcode_shlibpath_var, )" != no &&
+     test "$hardcode_minus_L" != no; then
+    # Linking always hardcodes the temporary library directory.
+    hardcode_action=relink
+  else
+    # We can link without hardcoding, and we can hardcode nonexisting dirs.
+    hardcode_action=immediate
+  fi
+else
+  # We cannot hardcode anything, or else we can only hardcode existing
+  # directories.
+  hardcode_action=unsupported
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $hardcode_action" >&5
+$as_echo "$hardcode_action" >&6; }
+
+if test "$hardcode_action" = relink ||
+   test "$inherit_rpath" = yes; then
+  # Fast installation is not supported
+  enable_fast_install=no
+elif test "$shlibpath_overrides_runpath" = yes ||
+     test "$enable_shared" = no; then
+  # Fast installation is not necessary
+  enable_fast_install=needless
+fi
+
+
+
+
+
+
+  if test "x$enable_dlopen" != xyes; then
+  enable_dlopen=unknown
+  enable_dlopen_self=unknown
+  enable_dlopen_self_static=unknown
+else
+  lt_cv_dlopen=no
+  lt_cv_dlopen_libs=
+
+  case $host_os in
+  beos*)
+    lt_cv_dlopen="load_add_on"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+    ;;
+
+  mingw* | pw32* | cegcc*)
+    lt_cv_dlopen="LoadLibrary"
+    lt_cv_dlopen_libs=
+    ;;
+
+  cygwin*)
+    lt_cv_dlopen="dlopen"
+    lt_cv_dlopen_libs=
+    ;;
+
+  darwin*)
+  # if libdl is installed we need to link against it
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if ${ac_cv_lib_dl_dlopen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+
+    lt_cv_dlopen="dyld"
+    lt_cv_dlopen_libs=
+    lt_cv_dlopen_self=yes
+
+fi
+
+    ;;
+
+  *)
+    ac_fn_c_check_func "$LINENO" "shl_load" "ac_cv_func_shl_load"
+if test "x$ac_cv_func_shl_load" = xyes; then :
+  lt_cv_dlopen="shl_load"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for shl_load in -ldld" >&5
+$as_echo_n "checking for shl_load in -ldld... " >&6; }
+if ${ac_cv_lib_dld_shl_load+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char shl_load ();
+int
+main ()
+{
+return shl_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_shl_load=yes
+else
+  ac_cv_lib_dld_shl_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_shl_load" >&5
+$as_echo "$ac_cv_lib_dld_shl_load" >&6; }
+if test "x$ac_cv_lib_dld_shl_load" = xyes; then :
+  lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-ldld"
+else
+  ac_fn_c_check_func "$LINENO" "dlopen" "ac_cv_func_dlopen"
+if test "x$ac_cv_func_dlopen" = xyes; then :
+  lt_cv_dlopen="dlopen"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -ldl" >&5
+$as_echo_n "checking for dlopen in -ldl... " >&6; }
+if ${ac_cv_lib_dl_dlopen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dl_dlopen=yes
+else
+  ac_cv_lib_dl_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dl_dlopen" >&5
+$as_echo "$ac_cv_lib_dl_dlopen" >&6; }
+if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dlopen in -lsvld" >&5
+$as_echo_n "checking for dlopen in -lsvld... " >&6; }
+if ${ac_cv_lib_svld_dlopen+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsvld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dlopen ();
+int
+main ()
+{
+return dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_svld_dlopen=yes
+else
+  ac_cv_lib_svld_dlopen=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_svld_dlopen" >&5
+$as_echo "$ac_cv_lib_svld_dlopen" >&6; }
+if test "x$ac_cv_lib_svld_dlopen" = xyes; then :
+  lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for dld_link in -ldld" >&5
+$as_echo_n "checking for dld_link in -ldld... " >&6; }
+if ${ac_cv_lib_dld_dld_link+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldld  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char dld_link ();
+int
+main ()
+{
+return dld_link ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_dld_dld_link=yes
+else
+  ac_cv_lib_dld_dld_link=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_dld_dld_link" >&5
+$as_echo "$ac_cv_lib_dld_dld_link" >&6; }
+if test "x$ac_cv_lib_dld_dld_link" = xyes; then :
+  lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-ldld"
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+
+fi
+
+    ;;
+  esac
+
+  if test "x$lt_cv_dlopen" != xno; then
+    enable_dlopen=yes
+  else
+    enable_dlopen=no
+  fi
+
+  case $lt_cv_dlopen in
+  dlopen)
+    save_CPPFLAGS="$CPPFLAGS"
+    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
+
+    save_LDFLAGS="$LDFLAGS"
+    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
+
+    save_LIBS="$LIBS"
+    LIBS="$lt_cv_dlopen_libs $LIBS"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a program can dlopen itself" >&5
+$as_echo_n "checking whether a program can dlopen itself... " >&6; }
+if ${lt_cv_dlopen_self+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+int fnord () __attribute__((visibility("default")));
+#endif
+
+int fnord () { return 42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self" >&5
+$as_echo "$lt_cv_dlopen_self" >&6; }
+
+    if test "x$lt_cv_dlopen_self" = xyes; then
+      wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $lt_prog_compiler_static\"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether a statically linked program can dlopen itself" >&5
+$as_echo_n "checking whether a statically linked program can dlopen itself... " >&6; }
+if ${lt_cv_dlopen_self_static+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  	  if test "$cross_compiling" = yes; then :
+  lt_cv_dlopen_self_static=cross
+else
+  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+  lt_status=$lt_dlunknown
+  cat > conftest.$ac_ext <<_LT_EOF
+#line $LINENO "configure"
+#include "confdefs.h"
+
+#if HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+
+#include <stdio.h>
+
+#ifdef RTLD_GLOBAL
+#  define LT_DLGLOBAL		RTLD_GLOBAL
+#else
+#  ifdef DL_GLOBAL
+#    define LT_DLGLOBAL		DL_GLOBAL
+#  else
+#    define LT_DLGLOBAL		0
+#  endif
+#endif
+
+/* We may have to define LT_DLLAZY_OR_NOW in the command line if we
+   find out it does not work in some platform. */
+#ifndef LT_DLLAZY_OR_NOW
+#  ifdef RTLD_LAZY
+#    define LT_DLLAZY_OR_NOW		RTLD_LAZY
+#  else
+#    ifdef DL_LAZY
+#      define LT_DLLAZY_OR_NOW		DL_LAZY
+#    else
+#      ifdef RTLD_NOW
+#        define LT_DLLAZY_OR_NOW	RTLD_NOW
+#      else
+#        ifdef DL_NOW
+#          define LT_DLLAZY_OR_NOW	DL_NOW
+#        else
+#          define LT_DLLAZY_OR_NOW	0
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+
+/* When -fvisbility=hidden is used, assume the code has been annotated
+   correspondingly for the symbols needed.  */
+#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))
+int fnord () __attribute__((visibility("default")));
+#endif
+
+int fnord () { return 42; }
+int main ()
+{
+  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);
+  int status = $lt_dlunknown;
+
+  if (self)
+    {
+      if (dlsym (self,"fnord"))       status = $lt_dlno_uscore;
+      else
+        {
+	  if (dlsym( self,"_fnord"))  status = $lt_dlneed_uscore;
+          else puts (dlerror ());
+	}
+      /* dlclose (self); */
+    }
+  else
+    puts (dlerror ());
+
+  return status;
+}
+_LT_EOF
+  if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_link\""; } >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
+    (./conftest; exit; ) >&5 2>/dev/null
+    lt_status=$?
+    case x$lt_status in
+      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
+      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
+    esac
+  else :
+    # compilation failed
+    lt_cv_dlopen_self_static=no
+  fi
+fi
+rm -fr conftest*
+
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_dlopen_self_static" >&5
+$as_echo "$lt_cv_dlopen_self_static" >&6; }
+    fi
+
+    CPPFLAGS="$save_CPPFLAGS"
+    LDFLAGS="$save_LDFLAGS"
+    LIBS="$save_LIBS"
+    ;;
+  esac
+
+  case $lt_cv_dlopen_self in
+  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;
+  *) enable_dlopen_self=unknown ;;
+  esac
+
+  case $lt_cv_dlopen_self_static in
+  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;
+  *) enable_dlopen_self_static=unknown ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+striplib=
+old_striplib=
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether stripping libraries is possible" >&5
+$as_echo_n "checking whether stripping libraries is possible... " >&6; }
+if test -n "$STRIP" && $STRIP -V 2>&1 | $GREP "GNU strip" >/dev/null; then
+  test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
+  test -z "$striplib" && striplib="$STRIP --strip-unneeded"
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+# FIXME - insert some real tests, host_os isn't really good enough
+  case $host_os in
+  darwin*)
+    if test -n "$STRIP" ; then
+      striplib="$STRIP -x"
+      old_striplib="$STRIP -S"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    else
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    fi
+    ;;
+  *)
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    ;;
+  esac
+fi
+
+
+
+
+
+
+
+
+
+
+
+
+  # Report which library types will actually be built
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if libtool supports shared libraries" >&5
+$as_echo_n "checking if libtool supports shared libraries... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $can_build_shared" >&5
+$as_echo "$can_build_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build shared libraries" >&5
+$as_echo_n "checking whether to build shared libraries... " >&6; }
+  test "$can_build_shared" = "no" && enable_shared=no
+
+  # On AIX, shared libraries and static libraries use the same namespace, and
+  # are all built from PIC.
+  case $host_os in
+  aix3*)
+    test "$enable_shared" = yes && enable_static=no
+    if test -n "$RANLIB"; then
+      archive_cmds="$archive_cmds~\$RANLIB \$lib"
+      postinstall_cmds='$RANLIB $lib'
+    fi
+    ;;
+
+  aix[4-9]*)
+    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
+      test "$enable_shared" = yes && enable_static=no
+    fi
+    ;;
+  esac
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_shared" >&5
+$as_echo "$enable_shared" >&6; }
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to build static libraries" >&5
+$as_echo_n "checking whether to build static libraries... " >&6; }
+  # Make sure either enable_shared or enable_static is yes.
+  test "$enable_shared" = yes || enable_static=yes
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_static" >&5
+$as_echo "$enable_static" >&6; }
+
+
+
+
+fi
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+CC="$lt_save_CC"
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+        ac_config_commands="$ac_config_commands libtool"
+
+
+
+
+# Only expand once:
+
+
+
+
+for ac_header in sys/inotify.h sys/epoll.h sys/event.h port.h poll.h sys/select.h sys/eventfd.h sys/signalfd.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_func in inotify_init epoll_ctl kqueue port_create poll select eventfd signalfd
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+for ac_func in clock_gettime
+do :
+  ac_fn_c_check_func "$LINENO" "clock_gettime" "ac_cv_func_clock_gettime"
+if test "x$ac_cv_func_clock_gettime" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_CLOCK_GETTIME 1
+_ACEOF
+
+else
+
+      if test $(uname) = Linux; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clock_gettime syscall" >&5
+$as_echo_n "checking for clock_gettime syscall... " >&6; }
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <unistd.h>
+                       #include <sys/syscall.h>
+                       #include <time.h>
+int
+main ()
+{
+struct timespec ts; int status = syscall (SYS_clock_gettime, CLOCK_REALTIME, &ts)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_have_clock_syscall=1
+
+$as_echo "#define HAVE_CLOCK_SYSCALL 1" >>confdefs.h
+
+                      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+   fi
+   if test -z "$LIBEV_M4_AVOID_LIBRT" && test -z "$ac_have_clock_syscall"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for clock_gettime in -lrt" >&5
+$as_echo_n "checking for clock_gettime in -lrt... " >&6; }
+if ${ac_cv_lib_rt_clock_gettime+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char clock_gettime ();
+int
+main ()
+{
+return clock_gettime ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_rt_clock_gettime=yes
+else
+  ac_cv_lib_rt_clock_gettime=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_clock_gettime" >&5
+$as_echo "$ac_cv_lib_rt_clock_gettime" >&6; }
+if test "x$ac_cv_lib_rt_clock_gettime" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRT 1
+_ACEOF
+
+  LIBS="-lrt $LIBS"
+
+fi
+
+      unset ac_cv_func_clock_gettime
+      for ac_func in clock_gettime
+do :
+  ac_fn_c_check_func "$LINENO" "clock_gettime" "ac_cv_func_clock_gettime"
+if test "x$ac_cv_func_clock_gettime" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_CLOCK_GETTIME 1
+_ACEOF
+
+fi
+done
+
+   fi
+
+fi
+done
+
+
+for ac_func in nanosleep
+do :
+  ac_fn_c_check_func "$LINENO" "nanosleep" "ac_cv_func_nanosleep"
+if test "x$ac_cv_func_nanosleep" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NANOSLEEP 1
+_ACEOF
+
+else
+
+   if test -z "$LIBEV_M4_AVOID_LIBRT"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: checking for nanosleep in -lrt" >&5
+$as_echo_n "checking for nanosleep in -lrt... " >&6; }
+if ${ac_cv_lib_rt_nanosleep+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lrt  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char nanosleep ();
+int
+main ()
+{
+return nanosleep ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_rt_nanosleep=yes
+else
+  ac_cv_lib_rt_nanosleep=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_rt_nanosleep" >&5
+$as_echo "$ac_cv_lib_rt_nanosleep" >&6; }
+if test "x$ac_cv_lib_rt_nanosleep" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRT 1
+_ACEOF
+
+  LIBS="-lrt $LIBS"
+
+fi
+
+      unset ac_cv_func_nanosleep
+      for ac_func in nanosleep
+do :
+  ac_fn_c_check_func "$LINENO" "nanosleep" "ac_cv_func_nanosleep"
+if test "x$ac_cv_func_nanosleep" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_NANOSLEEP 1
+_ACEOF
+
+fi
+done
+
+   fi
+
+fi
+done
+
+
+if test -z "$LIBEV_M4_AVOID_LIBM"; then
+   LIBM=m
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for library containing floor" >&5
+$as_echo_n "checking for library containing floor... " >&6; }
+if ${ac_cv_search_floor+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char floor ();
+int
+main ()
+{
+return floor ();
+  ;
+  return 0;
+}
+_ACEOF
+for ac_lib in '' $LIBM; do
+  if test -z "$ac_lib"; then
+    ac_res="none required"
+  else
+    ac_res=-l$ac_lib
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+  fi
+  if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_search_floor=$ac_res
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext
+  if ${ac_cv_search_floor+:} false; then :
+  break
+fi
+done
+if ${ac_cv_search_floor+:} false; then :
+
+else
+  ac_cv_search_floor=no
+fi
+rm conftest.$ac_ext
+LIBS=$ac_func_search_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_floor" >&5
+$as_echo "$ac_cv_search_floor" >&6; }
+ac_res=$ac_cv_search_floor
+if test "$ac_res" != no; then :
+  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
+
+$as_echo "#define HAVE_FLOOR 1" >>confdefs.h
+
+fi
+
+
+
+
+ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    if test "x$cache_file" != "x/dev/null"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+DEFS=-DHAVE_CONFIG_H
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+$as_echo_n "checking that generated files are newer than configure... " >&6; }
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+$as_echo "done" >&6; }
+ if test -n "$EXEEXT"; then
+  am__EXEEXT_TRUE=
+  am__EXEEXT_FALSE='#'
+else
+  am__EXEEXT_TRUE='#'
+  am__EXEEXT_FALSE=
+fi
+
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: "${CONFIG_STATUS=./config.status}"
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -pR'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -pR'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -pR'
+  fi
+else
+  as_ln_s='cp -pR'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+
+# as_fn_executable_p FILE
+# -----------------------
+# Test if FILE is an executable regular file.
+as_fn_executable_p ()
+{
+  test -f "$1" && test -x "$1"
+} # as_fn_executable_p
+as_test_x='test -x'
+as_executable_p=as_fn_executable_p
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by $as_me, which was
+generated by GNU Autoconf 2.69.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+case $ac_config_headers in *"
+"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
+esac
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_headers="$ac_config_headers"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+      --header=FILE[:TEMPLATE]
+                   instantiate the configuration header FILE
+
+Configuration files:
+$config_files
+
+Configuration headers:
+$config_headers
+
+Configuration commands:
+$config_commands
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+config.status
+configured by $0, generated by GNU Autoconf 2.69,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2012 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --header | --heade | --head | --hea )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    as_fn_append CONFIG_HEADERS " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h)
+    # Conflict between --help and --header
+    as_fn_error $? "ambiguous option: \`$1'
+Try \`$0 --help' for more information.";;
+  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+sed_quote_subst='$sed_quote_subst'
+double_quote_subst='$double_quote_subst'
+delay_variable_subst='$delay_variable_subst'
+macro_version='`$ECHO "$macro_version" | $SED "$delay_single_quote_subst"`'
+macro_revision='`$ECHO "$macro_revision" | $SED "$delay_single_quote_subst"`'
+enable_shared='`$ECHO "$enable_shared" | $SED "$delay_single_quote_subst"`'
+enable_static='`$ECHO "$enable_static" | $SED "$delay_single_quote_subst"`'
+pic_mode='`$ECHO "$pic_mode" | $SED "$delay_single_quote_subst"`'
+enable_fast_install='`$ECHO "$enable_fast_install" | $SED "$delay_single_quote_subst"`'
+SHELL='`$ECHO "$SHELL" | $SED "$delay_single_quote_subst"`'
+ECHO='`$ECHO "$ECHO" | $SED "$delay_single_quote_subst"`'
+PATH_SEPARATOR='`$ECHO "$PATH_SEPARATOR" | $SED "$delay_single_quote_subst"`'
+host_alias='`$ECHO "$host_alias" | $SED "$delay_single_quote_subst"`'
+host='`$ECHO "$host" | $SED "$delay_single_quote_subst"`'
+host_os='`$ECHO "$host_os" | $SED "$delay_single_quote_subst"`'
+build_alias='`$ECHO "$build_alias" | $SED "$delay_single_quote_subst"`'
+build='`$ECHO "$build" | $SED "$delay_single_quote_subst"`'
+build_os='`$ECHO "$build_os" | $SED "$delay_single_quote_subst"`'
+SED='`$ECHO "$SED" | $SED "$delay_single_quote_subst"`'
+Xsed='`$ECHO "$Xsed" | $SED "$delay_single_quote_subst"`'
+GREP='`$ECHO "$GREP" | $SED "$delay_single_quote_subst"`'
+EGREP='`$ECHO "$EGREP" | $SED "$delay_single_quote_subst"`'
+FGREP='`$ECHO "$FGREP" | $SED "$delay_single_quote_subst"`'
+LD='`$ECHO "$LD" | $SED "$delay_single_quote_subst"`'
+NM='`$ECHO "$NM" | $SED "$delay_single_quote_subst"`'
+LN_S='`$ECHO "$LN_S" | $SED "$delay_single_quote_subst"`'
+max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
+ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
+exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
+lt_unset='`$ECHO "$lt_unset" | $SED "$delay_single_quote_subst"`'
+lt_SP2NL='`$ECHO "$lt_SP2NL" | $SED "$delay_single_quote_subst"`'
+lt_NL2SP='`$ECHO "$lt_NL2SP" | $SED "$delay_single_quote_subst"`'
+lt_cv_to_host_file_cmd='`$ECHO "$lt_cv_to_host_file_cmd" | $SED "$delay_single_quote_subst"`'
+lt_cv_to_tool_file_cmd='`$ECHO "$lt_cv_to_tool_file_cmd" | $SED "$delay_single_quote_subst"`'
+reload_flag='`$ECHO "$reload_flag" | $SED "$delay_single_quote_subst"`'
+reload_cmds='`$ECHO "$reload_cmds" | $SED "$delay_single_quote_subst"`'
+OBJDUMP='`$ECHO "$OBJDUMP" | $SED "$delay_single_quote_subst"`'
+deplibs_check_method='`$ECHO "$deplibs_check_method" | $SED "$delay_single_quote_subst"`'
+file_magic_cmd='`$ECHO "$file_magic_cmd" | $SED "$delay_single_quote_subst"`'
+file_magic_glob='`$ECHO "$file_magic_glob" | $SED "$delay_single_quote_subst"`'
+want_nocaseglob='`$ECHO "$want_nocaseglob" | $SED "$delay_single_quote_subst"`'
+DLLTOOL='`$ECHO "$DLLTOOL" | $SED "$delay_single_quote_subst"`'
+sharedlib_from_linklib_cmd='`$ECHO "$sharedlib_from_linklib_cmd" | $SED "$delay_single_quote_subst"`'
+AR='`$ECHO "$AR" | $SED "$delay_single_quote_subst"`'
+AR_FLAGS='`$ECHO "$AR_FLAGS" | $SED "$delay_single_quote_subst"`'
+archiver_list_spec='`$ECHO "$archiver_list_spec" | $SED "$delay_single_quote_subst"`'
+STRIP='`$ECHO "$STRIP" | $SED "$delay_single_quote_subst"`'
+RANLIB='`$ECHO "$RANLIB" | $SED "$delay_single_quote_subst"`'
+old_postinstall_cmds='`$ECHO "$old_postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_postuninstall_cmds='`$ECHO "$old_postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_cmds='`$ECHO "$old_archive_cmds" | $SED "$delay_single_quote_subst"`'
+lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
+CC='`$ECHO "$CC" | $SED "$delay_single_quote_subst"`'
+CFLAGS='`$ECHO "$CFLAGS" | $SED "$delay_single_quote_subst"`'
+compiler='`$ECHO "$compiler" | $SED "$delay_single_quote_subst"`'
+GCC='`$ECHO "$GCC" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_pipe='`$ECHO "$lt_cv_sys_global_symbol_pipe" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_cdecl='`$ECHO "$lt_cv_sys_global_symbol_to_cdecl" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address" | $SED "$delay_single_quote_subst"`'
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
+nm_file_list_spec='`$ECHO "$nm_file_list_spec" | $SED "$delay_single_quote_subst"`'
+lt_sysroot='`$ECHO "$lt_sysroot" | $SED "$delay_single_quote_subst"`'
+objdir='`$ECHO "$objdir" | $SED "$delay_single_quote_subst"`'
+MAGIC_CMD='`$ECHO "$MAGIC_CMD" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_no_builtin_flag='`$ECHO "$lt_prog_compiler_no_builtin_flag" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_pic='`$ECHO "$lt_prog_compiler_pic" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_wl='`$ECHO "$lt_prog_compiler_wl" | $SED "$delay_single_quote_subst"`'
+lt_prog_compiler_static='`$ECHO "$lt_prog_compiler_static" | $SED "$delay_single_quote_subst"`'
+lt_cv_prog_compiler_c_o='`$ECHO "$lt_cv_prog_compiler_c_o" | $SED "$delay_single_quote_subst"`'
+need_locks='`$ECHO "$need_locks" | $SED "$delay_single_quote_subst"`'
+MANIFEST_TOOL='`$ECHO "$MANIFEST_TOOL" | $SED "$delay_single_quote_subst"`'
+DSYMUTIL='`$ECHO "$DSYMUTIL" | $SED "$delay_single_quote_subst"`'
+NMEDIT='`$ECHO "$NMEDIT" | $SED "$delay_single_quote_subst"`'
+LIPO='`$ECHO "$LIPO" | $SED "$delay_single_quote_subst"`'
+OTOOL='`$ECHO "$OTOOL" | $SED "$delay_single_quote_subst"`'
+OTOOL64='`$ECHO "$OTOOL64" | $SED "$delay_single_quote_subst"`'
+libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
+shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
+extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds_need_lc='`$ECHO "$archive_cmds_need_lc" | $SED "$delay_single_quote_subst"`'
+enable_shared_with_static_runtimes='`$ECHO "$enable_shared_with_static_runtimes" | $SED "$delay_single_quote_subst"`'
+export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
+whole_archive_flag_spec='`$ECHO "$whole_archive_flag_spec" | $SED "$delay_single_quote_subst"`'
+compiler_needs_object='`$ECHO "$compiler_needs_object" | $SED "$delay_single_quote_subst"`'
+old_archive_from_new_cmds='`$ECHO "$old_archive_from_new_cmds" | $SED "$delay_single_quote_subst"`'
+old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
+archive_cmds='`$ECHO "$archive_cmds" | $SED "$delay_single_quote_subst"`'
+archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+module_cmds='`$ECHO "$module_cmds" | $SED "$delay_single_quote_subst"`'
+module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
+with_gnu_ld='`$ECHO "$with_gnu_ld" | $SED "$delay_single_quote_subst"`'
+allow_undefined_flag='`$ECHO "$allow_undefined_flag" | $SED "$delay_single_quote_subst"`'
+no_undefined_flag='`$ECHO "$no_undefined_flag" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_flag_spec='`$ECHO "$hardcode_libdir_flag_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_libdir_separator='`$ECHO "$hardcode_libdir_separator" | $SED "$delay_single_quote_subst"`'
+hardcode_direct='`$ECHO "$hardcode_direct" | $SED "$delay_single_quote_subst"`'
+hardcode_direct_absolute='`$ECHO "$hardcode_direct_absolute" | $SED "$delay_single_quote_subst"`'
+hardcode_minus_L='`$ECHO "$hardcode_minus_L" | $SED "$delay_single_quote_subst"`'
+hardcode_shlibpath_var='`$ECHO "$hardcode_shlibpath_var" | $SED "$delay_single_quote_subst"`'
+hardcode_automatic='`$ECHO "$hardcode_automatic" | $SED "$delay_single_quote_subst"`'
+inherit_rpath='`$ECHO "$inherit_rpath" | $SED "$delay_single_quote_subst"`'
+link_all_deplibs='`$ECHO "$link_all_deplibs" | $SED "$delay_single_quote_subst"`'
+always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
+export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
+exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
+include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
+prelink_cmds='`$ECHO "$prelink_cmds" | $SED "$delay_single_quote_subst"`'
+postlink_cmds='`$ECHO "$postlink_cmds" | $SED "$delay_single_quote_subst"`'
+file_list_spec='`$ECHO "$file_list_spec" | $SED "$delay_single_quote_subst"`'
+variables_saved_for_relink='`$ECHO "$variables_saved_for_relink" | $SED "$delay_single_quote_subst"`'
+need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
+need_version='`$ECHO "$need_version" | $SED "$delay_single_quote_subst"`'
+version_type='`$ECHO "$version_type" | $SED "$delay_single_quote_subst"`'
+runpath_var='`$ECHO "$runpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_var='`$ECHO "$shlibpath_var" | $SED "$delay_single_quote_subst"`'
+shlibpath_overrides_runpath='`$ECHO "$shlibpath_overrides_runpath" | $SED "$delay_single_quote_subst"`'
+libname_spec='`$ECHO "$libname_spec" | $SED "$delay_single_quote_subst"`'
+library_names_spec='`$ECHO "$library_names_spec" | $SED "$delay_single_quote_subst"`'
+soname_spec='`$ECHO "$soname_spec" | $SED "$delay_single_quote_subst"`'
+install_override_mode='`$ECHO "$install_override_mode" | $SED "$delay_single_quote_subst"`'
+postinstall_cmds='`$ECHO "$postinstall_cmds" | $SED "$delay_single_quote_subst"`'
+postuninstall_cmds='`$ECHO "$postuninstall_cmds" | $SED "$delay_single_quote_subst"`'
+finish_cmds='`$ECHO "$finish_cmds" | $SED "$delay_single_quote_subst"`'
+finish_eval='`$ECHO "$finish_eval" | $SED "$delay_single_quote_subst"`'
+hardcode_into_libs='`$ECHO "$hardcode_into_libs" | $SED "$delay_single_quote_subst"`'
+sys_lib_search_path_spec='`$ECHO "$sys_lib_search_path_spec" | $SED "$delay_single_quote_subst"`'
+sys_lib_dlsearch_path_spec='`$ECHO "$sys_lib_dlsearch_path_spec" | $SED "$delay_single_quote_subst"`'
+hardcode_action='`$ECHO "$hardcode_action" | $SED "$delay_single_quote_subst"`'
+enable_dlopen='`$ECHO "$enable_dlopen" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self='`$ECHO "$enable_dlopen_self" | $SED "$delay_single_quote_subst"`'
+enable_dlopen_self_static='`$ECHO "$enable_dlopen_self_static" | $SED "$delay_single_quote_subst"`'
+old_striplib='`$ECHO "$old_striplib" | $SED "$delay_single_quote_subst"`'
+striplib='`$ECHO "$striplib" | $SED "$delay_single_quote_subst"`'
+
+LTCC='$LTCC'
+LTCFLAGS='$LTCFLAGS'
+compiler='$compiler_DEFAULT'
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$1
+_LTECHO_EOF'
+}
+
+# Quote evaled strings.
+for var in SHELL \
+ECHO \
+PATH_SEPARATOR \
+SED \
+GREP \
+EGREP \
+FGREP \
+LD \
+NM \
+LN_S \
+lt_SP2NL \
+lt_NL2SP \
+reload_flag \
+OBJDUMP \
+deplibs_check_method \
+file_magic_cmd \
+file_magic_glob \
+want_nocaseglob \
+DLLTOOL \
+sharedlib_from_linklib_cmd \
+AR \
+AR_FLAGS \
+archiver_list_spec \
+STRIP \
+RANLIB \
+CC \
+CFLAGS \
+compiler \
+lt_cv_sys_global_symbol_pipe \
+lt_cv_sys_global_symbol_to_cdecl \
+lt_cv_sys_global_symbol_to_c_name_address \
+lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
+nm_file_list_spec \
+lt_prog_compiler_no_builtin_flag \
+lt_prog_compiler_pic \
+lt_prog_compiler_wl \
+lt_prog_compiler_static \
+lt_cv_prog_compiler_c_o \
+need_locks \
+MANIFEST_TOOL \
+DSYMUTIL \
+NMEDIT \
+LIPO \
+OTOOL \
+OTOOL64 \
+shrext_cmds \
+export_dynamic_flag_spec \
+whole_archive_flag_spec \
+compiler_needs_object \
+with_gnu_ld \
+allow_undefined_flag \
+no_undefined_flag \
+hardcode_libdir_flag_spec \
+hardcode_libdir_separator \
+exclude_expsyms \
+include_expsyms \
+file_list_spec \
+variables_saved_for_relink \
+libname_spec \
+library_names_spec \
+soname_spec \
+install_override_mode \
+finish_eval \
+old_striplib \
+striplib; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED \\"\\\$sed_quote_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+# Double-quote double-evaled strings.
+for var in reload_cmds \
+old_postinstall_cmds \
+old_postuninstall_cmds \
+old_archive_cmds \
+extract_expsyms_cmds \
+old_archive_from_new_cmds \
+old_archive_from_expsyms_cmds \
+archive_cmds \
+archive_expsym_cmds \
+module_cmds \
+module_expsym_cmds \
+export_symbols_cmds \
+prelink_cmds \
+postlink_cmds \
+postinstall_cmds \
+postuninstall_cmds \
+finish_cmds \
+sys_lib_search_path_spec \
+sys_lib_dlsearch_path_spec; do
+    case \`eval \\\\\$ECHO \\\\""\\\\\$\$var"\\\\"\` in
+    *[\\\\\\\`\\"\\\$]*)
+      eval "lt_\$var=\\\\\\"\\\`\\\$ECHO \\"\\\$\$var\\" | \\\$SED -e \\"\\\$double_quote_subst\\" -e \\"\\\$sed_quote_subst\\" -e \\"\\\$delay_variable_subst\\"\\\`\\\\\\""
+      ;;
+    *)
+      eval "lt_\$var=\\\\\\"\\\$\$var\\\\\\""
+      ;;
+    esac
+done
+
+ac_aux_dir='$ac_aux_dir'
+xsi_shell='$xsi_shell'
+lt_shell_append='$lt_shell_append'
+
+# See if we are running on zsh, and set the options which allow our
+# commands through without removal of \ escapes INIT.
+if test -n "\${ZSH_VERSION+set}" ; then
+   setopt NO_GLOB_SUBST
+fi
+
+
+    PACKAGE='$PACKAGE'
+    VERSION='$VERSION'
+    TIMESTAMP='$TIMESTAMP'
+    RM='$RM'
+    ofile='$ofile'
+
+
+
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "libtool") CONFIG_COMMANDS="$CONFIG_COMMANDS libtool" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp= ac_tmp=
+  trap 'exit_status=$?
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
+s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+# Set up the scripts for CONFIG_HEADERS section.
+# No need to generate them if there are no CONFIG_HEADERS.
+# This happens for instance with `./config.status Makefile'.
+if test -n "$CONFIG_HEADERS"; then
+cat >"$ac_tmp/defines.awk" <<\_ACAWK ||
+BEGIN {
+_ACEOF
+
+# Transform confdefs.h into an awk script `defines.awk', embedded as
+# here-document in config.status, that substitutes the proper values into
+# config.h.in to produce config.h.
+
+# Create a delimiter string that does not exist in confdefs.h, to ease
+# handling of long lines.
+ac_delim='%!_!# '
+for ac_last_try in false false :; do
+  ac_tt=`sed -n "/$ac_delim/p" confdefs.h`
+  if test -z "$ac_tt"; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_HEADERS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+
+# For the awk script, D is an array of macro values keyed by name,
+# likewise P contains macro parameters if any.  Preserve backslash
+# newline sequences.
+
+ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
+sed -n '
+s/.\{148\}/&'"$ac_delim"'/g
+t rset
+:rset
+s/^[	 ]*#[	 ]*define[	 ][	 ]*/ /
+t def
+d
+:def
+s/\\$//
+t bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3"/p
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2"/p
+d
+:bsnl
+s/["\\]/\\&/g
+s/^ \('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/P["\1"]="\2"\
+D["\1"]=" \3\\\\\\n"\\/p
+t cont
+s/^ \('"$ac_word_re"'\)[	 ]*\(.*\)/D["\1"]=" \2\\\\\\n"\\/p
+t cont
+d
+:cont
+n
+s/.\{148\}/&'"$ac_delim"'/g
+t clear
+:clear
+s/\\$//
+t bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/"/p
+d
+:bsnlc
+s/["\\]/\\&/g; s/^/"/; s/$/\\\\\\n"\\/p
+b cont
+' <confdefs.h | sed '
+s/'"$ac_delim"'/"\\\
+"/g' >>$CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  for (key in D) D_is_set[key] = 1
+  FS = ""
+}
+/^[\t ]*#[\t ]*(define|undef)[\t ]+$ac_word_re([\t (]|\$)/ {
+  line = \$ 0
+  split(line, arg, " ")
+  if (arg[1] == "#") {
+    defundef = arg[2]
+    mac1 = arg[3]
+  } else {
+    defundef = substr(arg[1], 2)
+    mac1 = arg[2]
+  }
+  split(mac1, mac2, "(") #)
+  macro = mac2[1]
+  prefix = substr(line, 1, index(line, defundef) - 1)
+  if (D_is_set[macro]) {
+    # Preserve the white space surrounding the "#".
+    print prefix "define", macro P[macro] D[macro]
+    next
+  } else {
+    # Replace #undef with comments.  This is necessary, for example,
+    # in the case of _POSIX_SOURCE, which is predefined and required
+    # on some systems where configure will not decide to define it.
+    if (defundef == "undef") {
+      print "/*", prefix defundef, macro, "*/"
+      next
+    }
+  }
+}
+{ print }
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+  as_fn_error $? "could not setup config headers machinery" "$LINENO" 5
+fi # test -n "$CONFIG_HEADERS"
+
+
+eval set X "  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$ac_tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&2;}
+
+  rm -f "$ac_tmp/stdin"
+  case $ac_file in
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ ;;
+  :H)
+  #
+  # CONFIG_HEADER
+  #
+  if test x"$ac_file" != x-; then
+    {
+      $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs"
+    } >"$ac_tmp/config.h" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    if diff "$ac_file" "$ac_tmp/config.h" >/dev/null 2>&1; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: $ac_file is unchanged" >&5
+$as_echo "$as_me: $ac_file is unchanged" >&6;}
+    else
+      rm -f "$ac_file"
+      mv "$ac_tmp/config.h" "$ac_file" \
+	|| as_fn_error $? "could not create $ac_file" "$LINENO" 5
+    fi
+  else
+    $as_echo "/* $configure_input  */" \
+      && eval '$AWK -f "$ac_tmp/defines.awk"' "$ac_file_inputs" \
+      || as_fn_error $? "could not create -" "$LINENO" 5
+  fi
+# Compute "$ac_file"'s index in $config_headers.
+_am_arg="$ac_file"
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $_am_arg | $_am_arg:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
+$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$_am_arg" : 'X\(//\)[^/]' \| \
+	 X"$_am_arg" : 'X\(//\)$' \| \
+	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$_am_arg" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`/stamp-h$_am_stamp_count
+ ;;
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Older Autoconf quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named 'Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running 'make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "$am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+    "libtool":C)
+
+    # See if we are running on zsh, and set the options which allow our
+    # commands through without removal of \ escapes.
+    if test -n "${ZSH_VERSION+set}" ; then
+      setopt NO_GLOB_SUBST
+    fi
+
+    cfgfile="${ofile}T"
+    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
+    $RM "$cfgfile"
+
+    cat <<_LT_EOF >> "$cfgfile"
+#! $SHELL
+
+# `$ECHO "$ofile" | sed 's%^.*/%%'` - Provide generalized library-building support services.
+# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION
+# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
+# NOTE: Changes made to this file will be lost: look at ltmain.sh.
+#
+#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,
+#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+#                 Foundation, Inc.
+#   Written by Gordon Matzigkeit, 1996
+#
+#   This file is part of GNU Libtool.
+#
+# GNU Libtool is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html, or
+# obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
+# The names of the tagged configurations supported by this script.
+available_tags=""
+
+# ### BEGIN LIBTOOL CONFIG
+
+# Which release of libtool.m4 was used?
+macro_version=$macro_version
+macro_revision=$macro_revision
+
+# Whether or not to build shared libraries.
+build_libtool_libs=$enable_shared
+
+# Whether or not to build static libraries.
+build_old_libs=$enable_static
+
+# What type of objects to build.
+pic_mode=$pic_mode
+
+# Whether or not to optimize for fast installation.
+fast_install=$enable_fast_install
+
+# Shell to use when invoking shell scripts.
+SHELL=$lt_SHELL
+
+# An echo program that protects backslashes.
+ECHO=$lt_ECHO
+
+# The PATH separator for the build system.
+PATH_SEPARATOR=$lt_PATH_SEPARATOR
+
+# The host system.
+host_alias=$host_alias
+host=$host
+host_os=$host_os
+
+# The build system.
+build_alias=$build_alias
+build=$build
+build_os=$build_os
+
+# A sed program that does not truncate output.
+SED=$lt_SED
+
+# Sed that helps us avoid accidentally triggering echo(1) options like -n.
+Xsed="\$SED -e 1s/^X//"
+
+# A grep program that handles long lines.
+GREP=$lt_GREP
+
+# An ERE matcher.
+EGREP=$lt_EGREP
+
+# A literal string matcher.
+FGREP=$lt_FGREP
+
+# A BSD- or MS-compatible name lister.
+NM=$lt_NM
+
+# Whether we need soft or hard links.
+LN_S=$lt_LN_S
+
+# What is the maximum length of a command?
+max_cmd_len=$max_cmd_len
+
+# Object file suffix (normally "o").
+objext=$ac_objext
+
+# Executable file suffix (normally "").
+exeext=$exeext
+
+# whether the shell understands "unset".
+lt_unset=$lt_unset
+
+# turn spaces into newlines.
+SP2NL=$lt_lt_SP2NL
+
+# turn newlines into spaces.
+NL2SP=$lt_lt_NL2SP
+
+# convert \$build file names to \$host format.
+to_host_file_cmd=$lt_cv_to_host_file_cmd
+
+# convert \$build files to toolchain format.
+to_tool_file_cmd=$lt_cv_to_tool_file_cmd
+
+# An object symbol dumper.
+OBJDUMP=$lt_OBJDUMP
+
+# Method to check whether dependent libraries are shared objects.
+deplibs_check_method=$lt_deplibs_check_method
+
+# Command to use when deplibs_check_method = "file_magic".
+file_magic_cmd=$lt_file_magic_cmd
+
+# How to find potential files when deplibs_check_method = "file_magic".
+file_magic_glob=$lt_file_magic_glob
+
+# Find potential files using nocaseglob when deplibs_check_method = "file_magic".
+want_nocaseglob=$lt_want_nocaseglob
+
+# DLL creation program.
+DLLTOOL=$lt_DLLTOOL
+
+# Command to associate shared and link libraries.
+sharedlib_from_linklib_cmd=$lt_sharedlib_from_linklib_cmd
+
+# The archiver.
+AR=$lt_AR
+
+# Flags to create an archive.
+AR_FLAGS=$lt_AR_FLAGS
+
+# How to feed a file listing to the archiver.
+archiver_list_spec=$lt_archiver_list_spec
+
+# A symbol stripping program.
+STRIP=$lt_STRIP
+
+# Commands used to install an old-style archive.
+RANLIB=$lt_RANLIB
+old_postinstall_cmds=$lt_old_postinstall_cmds
+old_postuninstall_cmds=$lt_old_postuninstall_cmds
+
+# Whether to use a lock for old archive extraction.
+lock_old_archive_extraction=$lock_old_archive_extraction
+
+# A C compiler.
+LTCC=$lt_CC
+
+# LTCC compiler flags.
+LTCFLAGS=$lt_CFLAGS
+
+# Take the output of nm and produce a listing of raw symbols and C names.
+global_symbol_pipe=$lt_lt_cv_sys_global_symbol_pipe
+
+# Transform the output of nm in a proper C declaration.
+global_symbol_to_cdecl=$lt_lt_cv_sys_global_symbol_to_cdecl
+
+# Transform the output of nm in a C name address pair.
+global_symbol_to_c_name_address=$lt_lt_cv_sys_global_symbol_to_c_name_address
+
+# Transform the output of nm in a C name address pair when lib prefix is needed.
+global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
+
+# Specify filename containing input files for \$NM.
+nm_file_list_spec=$lt_nm_file_list_spec
+
+# The root where to search for dependent libraries,and in which our libraries should be installed.
+lt_sysroot=$lt_sysroot
+
+# The name of the directory that contains temporary libtool files.
+objdir=$objdir
+
+# Used to examine libraries when file_magic_cmd begins with "file".
+MAGIC_CMD=$MAGIC_CMD
+
+# Must we lock files when doing compilation?
+need_locks=$lt_need_locks
+
+# Manifest tool.
+MANIFEST_TOOL=$lt_MANIFEST_TOOL
+
+# Tool to manipulate archived DWARF debug symbol files on Mac OS X.
+DSYMUTIL=$lt_DSYMUTIL
+
+# Tool to change global to local symbols on Mac OS X.
+NMEDIT=$lt_NMEDIT
+
+# Tool to manipulate fat objects and archives on Mac OS X.
+LIPO=$lt_LIPO
+
+# ldd/readelf like tool for Mach-O binaries on Mac OS X.
+OTOOL=$lt_OTOOL
+
+# ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4.
+OTOOL64=$lt_OTOOL64
+
+# Old archive suffix (normally "a").
+libext=$libext
+
+# Shared library suffix (normally ".so").
+shrext_cmds=$lt_shrext_cmds
+
+# The commands to extract the exported symbol list from a shared archive.
+extract_expsyms_cmds=$lt_extract_expsyms_cmds
+
+# Variables whose values should be saved in libtool wrapper scripts and
+# restored at link time.
+variables_saved_for_relink=$lt_variables_saved_for_relink
+
+# Do we need the "lib" prefix for modules?
+need_lib_prefix=$need_lib_prefix
+
+# Do we need a version for libraries?
+need_version=$need_version
+
+# Library versioning type.
+version_type=$version_type
+
+# Shared library runtime path variable.
+runpath_var=$runpath_var
+
+# Shared library path variable.
+shlibpath_var=$shlibpath_var
+
+# Is shlibpath searched before the hard-coded library search path?
+shlibpath_overrides_runpath=$shlibpath_overrides_runpath
+
+# Format of library name prefix.
+libname_spec=$lt_libname_spec
+
+# List of archive names.  First name is the real one, the rest are links.
+# The last name is the one that the linker finds with -lNAME
+library_names_spec=$lt_library_names_spec
+
+# The coded name of the library, if different from the real name.
+soname_spec=$lt_soname_spec
+
+# Permission mode override for installation of shared libraries.
+install_override_mode=$lt_install_override_mode
+
+# Command to use after installation of a shared archive.
+postinstall_cmds=$lt_postinstall_cmds
+
+# Command to use after uninstallation of a shared archive.
+postuninstall_cmds=$lt_postuninstall_cmds
+
+# Commands used to finish a libtool library installation in a directory.
+finish_cmds=$lt_finish_cmds
+
+# As "finish_cmds", except a single script fragment to be evaled but
+# not shown.
+finish_eval=$lt_finish_eval
+
+# Whether we should hardcode library paths into libraries.
+hardcode_into_libs=$hardcode_into_libs
+
+# Compile-time system search path for libraries.
+sys_lib_search_path_spec=$lt_sys_lib_search_path_spec
+
+# Run-time system search path for libraries.
+sys_lib_dlsearch_path_spec=$lt_sys_lib_dlsearch_path_spec
+
+# Whether dlopen is supported.
+dlopen_support=$enable_dlopen
+
+# Whether dlopen of programs is supported.
+dlopen_self=$enable_dlopen_self
+
+# Whether dlopen of statically linked programs is supported.
+dlopen_self_static=$enable_dlopen_self_static
+
+# Commands to strip libraries.
+old_striplib=$lt_old_striplib
+striplib=$lt_striplib
+
+
+# The linker used to build libraries.
+LD=$lt_LD
+
+# How to create reloadable object files.
+reload_flag=$lt_reload_flag
+reload_cmds=$lt_reload_cmds
+
+# Commands used to build an old-style archive.
+old_archive_cmds=$lt_old_archive_cmds
+
+# A language specific compiler.
+CC=$lt_compiler
+
+# Is the compiler the GNU compiler?
+with_gcc=$GCC
+
+# Compiler flag to turn off builtin functions.
+no_builtin_flag=$lt_lt_prog_compiler_no_builtin_flag
+
+# Additional compiler flags for building library objects.
+pic_flag=$lt_lt_prog_compiler_pic
+
+# How to pass a linker flag through the compiler.
+wl=$lt_lt_prog_compiler_wl
+
+# Compiler flag to prevent dynamic linking.
+link_static_flag=$lt_lt_prog_compiler_static
+
+# Does compiler simultaneously support -c and -o options?
+compiler_c_o=$lt_lt_cv_prog_compiler_c_o
+
+# Whether or not to add -lc for building shared libraries.
+build_libtool_need_lc=$archive_cmds_need_lc
+
+# Whether or not to disallow shared libs when runtime libs are static.
+allow_libtool_libs_with_static_runtimes=$enable_shared_with_static_runtimes
+
+# Compiler flag to allow reflexive dlopens.
+export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
+
+# Compiler flag to generate shared objects directly from archives.
+whole_archive_flag_spec=$lt_whole_archive_flag_spec
+
+# Whether the compiler copes with passing no objects directly.
+compiler_needs_object=$lt_compiler_needs_object
+
+# Create an old-style archive from a shared archive.
+old_archive_from_new_cmds=$lt_old_archive_from_new_cmds
+
+# Create a temporary old-style archive to link instead of a shared archive.
+old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
+
+# Commands used to build a shared archive.
+archive_cmds=$lt_archive_cmds
+archive_expsym_cmds=$lt_archive_expsym_cmds
+
+# Commands used to build a loadable module if different from building
+# a shared archive.
+module_cmds=$lt_module_cmds
+module_expsym_cmds=$lt_module_expsym_cmds
+
+# Whether we are building with GNU ld or not.
+with_gnu_ld=$lt_with_gnu_ld
+
+# Flag that allows shared libraries with undefined symbols to be built.
+allow_undefined_flag=$lt_allow_undefined_flag
+
+# Flag that enforces no undefined symbols.
+no_undefined_flag=$lt_no_undefined_flag
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist
+hardcode_libdir_flag_spec=$lt_hardcode_libdir_flag_spec
+
+# Whether we need a single "-rpath" flag with a separated argument.
+hardcode_libdir_separator=$lt_hardcode_libdir_separator
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary.
+hardcode_direct=$hardcode_direct
+
+# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
+# DIR into the resulting binary and the resulting library dependency is
+# "absolute",i.e impossible to change by setting \${shlibpath_var} if the
+# library is relocated.
+hardcode_direct_absolute=$hardcode_direct_absolute
+
+# Set to "yes" if using the -LDIR flag during linking hardcodes DIR
+# into the resulting binary.
+hardcode_minus_L=$hardcode_minus_L
+
+# Set to "yes" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR
+# into the resulting binary.
+hardcode_shlibpath_var=$hardcode_shlibpath_var
+
+# Set to "yes" if building a shared library automatically hardcodes DIR
+# into the library and all subsequent libraries and executables linked
+# against it.
+hardcode_automatic=$hardcode_automatic
+
+# Set to yes if linker adds runtime paths of dependent libraries
+# to runtime path list.
+inherit_rpath=$inherit_rpath
+
+# Whether libtool must link a program against all its dependency libraries.
+link_all_deplibs=$link_all_deplibs
+
+# Set to "yes" if exported symbols are required.
+always_export_symbols=$always_export_symbols
+
+# The commands to list exported symbols.
+export_symbols_cmds=$lt_export_symbols_cmds
+
+# Symbols that should not be listed in the preloaded symbols.
+exclude_expsyms=$lt_exclude_expsyms
+
+# Symbols that must always be exported.
+include_expsyms=$lt_include_expsyms
+
+# Commands necessary for linking programs (against libraries) with templates.
+prelink_cmds=$lt_prelink_cmds
+
+# Commands necessary for finishing linking programs.
+postlink_cmds=$lt_postlink_cmds
+
+# Specify filename containing input files.
+file_list_spec=$lt_file_list_spec
+
+# How to hardcode a shared library path into an executable.
+hardcode_action=$hardcode_action
+
+# ### END LIBTOOL CONFIG
+
+_LT_EOF
+
+  case $host_os in
+  aix3*)
+    cat <<\_LT_EOF >> "$cfgfile"
+# AIX sometimes has problems with the GCC collect2 program.  For some
+# reason, if we set the COLLECT_NAMES environment variable, the problems
+# vanish in a puff of smoke.
+if test "X${COLLECT_NAMES+set}" != Xset; then
+  COLLECT_NAMES=
+  export COLLECT_NAMES
+fi
+_LT_EOF
+    ;;
+  esac
+
+
+ltmain="$ac_aux_dir/ltmain.sh"
+
+
+  # We use sed instead of cat because bash on DJGPP gets confused if
+  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
+  # text mode, it properly converts lines to CR/LF.  This bash problem
+  # is reportedly fixed, but why not run on old versions too?
+  sed '$q' "$ltmain" >> "$cfgfile" \
+     || (rm -f "$cfgfile"; exit 1)
+
+  if test x"$xsi_shell" = xyes; then
+  sed -e '/^func_dirname ()$/,/^} # func_dirname /c\
+func_dirname ()\
+{\
+\    case ${1} in\
+\      */*) func_dirname_result="${1%/*}${2}" ;;\
+\      *  ) func_dirname_result="${3}" ;;\
+\    esac\
+} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_basename ()$/,/^} # func_basename /c\
+func_basename ()\
+{\
+\    func_basename_result="${1##*/}"\
+} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_dirname_and_basename ()$/,/^} # func_dirname_and_basename /c\
+func_dirname_and_basename ()\
+{\
+\    case ${1} in\
+\      */*) func_dirname_result="${1%/*}${2}" ;;\
+\      *  ) func_dirname_result="${3}" ;;\
+\    esac\
+\    func_basename_result="${1##*/}"\
+} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_stripname ()$/,/^} # func_stripname /c\
+func_stripname ()\
+{\
+\    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\
+\    # positional parameters, so assign one to ordinary parameter first.\
+\    func_stripname_result=${3}\
+\    func_stripname_result=${func_stripname_result#"${1}"}\
+\    func_stripname_result=${func_stripname_result%"${2}"}\
+} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_split_long_opt ()$/,/^} # func_split_long_opt /c\
+func_split_long_opt ()\
+{\
+\    func_split_long_opt_name=${1%%=*}\
+\    func_split_long_opt_arg=${1#*=}\
+} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_split_short_opt ()$/,/^} # func_split_short_opt /c\
+func_split_short_opt ()\
+{\
+\    func_split_short_opt_arg=${1#??}\
+\    func_split_short_opt_name=${1%"$func_split_short_opt_arg"}\
+} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_lo2o ()$/,/^} # func_lo2o /c\
+func_lo2o ()\
+{\
+\    case ${1} in\
+\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
+\      *)    func_lo2o_result=${1} ;;\
+\    esac\
+} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_xform ()$/,/^} # func_xform /c\
+func_xform ()\
+{\
+    func_xform_result=${1%.*}.lo\
+} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_arith ()$/,/^} # func_arith /c\
+func_arith ()\
+{\
+    func_arith_result=$(( $* ))\
+} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_len ()$/,/^} # func_len /c\
+func_len ()\
+{\
+    func_len_result=${#1}\
+} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+fi
+
+if test x"$lt_shell_append" = xyes; then
+  sed -e '/^func_append ()$/,/^} # func_append /c\
+func_append ()\
+{\
+    eval "${1}+=\\${2}"\
+} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  sed -e '/^func_append_quoted ()$/,/^} # func_append_quoted /c\
+func_append_quoted ()\
+{\
+\    func_quote_for_eval "${2}"\
+\    eval "${1}+=\\\\ \\$func_quote_for_eval_result"\
+} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
+  && mv -f "$cfgfile.tmp" "$cfgfile" \
+    || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+test 0 -eq $? || _lt_function_replace_fail=:
+
+
+  # Save a `func_append' function call where possible by direct use of '+='
+  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1+="%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+else
+  # Save a `func_append' function call even when '+=' is not available
+  sed -e 's%func_append \([a-zA-Z_]\{1,\}\) "%\1="$\1%g' $cfgfile > $cfgfile.tmp \
+    && mv -f "$cfgfile.tmp" "$cfgfile" \
+      || (rm -f "$cfgfile" && cp "$cfgfile.tmp" "$cfgfile" && rm -f "$cfgfile.tmp")
+  test 0 -eq $? || _lt_function_replace_fail=:
+fi
+
+if test x"$_lt_function_replace_fail" = x":"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
+$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
+fi
+
+
+   mv -f "$cfgfile" "$ofile" ||
+    (rm -f "$ofile" && cp "$cfgfile" "$ofile" && rm -f "$cfgfile")
+  chmod +x "$ofile"
+
+ ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
diff --git a/release/src/router/libev-4.22/configure.ac b/release/src/router/libev-4.22/configure.ac
new file mode 100644
index 0000000000..dbdcda88d2
--- /dev/null
+++ b/release/src/router/libev-4.22/configure.ac
@@ -0,0 +1,27 @@
+AC_INIT
+
+orig_CFLAGS="$CFLAGS"
+
+AC_CONFIG_SRCDIR([ev_epoll.c])
+
+dnl also update ev.h!
+AM_INIT_AUTOMAKE(libev,4.22)
+AC_CONFIG_HEADERS([config.h])
+AM_MAINTAINER_MODE
+
+AC_PROG_CC
+
+dnl Supply default CFLAGS, if not specified
+if test -z "$orig_CFLAGS"; then
+  if test x$GCC = xyes; then
+    CFLAGS="-g -O3"
+  fi
+fi
+
+AC_PROG_INSTALL
+AC_PROG_LIBTOOL
+
+m4_include([libev.m4])
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff --git a/release/src/router/libev-4.22/depcomp b/release/src/router/libev-4.22/depcomp
new file mode 100755
index 0000000000..4ebd5b3a2f
--- /dev/null
+++ b/release/src/router/libev-4.22/depcomp
@@ -0,0 +1,791 @@
+#! /bin/sh
+# depcomp - compile a program generating dependencies as side-effects
+
+scriptversion=2013-05-30.07; # UTC
+
+# Copyright (C) 1999-2013 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
+
+case $1 in
+  '')
+    echo "$0: No command.  Try '$0 --help' for more information." 1>&2
+    exit 1;
+    ;;
+  -h | --h*)
+    cat <<\EOF
+Usage: depcomp [--help] [--version] PROGRAM [ARGS]
+
+Run PROGRAMS ARGS to compile a file, generating dependencies
+as side-effects.
+
+Environment variables:
+  depmode     Dependency tracking mode.
+  source      Source file read by 'PROGRAMS ARGS'.
+  object      Object file output by 'PROGRAMS ARGS'.
+  DEPDIR      directory where to store dependencies.
+  depfile     Dependency file to output.
+  tmpdepfile  Temporary file to use when outputting dependencies.
+  libtool     Whether libtool is used (yes/no).
+
+Report bugs to <bug-automake@gnu.org>.
+EOF
+    exit $?
+    ;;
+  -v | --v*)
+    echo "depcomp $scriptversion"
+    exit $?
+    ;;
+esac
+
+# Get the directory component of the given path, and save it in the
+# global variables '$dir'.  Note that this directory component will
+# be either empty or ending with a '/' character.  This is deliberate.
+set_dir_from ()
+{
+  case $1 in
+    */*) dir=`echo "$1" | sed -e 's|/[^/]*$|/|'`;;
+      *) dir=;;
+  esac
+}
+
+# Get the suffix-stripped basename of the given path, and save it the
+# global variable '$base'.
+set_base_from ()
+{
+  base=`echo "$1" | sed -e 's|^.*/||' -e 's/\.[^.]*$//'`
+}
+
+# If no dependency file was actually created by the compiler invocation,
+# we still have to create a dummy depfile, to avoid errors with the
+# Makefile "include basename.Plo" scheme.
+make_dummy_depfile ()
+{
+  echo "#dummy" > "$depfile"
+}
+
+# Factor out some common post-processing of the generated depfile.
+# Requires the auxiliary global variable '$tmpdepfile' to be set.
+aix_post_process_depfile ()
+{
+  # If the compiler actually managed to produce a dependency file,
+  # post-process it.
+  if test -f "$tmpdepfile"; then
+    # Each line is of the form 'foo.o: dependency.h'.
+    # Do two passes, one to just change these to
+    #   $object: dependency.h
+    # and one to simply output
+    #   dependency.h:
+    # which is needed to avoid the deleted-header problem.
+    { sed -e "s,^.*\.[$lower]*:,$object:," < "$tmpdepfile"
+      sed -e "s,^.*\.[$lower]*:[$tab ]*,," -e 's,$,:,' < "$tmpdepfile"
+    } > "$depfile"
+    rm -f "$tmpdepfile"
+  else
+    make_dummy_depfile
+  fi
+}
+
+# A tabulation character.
+tab='	'
+# A newline character.
+nl='
+'
+# Character ranges might be problematic outside the C locale.
+# These definitions help.
+upper=ABCDEFGHIJKLMNOPQRSTUVWXYZ
+lower=abcdefghijklmnopqrstuvwxyz
+digits=0123456789
+alpha=${upper}${lower}
+
+if test -z "$depmode" || test -z "$source" || test -z "$object"; then
+  echo "depcomp: Variables source, object and depmode must be set" 1>&2
+  exit 1
+fi
+
+# Dependencies for sub/bar.o or sub/bar.obj go into sub/.deps/bar.Po.
+depfile=${depfile-`echo "$object" |
+  sed 's|[^\\/]*$|'${DEPDIR-.deps}'/&|;s|\.\([^.]*\)$|.P\1|;s|Pobj$|Po|'`}
+tmpdepfile=${tmpdepfile-`echo "$depfile" | sed 's/\.\([^.]*\)$/.T\1/'`}
+
+rm -f "$tmpdepfile"
+
+# Avoid interferences from the environment.
+gccflag= dashmflag=
+
+# Some modes work just like other modes, but use different flags.  We
+# parameterize here, but still list the modes in the big case below,
+# to make depend.m4 easier to write.  Note that we *cannot* use a case
+# here, because this file can only contain one case statement.
+if test "$depmode" = hp; then
+  # HP compiler uses -M and no extra arg.
+  gccflag=-M
+  depmode=gcc
+fi
+
+if test "$depmode" = dashXmstdout; then
+  # This is just like dashmstdout with a different argument.
+  dashmflag=-xM
+  depmode=dashmstdout
+fi
+
+cygpath_u="cygpath -u -f -"
+if test "$depmode" = msvcmsys; then
+  # This is just like msvisualcpp but w/o cygpath translation.
+  # Just convert the backslash-escaped backslashes to single forward
+  # slashes to satisfy depend.m4
+  cygpath_u='sed s,\\\\,/,g'
+  depmode=msvisualcpp
+fi
+
+if test "$depmode" = msvc7msys; then
+  # This is just like msvc7 but w/o cygpath translation.
+  # Just convert the backslash-escaped backslashes to single forward
+  # slashes to satisfy depend.m4
+  cygpath_u='sed s,\\\\,/,g'
+  depmode=msvc7
+fi
+
+if test "$depmode" = xlc; then
+  # IBM C/C++ Compilers xlc/xlC can output gcc-like dependency information.
+  gccflag=-qmakedep=gcc,-MF
+  depmode=gcc
+fi
+
+case "$depmode" in
+gcc3)
+## gcc 3 implements dependency tracking that does exactly what
+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like
+## it if -MD -MP comes after the -MF stuff.  Hmm.
+## Unfortunately, FreeBSD c89 acceptance of flags depends upon
+## the command line argument order; so add the flags where they
+## appear in depend2.am.  Note that the slowdown incurred here
+## affects only configure: in makefiles, %FASTDEP% shortcuts this.
+  for arg
+  do
+    case $arg in
+    -c) set fnord "$@" -MT "$object" -MD -MP -MF "$tmpdepfile" "$arg" ;;
+    *)  set fnord "$@" "$arg" ;;
+    esac
+    shift # fnord
+    shift # $arg
+  done
+  "$@"
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  mv "$tmpdepfile" "$depfile"
+  ;;
+
+gcc)
+## Note that this doesn't just cater to obsosete pre-3.x GCC compilers.
+## but also to in-use compilers like IMB xlc/xlC and the HP C compiler.
+## (see the conditional assignment to $gccflag above).
+## There are various ways to get dependency output from gcc.  Here's
+## why we pick this rather obscure method:
+## - Don't want to use -MD because we'd like the dependencies to end
+##   up in a subdir.  Having to rename by hand is ugly.
+##   (We might end up doing this anyway to support other compilers.)
+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like
+##   -MM, not -M (despite what the docs say).  Also, it might not be
+##   supported by the other compilers which use the 'gcc' depmode.
+## - Using -M directly means running the compiler twice (even worse
+##   than renaming).
+  if test -z "$gccflag"; then
+    gccflag=-MD,
+  fi
+  "$@" -Wp,"$gccflag$tmpdepfile"
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  # The second -e expression handles DOS-style file names with drive
+  # letters.
+  sed -e 's/^[^:]*: / /' \
+      -e 's/^['$alpha']:\/[^:]*: / /' < "$tmpdepfile" >> "$depfile"
+## This next piece of magic avoids the "deleted header file" problem.
+## The problem is that when a header file which appears in a .P file
+## is deleted, the dependency causes make to die (because there is
+## typically no way to rebuild the header).  We avoid this by adding
+## dummy dependencies for each header file.  Too bad gcc doesn't do
+## this for us directly.
+## Some versions of gcc put a space before the ':'.  On the theory
+## that the space means something, we add a space to the output as
+## well.  hp depmode also adds that space, but also prefixes the VPATH
+## to the object.  Take care to not repeat it in the output.
+## Some versions of the HPUX 10.20 sed can't process this invocation
+## correctly.  Breaking it into two sed invocations is a workaround.
+  tr ' ' "$nl" < "$tmpdepfile" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e "s|.*$object$||" -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+sgi)
+  if test "$libtool" = yes; then
+    "$@" "-Wp,-MDupdate,$tmpdepfile"
+  else
+    "$@" -MDupdate "$tmpdepfile"
+  fi
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+
+  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files
+    echo "$object : \\" > "$depfile"
+    # Clip off the initial element (the dependent).  Don't try to be
+    # clever and replace this with sed code, as IRIX sed won't handle
+    # lines with more than a fixed number of characters (4096 in
+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;
+    # the IRIX cc adds comments like '#:fec' to the end of the
+    # dependency line.
+    tr ' ' "$nl" < "$tmpdepfile" \
+      | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' \
+      | tr "$nl" ' ' >> "$depfile"
+    echo >> "$depfile"
+    # The second pass generates a dummy entry for each header file.
+    tr ' ' "$nl" < "$tmpdepfile" \
+      | sed -e 's/^.*\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \
+      >> "$depfile"
+  else
+    make_dummy_depfile
+  fi
+  rm -f "$tmpdepfile"
+  ;;
+
+xlc)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+aix)
+  # The C for AIX Compiler uses -M and outputs the dependencies
+  # in a .u file.  In older versions, this file always lives in the
+  # current directory.  Also, the AIX compiler puts '$object:' at the
+  # start of each line; $object doesn't have directory information.
+  # Version 6 uses the directory in both cases.
+  set_dir_from "$object"
+  set_base_from "$object"
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$base.u
+    tmpdepfile3=$dir.libs/$base.u
+    "$@" -Wc,-M
+  else
+    tmpdepfile1=$dir$base.u
+    tmpdepfile2=$dir$base.u
+    tmpdepfile3=$dir$base.u
+    "$@" -M
+  fi
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  aix_post_process_depfile
+  ;;
+
+tcc)
+  # tcc (Tiny C Compiler) understand '-MD -MF file' since version 0.9.26
+  # FIXME: That version still under development at the moment of writing.
+  #        Make that this statement remains true also for stable, released
+  #        versions.
+  # It will wrap lines (doesn't matter whether long or short) with a
+  # trailing '\', as in:
+  #
+  #   foo.o : \
+  #    foo.c \
+  #    foo.h \
+  #
+  # It will put a trailing '\' even on the last line, and will use leading
+  # spaces rather than leading tabs (at least since its commit 0394caf7
+  # "Emit spaces for -MD").
+  "$@" -MD -MF "$tmpdepfile"
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each non-empty line is of the form 'foo.o : \' or ' dep.h \'.
+  # We have to change lines of the first kind to '$object: \'.
+  sed -e "s|.*:|$object :|" < "$tmpdepfile" > "$depfile"
+  # And for each line of the second kind, we have to emit a 'dep.h:'
+  # dummy dependency, to avoid the deleted-header problem.
+  sed -n -e 's|^  *\(.*\) *\\$|\1:|p' < "$tmpdepfile" >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+## The order of this option in the case statement is important, since the
+## shell code in configure will try each of these formats in the order
+## listed in this file.  A plain '-MD' option would be understood by many
+## compilers, so we must ensure this comes after the gcc and icc options.
+pgcc)
+  # Portland's C compiler understands '-MD'.
+  # Will always output deps to 'file.d' where file is the root name of the
+  # source file under compilation, even if file resides in a subdirectory.
+  # The object file name does not affect the name of the '.d' file.
+  # pgcc 10.2 will output
+  #    foo.o: sub/foo.c sub/foo.h
+  # and will wrap long lines using '\' :
+  #    foo.o: sub/foo.c ... \
+  #     sub/foo.h ... \
+  #     ...
+  set_dir_from "$object"
+  # Use the source, not the object, to determine the base name, since
+  # that's sadly what pgcc will do too.
+  set_base_from "$source"
+  tmpdepfile=$base.d
+
+  # For projects that build the same source file twice into different object
+  # files, the pgcc approach of using the *source* file root name can cause
+  # problems in parallel builds.  Use a locking strategy to avoid stomping on
+  # the same $tmpdepfile.
+  lockdir=$base.d-lock
+  trap "
+    echo '$0: caught signal, cleaning up...' >&2
+    rmdir '$lockdir'
+    exit 1
+  " 1 2 13 15
+  numtries=100
+  i=$numtries
+  while test $i -gt 0; do
+    # mkdir is a portable test-and-set.
+    if mkdir "$lockdir" 2>/dev/null; then
+      # This process acquired the lock.
+      "$@" -MD
+      stat=$?
+      # Release the lock.
+      rmdir "$lockdir"
+      break
+    else
+      # If the lock is being held by a different process, wait
+      # until the winning process is done or we timeout.
+      while test -d "$lockdir" && test $i -gt 0; do
+        sleep 1
+        i=`expr $i - 1`
+      done
+    fi
+    i=`expr $i - 1`
+  done
+  trap - 1 2 13 15
+  if test $i -le 0; then
+    echo "$0: failed to acquire lock after $numtries attempts" >&2
+    echo "$0: check lockdir '$lockdir'" >&2
+    exit 1
+  fi
+
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  # Each line is of the form `foo.o: dependent.h',
+  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Do two passes, one to just change these to
+  # `$object: dependent.h' and one to simply `dependent.h:'.
+  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" \
+    | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+hp2)
+  # The "hp" stanza above does not work with aCC (C++) and HP's ia64
+  # compilers, which have integrated preprocessors.  The correct option
+  # to use with these is +Maked; it writes dependencies to a file named
+  # 'foo.d', which lands next to the object file, wherever that
+  # happens to be.
+  # Much of this is similar to the tru64 case; see comments there.
+  set_dir_from  "$object"
+  set_base_from "$object"
+  if test "$libtool" = yes; then
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir.libs/$base.d
+    "$@" -Wc,+Maked
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    "$@" +Maked
+  fi
+  stat=$?
+  if test $stat -ne 0; then
+     rm -f "$tmpdepfile1" "$tmpdepfile2"
+     exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  if test -f "$tmpdepfile"; then
+    sed -e "s,^.*\.[$lower]*:,$object:," "$tmpdepfile" > "$depfile"
+    # Add 'dependent.h:' lines.
+    sed -ne '2,${
+               s/^ *//
+               s/ \\*$//
+               s/$/:/
+               p
+             }' "$tmpdepfile" >> "$depfile"
+  else
+    make_dummy_depfile
+  fi
+  rm -f "$tmpdepfile" "$tmpdepfile2"
+  ;;
+
+tru64)
+  # The Tru64 compiler uses -MD to generate dependencies as a side
+  # effect.  'cc -MD -o foo.o ...' puts the dependencies into 'foo.o.d'.
+  # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put
+  # dependencies in 'foo.d' instead, so we check for that too.
+  # Subdirectories are respected.
+  set_dir_from  "$object"
+  set_base_from "$object"
+
+  if test "$libtool" = yes; then
+    # Libtool generates 2 separate objects for the 2 libraries.  These
+    # two compilations output dependencies in $dir.libs/$base.o.d and
+    # in $dir$base.o.d.  We have to check for both files, because
+    # one of the two compilations can be disabled.  We should prefer
+    # $dir$base.o.d over $dir.libs/$base.o.d because the latter is
+    # automatically cleaned when .libs/ is deleted, while ignoring
+    # the former would cause a distcleancheck panic.
+    tmpdepfile1=$dir$base.o.d          # libtool 1.5
+    tmpdepfile2=$dir.libs/$base.o.d    # Likewise.
+    tmpdepfile3=$dir.libs/$base.d      # Compaq CCC V6.2-504
+    "$@" -Wc,-MD
+  else
+    tmpdepfile1=$dir$base.d
+    tmpdepfile2=$dir$base.d
+    tmpdepfile3=$dir$base.d
+    "$@" -MD
+  fi
+
+  stat=$?
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    exit $stat
+  fi
+
+  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+  do
+    test -f "$tmpdepfile" && break
+  done
+  # Same post-processing that is required for AIX mode.
+  aix_post_process_depfile
+  ;;
+
+msvc7)
+  if test "$libtool" = yes; then
+    showIncludes=-Wc,-showIncludes
+  else
+    showIncludes=-showIncludes
+  fi
+  "$@" $showIncludes > "$tmpdepfile"
+  stat=$?
+  grep -v '^Note: including file: ' "$tmpdepfile"
+  if test $stat -ne 0; then
+    rm -f "$tmpdepfile"
+    exit $stat
+  fi
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  # The first sed program below extracts the file names and escapes
+  # backslashes for cygpath.  The second sed program outputs the file
+  # name when reading, but also accumulates all include files in the
+  # hold buffer in order to output them again at the end.  This only
+  # works with sed implementations that can handle large buffers.
+  sed < "$tmpdepfile" -n '
+/^Note: including file:  *\(.*\)/ {
+  s//\1/
+  s/\\/\\\\/g
+  p
+}' | $cygpath_u | sort -u | sed -n '
+s/ /\\ /g
+s/\(.*\)/'"$tab"'\1 \\/p
+s/.\(.*\) \\/\1:/
+H
+$ {
+  s/.*/'"$tab"'/
+  G
+  p
+}' >> "$depfile"
+  echo >> "$depfile" # make sure the fragment doesn't end with a backslash
+  rm -f "$tmpdepfile"
+  ;;
+
+msvc7msys)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+#nosideeffect)
+  # This comment above is used by automake to tell side-effect
+  # dependency tracking mechanisms from slower ones.
+
+dashmstdout)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout, regardless of -o.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove '-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  test -z "$dashmflag" && dashmflag=-M
+  # Require at least two characters before searching for ':'
+  # in the target name.  This is to cope with DOS-style filenames:
+  # a dependency such as 'c:/foo/bar' could be seen as target 'c' otherwise.
+  "$@" $dashmflag |
+    sed "s|^[$tab ]*[^:$tab ][^:][^:]*:[$tab ]*|$object: |" > "$tmpdepfile"
+  rm -f "$depfile"
+  cat < "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process this sed invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  tr ' ' "$nl" < "$tmpdepfile" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+dashXmstdout)
+  # This case only exists to satisfy depend.m4.  It is never actually
+  # run, as this mode is specially recognized in the preamble.
+  exit 1
+  ;;
+
+makedepend)
+  "$@" || exit $?
+  # Remove any Libtool call
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+  # X makedepend
+  shift
+  cleared=no eat=no
+  for arg
+  do
+    case $cleared in
+    no)
+      set ""; shift
+      cleared=yes ;;
+    esac
+    if test $eat = yes; then
+      eat=no
+      continue
+    fi
+    case "$arg" in
+    -D*|-I*)
+      set fnord "$@" "$arg"; shift ;;
+    # Strip any option that makedepend may not understand.  Remove
+    # the object too, otherwise makedepend will parse it as a source file.
+    -arch)
+      eat=yes ;;
+    -*|$object)
+      ;;
+    *)
+      set fnord "$@" "$arg"; shift ;;
+    esac
+  done
+  obj_suffix=`echo "$object" | sed 's/^.*\././'`
+  touch "$tmpdepfile"
+  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
+  rm -f "$depfile"
+  # makedepend may prepend the VPATH from the source file name to the object.
+  # No need to regex-escape $object, excess matching of '.' is harmless.
+  sed "s|^.*\($object *:\)|\1|" "$tmpdepfile" > "$depfile"
+  # Some versions of the HPUX 10.20 sed can't process the last invocation
+  # correctly.  Breaking it into two sed invocations is a workaround.
+  sed '1,2d' "$tmpdepfile" \
+    | tr ' ' "$nl" \
+    | sed -e 's/^\\$//' -e '/^$/d' -e '/:$/d' \
+    | sed -e 's/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile" "$tmpdepfile".bak
+  ;;
+
+cpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  # Remove '-o $object'.
+  IFS=" "
+  for arg
+  do
+    case $arg in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    *)
+      set fnord "$@" "$arg"
+      shift # fnord
+      shift # $arg
+      ;;
+    esac
+  done
+
+  "$@" -E \
+    | sed -n -e '/^# [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+             -e '/^#line [0-9][0-9]* "\([^"]*\)".*/ s:: \1 \\:p' \
+    | sed '$ s: \\$::' > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  cat < "$tmpdepfile" >> "$depfile"
+  sed < "$tmpdepfile" '/^$/d;s/^ //;s/ \\$//;s/$/ :/' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvisualcpp)
+  # Important note: in order to support this mode, a compiler *must*
+  # always write the preprocessed file to stdout.
+  "$@" || exit $?
+
+  # Remove the call to Libtool.
+  if test "$libtool" = yes; then
+    while test "X$1" != 'X--mode=compile'; do
+      shift
+    done
+    shift
+  fi
+
+  IFS=" "
+  for arg
+  do
+    case "$arg" in
+    -o)
+      shift
+      ;;
+    $object)
+      shift
+      ;;
+    "-Gm"|"/Gm"|"-Gi"|"/Gi"|"-ZI"|"/ZI")
+        set fnord "$@"
+        shift
+        shift
+        ;;
+    *)
+        set fnord "$@" "$arg"
+        shift
+        shift
+        ;;
+    esac
+  done
+  "$@" -E 2>/dev/null |
+  sed -n '/^#line [0-9][0-9]* "\([^"]*\)"/ s::\1:p' | $cygpath_u | sort -u > "$tmpdepfile"
+  rm -f "$depfile"
+  echo "$object : \\" > "$depfile"
+  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::'"$tab"'\1 \\:p' >> "$depfile"
+  echo "$tab" >> "$depfile"
+  sed < "$tmpdepfile" -n -e 's% %\\ %g' -e '/^\(.*\)$/ s::\1\::p' >> "$depfile"
+  rm -f "$tmpdepfile"
+  ;;
+
+msvcmsys)
+  # This case exists only to let depend.m4 do its work.  It works by
+  # looking at the text of this script.  This case will never be run,
+  # since it is checked for above.
+  exit 1
+  ;;
+
+none)
+  exec "$@"
+  ;;
+
+*)
+  echo "Unknown depmode $depmode" 1>&2
+  exit 1
+  ;;
+esac
+
+exit 0
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/release/src/router/libev-4.22/ev++.h b/release/src/router/libev-4.22/ev++.h
new file mode 100644
index 0000000000..4f0a36ab02
--- /dev/null
+++ b/release/src/router/libev-4.22/ev++.h
@@ -0,0 +1,816 @@
+/*
+ * libev simple C++ wrapper classes
+ *
+ * Copyright (c) 2007,2008,2010 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef EVPP_H__
+#define EVPP_H__
+
+#ifdef EV_H
+# include EV_H
+#else
+# include "ev.h"
+#endif
+
+#ifndef EV_USE_STDEXCEPT
+# define EV_USE_STDEXCEPT 1
+#endif
+
+#if EV_USE_STDEXCEPT
+# include <stdexcept>
+#endif
+
+namespace ev {
+
+  typedef ev_tstamp tstamp;
+
+  enum {
+    UNDEF    = EV_UNDEF,
+    NONE     = EV_NONE,
+    READ     = EV_READ,
+    WRITE    = EV_WRITE,
+#if EV_COMPAT3
+    TIMEOUT  = EV_TIMEOUT,
+#endif
+    TIMER    = EV_TIMER,
+    PERIODIC = EV_PERIODIC,
+    SIGNAL   = EV_SIGNAL,
+    CHILD    = EV_CHILD,
+    STAT     = EV_STAT,
+    IDLE     = EV_IDLE,
+    CHECK    = EV_CHECK,
+    PREPARE  = EV_PREPARE,
+    FORK     = EV_FORK,
+    ASYNC    = EV_ASYNC,
+    EMBED    = EV_EMBED,
+#   undef ERROR // some systems stupidly #define ERROR
+    ERROR    = EV_ERROR
+  };
+
+  enum
+  {
+    AUTO      = EVFLAG_AUTO,
+    NOENV     = EVFLAG_NOENV,
+    FORKCHECK = EVFLAG_FORKCHECK,
+
+    SELECT    = EVBACKEND_SELECT,
+    POLL      = EVBACKEND_POLL,
+    EPOLL     = EVBACKEND_EPOLL,
+    KQUEUE    = EVBACKEND_KQUEUE,
+    DEVPOLL   = EVBACKEND_DEVPOLL,
+    PORT      = EVBACKEND_PORT
+  };
+
+  enum
+  {
+#if EV_COMPAT3
+    NONBLOCK = EVLOOP_NONBLOCK,
+    ONESHOT  = EVLOOP_ONESHOT,
+#endif
+    NOWAIT   = EVRUN_NOWAIT,
+    ONCE     = EVRUN_ONCE
+  };
+
+  enum how_t
+  {
+    ONE = EVBREAK_ONE,
+    ALL = EVBREAK_ALL
+  };
+
+  struct bad_loop
+#if EV_USE_STDEXCEPT
+  : std::runtime_error
+#endif
+  {
+#if EV_USE_STDEXCEPT
+    bad_loop ()
+    : std::runtime_error ("libev event loop cannot be initialized, bad value of LIBEV_FLAGS?")
+    {
+    }
+#endif
+  };
+
+#ifdef EV_AX
+#  undef EV_AX
+#endif
+
+#ifdef EV_AX_
+#  undef EV_AX_
+#endif
+
+#if EV_MULTIPLICITY
+#  define EV_AX  raw_loop
+#  define EV_AX_ raw_loop,
+#else
+#  define EV_AX
+#  define EV_AX_
+#endif
+
+  struct loop_ref
+  {
+    loop_ref (EV_P) throw ()
+#if EV_MULTIPLICITY
+    : EV_AX (EV_A)
+#endif
+    {
+    }
+
+    bool operator == (const loop_ref &other) const throw ()
+    {
+#if EV_MULTIPLICITY
+      return EV_AX == other.EV_AX;
+#else
+      return true;
+#endif
+    }
+
+    bool operator != (const loop_ref &other) const throw ()
+    {
+#if EV_MULTIPLICITY
+      return ! (*this == other);
+#else
+      return false;
+#endif
+    }
+
+#if EV_MULTIPLICITY
+    bool operator == (const EV_P) const throw ()
+    {
+      return this->EV_AX == EV_A;
+    }
+
+    bool operator != (const EV_P) const throw ()
+    {
+      return (*this == EV_A);
+    }
+
+    operator struct ev_loop * () const throw ()
+    {
+      return EV_AX;
+    }
+
+    operator const struct ev_loop * () const throw ()
+    {
+      return EV_AX;
+    }
+
+    bool is_default () const throw ()
+    {
+      return EV_AX == ev_default_loop (0);
+    }
+#endif
+
+#if EV_COMPAT3
+    void loop (int flags = 0)
+    {
+      ev_run (EV_AX_ flags);
+    }
+
+    void unloop (how_t how = ONE) throw ()
+    {
+      ev_break (EV_AX_ how);
+    }
+#endif
+
+    void run (int flags = 0)
+    {
+      ev_run (EV_AX_ flags);
+    }
+
+    void break_loop (how_t how = ONE) throw ()
+    {
+      ev_break (EV_AX_ how);
+    }
+
+    void post_fork () throw ()
+    {
+      ev_loop_fork (EV_AX);
+    }
+
+    unsigned int backend () const throw ()
+    {
+      return ev_backend (EV_AX);
+    }
+
+    tstamp now () const throw ()
+    {
+      return ev_now (EV_AX);
+    }
+
+    void ref () throw ()
+    {
+      ev_ref (EV_AX);
+    }
+
+    void unref () throw ()
+    {
+      ev_unref (EV_AX);
+    }
+
+#if EV_FEATURE_API
+    unsigned int iteration () const throw ()
+    {
+      return ev_iteration (EV_AX);
+    }
+
+    unsigned int depth () const throw ()
+    {
+      return ev_depth (EV_AX);
+    }
+
+    void set_io_collect_interval (tstamp interval) throw ()
+    {
+      ev_set_io_collect_interval (EV_AX_ interval);
+    }
+
+    void set_timeout_collect_interval (tstamp interval) throw ()
+    {
+      ev_set_timeout_collect_interval (EV_AX_ interval);
+    }
+#endif
+
+    // function callback
+    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()
+    {
+      ev_once (EV_AX_ fd, events, timeout, cb, arg);
+    }
+
+    // method callback
+    template<class K, void (K::*method)(int)>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_thunk<K, method>, object);
+    }
+
+    // default method == operator ()
+    template<class K>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_thunk<K, &K::operator ()>, object);
+    }
+
+    template<class K, void (K::*method)(int)>
+    static void method_thunk (int revents, void *arg)
+    {
+      (static_cast<K *>(arg)->*method)
+        (revents);
+    }
+
+    // no-argument method callback
+    template<class K, void (K::*method)()>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_noargs_thunk<K, method>, object);
+    }
+
+    template<class K, void (K::*method)()>
+    static void method_noargs_thunk (int revents, void *arg)
+    {
+      (static_cast<K *>(arg)->*method)
+        ();
+    }
+
+    // simpler function callback
+    template<void (*cb)(int)>
+    void once (int fd, int events, tstamp timeout) throw ()
+    {
+      once (fd, events, timeout, simpler_func_thunk<cb>);
+    }
+
+    template<void (*cb)(int)>
+    static void simpler_func_thunk (int revents, void *arg)
+    {
+      (*cb)
+        (revents);
+    }
+
+    // simplest function callback
+    template<void (*cb)()>
+    void once (int fd, int events, tstamp timeout) throw ()
+    {
+      once (fd, events, timeout, simplest_func_thunk<cb>);
+    }
+
+    template<void (*cb)()>
+    static void simplest_func_thunk (int revents, void *arg)
+    {
+      (*cb)
+        ();
+    }
+
+    void feed_fd_event (int fd, int revents) throw ()
+    {
+      ev_feed_fd_event (EV_AX_ fd, revents);
+    }
+
+    void feed_signal_event (int signum) throw ()
+    {
+      ev_feed_signal_event (EV_AX_ signum);
+    }
+
+#if EV_MULTIPLICITY
+    struct ev_loop* EV_AX;
+#endif
+
+  };
+
+#if EV_MULTIPLICITY
+  struct dynamic_loop : loop_ref
+  {
+
+    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)
+    : loop_ref (ev_loop_new (flags))
+    {
+      if (!EV_AX)
+        throw bad_loop ();
+    }
+
+    ~dynamic_loop () throw ()
+    {
+      ev_loop_destroy (EV_AX);
+      EV_AX = 0;
+    }
+
+  private:
+
+    dynamic_loop (const dynamic_loop &);
+
+    dynamic_loop & operator= (const dynamic_loop &);
+
+  };
+#endif
+
+  struct default_loop : loop_ref
+  {
+    default_loop (unsigned int flags = AUTO) throw (bad_loop)
+#if EV_MULTIPLICITY
+    : loop_ref (ev_default_loop (flags))
+#endif
+    {
+      if (
+#if EV_MULTIPLICITY
+          !EV_AX
+#else
+          !ev_default_loop (flags)
+#endif
+      )
+        throw bad_loop ();
+    }
+
+  private:
+    default_loop (const default_loop &);
+    default_loop &operator = (const default_loop &);
+  };
+
+  inline loop_ref get_default_loop () throw ()
+  {
+#if EV_MULTIPLICITY
+    return ev_default_loop (0);
+#else
+    return loop_ref ();
+#endif
+  }
+
+#undef EV_AX
+#undef EV_AX_
+
+#undef EV_PX
+#undef EV_PX_
+#if EV_MULTIPLICITY
+#  define EV_PX  loop_ref EV_A
+#  define EV_PX_ loop_ref EV_A_
+#else
+#  define EV_PX
+#  define EV_PX_
+#endif
+
+  template<class ev_watcher, class watcher>
+  struct base : ev_watcher
+  {
+    #if EV_MULTIPLICITY
+      EV_PX;
+
+      // loop set
+      void set (EV_P) throw ()
+      {
+        this->EV_A = EV_A;
+      }
+    #endif
+
+    base (EV_PX) throw ()
+    #if EV_MULTIPLICITY
+      : EV_A (EV_A)
+    #endif
+    {
+      ev_init (this, 0);
+    }
+
+    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()
+    {
+      this->data = (void *)data;
+      ev_set_cb (static_cast<ev_watcher *>(this), cb);
+    }
+
+    // function callback
+    template<void (*function)(watcher &w, int)>
+    void set (void *data = 0) throw ()
+    {
+      set_ (data, function_thunk<function>);
+    }
+
+    template<void (*function)(watcher &w, int)>
+    static void function_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      function
+        (*static_cast<watcher *>(w), revents);
+    }
+
+    // method callback
+    template<class K, void (K::*method)(watcher &w, int)>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_thunk<K, method>);
+    }
+
+    // default method == operator ()
+    template<class K>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_thunk<K, &K::operator ()>);
+    }
+
+    template<class K, void (K::*method)(watcher &w, int)>
+    static void method_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      (static_cast<K *>(w->data)->*method)
+        (*static_cast<watcher *>(w), revents);
+    }
+
+    // no-argument callback
+    template<class K, void (K::*method)()>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_noargs_thunk<K, method>);
+    }
+
+    template<class K, void (K::*method)()>
+    static void method_noargs_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      (static_cast<K *>(w->data)->*method)
+        ();
+    }
+
+    void operator ()(int events = EV_UNDEF)
+    {
+      return
+        ev_cb (static_cast<ev_watcher *>(this))
+          (static_cast<ev_watcher *>(this), events);
+    }
+
+    bool is_active () const throw ()
+    {
+      return ev_is_active (static_cast<const ev_watcher *>(this));
+    }
+
+    bool is_pending () const throw ()
+    {
+      return ev_is_pending (static_cast<const ev_watcher *>(this));
+    }
+
+    void feed_event (int revents) throw ()
+    {
+      ev_feed_event (EV_A_ static_cast<ev_watcher *>(this), revents);
+    }
+  };
+
+  inline tstamp now (EV_P) throw ()
+  {
+    return ev_now (EV_A);
+  }
+
+  inline void delay (tstamp interval) throw ()
+  {
+    ev_sleep (interval);
+  }
+
+  inline int version_major () throw ()
+  {
+    return ev_version_major ();
+  }
+
+  inline int version_minor () throw ()
+  {
+    return ev_version_minor ();
+  }
+
+  inline unsigned int supported_backends () throw ()
+  {
+    return ev_supported_backends ();
+  }
+
+  inline unsigned int recommended_backends () throw ()
+  {
+    return ev_recommended_backends ();
+  }
+
+  inline unsigned int embeddable_backends () throw ()
+  {
+    return ev_embeddable_backends ();
+  }
+
+  inline void set_allocator (void *(*cb)(void *ptr, long size) throw ()) throw ()
+  {
+    ev_set_allocator (cb);
+  }
+
+  inline void set_syserr_cb (void (*cb)(const char *msg) throw ()) throw ()
+  {
+    ev_set_syserr_cb (cb);
+  }
+
+  #if EV_MULTIPLICITY
+    #define EV_CONSTRUCT(cppstem,cstem)	                                                \
+      (EV_PX = get_default_loop ()) throw ()                                            \
+        : base<ev_ ## cstem, cppstem> (EV_A)                                            \
+      {                                                                                 \
+      }
+  #else
+    #define EV_CONSTRUCT(cppstem,cstem)                                                 \
+      () throw ()                                                                       \
+      {                                                                                 \
+      }
+  #endif
+
+  /* using a template here would require quite a few more lines,
+   * so a macro solution was chosen */
+  #define EV_BEGIN_WATCHER(cppstem,cstem)	                                        \
+                                                                                        \
+  struct cppstem : base<ev_ ## cstem, cppstem>                                          \
+  {                                                                                     \
+    void start () throw ()                                                              \
+    {                                                                                   \
+      ev_ ## cstem ## _start (EV_A_ static_cast<ev_ ## cstem *>(this));                 \
+    }                                                                                   \
+                                                                                        \
+    void stop () throw ()                                                               \
+    {                                                                                   \
+      ev_ ## cstem ## _stop (EV_A_ static_cast<ev_ ## cstem *>(this));                  \
+    }                                                                                   \
+                                                                                        \
+    cppstem EV_CONSTRUCT(cppstem,cstem)                                                 \
+                                                                                        \
+    ~cppstem () throw ()                                                                \
+    {                                                                                   \
+      stop ();                                                                          \
+    }                                                                                   \
+                                                                                        \
+    using base<ev_ ## cstem, cppstem>::set;                                             \
+                                                                                        \
+  private:                                                                              \
+                                                                                        \
+    cppstem (const cppstem &o);                                                         \
+                                                                                        \
+    cppstem &operator =(const cppstem &o);                                              \
+                                                                                        \
+  public:
+
+  #define EV_END_WATCHER(cppstem,cstem)	                                                \
+  };
+
+  EV_BEGIN_WATCHER (io, io)
+    void set (int fd, int events) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_io_set (static_cast<ev_io *>(this), fd, events);
+      if (active) start ();
+    }
+
+    void set (int events) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_io_set (static_cast<ev_io *>(this), fd, events);
+      if (active) start ();
+    }
+
+    void start (int fd, int events) throw ()
+    {
+      set (fd, events);
+      start ();
+    }
+  EV_END_WATCHER (io, io)
+
+  EV_BEGIN_WATCHER (timer, timer)
+    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_timer_set (static_cast<ev_timer *>(this), after, repeat);
+      if (active) start ();
+    }
+
+    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    {
+      set (after, repeat);
+      start ();
+    }
+
+    void again () throw ()
+    {
+      ev_timer_again (EV_A_ static_cast<ev_timer *>(this));
+    }
+
+    ev_tstamp remaining ()
+    {
+      return ev_timer_remaining (EV_A_ static_cast<ev_timer *>(this));
+    }
+  EV_END_WATCHER (timer, timer)
+
+  #if EV_PERIODIC_ENABLE
+  EV_BEGIN_WATCHER (periodic, periodic)
+    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_periodic_set (static_cast<ev_periodic *>(this), at, interval, 0);
+      if (active) start ();
+    }
+
+    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    {
+      set (at, interval);
+      start ();
+    }
+
+    void again () throw ()
+    {
+      ev_periodic_again (EV_A_ static_cast<ev_periodic *>(this));
+    }
+  EV_END_WATCHER (periodic, periodic)
+  #endif
+
+  #if EV_SIGNAL_ENABLE
+  EV_BEGIN_WATCHER (sig, signal)
+    void set (int signum) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_signal_set (static_cast<ev_signal *>(this), signum);
+      if (active) start ();
+    }
+
+    void start (int signum) throw ()
+    {
+      set (signum);
+      start ();
+    }
+  EV_END_WATCHER (sig, signal)
+  #endif
+
+  #if EV_CHILD_ENABLE
+  EV_BEGIN_WATCHER (child, child)
+    void set (int pid, int trace = 0) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_child_set (static_cast<ev_child *>(this), pid, trace);
+      if (active) start ();
+    }
+
+    void start (int pid, int trace = 0) throw ()
+    {
+      set (pid, trace);
+      start ();
+    }
+  EV_END_WATCHER (child, child)
+  #endif
+
+  #if EV_STAT_ENABLE
+  EV_BEGIN_WATCHER (stat, stat)
+    void set (const char *path, ev_tstamp interval = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_stat_set (static_cast<ev_stat *>(this), path, interval);
+      if (active) start ();
+    }
+
+    void start (const char *path, ev_tstamp interval = 0.) throw ()
+    {
+      stop ();
+      set (path, interval);
+      start ();
+    }
+
+    void update () throw ()
+    {
+      ev_stat_stat (EV_A_ static_cast<ev_stat *>(this));
+    }
+  EV_END_WATCHER (stat, stat)
+  #endif
+
+  #if EV_IDLE_ENABLE
+  EV_BEGIN_WATCHER (idle, idle)
+    void set () throw () { }
+  EV_END_WATCHER (idle, idle)
+  #endif
+
+  #if EV_PREPARE_ENABLE
+  EV_BEGIN_WATCHER (prepare, prepare)
+    void set () throw () { }
+  EV_END_WATCHER (prepare, prepare)
+  #endif
+
+  #if EV_CHECK_ENABLE
+  EV_BEGIN_WATCHER (check, check)
+    void set () throw () { }
+  EV_END_WATCHER (check, check)
+  #endif
+
+  #if EV_EMBED_ENABLE
+  EV_BEGIN_WATCHER (embed, embed)
+    void set_embed (struct ev_loop *embedded_loop) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_embed_set (static_cast<ev_embed *>(this), embedded_loop);
+      if (active) start ();
+    }
+
+    void start (struct ev_loop *embedded_loop) throw ()
+    {
+      set (embedded_loop);
+      start ();
+    }
+
+    void sweep ()
+    {
+      ev_embed_sweep (EV_A_ static_cast<ev_embed *>(this));
+    }
+  EV_END_WATCHER (embed, embed)
+  #endif
+
+  #if EV_FORK_ENABLE
+  EV_BEGIN_WATCHER (fork, fork)
+    void set () throw () { }
+  EV_END_WATCHER (fork, fork)
+  #endif
+
+  #if EV_ASYNC_ENABLE
+  EV_BEGIN_WATCHER (async, async)
+    void send () throw ()
+    {
+      ev_async_send (EV_A_ static_cast<ev_async *>(this));
+    }
+
+    bool async_pending () throw ()
+    {
+      return ev_async_pending (static_cast<ev_async *>(this));
+    }
+  EV_END_WATCHER (async, async)
+  #endif
+
+  #undef EV_PX
+  #undef EV_PX_
+  #undef EV_CONSTRUCT
+  #undef EV_BEGIN_WATCHER
+  #undef EV_END_WATCHER
+}
+
+#endif
+
diff --git a/release/src/router/libev-4.22/ev.3 b/release/src/router/libev-4.22/ev.3
new file mode 100644
index 0000000000..7cc2d5724b
--- /dev/null
+++ b/release/src/router/libev-4.22/ev.3
@@ -0,0 +1,5643 @@
+.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.30)
+.\"
+.\" Standard preamble:
+.\" ========================================================================
+.de Sp \" Vertical space (when we can't use .PP)
+.if t .sp .5v
+.if n .sp
+..
+.de Vb \" Begin verbatim text
+.ft CW
+.nf
+.ne \\$1
+..
+.de Ve \" End verbatim text
+.ft R
+.fi
+..
+.\" Set up some character translations and predefined strings.  \*(-- will
+.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
+.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
+.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
+.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
+.\" nothing in troff, for use with C<>.
+.tr \(*W-
+.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
+.ie n \{\
+.    ds -- \(*W-
+.    ds PI pi
+.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
+.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
+.    ds L" ""
+.    ds R" ""
+.    ds C` ""
+.    ds C' ""
+'br\}
+.el\{\
+.    ds -- \|\(em\|
+.    ds PI \(*p
+.    ds L" ``
+.    ds R" ''
+.    ds C`
+.    ds C'
+'br\}
+.\"
+.\" Escape single quotes in literal strings from groff's Unicode transform.
+.ie \n(.g .ds Aq \(aq
+.el       .ds Aq '
+.\"
+.\" If the F register is turned on, we'll generate index entries on stderr for
+.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
+.\" entries marked with X<> in POD.  Of course, you'll have to process the
+.\" output yourself in some meaningful fashion.
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
+..
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
+..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
+.\}
+.rr rF
+.\"
+.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
+.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
+.    \" fudge factors for nroff and troff
+.if n \{\
+.    ds #H 0
+.    ds #V .8m
+.    ds #F .3m
+.    ds #[ \f1
+.    ds #] \fP
+.\}
+.if t \{\
+.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
+.    ds #V .6m
+.    ds #F 0
+.    ds #[ \&
+.    ds #] \&
+.\}
+.    \" simple accents for nroff and troff
+.if n \{\
+.    ds ' \&
+.    ds ` \&
+.    ds ^ \&
+.    ds , \&
+.    ds ~ ~
+.    ds /
+.\}
+.if t \{\
+.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
+.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
+.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
+.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
+.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
+.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
+.\}
+.    \" troff and (daisy-wheel) nroff accents
+.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
+.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
+.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
+.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
+.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
+.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
+.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
+.ds ae a\h'-(\w'a'u*4/10)'e
+.ds Ae A\h'-(\w'A'u*4/10)'E
+.    \" corrections for vroff
+.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
+.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
+.    \" for low resolution devices (crt and lpr)
+.if \n(.H>23 .if \n(.V>19 \
+\{\
+.    ds : e
+.    ds 8 ss
+.    ds o a
+.    ds d- d\h'-1'\(ga
+.    ds D- D\h'-1'\(hy
+.    ds th \o'bp'
+.    ds Th \o'LP'
+.    ds ae ae
+.    ds Ae AE
+.\}
+.rm #[ #] #H #V #F C
+.\" ========================================================================
+.\"
+.IX Title "LIBEV 3"
+.TH LIBEV 3 "2015-12-20" "libev-4.20" "libev - high performance full featured event loop"
+.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
+.\" way too many mistakes in technical documents.
+.if n .ad l
+.nh
+.SH "NAME"
+libev \- a high performance full\-featured event loop written in C
+.SH "SYNOPSIS"
+.IX Header "SYNOPSIS"
+.Vb 1
+\&   #include <ev.h>
+.Ve
+.SS "\s-1EXAMPLE PROGRAM\s0"
+.IX Subsection "EXAMPLE PROGRAM"
+.Vb 2
+\&   // a single header file is required
+\&   #include <ev.h>
+\&
+\&   #include <stdio.h> // for puts
+\&
+\&   // every watcher type has its own typedef\*(Aqd struct
+\&   // with the name ev_TYPE
+\&   ev_io stdin_watcher;
+\&   ev_timer timeout_watcher;
+\&
+\&   // all watcher callbacks have a similar signature
+\&   // this callback is called when data is readable on stdin
+\&   static void
+\&   stdin_cb (EV_P_ ev_io *w, int revents)
+\&   {
+\&     puts ("stdin ready");
+\&     // for one\-shot events, one must manually stop the watcher
+\&     // with its corresponding stop function.
+\&     ev_io_stop (EV_A_ w);
+\&
+\&     // this causes all nested ev_run\*(Aqs to stop iterating
+\&     ev_break (EV_A_ EVBREAK_ALL);
+\&   }
+\&
+\&   // another callback, this time for a time\-out
+\&   static void
+\&   timeout_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     puts ("timeout");
+\&     // this causes the innermost ev_run to stop iterating
+\&     ev_break (EV_A_ EVBREAK_ONE);
+\&   }
+\&
+\&   int
+\&   main (void)
+\&   {
+\&     // use the default event loop unless you have special needs
+\&     struct ev_loop *loop = EV_DEFAULT;
+\&
+\&     // initialise an io watcher, then start it
+\&     // this one will watch for stdin to become readable
+\&     ev_io_init (&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
+\&     ev_io_start (loop, &stdin_watcher);
+\&
+\&     // initialise a timer watcher, then start it
+\&     // simple non\-repeating 5.5 second timeout
+\&     ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
+\&     ev_timer_start (loop, &timeout_watcher);
+\&
+\&     // now wait for events to arrive
+\&     ev_run (loop, 0);
+\&
+\&     // break was called, so exit
+\&     return 0;
+\&   }
+.Ve
+.SH "ABOUT THIS DOCUMENT"
+.IX Header "ABOUT THIS DOCUMENT"
+This document documents the libev software package.
+.PP
+The newest version of this document is also available as an html-formatted
+web page you might find easier to navigate when reading it for the first
+time: <http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod>.
+.PP
+While this document tries to be as complete as possible in documenting
+libev, its usage and the rationale behind its design, it is not a tutorial
+on event-based programming, nor will it introduce event-based programming
+with libev.
+.PP
+Familiarity with event based programming techniques in general is assumed
+throughout this document.
+.SH "WHAT TO READ WHEN IN A HURRY"
+.IX Header "WHAT TO READ WHEN IN A HURRY"
+This manual tries to be very detailed, but unfortunately, this also makes
+it very long. If you just want to know the basics of libev, I suggest
+reading \*(L"\s-1ANATOMY OF A WATCHER\*(R"\s0, then the \*(L"\s-1EXAMPLE PROGRAM\*(R"\s0 above and
+look up the missing functions in \*(L"\s-1GLOBAL FUNCTIONS\*(R"\s0 and the \f(CW\*(C`ev_io\*(C'\fR and
+\&\f(CW\*(C`ev_timer\*(C'\fR sections in \*(L"\s-1WATCHER TYPES\*(R"\s0.
+.SH "ABOUT LIBEV"
+.IX Header "ABOUT LIBEV"
+Libev is an event loop: you register interest in certain events (such as a
+file descriptor being readable or a timeout occurring), and it will manage
+these event sources and provide your program with events.
+.PP
+To do this, it must take more or less complete control over your process
+(or thread) by executing the \fIevent loop\fR handler, and will then
+communicate events via a callback mechanism.
+.PP
+You register interest in certain events by registering so-called \fIevent
+watchers\fR, which are relatively small C structures you initialise with the
+details of the event, and then hand it over to libev by \fIstarting\fR the
+watcher.
+.SS "\s-1FEATURES\s0"
+.IX Subsection "FEATURES"
+Libev supports \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`poll\*(C'\fR, the Linux-specific \f(CW\*(C`epoll\*(C'\fR, the
+BSD-specific \f(CW\*(C`kqueue\*(C'\fR and the Solaris-specific event port mechanisms
+for file descriptor events (\f(CW\*(C`ev_io\*(C'\fR), the Linux \f(CW\*(C`inotify\*(C'\fR interface
+(for \f(CW\*(C`ev_stat\*(C'\fR), Linux eventfd/signalfd (for faster and cleaner
+inter-thread wakeup (\f(CW\*(C`ev_async\*(C'\fR)/signal handling (\f(CW\*(C`ev_signal\*(C'\fR)) relative
+timers (\f(CW\*(C`ev_timer\*(C'\fR), absolute timers with customised rescheduling
+(\f(CW\*(C`ev_periodic\*(C'\fR), synchronous signals (\f(CW\*(C`ev_signal\*(C'\fR), process status
+change events (\f(CW\*(C`ev_child\*(C'\fR), and event watchers dealing with the event
+loop mechanism itself (\f(CW\*(C`ev_idle\*(C'\fR, \f(CW\*(C`ev_embed\*(C'\fR, \f(CW\*(C`ev_prepare\*(C'\fR and
+\&\f(CW\*(C`ev_check\*(C'\fR watchers) as well as file watchers (\f(CW\*(C`ev_stat\*(C'\fR) and even
+limited support for fork events (\f(CW\*(C`ev_fork\*(C'\fR).
+.PP
+It also is quite fast (see this
+benchmark <http://libev.schmorp.de/bench.html> comparing it to libevent
+for example).
+.SS "\s-1CONVENTIONS\s0"
+.IX Subsection "CONVENTIONS"
+Libev is very configurable. In this manual the default (and most common)
+configuration will be described, which supports multiple event loops. For
+more info about various configuration options please have a look at
+\&\fB\s-1EMBED\s0\fR section in this manual. If libev was configured without support
+for multiple event loops, then all functions taking an initial argument of
+name \f(CW\*(C`loop\*(C'\fR (which is always of type \f(CW\*(C`struct ev_loop *\*(C'\fR) will not have
+this argument.
+.SS "\s-1TIME REPRESENTATION\s0"
+.IX Subsection "TIME REPRESENTATION"
+Libev represents time as a single floating point number, representing
+the (fractional) number of seconds since the (\s-1POSIX\s0) epoch (in practice
+somewhere near the beginning of 1970, details are complicated, don't
+ask). This type is called \f(CW\*(C`ev_tstamp\*(C'\fR, which is what you should use
+too. It usually aliases to the \f(CW\*(C`double\*(C'\fR type in C. When you need to do
+any calculations on it, you should treat it as some floating point value.
+.PP
+Unlike the name component \f(CW\*(C`stamp\*(C'\fR might indicate, it is also used for
+time differences (e.g. delays) throughout libev.
+.SH "ERROR HANDLING"
+.IX Header "ERROR HANDLING"
+Libev knows three classes of errors: operating system errors, usage errors
+and internal errors (bugs).
+.PP
+When libev catches an operating system error it cannot handle (for example
+a system call indicating a condition libev cannot fix), it calls the callback
+set via \f(CW\*(C`ev_set_syserr_cb\*(C'\fR, which is supposed to fix the problem or
+abort. The default is to print a diagnostic message and to call \f(CW\*(C`abort
+()\*(C'\fR.
+.PP
+When libev detects a usage error such as a negative timer interval, then
+it will print a diagnostic message and abort (via the \f(CW\*(C`assert\*(C'\fR mechanism,
+so \f(CW\*(C`NDEBUG\*(C'\fR will disable this checking): these are programming errors in
+the libev caller and need to be fixed there.
+.PP
+Libev also has a few internal error-checking \f(CW\*(C`assert\*(C'\fRions, and also has
+extensive consistency checking code. These do not trigger under normal
+circumstances, as they indicate either a bug in libev or worse.
+.SH "GLOBAL FUNCTIONS"
+.IX Header "GLOBAL FUNCTIONS"
+These functions can be called anytime, even before initialising the
+library in any way.
+.IP "ev_tstamp ev_time ()" 4
+.IX Item "ev_tstamp ev_time ()"
+Returns the current time as libev would use it. Please note that the
+\&\f(CW\*(C`ev_now\*(C'\fR function is usually faster and also often returns the timestamp
+you actually want to know. Also interesting is the combination of
+\&\f(CW\*(C`ev_now_update\*(C'\fR and \f(CW\*(C`ev_now\*(C'\fR.
+.IP "ev_sleep (ev_tstamp interval)" 4
+.IX Item "ev_sleep (ev_tstamp interval)"
+Sleep for the given interval: The current thread will be blocked
+until either it is interrupted or the given time interval has
+passed (approximately \- it might return a bit earlier even if not
+interrupted). Returns immediately if \f(CW\*(C`interval <= 0\*(C'\fR.
+.Sp
+Basically this is a sub-second-resolution \f(CW\*(C`sleep ()\*(C'\fR.
+.Sp
+The range of the \f(CW\*(C`interval\*(C'\fR is limited \- libev only guarantees to work
+with sleep times of up to one day (\f(CW\*(C`interval <= 86400\*(C'\fR).
+.IP "int ev_version_major ()" 4
+.IX Item "int ev_version_major ()"
+.PD 0
+.IP "int ev_version_minor ()" 4
+.IX Item "int ev_version_minor ()"
+.PD
+You can find out the major and minor \s-1ABI\s0 version numbers of the library
+you linked against by calling the functions \f(CW\*(C`ev_version_major\*(C'\fR and
+\&\f(CW\*(C`ev_version_minor\*(C'\fR. If you want, you can compare against the global
+symbols \f(CW\*(C`EV_VERSION_MAJOR\*(C'\fR and \f(CW\*(C`EV_VERSION_MINOR\*(C'\fR, which specify the
+version of the library your program was compiled against.
+.Sp
+These version numbers refer to the \s-1ABI\s0 version of the library, not the
+release version.
+.Sp
+Usually, it's a good idea to terminate if the major versions mismatch,
+as this indicates an incompatible change. Minor versions are usually
+compatible to older versions, so a larger minor version alone is usually
+not a problem.
+.Sp
+Example: Make sure we haven't accidentally been linked against the wrong
+version (note, however, that this will not detect other \s-1ABI\s0 mismatches,
+such as \s-1LFS\s0 or reentrancy).
+.Sp
+.Vb 3
+\&   assert (("libev version mismatch",
+\&            ev_version_major () == EV_VERSION_MAJOR
+\&            && ev_version_minor () >= EV_VERSION_MINOR));
+.Ve
+.IP "unsigned int ev_supported_backends ()" 4
+.IX Item "unsigned int ev_supported_backends ()"
+Return the set of all backends (i.e. their corresponding \f(CW\*(C`EV_BACKEND_*\*(C'\fR
+value) compiled into this binary of libev (independent of their
+availability on the system you are running on). See \f(CW\*(C`ev_default_loop\*(C'\fR for
+a description of the set values.
+.Sp
+Example: make sure we have the epoll method, because yeah this is cool and
+a must have and can we have a torrent of it please!!!11
+.Sp
+.Vb 2
+\&   assert (("sorry, no epoll, no sex",
+\&            ev_supported_backends () & EVBACKEND_EPOLL));
+.Ve
+.IP "unsigned int ev_recommended_backends ()" 4
+.IX Item "unsigned int ev_recommended_backends ()"
+Return the set of all backends compiled into this binary of libev and
+also recommended for this platform, meaning it will work for most file
+descriptor types. This set is often smaller than the one returned by
+\&\f(CW\*(C`ev_supported_backends\*(C'\fR, as for example kqueue is broken on most BSDs
+and will not be auto-detected unless you explicitly request it (assuming
+you know what you are doing). This is the set of backends that libev will
+probe for if you specify no backends explicitly.
+.IP "unsigned int ev_embeddable_backends ()" 4
+.IX Item "unsigned int ev_embeddable_backends ()"
+Returns the set of backends that are embeddable in other event loops. This
+value is platform-specific but can include backends not available on the
+current system. To find which embeddable backends might be supported on
+the current system, you would need to look at \f(CW\*(C`ev_embeddable_backends ()
+& ev_supported_backends ()\*(C'\fR, likewise for recommended ones.
+.Sp
+See the description of \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
+.IP "ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())" 4
+.IX Item "ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())"
+Sets the allocation function to use (the prototype is similar \- the
+semantics are identical to the \f(CW\*(C`realloc\*(C'\fR C89/SuS/POSIX function). It is
+used to allocate and free memory (no surprises here). If it returns zero
+when memory needs to be allocated (\f(CW\*(C`size != 0\*(C'\fR), the library might abort
+or take some potentially destructive action.
+.Sp
+Since some systems (at least OpenBSD and Darwin) fail to implement
+correct \f(CW\*(C`realloc\*(C'\fR semantics, libev will use a wrapper around the system
+\&\f(CW\*(C`realloc\*(C'\fR and \f(CW\*(C`free\*(C'\fR functions by default.
+.Sp
+You could override this function in high-availability programs to, say,
+free some memory if it cannot allocate memory, to use a special allocator,
+or even to sleep a while and retry until some memory is available.
+.Sp
+Example: Replace the libev allocator with one that waits a bit and then
+retries (example requires a standards-compliant \f(CW\*(C`realloc\*(C'\fR).
+.Sp
+.Vb 6
+\&   static void *
+\&   persistent_realloc (void *ptr, size_t size)
+\&   {
+\&     for (;;)
+\&       {
+\&         void *newptr = realloc (ptr, size);
+\&
+\&         if (newptr)
+\&           return newptr;
+\&
+\&         sleep (60);
+\&       }
+\&   }
+\&
+\&   ...
+\&   ev_set_allocator (persistent_realloc);
+.Ve
+.IP "ev_set_syserr_cb (void (*cb)(const char *msg) throw ())" 4
+.IX Item "ev_set_syserr_cb (void (*cb)(const char *msg) throw ())"
+Set the callback function to call on a retryable system call error (such
+as failed select, poll, epoll_wait). The message is a printable string
+indicating the system call or subsystem causing the problem. If this
+callback is set, then libev will expect it to remedy the situation, no
+matter what, when it returns. That is, libev will generally retry the
+requested operation, or, if the condition doesn't go away, do bad stuff
+(such as abort).
+.Sp
+Example: This is basically the same thing that libev does internally, too.
+.Sp
+.Vb 6
+\&   static void
+\&   fatal_error (const char *msg)
+\&   {
+\&     perror (msg);
+\&     abort ();
+\&   }
+\&
+\&   ...
+\&   ev_set_syserr_cb (fatal_error);
+.Ve
+.IP "ev_feed_signal (int signum)" 4
+.IX Item "ev_feed_signal (int signum)"
+This function can be used to \*(L"simulate\*(R" a signal receive. It is completely
+safe to call this function at any time, from any context, including signal
+handlers or random threads.
+.Sp
+Its main use is to customise signal handling in your process, especially
+in the presence of threads. For example, you could block signals
+by default in all threads (and specifying \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR when
+creating any loops), and in one thread, use \f(CW\*(C`sigwait\*(C'\fR or any other
+mechanism to wait for signals, then \*(L"deliver\*(R" them to libev by calling
+\&\f(CW\*(C`ev_feed_signal\*(C'\fR.
+.SH "FUNCTIONS CONTROLLING EVENT LOOPS"
+.IX Header "FUNCTIONS CONTROLLING EVENT LOOPS"
+An event loop is described by a \f(CW\*(C`struct ev_loop *\*(C'\fR (the \f(CW\*(C`struct\*(C'\fR is
+\&\fInot\fR optional in this case unless libev 3 compatibility is disabled, as
+libev 3 had an \f(CW\*(C`ev_loop\*(C'\fR function colliding with the struct name).
+.PP
+The library knows two types of such loops, the \fIdefault\fR loop, which
+supports child process events, and dynamically created event loops which
+do not.
+.IP "struct ev_loop *ev_default_loop (unsigned int flags)" 4
+.IX Item "struct ev_loop *ev_default_loop (unsigned int flags)"
+This returns the \*(L"default\*(R" event loop object, which is what you should
+normally use when you just need \*(L"the event loop\*(R". Event loop objects and
+the \f(CW\*(C`flags\*(C'\fR parameter are described in more detail in the entry for
+\&\f(CW\*(C`ev_loop_new\*(C'\fR.
+.Sp
+If the default loop is already initialised then this function simply
+returns it (and ignores the flags. If that is troubling you, check
+\&\f(CW\*(C`ev_backend ()\*(C'\fR afterwards). Otherwise it will create it with the given
+flags, which should almost always be \f(CW0\fR, unless the caller is also the
+one calling \f(CW\*(C`ev_run\*(C'\fR or otherwise qualifies as \*(L"the main program\*(R".
+.Sp
+If you don't know what event loop to use, use the one returned from this
+function (or via the \f(CW\*(C`EV_DEFAULT\*(C'\fR macro).
+.Sp
+Note that this function is \fInot\fR thread-safe, so if you want to use it
+from multiple threads, you have to employ some kind of mutex (note also
+that this case is unlikely, as loops cannot be shared easily between
+threads anyway).
+.Sp
+The default loop is the only loop that can handle \f(CW\*(C`ev_child\*(C'\fR watchers,
+and to do this, it always registers a handler for \f(CW\*(C`SIGCHLD\*(C'\fR. If this is
+a problem for your application you can either create a dynamic loop with
+\&\f(CW\*(C`ev_loop_new\*(C'\fR which doesn't do that, or you can simply overwrite the
+\&\f(CW\*(C`SIGCHLD\*(C'\fR signal handler \fIafter\fR calling \f(CW\*(C`ev_default_init\*(C'\fR.
+.Sp
+Example: This is the most typical usage.
+.Sp
+.Vb 2
+\&   if (!ev_default_loop (0))
+\&     fatal ("could not initialise libev, bad $LIBEV_FLAGS in environment?");
+.Ve
+.Sp
+Example: Restrict libev to the select and poll backends, and do not allow
+environment settings to be taken into account:
+.Sp
+.Vb 1
+\&   ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
+.Ve
+.IP "struct ev_loop *ev_loop_new (unsigned int flags)" 4
+.IX Item "struct ev_loop *ev_loop_new (unsigned int flags)"
+This will create and initialise a new event loop object. If the loop
+could not be initialised, returns false.
+.Sp
+This function is thread-safe, and one common way to use libev with
+threads is indeed to create one loop per thread, and using the default
+loop in the \*(L"main\*(R" or \*(L"initial\*(R" thread.
+.Sp
+The flags argument can be used to specify special behaviour or specific
+backends to use, and is usually specified as \f(CW0\fR (or \f(CW\*(C`EVFLAG_AUTO\*(C'\fR).
+.Sp
+The following flags are supported:
+.RS 4
+.ie n .IP """EVFLAG_AUTO""" 4
+.el .IP "\f(CWEVFLAG_AUTO\fR" 4
+.IX Item "EVFLAG_AUTO"
+The default flags value. Use this if you have no clue (it's the right
+thing, believe me).
+.ie n .IP """EVFLAG_NOENV""" 4
+.el .IP "\f(CWEVFLAG_NOENV\fR" 4
+.IX Item "EVFLAG_NOENV"
+If this flag bit is or'ed into the flag value (or the program runs setuid
+or setgid) then libev will \fInot\fR look at the environment variable
+\&\f(CW\*(C`LIBEV_FLAGS\*(C'\fR. Otherwise (the default), this environment variable will
+override the flags completely if it is found in the environment. This is
+useful to try out specific backends to test their performance, to work
+around bugs, or to make libev threadsafe (accessing environment variables
+cannot be done in a threadsafe way, but usually it works if no other
+thread modifies them).
+.ie n .IP """EVFLAG_FORKCHECK""" 4
+.el .IP "\f(CWEVFLAG_FORKCHECK\fR" 4
+.IX Item "EVFLAG_FORKCHECK"
+Instead of calling \f(CW\*(C`ev_loop_fork\*(C'\fR manually after a fork, you can also
+make libev check for a fork in each iteration by enabling this flag.
+.Sp
+This works by calling \f(CW\*(C`getpid ()\*(C'\fR on every iteration of the loop,
+and thus this might slow down your event loop if you do a lot of loop
+iterations and little real work, but is usually not noticeable (on my
+GNU/Linux system for example, \f(CW\*(C`getpid\*(C'\fR is actually a simple 5\-insn sequence
+without a system call and thus \fIvery\fR fast, but my GNU/Linux system also has
+\&\f(CW\*(C`pthread_atfork\*(C'\fR which is even faster).
+.Sp
+The big advantage of this flag is that you can forget about fork (and
+forget about forgetting to tell libev about forking, although you still
+have to ignore \f(CW\*(C`SIGPIPE\*(C'\fR) when you use this flag.
+.Sp
+This flag setting cannot be overridden or specified in the \f(CW\*(C`LIBEV_FLAGS\*(C'\fR
+environment variable.
+.ie n .IP """EVFLAG_NOINOTIFY""" 4
+.el .IP "\f(CWEVFLAG_NOINOTIFY\fR" 4
+.IX Item "EVFLAG_NOINOTIFY"
+When this flag is specified, then libev will not attempt to use the
+\&\fIinotify\fR \s-1API\s0 for its \f(CW\*(C`ev_stat\*(C'\fR watchers. Apart from debugging and
+testing, this flag can be useful to conserve inotify file descriptors, as
+otherwise each loop using \f(CW\*(C`ev_stat\*(C'\fR watchers consumes one inotify handle.
+.ie n .IP """EVFLAG_SIGNALFD""" 4
+.el .IP "\f(CWEVFLAG_SIGNALFD\fR" 4
+.IX Item "EVFLAG_SIGNALFD"
+When this flag is specified, then libev will attempt to use the
+\&\fIsignalfd\fR \s-1API\s0 for its \f(CW\*(C`ev_signal\*(C'\fR (and \f(CW\*(C`ev_child\*(C'\fR) watchers. This \s-1API\s0
+delivers signals synchronously, which makes it both faster and might make
+it possible to get the queued signal data. It can also simplify signal
+handling with threads, as long as you properly block signals in your
+threads that are not interested in handling them.
+.Sp
+Signalfd will not be used by default as this changes your signal mask, and
+there are a lot of shoddy libraries and programs (glib's threadpool for
+example) that can't properly initialise their signal masks.
+.ie n .IP """EVFLAG_NOSIGMASK""" 4
+.el .IP "\f(CWEVFLAG_NOSIGMASK\fR" 4
+.IX Item "EVFLAG_NOSIGMASK"
+When this flag is specified, then libev will avoid to modify the signal
+mask. Specifically, this means you have to make sure signals are unblocked
+when you want to receive them.
+.Sp
+This behaviour is useful when you want to do your own signal handling, or
+want to handle signals only in specific threads and want to avoid libev
+unblocking the signals.
+.Sp
+It's also required by \s-1POSIX\s0 in a threaded program, as libev calls
+\&\f(CW\*(C`sigprocmask\*(C'\fR, whose behaviour is officially unspecified.
+.Sp
+This flag's behaviour will become the default in future versions of libev.
+.ie n .IP """EVBACKEND_SELECT""  (value 1, portable select backend)" 4
+.el .IP "\f(CWEVBACKEND_SELECT\fR  (value 1, portable select backend)" 4
+.IX Item "EVBACKEND_SELECT (value 1, portable select backend)"
+This is your standard \fIselect\fR\|(2) backend. Not \fIcompletely\fR standard, as
+libev tries to roll its own fd_set with no limits on the number of fds,
+but if that fails, expect a fairly low limit on the number of fds when
+using this backend. It doesn't scale too well (O(highest_fd)), but its
+usually the fastest backend for a low number of (low-numbered :) fds.
+.Sp
+To get good performance out of this backend you need a high amount of
+parallelism (most of the file descriptors should be busy). If you are
+writing a server, you should \f(CW\*(C`accept ()\*(C'\fR in a loop to accept as many
+connections as possible during one iteration. You might also want to have
+a look at \f(CW\*(C`ev_set_io_collect_interval ()\*(C'\fR to increase the amount of
+readiness notifications you get per iteration.
+.Sp
+This backend maps \f(CW\*(C`EV_READ\*(C'\fR to the \f(CW\*(C`readfds\*(C'\fR set and \f(CW\*(C`EV_WRITE\*(C'\fR to the
+\&\f(CW\*(C`writefds\*(C'\fR set (and to work around Microsoft Windows bugs, also onto the
+\&\f(CW\*(C`exceptfds\*(C'\fR set on that platform).
+.ie n .IP """EVBACKEND_POLL""    (value 2, poll backend, available everywhere except on windows)" 4
+.el .IP "\f(CWEVBACKEND_POLL\fR    (value 2, poll backend, available everywhere except on windows)" 4
+.IX Item "EVBACKEND_POLL (value 2, poll backend, available everywhere except on windows)"
+And this is your standard \fIpoll\fR\|(2) backend. It's more complicated
+than select, but handles sparse fds better and has no artificial
+limit on the number of fds you can use (except it will slow down
+considerably with a lot of inactive fds). It scales similarly to select,
+i.e. O(total_fds). See the entry for \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR, above, for
+performance tips.
+.Sp
+This backend maps \f(CW\*(C`EV_READ\*(C'\fR to \f(CW\*(C`POLLIN | POLLERR | POLLHUP\*(C'\fR, and
+\&\f(CW\*(C`EV_WRITE\*(C'\fR to \f(CW\*(C`POLLOUT | POLLERR | POLLHUP\*(C'\fR.
+.ie n .IP """EVBACKEND_EPOLL""   (value 4, Linux)" 4
+.el .IP "\f(CWEVBACKEND_EPOLL\fR   (value 4, Linux)" 4
+.IX Item "EVBACKEND_EPOLL (value 4, Linux)"
+Use the linux-specific \fIepoll\fR\|(7) interface (for both pre\- and post\-2.6.9
+kernels).
+.Sp
+For few fds, this backend is a bit little slower than poll and select, but
+it scales phenomenally better. While poll and select usually scale like
+O(total_fds) where total_fds is the total number of fds (or the highest
+fd), epoll scales either O(1) or O(active_fds).
+.Sp
+The epoll mechanism deserves honorable mention as the most misdesigned
+of the more advanced event mechanisms: mere annoyances include silently
+dropping file descriptors, requiring a system call per change per file
+descriptor (and unnecessary guessing of parameters), problems with dup,
+returning before the timeout value, resulting in additional iterations
+(and only giving 5ms accuracy while select on the same platform gives
+0.1ms) and so on. The biggest issue is fork races, however \- if a program
+forks then \fIboth\fR parent and child process have to recreate the epoll
+set, which can take considerable time (one syscall per file descriptor)
+and is of course hard to detect.
+.Sp
+Epoll is also notoriously buggy \- embedding epoll fds \fIshould\fR work,
+but of course \fIdoesn't\fR, and epoll just loves to report events for
+totally \fIdifferent\fR file descriptors (even already closed ones, so
+one cannot even remove them from the set) than registered in the set
+(especially on \s-1SMP\s0 systems). Libev tries to counter these spurious
+notifications by employing an additional generation counter and comparing
+that against the events to filter out spurious ones, recreating the set
+when required. Epoll also erroneously rounds down timeouts, but gives you
+no way to know when and by how much, so sometimes you have to busy-wait
+because epoll returns immediately despite a nonzero timeout. And last
+not least, it also refuses to work with some file descriptors which work
+perfectly fine with \f(CW\*(C`select\*(C'\fR (files, many character devices...).
+.Sp
+Epoll is truly the train wreck among event poll mechanisms, a frankenpoll,
+cobbled together in a hurry, no thought to design or interaction with
+others. Oh, the pain, will it ever stop...
+.Sp
+While stopping, setting and starting an I/O watcher in the same iteration
+will result in some caching, there is still a system call per such
+incident (because the same \fIfile descriptor\fR could point to a different
+\&\fIfile description\fR now), so its best to avoid that. Also, \f(CW\*(C`dup ()\*(C'\fR'ed
+file descriptors might not work very well if you register events for both
+file descriptors.
+.Sp
+Best performance from this backend is achieved by not unregistering all
+watchers for a file descriptor until it has been closed, if possible,
+i.e. keep at least one watcher active per fd at all times. Stopping and
+starting a watcher (without re-setting it) also usually doesn't cause
+extra overhead. A fork can both result in spurious notifications as well
+as in libev having to destroy and recreate the epoll object, which can
+take considerable time and thus should be avoided.
+.Sp
+All this means that, in practice, \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR can be as fast or
+faster than epoll for maybe up to a hundred file descriptors, depending on
+the usage. So sad.
+.Sp
+While nominally embeddable in other event loops, this feature is broken in
+all kernel versions tested so far.
+.Sp
+This backend maps \f(CW\*(C`EV_READ\*(C'\fR and \f(CW\*(C`EV_WRITE\*(C'\fR in the same way as
+\&\f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
+.ie n .IP """EVBACKEND_KQUEUE""  (value 8, most \s-1BSD\s0 clones)" 4
+.el .IP "\f(CWEVBACKEND_KQUEUE\fR  (value 8, most \s-1BSD\s0 clones)" 4
+.IX Item "EVBACKEND_KQUEUE (value 8, most BSD clones)"
+Kqueue deserves special mention, as at the time of this writing, it
+was broken on all BSDs except NetBSD (usually it doesn't work reliably
+with anything but sockets and pipes, except on Darwin, where of course
+it's completely useless). Unlike epoll, however, whose brokenness
+is by design, these kqueue bugs can (and eventually will) be fixed
+without \s-1API\s0 changes to existing programs. For this reason it's not being
+\&\*(L"auto-detected\*(R" unless you explicitly specify it in the flags (i.e. using
+\&\f(CW\*(C`EVBACKEND_KQUEUE\*(C'\fR) or libev was compiled on a known-to-be-good (\-enough)
+system like NetBSD.
+.Sp
+You still can embed kqueue into a normal poll or select backend and use it
+only for sockets (after having made sure that sockets work with kqueue on
+the target platform). See \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
+.Sp
+It scales in the same way as the epoll backend, but the interface to the
+kernel is more efficient (which says nothing about its actual speed, of
+course). While stopping, setting and starting an I/O watcher does never
+cause an extra system call as with \f(CW\*(C`EVBACKEND_EPOLL\*(C'\fR, it still adds up to
+two event changes per incident. Support for \f(CW\*(C`fork ()\*(C'\fR is very bad (you
+might have to leak fd's on fork, but it's more sane than epoll) and it
+drops fds silently in similarly hard-to-detect cases.
+.Sp
+This backend usually performs well under most conditions.
+.Sp
+While nominally embeddable in other event loops, this doesn't work
+everywhere, so you might need to test for this. And since it is broken
+almost everywhere, you should only use it when you have a lot of sockets
+(for which it usually works), by embedding it into another event loop
+(e.g. \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR (but \f(CW\*(C`poll\*(C'\fR is of course
+also broken on \s-1OS X\s0)) and, did I mention it, using it only for sockets.
+.Sp
+This backend maps \f(CW\*(C`EV_READ\*(C'\fR into an \f(CW\*(C`EVFILT_READ\*(C'\fR kevent with
+\&\f(CW\*(C`NOTE_EOF\*(C'\fR, and \f(CW\*(C`EV_WRITE\*(C'\fR into an \f(CW\*(C`EVFILT_WRITE\*(C'\fR kevent with
+\&\f(CW\*(C`NOTE_EOF\*(C'\fR.
+.ie n .IP """EVBACKEND_DEVPOLL"" (value 16, Solaris 8)" 4
+.el .IP "\f(CWEVBACKEND_DEVPOLL\fR (value 16, Solaris 8)" 4
+.IX Item "EVBACKEND_DEVPOLL (value 16, Solaris 8)"
+This is not implemented yet (and might never be, unless you send me an
+implementation). According to reports, \f(CW\*(C`/dev/poll\*(C'\fR only supports sockets
+and is not embeddable, which would limit the usefulness of this backend
+immensely.
+.ie n .IP """EVBACKEND_PORT""    (value 32, Solaris 10)" 4
+.el .IP "\f(CWEVBACKEND_PORT\fR    (value 32, Solaris 10)" 4
+.IX Item "EVBACKEND_PORT (value 32, Solaris 10)"
+This uses the Solaris 10 event port mechanism. As with everything on Solaris,
+it's really slow, but it still scales very well (O(active_fds)).
+.Sp
+While this backend scales well, it requires one system call per active
+file descriptor per loop iteration. For small and medium numbers of file
+descriptors a \*(L"slow\*(R" \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR backend
+might perform better.
+.Sp
+On the positive side, this backend actually performed fully to
+specification in all tests and is fully embeddable, which is a rare feat
+among the OS-specific backends (I vastly prefer correctness over speed
+hacks).
+.Sp
+On the negative side, the interface is \fIbizarre\fR \- so bizarre that
+even sun itself gets it wrong in their code examples: The event polling
+function sometimes returns events to the caller even though an error
+occurred, but with no indication whether it has done so or not (yes, it's
+even documented that way) \- deadly for edge-triggered interfaces where you
+absolutely have to know whether an event occurred or not because you have
+to re-arm the watcher.
+.Sp
+Fortunately libev seems to be able to work around these idiocies.
+.Sp
+This backend maps \f(CW\*(C`EV_READ\*(C'\fR and \f(CW\*(C`EV_WRITE\*(C'\fR in the same way as
+\&\f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
+.ie n .IP """EVBACKEND_ALL""" 4
+.el .IP "\f(CWEVBACKEND_ALL\fR" 4
+.IX Item "EVBACKEND_ALL"
+Try all backends (even potentially broken ones that wouldn't be tried
+with \f(CW\*(C`EVFLAG_AUTO\*(C'\fR). Since this is a mask, you can do stuff such as
+\&\f(CW\*(C`EVBACKEND_ALL & ~EVBACKEND_KQUEUE\*(C'\fR.
+.Sp
+It is definitely not recommended to use this flag, use whatever
+\&\f(CW\*(C`ev_recommended_backends ()\*(C'\fR returns, or simply do not specify a backend
+at all.
+.ie n .IP """EVBACKEND_MASK""" 4
+.el .IP "\f(CWEVBACKEND_MASK\fR" 4
+.IX Item "EVBACKEND_MASK"
+Not a backend at all, but a mask to select all backend bits from a
+\&\f(CW\*(C`flags\*(C'\fR value, in case you want to mask out any backends from a flags
+value (e.g. when modifying the \f(CW\*(C`LIBEV_FLAGS\*(C'\fR environment variable).
+.RE
+.RS 4
+.Sp
+If one or more of the backend flags are or'ed into the flags value,
+then only these backends will be tried (in the reverse order as listed
+here). If none are specified, all backends in \f(CW\*(C`ev_recommended_backends
+()\*(C'\fR will be tried.
+.Sp
+Example: Try to create a event loop that uses epoll and nothing else.
+.Sp
+.Vb 3
+\&   struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
+\&   if (!epoller)
+\&     fatal ("no epoll found here, maybe it hides under your chair");
+.Ve
+.Sp
+Example: Use whatever libev has to offer, but make sure that kqueue is
+used if available.
+.Sp
+.Vb 1
+\&   struct ev_loop *loop = ev_loop_new (ev_recommended_backends () | EVBACKEND_KQUEUE);
+.Ve
+.RE
+.IP "ev_loop_destroy (loop)" 4
+.IX Item "ev_loop_destroy (loop)"
+Destroys an event loop object (frees all memory and kernel state
+etc.). None of the active event watchers will be stopped in the normal
+sense, so e.g. \f(CW\*(C`ev_is_active\*(C'\fR might still return true. It is your
+responsibility to either stop all watchers cleanly yourself \fIbefore\fR
+calling this function, or cope with the fact afterwards (which is usually
+the easiest thing, you can just ignore the watchers and/or \f(CW\*(C`free ()\*(C'\fR them
+for example).
+.Sp
+Note that certain global state, such as signal state (and installed signal
+handlers), will not be freed by this function, and related watchers (such
+as signal and child watchers) would need to be stopped manually.
+.Sp
+This function is normally used on loop objects allocated by
+\&\f(CW\*(C`ev_loop_new\*(C'\fR, but it can also be used on the default loop returned by
+\&\f(CW\*(C`ev_default_loop\*(C'\fR, in which case it is not thread-safe.
+.Sp
+Note that it is not advisable to call this function on the default loop
+except in the rare occasion where you really need to free its resources.
+If you need dynamically allocated loops it is better to use \f(CW\*(C`ev_loop_new\*(C'\fR
+and \f(CW\*(C`ev_loop_destroy\*(C'\fR.
+.IP "ev_loop_fork (loop)" 4
+.IX Item "ev_loop_fork (loop)"
+This function sets a flag that causes subsequent \f(CW\*(C`ev_run\*(C'\fR iterations
+to reinitialise the kernel state for backends that have one. Despite
+the name, you can call it anytime you are allowed to start or stop
+watchers (except inside an \f(CW\*(C`ev_prepare\*(C'\fR callback), but it makes most
+sense after forking, in the child process. You \fImust\fR call it (or use
+\&\f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR) in the child before resuming or calling \f(CW\*(C`ev_run\*(C'\fR.
+.Sp
+In addition, if you want to reuse a loop (via this function or
+\&\f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR), you \fIalso\fR have to ignore \f(CW\*(C`SIGPIPE\*(C'\fR.
+.Sp
+Again, you \fIhave\fR to call it on \fIany\fR loop that you want to re-use after
+a fork, \fIeven if you do not plan to use the loop in the parent\fR. This is
+because some kernel interfaces *cough* \fIkqueue\fR *cough* do funny things
+during fork.
+.Sp
+On the other hand, you only need to call this function in the child
+process if and only if you want to use the event loop in the child. If
+you just fork+exec or create a new loop in the child, you don't have to
+call it at all (in fact, \f(CW\*(C`epoll\*(C'\fR is so badly broken that it makes a
+difference, but libev will usually detect this case on its own and do a
+costly reset of the backend).
+.Sp
+The function itself is quite fast and it's usually not a problem to call
+it just in case after a fork.
+.Sp
+Example: Automate calling \f(CW\*(C`ev_loop_fork\*(C'\fR on the default loop when
+using pthreads.
+.Sp
+.Vb 5
+\&   static void
+\&   post_fork_child (void)
+\&   {
+\&     ev_loop_fork (EV_DEFAULT);
+\&   }
+\&
+\&   ...
+\&   pthread_atfork (0, 0, post_fork_child);
+.Ve
+.IP "int ev_is_default_loop (loop)" 4
+.IX Item "int ev_is_default_loop (loop)"
+Returns true when the given loop is, in fact, the default loop, and false
+otherwise.
+.IP "unsigned int ev_iteration (loop)" 4
+.IX Item "unsigned int ev_iteration (loop)"
+Returns the current iteration count for the event loop, which is identical
+to the number of times libev did poll for new events. It starts at \f(CW0\fR
+and happily wraps around with enough iterations.
+.Sp
+This value can sometimes be useful as a generation counter of sorts (it
+\&\*(L"ticks\*(R" the number of loop iterations), as it roughly corresponds with
+\&\f(CW\*(C`ev_prepare\*(C'\fR and \f(CW\*(C`ev_check\*(C'\fR calls \- and is incremented between the
+prepare and check phases.
+.IP "unsigned int ev_depth (loop)" 4
+.IX Item "unsigned int ev_depth (loop)"
+Returns the number of times \f(CW\*(C`ev_run\*(C'\fR was entered minus the number of
+times \f(CW\*(C`ev_run\*(C'\fR was exited normally, in other words, the recursion depth.
+.Sp
+Outside \f(CW\*(C`ev_run\*(C'\fR, this number is zero. In a callback, this number is
+\&\f(CW1\fR, unless \f(CW\*(C`ev_run\*(C'\fR was invoked recursively (or from another thread),
+in which case it is higher.
+.Sp
+Leaving \f(CW\*(C`ev_run\*(C'\fR abnormally (setjmp/longjmp, cancelling the thread,
+throwing an exception etc.), doesn't count as \*(L"exit\*(R" \- consider this
+as a hint to avoid such ungentleman-like behaviour unless it's really
+convenient, in which case it is fully supported.
+.IP "unsigned int ev_backend (loop)" 4
+.IX Item "unsigned int ev_backend (loop)"
+Returns one of the \f(CW\*(C`EVBACKEND_*\*(C'\fR flags indicating the event backend in
+use.
+.IP "ev_tstamp ev_now (loop)" 4
+.IX Item "ev_tstamp ev_now (loop)"
+Returns the current \*(L"event loop time\*(R", which is the time the event loop
+received events and started processing them. This timestamp does not
+change as long as callbacks are being processed, and this is also the base
+time used for relative timers. You can treat it as the timestamp of the
+event occurring (or more correctly, libev finding out about it).
+.IP "ev_now_update (loop)" 4
+.IX Item "ev_now_update (loop)"
+Establishes the current time by querying the kernel, updating the time
+returned by \f(CW\*(C`ev_now ()\*(C'\fR in the progress. This is a costly operation and
+is usually done automatically within \f(CW\*(C`ev_run ()\*(C'\fR.
+.Sp
+This function is rarely useful, but when some event callback runs for a
+very long time without entering the event loop, updating libev's idea of
+the current time is a good idea.
+.Sp
+See also \*(L"The special problem of time updates\*(R" in the \f(CW\*(C`ev_timer\*(C'\fR section.
+.IP "ev_suspend (loop)" 4
+.IX Item "ev_suspend (loop)"
+.PD 0
+.IP "ev_resume (loop)" 4
+.IX Item "ev_resume (loop)"
+.PD
+These two functions suspend and resume an event loop, for use when the
+loop is not used for a while and timeouts should not be processed.
+.Sp
+A typical use case would be an interactive program such as a game:  When
+the user presses \f(CW\*(C`^Z\*(C'\fR to suspend the game and resumes it an hour later it
+would be best to handle timeouts as if no time had actually passed while
+the program was suspended. This can be achieved by calling \f(CW\*(C`ev_suspend\*(C'\fR
+in your \f(CW\*(C`SIGTSTP\*(C'\fR handler, sending yourself a \f(CW\*(C`SIGSTOP\*(C'\fR and calling
+\&\f(CW\*(C`ev_resume\*(C'\fR directly afterwards to resume timer processing.
+.Sp
+Effectively, all \f(CW\*(C`ev_timer\*(C'\fR watchers will be delayed by the time spend
+between \f(CW\*(C`ev_suspend\*(C'\fR and \f(CW\*(C`ev_resume\*(C'\fR, and all \f(CW\*(C`ev_periodic\*(C'\fR watchers
+will be rescheduled (that is, they will lose any events that would have
+occurred while suspended).
+.Sp
+After calling \f(CW\*(C`ev_suspend\*(C'\fR you \fBmust not\fR call \fIany\fR function on the
+given loop other than \f(CW\*(C`ev_resume\*(C'\fR, and you \fBmust not\fR call \f(CW\*(C`ev_resume\*(C'\fR
+without a previous call to \f(CW\*(C`ev_suspend\*(C'\fR.
+.Sp
+Calling \f(CW\*(C`ev_suspend\*(C'\fR/\f(CW\*(C`ev_resume\*(C'\fR has the side effect of updating the
+event loop time (see \f(CW\*(C`ev_now_update\*(C'\fR).
+.IP "bool ev_run (loop, int flags)" 4
+.IX Item "bool ev_run (loop, int flags)"
+Finally, this is it, the event handler. This function usually is called
+after you have initialised all your watchers and you want to start
+handling events. It will ask the operating system for any new events, call
+the watcher callbacks, and then repeat the whole process indefinitely: This
+is why event loops are called \fIloops\fR.
+.Sp
+If the flags argument is specified as \f(CW0\fR, it will keep handling events
+until either no event watchers are active anymore or \f(CW\*(C`ev_break\*(C'\fR was
+called.
+.Sp
+The return value is false if there are no more active watchers (which
+usually means \*(L"all jobs done\*(R" or \*(L"deadlock\*(R"), and true in all other cases
+(which usually means " you should call \f(CW\*(C`ev_run\*(C'\fR again").
+.Sp
+Please note that an explicit \f(CW\*(C`ev_break\*(C'\fR is usually better than
+relying on all watchers to be stopped when deciding when a program has
+finished (especially in interactive programs), but having a program
+that automatically loops as long as it has to and no longer by virtue
+of relying on its watchers stopping correctly, that is truly a thing of
+beauty.
+.Sp
+This function is \fImostly\fR exception-safe \- you can break out of a
+\&\f(CW\*(C`ev_run\*(C'\fR call by calling \f(CW\*(C`longjmp\*(C'\fR in a callback, throwing a \*(C+
+exception and so on. This does not decrement the \f(CW\*(C`ev_depth\*(C'\fR value, nor
+will it clear any outstanding \f(CW\*(C`EVBREAK_ONE\*(C'\fR breaks.
+.Sp
+A flags value of \f(CW\*(C`EVRUN_NOWAIT\*(C'\fR will look for new events, will handle
+those events and any already outstanding ones, but will not wait and
+block your process in case there are no events and will return after one
+iteration of the loop. This is sometimes useful to poll and handle new
+events while doing lengthy calculations, to keep the program responsive.
+.Sp
+A flags value of \f(CW\*(C`EVRUN_ONCE\*(C'\fR will look for new events (waiting if
+necessary) and will handle those and any already outstanding ones. It
+will block your process until at least one new event arrives (which could
+be an event internal to libev itself, so there is no guarantee that a
+user-registered callback will be called), and will return after one
+iteration of the loop.
+.Sp
+This is useful if you are waiting for some external event in conjunction
+with something not expressible using other libev watchers (i.e. "roll your
+own \f(CW\*(C`ev_run\*(C'\fR"). However, a pair of \f(CW\*(C`ev_prepare\*(C'\fR/\f(CW\*(C`ev_check\*(C'\fR watchers is
+usually a better approach for this kind of thing.
+.Sp
+Here are the gory details of what \f(CW\*(C`ev_run\*(C'\fR does (this is for your
+understanding, not a guarantee that things will work exactly like this in
+future versions):
+.Sp
+.Vb 10
+\&   \- Increment loop depth.
+\&   \- Reset the ev_break status.
+\&   \- Before the first iteration, call any pending watchers.
+\&   LOOP:
+\&   \- If EVFLAG_FORKCHECK was used, check for a fork.
+\&   \- If a fork was detected (by any means), queue and call all fork watchers.
+\&   \- Queue and call all prepare watchers.
+\&   \- If ev_break was called, goto FINISH.
+\&   \- If we have been forked, detach and recreate the kernel state
+\&     as to not disturb the other process.
+\&   \- Update the kernel state with all outstanding changes.
+\&   \- Update the "event loop time" (ev_now ()).
+\&   \- Calculate for how long to sleep or block, if at all
+\&     (active idle watchers, EVRUN_NOWAIT or not having
+\&     any active watchers at all will result in not sleeping).
+\&   \- Sleep if the I/O and timer collect interval say so.
+\&   \- Increment loop iteration counter.
+\&   \- Block the process, waiting for any events.
+\&   \- Queue all outstanding I/O (fd) events.
+\&   \- Update the "event loop time" (ev_now ()), and do time jump adjustments.
+\&   \- Queue all expired timers.
+\&   \- Queue all expired periodics.
+\&   \- Queue all idle watchers with priority higher than that of pending events.
+\&   \- Queue all check watchers.
+\&   \- Call all queued watchers in reverse order (i.e. check watchers first).
+\&     Signals and child watchers are implemented as I/O watchers, and will
+\&     be handled here by queueing them when their watcher gets executed.
+\&   \- If ev_break has been called, or EVRUN_ONCE or EVRUN_NOWAIT
+\&     were used, or there are no active watchers, goto FINISH, otherwise
+\&     continue with step LOOP.
+\&   FINISH:
+\&   \- Reset the ev_break status iff it was EVBREAK_ONE.
+\&   \- Decrement the loop depth.
+\&   \- Return.
+.Ve
+.Sp
+Example: Queue some jobs and then loop until no events are outstanding
+anymore.
+.Sp
+.Vb 4
+\&   ... queue jobs here, make sure they register event watchers as long
+\&   ... as they still have work to do (even an idle watcher will do..)
+\&   ev_run (my_loop, 0);
+\&   ... jobs done or somebody called break. yeah!
+.Ve
+.IP "ev_break (loop, how)" 4
+.IX Item "ev_break (loop, how)"
+Can be used to make a call to \f(CW\*(C`ev_run\*(C'\fR return early (but only after it
+has processed all outstanding events). The \f(CW\*(C`how\*(C'\fR argument must be either
+\&\f(CW\*(C`EVBREAK_ONE\*(C'\fR, which will make the innermost \f(CW\*(C`ev_run\*(C'\fR call return, or
+\&\f(CW\*(C`EVBREAK_ALL\*(C'\fR, which will make all nested \f(CW\*(C`ev_run\*(C'\fR calls return.
+.Sp
+This \*(L"break state\*(R" will be cleared on the next call to \f(CW\*(C`ev_run\*(C'\fR.
+.Sp
+It is safe to call \f(CW\*(C`ev_break\*(C'\fR from outside any \f(CW\*(C`ev_run\*(C'\fR calls, too, in
+which case it will have no effect.
+.IP "ev_ref (loop)" 4
+.IX Item "ev_ref (loop)"
+.PD 0
+.IP "ev_unref (loop)" 4
+.IX Item "ev_unref (loop)"
+.PD
+Ref/unref can be used to add or remove a reference count on the event
+loop: Every watcher keeps one reference, and as long as the reference
+count is nonzero, \f(CW\*(C`ev_run\*(C'\fR will not return on its own.
+.Sp
+This is useful when you have a watcher that you never intend to
+unregister, but that nevertheless should not keep \f(CW\*(C`ev_run\*(C'\fR from
+returning. In such a case, call \f(CW\*(C`ev_unref\*(C'\fR after starting, and \f(CW\*(C`ev_ref\*(C'\fR
+before stopping it.
+.Sp
+As an example, libev itself uses this for its internal signal pipe: It
+is not visible to the libev user and should not keep \f(CW\*(C`ev_run\*(C'\fR from
+exiting if no event watchers registered by it are active. It is also an
+excellent way to do this for generic recurring timers or from within
+third-party libraries. Just remember to \fIunref after start\fR and \fIref
+before stop\fR (but only if the watcher wasn't active before, or was active
+before, respectively. Note also that libev might stop watchers itself
+(e.g. non-repeating timers) in which case you have to \f(CW\*(C`ev_ref\*(C'\fR
+in the callback).
+.Sp
+Example: Create a signal watcher, but keep it from keeping \f(CW\*(C`ev_run\*(C'\fR
+running when nothing else is active.
+.Sp
+.Vb 4
+\&   ev_signal exitsig;
+\&   ev_signal_init (&exitsig, sig_cb, SIGINT);
+\&   ev_signal_start (loop, &exitsig);
+\&   ev_unref (loop);
+.Ve
+.Sp
+Example: For some weird reason, unregister the above signal handler again.
+.Sp
+.Vb 2
+\&   ev_ref (loop);
+\&   ev_signal_stop (loop, &exitsig);
+.Ve
+.IP "ev_set_io_collect_interval (loop, ev_tstamp interval)" 4
+.IX Item "ev_set_io_collect_interval (loop, ev_tstamp interval)"
+.PD 0
+.IP "ev_set_timeout_collect_interval (loop, ev_tstamp interval)" 4
+.IX Item "ev_set_timeout_collect_interval (loop, ev_tstamp interval)"
+.PD
+These advanced functions influence the time that libev will spend waiting
+for events. Both time intervals are by default \f(CW0\fR, meaning that libev
+will try to invoke timer/periodic callbacks and I/O callbacks with minimum
+latency.
+.Sp
+Setting these to a higher value (the \f(CW\*(C`interval\*(C'\fR \fImust\fR be >= \f(CW0\fR)
+allows libev to delay invocation of I/O and timer/periodic callbacks
+to increase efficiency of loop iterations (or to increase power-saving
+opportunities).
+.Sp
+The idea is that sometimes your program runs just fast enough to handle
+one (or very few) event(s) per loop iteration. While this makes the
+program responsive, it also wastes a lot of \s-1CPU\s0 time to poll for new
+events, especially with backends like \f(CW\*(C`select ()\*(C'\fR which have a high
+overhead for the actual polling but can deliver many events at once.
+.Sp
+By setting a higher \fIio collect interval\fR you allow libev to spend more
+time collecting I/O events, so you can handle more events per iteration,
+at the cost of increasing latency. Timeouts (both \f(CW\*(C`ev_periodic\*(C'\fR and
+\&\f(CW\*(C`ev_timer\*(C'\fR) will not be affected. Setting this to a non-null value will
+introduce an additional \f(CW\*(C`ev_sleep ()\*(C'\fR call into most loop iterations. The
+sleep time ensures that libev will not poll for I/O events more often then
+once per this interval, on average (as long as the host time resolution is
+good enough).
+.Sp
+Likewise, by setting a higher \fItimeout collect interval\fR you allow libev
+to spend more time collecting timeouts, at the expense of increased
+latency/jitter/inexactness (the watcher callback will be called
+later). \f(CW\*(C`ev_io\*(C'\fR watchers will not be affected. Setting this to a non-null
+value will not introduce any overhead in libev.
+.Sp
+Many (busy) programs can usually benefit by setting the I/O collect
+interval to a value near \f(CW0.1\fR or so, which is often enough for
+interactive servers (of course not for games), likewise for timeouts. It
+usually doesn't make much sense to set it to a lower value than \f(CW0.01\fR,
+as this approaches the timing granularity of most systems. Note that if
+you do transactions with the outside world and you can't increase the
+parallelity, then this setting will limit your transaction rate (if you
+need to poll once per transaction and the I/O collect interval is 0.01,
+then you can't do more than 100 transactions per second).
+.Sp
+Setting the \fItimeout collect interval\fR can improve the opportunity for
+saving power, as the program will \*(L"bundle\*(R" timer callback invocations that
+are \*(L"near\*(R" in time together, by delaying some, thus reducing the number of
+times the process sleeps and wakes up again. Another useful technique to
+reduce iterations/wake\-ups is to use \f(CW\*(C`ev_periodic\*(C'\fR watchers and make sure
+they fire on, say, one-second boundaries only.
+.Sp
+Example: we only need 0.1s timeout granularity, and we wish not to poll
+more often than 100 times per second:
+.Sp
+.Vb 2
+\&   ev_set_timeout_collect_interval (EV_DEFAULT_UC_ 0.1);
+\&   ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);
+.Ve
+.IP "ev_invoke_pending (loop)" 4
+.IX Item "ev_invoke_pending (loop)"
+This call will simply invoke all pending watchers while resetting their
+pending state. Normally, \f(CW\*(C`ev_run\*(C'\fR does this automatically when required,
+but when overriding the invoke callback this call comes handy. This
+function can be invoked from a watcher \- this can be useful for example
+when you want to do some lengthy calculation and want to pass further
+event handling to another thread (you still have to make sure only one
+thread executes within \f(CW\*(C`ev_invoke_pending\*(C'\fR or \f(CW\*(C`ev_run\*(C'\fR of course).
+.IP "int ev_pending_count (loop)" 4
+.IX Item "int ev_pending_count (loop)"
+Returns the number of pending watchers \- zero indicates that no watchers
+are pending.
+.IP "ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(\s-1EV_P\s0))" 4
+.IX Item "ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(EV_P))"
+This overrides the invoke pending functionality of the loop: Instead of
+invoking all pending watchers when there are any, \f(CW\*(C`ev_run\*(C'\fR will call
+this callback instead. This is useful, for example, when you want to
+invoke the actual watchers inside another context (another thread etc.).
+.Sp
+If you want to reset the callback, use \f(CW\*(C`ev_invoke_pending\*(C'\fR as new
+callback.
+.IP "ev_set_loop_release_cb (loop, void (*release)(\s-1EV_P\s0) throw (), void (*acquire)(\s-1EV_P\s0) throw ())" 4
+.IX Item "ev_set_loop_release_cb (loop, void (*release)(EV_P) throw (), void (*acquire)(EV_P) throw ())"
+Sometimes you want to share the same loop between multiple threads. This
+can be done relatively simply by putting mutex_lock/unlock calls around
+each call to a libev function.
+.Sp
+However, \f(CW\*(C`ev_run\*(C'\fR can run an indefinite time, so it is not feasible
+to wait for it to return. One way around this is to wake up the event
+loop via \f(CW\*(C`ev_break\*(C'\fR and \f(CW\*(C`ev_async_send\*(C'\fR, another way is to set these
+\&\fIrelease\fR and \fIacquire\fR callbacks on the loop.
+.Sp
+When set, then \f(CW\*(C`release\*(C'\fR will be called just before the thread is
+suspended waiting for new events, and \f(CW\*(C`acquire\*(C'\fR is called just
+afterwards.
+.Sp
+Ideally, \f(CW\*(C`release\*(C'\fR will just call your mutex_unlock function, and
+\&\f(CW\*(C`acquire\*(C'\fR will just call the mutex_lock function again.
+.Sp
+While event loop modifications are allowed between invocations of
+\&\f(CW\*(C`release\*(C'\fR and \f(CW\*(C`acquire\*(C'\fR (that's their only purpose after all), no
+modifications done will affect the event loop, i.e. adding watchers will
+have no effect on the set of file descriptors being watched, or the time
+waited. Use an \f(CW\*(C`ev_async\*(C'\fR watcher to wake up \f(CW\*(C`ev_run\*(C'\fR when you want it
+to take note of any changes you made.
+.Sp
+In theory, threads executing \f(CW\*(C`ev_run\*(C'\fR will be async-cancel safe between
+invocations of \f(CW\*(C`release\*(C'\fR and \f(CW\*(C`acquire\*(C'\fR.
+.Sp
+See also the locking example in the \f(CW\*(C`THREADS\*(C'\fR section later in this
+document.
+.IP "ev_set_userdata (loop, void *data)" 4
+.IX Item "ev_set_userdata (loop, void *data)"
+.PD 0
+.IP "void *ev_userdata (loop)" 4
+.IX Item "void *ev_userdata (loop)"
+.PD
+Set and retrieve a single \f(CW\*(C`void *\*(C'\fR associated with a loop. When
+\&\f(CW\*(C`ev_set_userdata\*(C'\fR has never been called, then \f(CW\*(C`ev_userdata\*(C'\fR returns
+\&\f(CW0\fR.
+.Sp
+These two functions can be used to associate arbitrary data with a loop,
+and are intended solely for the \f(CW\*(C`invoke_pending_cb\*(C'\fR, \f(CW\*(C`release\*(C'\fR and
+\&\f(CW\*(C`acquire\*(C'\fR callbacks described above, but of course can be (ab\-)used for
+any other purpose as well.
+.IP "ev_verify (loop)" 4
+.IX Item "ev_verify (loop)"
+This function only does something when \f(CW\*(C`EV_VERIFY\*(C'\fR support has been
+compiled in, which is the default for non-minimal builds. It tries to go
+through all internal structures and checks them for validity. If anything
+is found to be inconsistent, it will print an error message to standard
+error and call \f(CW\*(C`abort ()\*(C'\fR.
+.Sp
+This can be used to catch bugs inside libev itself: under normal
+circumstances, this function will never abort as of course libev keeps its
+data structures consistent.
+.SH "ANATOMY OF A WATCHER"
+.IX Header "ANATOMY OF A WATCHER"
+In the following description, uppercase \f(CW\*(C`TYPE\*(C'\fR in names stands for the
+watcher type, e.g. \f(CW\*(C`ev_TYPE_start\*(C'\fR can mean \f(CW\*(C`ev_timer_start\*(C'\fR for timer
+watchers and \f(CW\*(C`ev_io_start\*(C'\fR for I/O watchers.
+.PP
+A watcher is an opaque structure that you allocate and register to record
+your interest in some event. To make a concrete example, imagine you want
+to wait for \s-1STDIN\s0 to become readable, you would create an \f(CW\*(C`ev_io\*(C'\fR watcher
+for that:
+.PP
+.Vb 5
+\&   static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
+\&   {
+\&     ev_io_stop (w);
+\&     ev_break (loop, EVBREAK_ALL);
+\&   }
+\&
+\&   struct ev_loop *loop = ev_default_loop (0);
+\&
+\&   ev_io stdin_watcher;
+\&
+\&   ev_init (&stdin_watcher, my_cb);
+\&   ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
+\&   ev_io_start (loop, &stdin_watcher);
+\&
+\&   ev_run (loop, 0);
+.Ve
+.PP
+As you can see, you are responsible for allocating the memory for your
+watcher structures (and it is \fIusually\fR a bad idea to do this on the
+stack).
+.PP
+Each watcher has an associated watcher structure (called \f(CW\*(C`struct ev_TYPE\*(C'\fR
+or simply \f(CW\*(C`ev_TYPE\*(C'\fR, as typedefs are provided for all watcher structs).
+.PP
+Each watcher structure must be initialised by a call to \f(CW\*(C`ev_init (watcher
+*, callback)\*(C'\fR, which expects a callback to be provided. This callback is
+invoked each time the event occurs (or, in the case of I/O watchers, each
+time the event loop detects that the file descriptor given is readable
+and/or writable).
+.PP
+Each watcher type further has its own \f(CW\*(C`ev_TYPE_set (watcher *, ...)\*(C'\fR
+macro to configure it, with arguments specific to the watcher type. There
+is also a macro to combine initialisation and setting in one call: \f(CW\*(C`ev_TYPE_init (watcher *, callback, ...)\*(C'\fR.
+.PP
+To make the watcher actually watch out for events, you have to start it
+with a watcher-specific start function (\f(CW\*(C`ev_TYPE_start (loop, watcher
+*)\*(C'\fR), and you can stop watching for events at any time by calling the
+corresponding stop function (\f(CW\*(C`ev_TYPE_stop (loop, watcher *)\*(C'\fR.
+.PP
+As long as your watcher is active (has been started but not stopped) you
+must not touch the values stored in it. Most specifically you must never
+reinitialise it or call its \f(CW\*(C`ev_TYPE_set\*(C'\fR macro.
+.PP
+Each and every callback receives the event loop pointer as first, the
+registered watcher structure as second, and a bitset of received events as
+third argument.
+.PP
+The received events usually include a single bit per event type received
+(you can receive multiple events at the same time). The possible bit masks
+are:
+.ie n .IP """EV_READ""" 4
+.el .IP "\f(CWEV_READ\fR" 4
+.IX Item "EV_READ"
+.PD 0
+.ie n .IP """EV_WRITE""" 4
+.el .IP "\f(CWEV_WRITE\fR" 4
+.IX Item "EV_WRITE"
+.PD
+The file descriptor in the \f(CW\*(C`ev_io\*(C'\fR watcher has become readable and/or
+writable.
+.ie n .IP """EV_TIMER""" 4
+.el .IP "\f(CWEV_TIMER\fR" 4
+.IX Item "EV_TIMER"
+The \f(CW\*(C`ev_timer\*(C'\fR watcher has timed out.
+.ie n .IP """EV_PERIODIC""" 4
+.el .IP "\f(CWEV_PERIODIC\fR" 4
+.IX Item "EV_PERIODIC"
+The \f(CW\*(C`ev_periodic\*(C'\fR watcher has timed out.
+.ie n .IP """EV_SIGNAL""" 4
+.el .IP "\f(CWEV_SIGNAL\fR" 4
+.IX Item "EV_SIGNAL"
+The signal specified in the \f(CW\*(C`ev_signal\*(C'\fR watcher has been received by a thread.
+.ie n .IP """EV_CHILD""" 4
+.el .IP "\f(CWEV_CHILD\fR" 4
+.IX Item "EV_CHILD"
+The pid specified in the \f(CW\*(C`ev_child\*(C'\fR watcher has received a status change.
+.ie n .IP """EV_STAT""" 4
+.el .IP "\f(CWEV_STAT\fR" 4
+.IX Item "EV_STAT"
+The path specified in the \f(CW\*(C`ev_stat\*(C'\fR watcher changed its attributes somehow.
+.ie n .IP """EV_IDLE""" 4
+.el .IP "\f(CWEV_IDLE\fR" 4
+.IX Item "EV_IDLE"
+The \f(CW\*(C`ev_idle\*(C'\fR watcher has determined that you have nothing better to do.
+.ie n .IP """EV_PREPARE""" 4
+.el .IP "\f(CWEV_PREPARE\fR" 4
+.IX Item "EV_PREPARE"
+.PD 0
+.ie n .IP """EV_CHECK""" 4
+.el .IP "\f(CWEV_CHECK\fR" 4
+.IX Item "EV_CHECK"
+.PD
+All \f(CW\*(C`ev_prepare\*(C'\fR watchers are invoked just \fIbefore\fR \f(CW\*(C`ev_run\*(C'\fR starts to
+gather new events, and all \f(CW\*(C`ev_check\*(C'\fR watchers are queued (not invoked)
+just after \f(CW\*(C`ev_run\*(C'\fR has gathered them, but before it queues any callbacks
+for any received events. That means \f(CW\*(C`ev_prepare\*(C'\fR watchers are the last
+watchers invoked before the event loop sleeps or polls for new events, and
+\&\f(CW\*(C`ev_check\*(C'\fR watchers will be invoked before any other watchers of the same
+or lower priority within an event loop iteration.
+.Sp
+Callbacks of both watcher types can start and stop as many watchers as
+they want, and all of them will be taken into account (for example, a
+\&\f(CW\*(C`ev_prepare\*(C'\fR watcher might start an idle watcher to keep \f(CW\*(C`ev_run\*(C'\fR from
+blocking).
+.ie n .IP """EV_EMBED""" 4
+.el .IP "\f(CWEV_EMBED\fR" 4
+.IX Item "EV_EMBED"
+The embedded event loop specified in the \f(CW\*(C`ev_embed\*(C'\fR watcher needs attention.
+.ie n .IP """EV_FORK""" 4
+.el .IP "\f(CWEV_FORK\fR" 4
+.IX Item "EV_FORK"
+The event loop has been resumed in the child process after fork (see
+\&\f(CW\*(C`ev_fork\*(C'\fR).
+.ie n .IP """EV_CLEANUP""" 4
+.el .IP "\f(CWEV_CLEANUP\fR" 4
+.IX Item "EV_CLEANUP"
+The event loop is about to be destroyed (see \f(CW\*(C`ev_cleanup\*(C'\fR).
+.ie n .IP """EV_ASYNC""" 4
+.el .IP "\f(CWEV_ASYNC\fR" 4
+.IX Item "EV_ASYNC"
+The given async watcher has been asynchronously notified (see \f(CW\*(C`ev_async\*(C'\fR).
+.ie n .IP """EV_CUSTOM""" 4
+.el .IP "\f(CWEV_CUSTOM\fR" 4
+.IX Item "EV_CUSTOM"
+Not ever sent (or otherwise used) by libev itself, but can be freely used
+by libev users to signal watchers (e.g. via \f(CW\*(C`ev_feed_event\*(C'\fR).
+.ie n .IP """EV_ERROR""" 4
+.el .IP "\f(CWEV_ERROR\fR" 4
+.IX Item "EV_ERROR"
+An unspecified error has occurred, the watcher has been stopped. This might
+happen because the watcher could not be properly started because libev
+ran out of memory, a file descriptor was found to be closed or any other
+problem. Libev considers these application bugs.
+.Sp
+You best act on it by reporting the problem and somehow coping with the
+watcher being stopped. Note that well-written programs should not receive
+an error ever, so when your watcher receives it, this usually indicates a
+bug in your program.
+.Sp
+Libev will usually signal a few \*(L"dummy\*(R" events together with an error, for
+example it might indicate that a fd is readable or writable, and if your
+callbacks is well-written it can just attempt the operation and cope with
+the error from \fIread()\fR or \fIwrite()\fR. This will not work in multi-threaded
+programs, though, as the fd could already be closed and reused for another
+thing, so beware.
+.SS "\s-1GENERIC WATCHER FUNCTIONS\s0"
+.IX Subsection "GENERIC WATCHER FUNCTIONS"
+.ie n .IP """ev_init"" (ev_TYPE *watcher, callback)" 4
+.el .IP "\f(CWev_init\fR (ev_TYPE *watcher, callback)" 4
+.IX Item "ev_init (ev_TYPE *watcher, callback)"
+This macro initialises the generic portion of a watcher. The contents
+of the watcher object can be arbitrary (so \f(CW\*(C`malloc\*(C'\fR will do). Only
+the generic parts of the watcher are initialised, you \fIneed\fR to call
+the type-specific \f(CW\*(C`ev_TYPE_set\*(C'\fR macro afterwards to initialise the
+type-specific parts. For each type there is also a \f(CW\*(C`ev_TYPE_init\*(C'\fR macro
+which rolls both calls into one.
+.Sp
+You can reinitialise a watcher at any time as long as it has been stopped
+(or never started) and there are no pending events outstanding.
+.Sp
+The callback is always of type \f(CW\*(C`void (*)(struct ev_loop *loop, ev_TYPE *watcher,
+int revents)\*(C'\fR.
+.Sp
+Example: Initialise an \f(CW\*(C`ev_io\*(C'\fR watcher in two steps.
+.Sp
+.Vb 3
+\&   ev_io w;
+\&   ev_init (&w, my_cb);
+\&   ev_io_set (&w, STDIN_FILENO, EV_READ);
+.Ve
+.ie n .IP """ev_TYPE_set"" (ev_TYPE *watcher, [args])" 4
+.el .IP "\f(CWev_TYPE_set\fR (ev_TYPE *watcher, [args])" 4
+.IX Item "ev_TYPE_set (ev_TYPE *watcher, [args])"
+This macro initialises the type-specific parts of a watcher. You need to
+call \f(CW\*(C`ev_init\*(C'\fR at least once before you call this macro, but you can
+call \f(CW\*(C`ev_TYPE_set\*(C'\fR any number of times. You must not, however, call this
+macro on a watcher that is active (it can be pending, however, which is a
+difference to the \f(CW\*(C`ev_init\*(C'\fR macro).
+.Sp
+Although some watcher types do not have type-specific arguments
+(e.g. \f(CW\*(C`ev_prepare\*(C'\fR) you still need to call its \f(CW\*(C`set\*(C'\fR macro.
+.Sp
+See \f(CW\*(C`ev_init\*(C'\fR, above, for an example.
+.ie n .IP """ev_TYPE_init"" (ev_TYPE *watcher, callback, [args])" 4
+.el .IP "\f(CWev_TYPE_init\fR (ev_TYPE *watcher, callback, [args])" 4
+.IX Item "ev_TYPE_init (ev_TYPE *watcher, callback, [args])"
+This convenience macro rolls both \f(CW\*(C`ev_init\*(C'\fR and \f(CW\*(C`ev_TYPE_set\*(C'\fR macro
+calls into a single call. This is the most convenient method to initialise
+a watcher. The same limitations apply, of course.
+.Sp
+Example: Initialise and set an \f(CW\*(C`ev_io\*(C'\fR watcher in one step.
+.Sp
+.Vb 1
+\&   ev_io_init (&w, my_cb, STDIN_FILENO, EV_READ);
+.Ve
+.ie n .IP """ev_TYPE_start"" (loop, ev_TYPE *watcher)" 4
+.el .IP "\f(CWev_TYPE_start\fR (loop, ev_TYPE *watcher)" 4
+.IX Item "ev_TYPE_start (loop, ev_TYPE *watcher)"
+Starts (activates) the given watcher. Only active watchers will receive
+events. If the watcher is already active nothing will happen.
+.Sp
+Example: Start the \f(CW\*(C`ev_io\*(C'\fR watcher that is being abused as example in this
+whole section.
+.Sp
+.Vb 1
+\&   ev_io_start (EV_DEFAULT_UC, &w);
+.Ve
+.ie n .IP """ev_TYPE_stop"" (loop, ev_TYPE *watcher)" 4
+.el .IP "\f(CWev_TYPE_stop\fR (loop, ev_TYPE *watcher)" 4
+.IX Item "ev_TYPE_stop (loop, ev_TYPE *watcher)"
+Stops the given watcher if active, and clears the pending status (whether
+the watcher was active or not).
+.Sp
+It is possible that stopped watchers are pending \- for example,
+non-repeating timers are being stopped when they become pending \- but
+calling \f(CW\*(C`ev_TYPE_stop\*(C'\fR ensures that the watcher is neither active nor
+pending. If you want to free or reuse the memory used by the watcher it is
+therefore a good idea to always call its \f(CW\*(C`ev_TYPE_stop\*(C'\fR function.
+.IP "bool ev_is_active (ev_TYPE *watcher)" 4
+.IX Item "bool ev_is_active (ev_TYPE *watcher)"
+Returns a true value iff the watcher is active (i.e. it has been started
+and not yet been stopped). As long as a watcher is active you must not modify
+it.
+.IP "bool ev_is_pending (ev_TYPE *watcher)" 4
+.IX Item "bool ev_is_pending (ev_TYPE *watcher)"
+Returns a true value iff the watcher is pending, (i.e. it has outstanding
+events but its callback has not yet been invoked). As long as a watcher
+is pending (but not active) you must not call an init function on it (but
+\&\f(CW\*(C`ev_TYPE_set\*(C'\fR is safe), you must not change its priority, and you must
+make sure the watcher is available to libev (e.g. you cannot \f(CW\*(C`free ()\*(C'\fR
+it).
+.IP "callback ev_cb (ev_TYPE *watcher)" 4
+.IX Item "callback ev_cb (ev_TYPE *watcher)"
+Returns the callback currently set on the watcher.
+.IP "ev_set_cb (ev_TYPE *watcher, callback)" 4
+.IX Item "ev_set_cb (ev_TYPE *watcher, callback)"
+Change the callback. You can change the callback at virtually any time
+(modulo threads).
+.IP "ev_set_priority (ev_TYPE *watcher, int priority)" 4
+.IX Item "ev_set_priority (ev_TYPE *watcher, int priority)"
+.PD 0
+.IP "int ev_priority (ev_TYPE *watcher)" 4
+.IX Item "int ev_priority (ev_TYPE *watcher)"
+.PD
+Set and query the priority of the watcher. The priority is a small
+integer between \f(CW\*(C`EV_MAXPRI\*(C'\fR (default: \f(CW2\fR) and \f(CW\*(C`EV_MINPRI\*(C'\fR
+(default: \f(CW\*(C`\-2\*(C'\fR). Pending watchers with higher priority will be invoked
+before watchers with lower priority, but priority will not keep watchers
+from being executed (except for \f(CW\*(C`ev_idle\*(C'\fR watchers).
+.Sp
+If you need to suppress invocation when higher priority events are pending
+you need to look at \f(CW\*(C`ev_idle\*(C'\fR watchers, which provide this functionality.
+.Sp
+You \fImust not\fR change the priority of a watcher as long as it is active or
+pending.
+.Sp
+Setting a priority outside the range of \f(CW\*(C`EV_MINPRI\*(C'\fR to \f(CW\*(C`EV_MAXPRI\*(C'\fR is
+fine, as long as you do not mind that the priority value you query might
+or might not have been clamped to the valid range.
+.Sp
+The default priority used by watchers when no priority has been set is
+always \f(CW0\fR, which is supposed to not be too high and not be too low :).
+.Sp
+See \*(L"\s-1WATCHER PRIORITY MODELS\*(R"\s0, below, for a more thorough treatment of
+priorities.
+.IP "ev_invoke (loop, ev_TYPE *watcher, int revents)" 4
+.IX Item "ev_invoke (loop, ev_TYPE *watcher, int revents)"
+Invoke the \f(CW\*(C`watcher\*(C'\fR with the given \f(CW\*(C`loop\*(C'\fR and \f(CW\*(C`revents\*(C'\fR. Neither
+\&\f(CW\*(C`loop\*(C'\fR nor \f(CW\*(C`revents\*(C'\fR need to be valid as long as the watcher callback
+can deal with that fact, as both are simply passed through to the
+callback.
+.IP "int ev_clear_pending (loop, ev_TYPE *watcher)" 4
+.IX Item "int ev_clear_pending (loop, ev_TYPE *watcher)"
+If the watcher is pending, this function clears its pending status and
+returns its \f(CW\*(C`revents\*(C'\fR bitset (as if its callback was invoked). If the
+watcher isn't pending it does nothing and returns \f(CW0\fR.
+.Sp
+Sometimes it can be useful to \*(L"poll\*(R" a watcher instead of waiting for its
+callback to be invoked, which can be accomplished with this function.
+.IP "ev_feed_event (loop, ev_TYPE *watcher, int revents)" 4
+.IX Item "ev_feed_event (loop, ev_TYPE *watcher, int revents)"
+Feeds the given event set into the event loop, as if the specified event
+had happened for the specified watcher (which must be a pointer to an
+initialised but not necessarily started event watcher). Obviously you must
+not free the watcher as long as it has pending events.
+.Sp
+Stopping the watcher, letting libev invoke it, or calling
+\&\f(CW\*(C`ev_clear_pending\*(C'\fR will clear the pending event, even if the watcher was
+not started in the first place.
+.Sp
+See also \f(CW\*(C`ev_feed_fd_event\*(C'\fR and \f(CW\*(C`ev_feed_signal_event\*(C'\fR for related
+functions that do not need a watcher.
+.PP
+See also the \*(L"\s-1ASSOCIATING CUSTOM DATA WITH A WATCHER\*(R"\s0 and \*(L"\s-1BUILDING YOUR
+OWN COMPOSITE WATCHERS\*(R"\s0 idioms.
+.SS "\s-1WATCHER STATES\s0"
+.IX Subsection "WATCHER STATES"
+There are various watcher states mentioned throughout this manual \-
+active, pending and so on. In this section these states and the rules to
+transition between them will be described in more detail \- and while these
+rules might look complicated, they usually do \*(L"the right thing\*(R".
+.IP "initialised" 4
+.IX Item "initialised"
+Before a watcher can be registered with the event loop it has to be
+initialised. This can be done with a call to \f(CW\*(C`ev_TYPE_init\*(C'\fR, or calls to
+\&\f(CW\*(C`ev_init\*(C'\fR followed by the watcher-specific \f(CW\*(C`ev_TYPE_set\*(C'\fR function.
+.Sp
+In this state it is simply some block of memory that is suitable for
+use in an event loop. It can be moved around, freed, reused etc. at
+will \- as long as you either keep the memory contents intact, or call
+\&\f(CW\*(C`ev_TYPE_init\*(C'\fR again.
+.IP "started/running/active" 4
+.IX Item "started/running/active"
+Once a watcher has been started with a call to \f(CW\*(C`ev_TYPE_start\*(C'\fR it becomes
+property of the event loop, and is actively waiting for events. While in
+this state it cannot be accessed (except in a few documented ways), moved,
+freed or anything else \- the only legal thing is to keep a pointer to it,
+and call libev functions on it that are documented to work on active watchers.
+.IP "pending" 4
+.IX Item "pending"
+If a watcher is active and libev determines that an event it is interested
+in has occurred (such as a timer expiring), it will become pending. It will
+stay in this pending state until either it is stopped or its callback is
+about to be invoked, so it is not normally pending inside the watcher
+callback.
+.Sp
+The watcher might or might not be active while it is pending (for example,
+an expired non-repeating timer can be pending but no longer active). If it
+is stopped, it can be freely accessed (e.g. by calling \f(CW\*(C`ev_TYPE_set\*(C'\fR),
+but it is still property of the event loop at this time, so cannot be
+moved, freed or reused. And if it is active the rules described in the
+previous item still apply.
+.Sp
+It is also possible to feed an event on a watcher that is not active (e.g.
+via \f(CW\*(C`ev_feed_event\*(C'\fR), in which case it becomes pending without being
+active.
+.IP "stopped" 4
+.IX Item "stopped"
+A watcher can be stopped implicitly by libev (in which case it might still
+be pending), or explicitly by calling its \f(CW\*(C`ev_TYPE_stop\*(C'\fR function. The
+latter will clear any pending state the watcher might be in, regardless
+of whether it was active or not, so stopping a watcher explicitly before
+freeing it is often a good idea.
+.Sp
+While stopped (and not pending) the watcher is essentially in the
+initialised state, that is, it can be reused, moved, modified in any way
+you wish (but when you trash the memory block, you need to \f(CW\*(C`ev_TYPE_init\*(C'\fR
+it again).
+.SS "\s-1WATCHER PRIORITY MODELS\s0"
+.IX Subsection "WATCHER PRIORITY MODELS"
+Many event loops support \fIwatcher priorities\fR, which are usually small
+integers that influence the ordering of event callback invocation
+between watchers in some way, all else being equal.
+.PP
+In libev, Watcher priorities can be set using \f(CW\*(C`ev_set_priority\*(C'\fR. See its
+description for the more technical details such as the actual priority
+range.
+.PP
+There are two common ways how these these priorities are being interpreted
+by event loops:
+.PP
+In the more common lock-out model, higher priorities \*(L"lock out\*(R" invocation
+of lower priority watchers, which means as long as higher priority
+watchers receive events, lower priority watchers are not being invoked.
+.PP
+The less common only-for-ordering model uses priorities solely to order
+callback invocation within a single event loop iteration: Higher priority
+watchers are invoked before lower priority ones, but they all get invoked
+before polling for new events.
+.PP
+Libev uses the second (only-for-ordering) model for all its watchers
+except for idle watchers (which use the lock-out model).
+.PP
+The rationale behind this is that implementing the lock-out model for
+watchers is not well supported by most kernel interfaces, and most event
+libraries will just poll for the same events again and again as long as
+their callbacks have not been executed, which is very inefficient in the
+common case of one high-priority watcher locking out a mass of lower
+priority ones.
+.PP
+Static (ordering) priorities are most useful when you have two or more
+watchers handling the same resource: a typical usage example is having an
+\&\f(CW\*(C`ev_io\*(C'\fR watcher to receive data, and an associated \f(CW\*(C`ev_timer\*(C'\fR to handle
+timeouts. Under load, data might be received while the program handles
+other jobs, but since timers normally get invoked first, the timeout
+handler will be executed before checking for data. In that case, giving
+the timer a lower priority than the I/O watcher ensures that I/O will be
+handled first even under adverse conditions (which is usually, but not
+always, what you want).
+.PP
+Since idle watchers use the \*(L"lock-out\*(R" model, meaning that idle watchers
+will only be executed when no same or higher priority watchers have
+received events, they can be used to implement the \*(L"lock-out\*(R" model when
+required.
+.PP
+For example, to emulate how many other event libraries handle priorities,
+you can associate an \f(CW\*(C`ev_idle\*(C'\fR watcher to each such watcher, and in
+the normal watcher callback, you just start the idle watcher. The real
+processing is done in the idle watcher callback. This causes libev to
+continuously poll and process kernel event data for the watcher, but when
+the lock-out case is known to be rare (which in turn is rare :), this is
+workable.
+.PP
+Usually, however, the lock-out model implemented that way will perform
+miserably under the type of load it was designed to handle. In that case,
+it might be preferable to stop the real watcher before starting the
+idle watcher, so the kernel will not have to process the event in case
+the actual processing will be delayed for considerable time.
+.PP
+Here is an example of an I/O watcher that should run at a strictly lower
+priority than the default, and which should only process data when no
+other events are pending:
+.PP
+.Vb 2
+\&   ev_idle idle; // actual processing watcher
+\&   ev_io io;     // actual event watcher
+\&
+\&   static void
+\&   io_cb (EV_P_ ev_io *w, int revents)
+\&   {
+\&     // stop the I/O watcher, we received the event, but
+\&     // are not yet ready to handle it.
+\&     ev_io_stop (EV_A_ w);
+\&
+\&     // start the idle watcher to handle the actual event.
+\&     // it will not be executed as long as other watchers
+\&     // with the default priority are receiving events.
+\&     ev_idle_start (EV_A_ &idle);
+\&   }
+\&
+\&   static void
+\&   idle_cb (EV_P_ ev_idle *w, int revents)
+\&   {
+\&     // actual processing
+\&     read (STDIN_FILENO, ...);
+\&
+\&     // have to start the I/O watcher again, as
+\&     // we have handled the event
+\&     ev_io_start (EV_P_ &io);
+\&   }
+\&
+\&   // initialisation
+\&   ev_idle_init (&idle, idle_cb);
+\&   ev_io_init (&io, io_cb, STDIN_FILENO, EV_READ);
+\&   ev_io_start (EV_DEFAULT_ &io);
+.Ve
+.PP
+In the \*(L"real\*(R" world, it might also be beneficial to start a timer, so that
+low-priority connections can not be locked out forever under load. This
+enables your program to keep a lower latency for important connections
+during short periods of high load, while not completely locking out less
+important ones.
+.SH "WATCHER TYPES"
+.IX Header "WATCHER TYPES"
+This section describes each watcher in detail, but will not repeat
+information given in the last section. Any initialisation/set macros,
+functions and members specific to the watcher type are explained.
+.PP
+Members are additionally marked with either \fI[read\-only]\fR, meaning that,
+while the watcher is active, you can look at the member and expect some
+sensible content, but you must not modify it (you can modify it while the
+watcher is stopped to your hearts content), or \fI[read\-write]\fR, which
+means you can expect it to have some sensible content while the watcher
+is active, but you can also modify it. Modifying it may not do something
+sensible or take immediate effect (or do anything at all), but libev will
+not crash or malfunction in any way.
+.ie n .SS """ev_io"" \- is this file descriptor readable or writable?"
+.el .SS "\f(CWev_io\fP \- is this file descriptor readable or writable?"
+.IX Subsection "ev_io - is this file descriptor readable or writable?"
+I/O watchers check whether a file descriptor is readable or writable
+in each iteration of the event loop, or, more precisely, when reading
+would not block the process and writing would at least be able to write
+some data. This behaviour is called level-triggering because you keep
+receiving events as long as the condition persists. Remember you can stop
+the watcher if you don't want to act on the event and neither want to
+receive future events.
+.PP
+In general you can register as many read and/or write event watchers per
+fd as you want (as long as you don't confuse yourself). Setting all file
+descriptors to non-blocking mode is also usually a good idea (but not
+required if you know what you are doing).
+.PP
+Another thing you have to watch out for is that it is quite easy to
+receive \*(L"spurious\*(R" readiness notifications, that is, your callback might
+be called with \f(CW\*(C`EV_READ\*(C'\fR but a subsequent \f(CW\*(C`read\*(C'\fR(2) will actually block
+because there is no data. It is very easy to get into this situation even
+with a relatively standard program structure. Thus it is best to always
+use non-blocking I/O: An extra \f(CW\*(C`read\*(C'\fR(2) returning \f(CW\*(C`EAGAIN\*(C'\fR is far
+preferable to a program hanging until some data arrives.
+.PP
+If you cannot run the fd in non-blocking mode (for example you should
+not play around with an Xlib connection), then you have to separately
+re-test whether a file descriptor is really ready with a known-to-be good
+interface such as poll (fortunately in the case of Xlib, it already does
+this on its own, so its quite safe to use). Some people additionally
+use \f(CW\*(C`SIGALRM\*(C'\fR and an interval timer, just to be sure you won't block
+indefinitely.
+.PP
+But really, best use non-blocking mode.
+.PP
+\fIThe special problem of disappearing file descriptors\fR
+.IX Subsection "The special problem of disappearing file descriptors"
+.PP
+Some backends (e.g. kqueue, epoll) need to be told about closing a file
+descriptor (either due to calling \f(CW\*(C`close\*(C'\fR explicitly or any other means,
+such as \f(CW\*(C`dup2\*(C'\fR). The reason is that you register interest in some file
+descriptor, but when it goes away, the operating system will silently drop
+this interest. If another file descriptor with the same number then is
+registered with libev, there is no efficient way to see that this is, in
+fact, a different file descriptor.
+.PP
+To avoid having to explicitly tell libev about such cases, libev follows
+the following policy:  Each time \f(CW\*(C`ev_io_set\*(C'\fR is being called, libev
+will assume that this is potentially a new file descriptor, otherwise
+it is assumed that the file descriptor stays the same. That means that
+you \fIhave\fR to call \f(CW\*(C`ev_io_set\*(C'\fR (or \f(CW\*(C`ev_io_init\*(C'\fR) when you change the
+descriptor even if the file descriptor number itself did not change.
+.PP
+This is how one would do it normally anyway, the important point is that
+the libev application should not optimise around libev but should leave
+optimisations to libev.
+.PP
+\fIThe special problem of dup'ed file descriptors\fR
+.IX Subsection "The special problem of dup'ed file descriptors"
+.PP
+Some backends (e.g. epoll), cannot register events for file descriptors,
+but only events for the underlying file descriptions. That means when you
+have \f(CW\*(C`dup ()\*(C'\fR'ed file descriptors or weirder constellations, and register
+events for them, only one file descriptor might actually receive events.
+.PP
+There is no workaround possible except not registering events
+for potentially \f(CW\*(C`dup ()\*(C'\fR'ed file descriptors, or to resort to
+\&\f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
+.PP
+\fIThe special problem of files\fR
+.IX Subsection "The special problem of files"
+.PP
+Many people try to use \f(CW\*(C`select\*(C'\fR (or libev) on file descriptors
+representing files, and expect it to become ready when their program
+doesn't block on disk accesses (which can take a long time on their own).
+.PP
+However, this cannot ever work in the \*(L"expected\*(R" way \- you get a readiness
+notification as soon as the kernel knows whether and how much data is
+there, and in the case of open files, that's always the case, so you
+always get a readiness notification instantly, and your read (or possibly
+write) will still block on the disk I/O.
+.PP
+Another way to view it is that in the case of sockets, pipes, character
+devices and so on, there is another party (the sender) that delivers data
+on its own, but in the case of files, there is no such thing: the disk
+will not send data on its own, simply because it doesn't know what you
+wish to read \- you would first have to request some data.
+.PP
+Since files are typically not-so-well supported by advanced notification
+mechanism, libev tries hard to emulate \s-1POSIX\s0 behaviour with respect
+to files, even though you should not use it. The reason for this is
+convenience: sometimes you want to watch \s-1STDIN\s0 or \s-1STDOUT,\s0 which is
+usually a tty, often a pipe, but also sometimes files or special devices
+(for example, \f(CW\*(C`epoll\*(C'\fR on Linux works with \fI/dev/random\fR but not with
+\&\fI/dev/urandom\fR), and even though the file might better be served with
+asynchronous I/O instead of with non-blocking I/O, it is still useful when
+it \*(L"just works\*(R" instead of freezing.
+.PP
+So avoid file descriptors pointing to files when you know it (e.g. use
+libeio), but use them when it is convenient, e.g. for \s-1STDIN/STDOUT,\s0 or
+when you rarely read from a file instead of from a socket, and want to
+reuse the same code path.
+.PP
+\fIThe special problem of fork\fR
+.IX Subsection "The special problem of fork"
+.PP
+Some backends (epoll, kqueue) do not support \f(CW\*(C`fork ()\*(C'\fR at all or exhibit
+useless behaviour. Libev fully supports fork, but needs to be told about
+it in the child if you want to continue to use it in the child.
+.PP
+To support fork in your child processes, you have to call \f(CW\*(C`ev_loop_fork
+()\*(C'\fR after a fork in the child, enable \f(CW\*(C`EVFLAG_FORKCHECK\*(C'\fR, or resort to
+\&\f(CW\*(C`EVBACKEND_SELECT\*(C'\fR or \f(CW\*(C`EVBACKEND_POLL\*(C'\fR.
+.PP
+\fIThe special problem of \s-1SIGPIPE\s0\fR
+.IX Subsection "The special problem of SIGPIPE"
+.PP
+While not really specific to libev, it is easy to forget about \f(CW\*(C`SIGPIPE\*(C'\fR:
+when writing to a pipe whose other end has been closed, your program gets
+sent a \s-1SIGPIPE,\s0 which, by default, aborts your program. For most programs
+this is sensible behaviour, for daemons, this is usually undesirable.
+.PP
+So when you encounter spurious, unexplained daemon exits, make sure you
+ignore \s-1SIGPIPE \s0(and maybe make sure you log the exit status of your daemon
+somewhere, as that would have given you a big clue).
+.PP
+\fIThe special problem of \fIaccept()\fIing when you can't\fR
+.IX Subsection "The special problem of accept()ing when you can't"
+.PP
+Many implementations of the \s-1POSIX \s0\f(CW\*(C`accept\*(C'\fR function (for example,
+found in post\-2004 Linux) have the peculiar behaviour of not removing a
+connection from the pending queue in all error cases.
+.PP
+For example, larger servers often run out of file descriptors (because
+of resource limits), causing \f(CW\*(C`accept\*(C'\fR to fail with \f(CW\*(C`ENFILE\*(C'\fR but not
+rejecting the connection, leading to libev signalling readiness on
+the next iteration again (the connection still exists after all), and
+typically causing the program to loop at 100% \s-1CPU\s0 usage.
+.PP
+Unfortunately, the set of errors that cause this issue differs between
+operating systems, there is usually little the app can do to remedy the
+situation, and no known thread-safe method of removing the connection to
+cope with overload is known (to me).
+.PP
+One of the easiest ways to handle this situation is to just ignore it
+\&\- when the program encounters an overload, it will just loop until the
+situation is over. While this is a form of busy waiting, no \s-1OS\s0 offers an
+event-based way to handle this situation, so it's the best one can do.
+.PP
+A better way to handle the situation is to log any errors other than
+\&\f(CW\*(C`EAGAIN\*(C'\fR and \f(CW\*(C`EWOULDBLOCK\*(C'\fR, making sure not to flood the log with such
+messages, and continue as usual, which at least gives the user an idea of
+what could be wrong (\*(L"raise the ulimit!\*(R"). For extra points one could stop
+the \f(CW\*(C`ev_io\*(C'\fR watcher on the listening fd \*(L"for a while\*(R", which reduces \s-1CPU\s0
+usage.
+.PP
+If your program is single-threaded, then you could also keep a dummy file
+descriptor for overload situations (e.g. by opening \fI/dev/null\fR), and
+when you run into \f(CW\*(C`ENFILE\*(C'\fR or \f(CW\*(C`EMFILE\*(C'\fR, close it, run \f(CW\*(C`accept\*(C'\fR,
+close that fd, and create a new dummy fd. This will gracefully refuse
+clients under typical overload conditions.
+.PP
+The last way to handle it is to simply log the error and \f(CW\*(C`exit\*(C'\fR, as
+is often done with \f(CW\*(C`malloc\*(C'\fR failures, but this results in an easy
+opportunity for a DoS attack.
+.PP
+\fIWatcher-Specific Functions\fR
+.IX Subsection "Watcher-Specific Functions"
+.IP "ev_io_init (ev_io *, callback, int fd, int events)" 4
+.IX Item "ev_io_init (ev_io *, callback, int fd, int events)"
+.PD 0
+.IP "ev_io_set (ev_io *, int fd, int events)" 4
+.IX Item "ev_io_set (ev_io *, int fd, int events)"
+.PD
+Configures an \f(CW\*(C`ev_io\*(C'\fR watcher. The \f(CW\*(C`fd\*(C'\fR is the file descriptor to
+receive events for and \f(CW\*(C`events\*(C'\fR is either \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or
+\&\f(CW\*(C`EV_READ | EV_WRITE\*(C'\fR, to express the desire to receive the given events.
+.IP "int fd [read\-only]" 4
+.IX Item "int fd [read-only]"
+The file descriptor being watched.
+.IP "int events [read\-only]" 4
+.IX Item "int events [read-only]"
+The events being watched.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Call \f(CW\*(C`stdin_readable_cb\*(C'\fR when \s-1STDIN_FILENO\s0 has become, well
+readable, but only once. Since it is likely line-buffered, you could
+attempt to read a whole line in the callback.
+.PP
+.Vb 6
+\&   static void
+\&   stdin_readable_cb (struct ev_loop *loop, ev_io *w, int revents)
+\&   {
+\&      ev_io_stop (loop, w);
+\&     .. read from stdin here (or from w\->fd) and handle any I/O errors
+\&   }
+\&
+\&   ...
+\&   struct ev_loop *loop = ev_default_init (0);
+\&   ev_io stdin_readable;
+\&   ev_io_init (&stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
+\&   ev_io_start (loop, &stdin_readable);
+\&   ev_run (loop, 0);
+.Ve
+.ie n .SS """ev_timer"" \- relative and optionally repeating timeouts"
+.el .SS "\f(CWev_timer\fP \- relative and optionally repeating timeouts"
+.IX Subsection "ev_timer - relative and optionally repeating timeouts"
+Timer watchers are simple relative timers that generate an event after a
+given time, and optionally repeating in regular intervals after that.
+.PP
+The timers are based on real time, that is, if you register an event that
+times out after an hour and you reset your system clock to January last
+year, it will still time out after (roughly) one hour. \*(L"Roughly\*(R" because
+detecting time jumps is hard, and some inaccuracies are unavoidable (the
+monotonic clock option helps a lot here).
+.PP
+The callback is guaranteed to be invoked only \fIafter\fR its timeout has
+passed (not \fIat\fR, so on systems with very low-resolution clocks this
+might introduce a small delay, see \*(L"the special problem of being too
+early\*(R", below). If multiple timers become ready during the same loop
+iteration then the ones with earlier time-out values are invoked before
+ones of the same priority with later time-out values (but this is no
+longer true when a callback calls \f(CW\*(C`ev_run\*(C'\fR recursively).
+.PP
+\fIBe smart about timeouts\fR
+.IX Subsection "Be smart about timeouts"
+.PP
+Many real-world problems involve some kind of timeout, usually for error
+recovery. A typical example is an \s-1HTTP\s0 request \- if the other side hangs,
+you want to raise some error after a while.
+.PP
+What follows are some ways to handle this problem, from obvious and
+inefficient to smart and efficient.
+.PP
+In the following, a 60 second activity timeout is assumed \- a timeout that
+gets reset to 60 seconds each time there is activity (e.g. each time some
+data or other life sign was received).
+.IP "1. Use a timer and stop, reinitialise and start it on activity." 4
+.IX Item "1. Use a timer and stop, reinitialise and start it on activity."
+This is the most obvious, but not the most simple way: In the beginning,
+start the watcher:
+.Sp
+.Vb 2
+\&   ev_timer_init (timer, callback, 60., 0.);
+\&   ev_timer_start (loop, timer);
+.Ve
+.Sp
+Then, each time there is some activity, \f(CW\*(C`ev_timer_stop\*(C'\fR it, initialise it
+and start it again:
+.Sp
+.Vb 3
+\&   ev_timer_stop (loop, timer);
+\&   ev_timer_set (timer, 60., 0.);
+\&   ev_timer_start (loop, timer);
+.Ve
+.Sp
+This is relatively simple to implement, but means that each time there is
+some activity, libev will first have to remove the timer from its internal
+data structure and then add it again. Libev tries to be fast, but it's
+still not a constant-time operation.
+.ie n .IP "2. Use a timer and re-start it with ""ev_timer_again"" inactivity." 4
+.el .IP "2. Use a timer and re-start it with \f(CWev_timer_again\fR inactivity." 4
+.IX Item "2. Use a timer and re-start it with ev_timer_again inactivity."
+This is the easiest way, and involves using \f(CW\*(C`ev_timer_again\*(C'\fR instead of
+\&\f(CW\*(C`ev_timer_start\*(C'\fR.
+.Sp
+To implement this, configure an \f(CW\*(C`ev_timer\*(C'\fR with a \f(CW\*(C`repeat\*(C'\fR value
+of \f(CW60\fR and then call \f(CW\*(C`ev_timer_again\*(C'\fR at start and each time you
+successfully read or write some data. If you go into an idle state where
+you do not expect data to travel on the socket, you can \f(CW\*(C`ev_timer_stop\*(C'\fR
+the timer, and \f(CW\*(C`ev_timer_again\*(C'\fR will automatically restart it if need be.
+.Sp
+That means you can ignore both the \f(CW\*(C`ev_timer_start\*(C'\fR function and the
+\&\f(CW\*(C`after\*(C'\fR argument to \f(CW\*(C`ev_timer_set\*(C'\fR, and only ever use the \f(CW\*(C`repeat\*(C'\fR
+member and \f(CW\*(C`ev_timer_again\*(C'\fR.
+.Sp
+At start:
+.Sp
+.Vb 3
+\&   ev_init (timer, callback);
+\&   timer\->repeat = 60.;
+\&   ev_timer_again (loop, timer);
+.Ve
+.Sp
+Each time there is some activity:
+.Sp
+.Vb 1
+\&   ev_timer_again (loop, timer);
+.Ve
+.Sp
+It is even possible to change the time-out on the fly, regardless of
+whether the watcher is active or not:
+.Sp
+.Vb 2
+\&   timer\->repeat = 30.;
+\&   ev_timer_again (loop, timer);
+.Ve
+.Sp
+This is slightly more efficient then stopping/starting the timer each time
+you want to modify its timeout value, as libev does not have to completely
+remove and re-insert the timer from/into its internal data structure.
+.Sp
+It is, however, even simpler than the \*(L"obvious\*(R" way to do it.
+.IP "3. Let the timer time out, but then re-arm it as required." 4
+.IX Item "3. Let the timer time out, but then re-arm it as required."
+This method is more tricky, but usually most efficient: Most timeouts are
+relatively long compared to the intervals between other activity \- in
+our example, within 60 seconds, there are usually many I/O events with
+associated activity resets.
+.Sp
+In this case, it would be more efficient to leave the \f(CW\*(C`ev_timer\*(C'\fR alone,
+but remember the time of last activity, and check for a real timeout only
+within the callback:
+.Sp
+.Vb 3
+\&   ev_tstamp timeout = 60.;
+\&   ev_tstamp last_activity; // time of last activity
+\&   ev_timer timer;
+\&
+\&   static void
+\&   callback (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     // calculate when the timeout would happen
+\&     ev_tstamp after = last_activity \- ev_now (EV_A) + timeout;
+\&
+\&     // if negative, it means we the timeout already occurred
+\&     if (after < 0.)
+\&       {
+\&         // timeout occurred, take action
+\&       }
+\&     else
+\&       {
+\&         // callback was invoked, but there was some recent 
+\&         // activity. simply restart the timer to time out
+\&         // after "after" seconds, which is the earliest time
+\&         // the timeout can occur.
+\&         ev_timer_set (w, after, 0.);
+\&         ev_timer_start (EV_A_ w);
+\&       }
+\&   }
+.Ve
+.Sp
+To summarise the callback: first calculate in how many seconds the
+timeout will occur (by calculating the absolute time when it would occur,
+\&\f(CW\*(C`last_activity + timeout\*(C'\fR, and subtracting the current time, \f(CW\*(C`ev_now
+(EV_A)\*(C'\fR from that).
+.Sp
+If this value is negative, then we are already past the timeout, i.e. we
+timed out, and need to do whatever is needed in this case.
+.Sp
+Otherwise, we now the earliest time at which the timeout would trigger,
+and simply start the timer with this timeout value.
+.Sp
+In other words, each time the callback is invoked it will check whether
+the timeout occurred. If not, it will simply reschedule itself to check
+again at the earliest time it could time out. Rinse. Repeat.
+.Sp
+This scheme causes more callback invocations (about one every 60 seconds
+minus half the average time between activity), but virtually no calls to
+libev to change the timeout.
+.Sp
+To start the machinery, simply initialise the watcher and set
+\&\f(CW\*(C`last_activity\*(C'\fR to the current time (meaning there was some activity just
+now), then call the callback, which will \*(L"do the right thing\*(R" and start
+the timer:
+.Sp
+.Vb 3
+\&   last_activity = ev_now (EV_A);
+\&   ev_init (&timer, callback);
+\&   callback (EV_A_ &timer, 0);
+.Ve
+.Sp
+When there is some activity, simply store the current time in
+\&\f(CW\*(C`last_activity\*(C'\fR, no libev calls at all:
+.Sp
+.Vb 2
+\&   if (activity detected)
+\&     last_activity = ev_now (EV_A);
+.Ve
+.Sp
+When your timeout value changes, then the timeout can be changed by simply
+providing a new value, stopping the timer and calling the callback, which
+will again do the right thing (for example, time out immediately :).
+.Sp
+.Vb 3
+\&   timeout = new_value;
+\&   ev_timer_stop (EV_A_ &timer);
+\&   callback (EV_A_ &timer, 0);
+.Ve
+.Sp
+This technique is slightly more complex, but in most cases where the
+time-out is unlikely to be triggered, much more efficient.
+.IP "4. Wee, just use a double-linked list for your timeouts." 4
+.IX Item "4. Wee, just use a double-linked list for your timeouts."
+If there is not one request, but many thousands (millions...), all
+employing some kind of timeout with the same timeout value, then one can
+do even better:
+.Sp
+When starting the timeout, calculate the timeout value and put the timeout
+at the \fIend\fR of the list.
+.Sp
+Then use an \f(CW\*(C`ev_timer\*(C'\fR to fire when the timeout at the \fIbeginning\fR of
+the list is expected to fire (for example, using the technique #3).
+.Sp
+When there is some activity, remove the timer from the list, recalculate
+the timeout, append it to the end of the list again, and make sure to
+update the \f(CW\*(C`ev_timer\*(C'\fR if it was taken from the beginning of the list.
+.Sp
+This way, one can manage an unlimited number of timeouts in O(1) time for
+starting, stopping and updating the timers, at the expense of a major
+complication, and having to use a constant timeout. The constant timeout
+ensures that the list stays sorted.
+.PP
+So which method the best?
+.PP
+Method #2 is a simple no-brain-required solution that is adequate in most
+situations. Method #3 requires a bit more thinking, but handles many cases
+better, and isn't very complicated either. In most case, choosing either
+one is fine, with #3 being better in typical situations.
+.PP
+Method #1 is almost always a bad idea, and buys you nothing. Method #4 is
+rather complicated, but extremely efficient, something that really pays
+off after the first million or so of active timers, i.e. it's usually
+overkill :)
+.PP
+\fIThe special problem of being too early\fR
+.IX Subsection "The special problem of being too early"
+.PP
+If you ask a timer to call your callback after three seconds, then
+you expect it to be invoked after three seconds \- but of course, this
+cannot be guaranteed to infinite precision. Less obviously, it cannot be
+guaranteed to any precision by libev \- imagine somebody suspending the
+process with a \s-1STOP\s0 signal for a few hours for example.
+.PP
+So, libev tries to invoke your callback as soon as possible \fIafter\fR the
+delay has occurred, but cannot guarantee this.
+.PP
+A less obvious failure mode is calling your callback too early: many event
+loops compare timestamps with a \*(L"elapsed delay >= requested delay\*(R", but
+this can cause your callback to be invoked much earlier than you would
+expect.
+.PP
+To see why, imagine a system with a clock that only offers full second
+resolution (think windows if you can't come up with a broken enough \s-1OS\s0
+yourself). If you schedule a one-second timer at the time 500.9, then the
+event loop will schedule your timeout to elapse at a system time of 500
+(500.9 truncated to the resolution) + 1, or 501.
+.PP
+If an event library looks at the timeout 0.1s later, it will see \*(L"501 >=
+501\*(R" and invoke the callback 0.1s after it was started, even though a
+one-second delay was requested \- this is being \*(L"too early\*(R", despite best
+intentions.
+.PP
+This is the reason why libev will never invoke the callback if the elapsed
+delay equals the requested delay, but only when the elapsed delay is
+larger than the requested delay. In the example above, libev would only invoke
+the callback at system time 502, or 1.1s after the timer was started.
+.PP
+So, while libev cannot guarantee that your callback will be invoked
+exactly when requested, it \fIcan\fR and \fIdoes\fR guarantee that the requested
+delay has actually elapsed, or in other words, it always errs on the \*(L"too
+late\*(R" side of things.
+.PP
+\fIThe special problem of time updates\fR
+.IX Subsection "The special problem of time updates"
+.PP
+Establishing the current time is a costly operation (it usually takes
+at least one system call): \s-1EV\s0 therefore updates its idea of the current
+time only before and after \f(CW\*(C`ev_run\*(C'\fR collects new events, which causes a
+growing difference between \f(CW\*(C`ev_now ()\*(C'\fR and \f(CW\*(C`ev_time ()\*(C'\fR when handling
+lots of events in one iteration.
+.PP
+The relative timeouts are calculated relative to the \f(CW\*(C`ev_now ()\*(C'\fR
+time. This is usually the right thing as this timestamp refers to the time
+of the event triggering whatever timeout you are modifying/starting. If
+you suspect event processing to be delayed and you \fIneed\fR to base the
+timeout on the current time, use something like the following to adjust
+for it:
+.PP
+.Vb 1
+\&   ev_timer_set (&timer, after + (ev_time () \- ev_now ()), 0.);
+.Ve
+.PP
+If the event loop is suspended for a long time, you can also force an
+update of the time returned by \f(CW\*(C`ev_now ()\*(C'\fR by calling \f(CW\*(C`ev_now_update
+()\*(C'\fR, although that will push the event time of all outstanding events
+further into the future.
+.PP
+\fIThe special problem of unsynchronised clocks\fR
+.IX Subsection "The special problem of unsynchronised clocks"
+.PP
+Modern systems have a variety of clocks \- libev itself uses the normal
+\&\*(L"wall clock\*(R" clock and, if available, the monotonic clock (to avoid time
+jumps).
+.PP
+Neither of these clocks is synchronised with each other or any other clock
+on the system, so \f(CW\*(C`ev_time ()\*(C'\fR might return a considerably different time
+than \f(CW\*(C`gettimeofday ()\*(C'\fR or \f(CW\*(C`time ()\*(C'\fR. On a GNU/Linux system, for example,
+a call to \f(CW\*(C`gettimeofday\*(C'\fR might return a second count that is one higher
+than a directly following call to \f(CW\*(C`time\*(C'\fR.
+.PP
+The moral of this is to only compare libev-related timestamps with
+\&\f(CW\*(C`ev_time ()\*(C'\fR and \f(CW\*(C`ev_now ()\*(C'\fR, at least if you want better precision than
+a second or so.
+.PP
+One more problem arises due to this lack of synchronisation: if libev uses
+the system monotonic clock and you compare timestamps from \f(CW\*(C`ev_time\*(C'\fR
+or \f(CW\*(C`ev_now\*(C'\fR from when you started your timer and when your callback is
+invoked, you will find that sometimes the callback is a bit \*(L"early\*(R".
+.PP
+This is because \f(CW\*(C`ev_timer\*(C'\fRs work in real time, not wall clock time, so
+libev makes sure your callback is not invoked before the delay happened,
+\&\fImeasured according to the real time\fR, not the system clock.
+.PP
+If your timeouts are based on a physical timescale (e.g. \*(L"time out this
+connection after 100 seconds\*(R") then this shouldn't bother you as it is
+exactly the right behaviour.
+.PP
+If you want to compare wall clock/system timestamps to your timers, then
+you need to use \f(CW\*(C`ev_periodic\*(C'\fRs, as these are based on the wall clock
+time, where your comparisons will always generate correct results.
+.PP
+\fIThe special problems of suspended animation\fR
+.IX Subsection "The special problems of suspended animation"
+.PP
+When you leave the server world it is quite customary to hit machines that
+can suspend/hibernate \- what happens to the clocks during such a suspend?
+.PP
+Some quick tests made with a Linux 2.6.28 indicate that a suspend freezes
+all processes, while the clocks (\f(CW\*(C`times\*(C'\fR, \f(CW\*(C`CLOCK_MONOTONIC\*(C'\fR) continue
+to run until the system is suspended, but they will not advance while the
+system is suspended. That means, on resume, it will be as if the program
+was frozen for a few seconds, but the suspend time will not be counted
+towards \f(CW\*(C`ev_timer\*(C'\fR when a monotonic clock source is used. The real time
+clock advanced as expected, but if it is used as sole clocksource, then a
+long suspend would be detected as a time jump by libev, and timers would
+be adjusted accordingly.
+.PP
+I would not be surprised to see different behaviour in different between
+operating systems, \s-1OS\s0 versions or even different hardware.
+.PP
+The other form of suspend (job control, or sending a \s-1SIGSTOP\s0) will see a
+time jump in the monotonic clocks and the realtime clock. If the program
+is suspended for a very long time, and monotonic clock sources are in use,
+then you can expect \f(CW\*(C`ev_timer\*(C'\fRs to expire as the full suspension time
+will be counted towards the timers. When no monotonic clock source is in
+use, then libev will again assume a timejump and adjust accordingly.
+.PP
+It might be beneficial for this latter case to call \f(CW\*(C`ev_suspend\*(C'\fR
+and \f(CW\*(C`ev_resume\*(C'\fR in code that handles \f(CW\*(C`SIGTSTP\*(C'\fR, to at least get
+deterministic behaviour in this case (you can do nothing against
+\&\f(CW\*(C`SIGSTOP\*(C'\fR).
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)" 4
+.IX Item "ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)"
+.PD 0
+.IP "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)" 4
+.IX Item "ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)"
+.PD
+Configure the timer to trigger after \f(CW\*(C`after\*(C'\fR seconds. If \f(CW\*(C`repeat\*(C'\fR
+is \f(CW0.\fR, then it will automatically be stopped once the timeout is
+reached. If it is positive, then the timer will automatically be
+configured to trigger again \f(CW\*(C`repeat\*(C'\fR seconds later, again, and again,
+until stopped manually.
+.Sp
+The timer itself will do a best-effort at avoiding drift, that is, if
+you configure a timer to trigger every 10 seconds, then it will normally
+trigger at exactly 10 second intervals. If, however, your program cannot
+keep up with the timer (because it takes longer than those 10 seconds to
+do stuff) the timer will not fire more than once per event loop iteration.
+.IP "ev_timer_again (loop, ev_timer *)" 4
+.IX Item "ev_timer_again (loop, ev_timer *)"
+This will act as if the timer timed out, and restarts it again if it is
+repeating. It basically works like calling \f(CW\*(C`ev_timer_stop\*(C'\fR, updating the
+timeout to the \f(CW\*(C`repeat\*(C'\fR value and calling \f(CW\*(C`ev_timer_start\*(C'\fR.
+.Sp
+The exact semantics are as in the following rules, all of which will be
+applied to the watcher:
+.RS 4
+.IP "If the timer is pending, the pending status is always cleared." 4
+.IX Item "If the timer is pending, the pending status is always cleared."
+.PD 0
+.IP "If the timer is started but non-repeating, stop it (as if it timed out, without invoking it)." 4
+.IX Item "If the timer is started but non-repeating, stop it (as if it timed out, without invoking it)."
+.ie n .IP "If the timer is repeating, make the ""repeat"" value the new timeout and start the timer, if necessary." 4
+.el .IP "If the timer is repeating, make the \f(CWrepeat\fR value the new timeout and start the timer, if necessary." 4
+.IX Item "If the timer is repeating, make the repeat value the new timeout and start the timer, if necessary."
+.RE
+.RS 4
+.PD
+.Sp
+This sounds a bit complicated, see \*(L"Be smart about timeouts\*(R", above, for a
+usage example.
+.RE
+.IP "ev_tstamp ev_timer_remaining (loop, ev_timer *)" 4
+.IX Item "ev_tstamp ev_timer_remaining (loop, ev_timer *)"
+Returns the remaining time until a timer fires. If the timer is active,
+then this time is relative to the current event loop time, otherwise it's
+the timeout value currently configured.
+.Sp
+That is, after an \f(CW\*(C`ev_timer_set (w, 5, 7)\*(C'\fR, \f(CW\*(C`ev_timer_remaining\*(C'\fR returns
+\&\f(CW5\fR. When the timer is started and one second passes, \f(CW\*(C`ev_timer_remaining\*(C'\fR
+will return \f(CW4\fR. When the timer expires and is restarted, it will return
+roughly \f(CW7\fR (likely slightly less as callback invocation takes some time,
+too), and so on.
+.IP "ev_tstamp repeat [read\-write]" 4
+.IX Item "ev_tstamp repeat [read-write]"
+The current \f(CW\*(C`repeat\*(C'\fR value. Will be used each time the watcher times out
+or \f(CW\*(C`ev_timer_again\*(C'\fR is called, and determines the next timeout (if any),
+which is also when any modifications are taken into account.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Create a timer that fires after 60 seconds.
+.PP
+.Vb 5
+\&   static void
+\&   one_minute_cb (struct ev_loop *loop, ev_timer *w, int revents)
+\&   {
+\&     .. one minute over, w is actually stopped right here
+\&   }
+\&
+\&   ev_timer mytimer;
+\&   ev_timer_init (&mytimer, one_minute_cb, 60., 0.);
+\&   ev_timer_start (loop, &mytimer);
+.Ve
+.PP
+Example: Create a timeout timer that times out after 10 seconds of
+inactivity.
+.PP
+.Vb 5
+\&   static void
+\&   timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
+\&   {
+\&     .. ten seconds without any activity
+\&   }
+\&
+\&   ev_timer mytimer;
+\&   ev_timer_init (&mytimer, timeout_cb, 0., 10.); /* note, only repeat used */
+\&   ev_timer_again (&mytimer); /* start timer */
+\&   ev_run (loop, 0);
+\&
+\&   // and in some piece of code that gets executed on any "activity":
+\&   // reset the timeout to start ticking again at 10 seconds
+\&   ev_timer_again (&mytimer);
+.Ve
+.ie n .SS """ev_periodic"" \- to cron or not to cron?"
+.el .SS "\f(CWev_periodic\fP \- to cron or not to cron?"
+.IX Subsection "ev_periodic - to cron or not to cron?"
+Periodic watchers are also timers of a kind, but they are very versatile
+(and unfortunately a bit complex).
+.PP
+Unlike \f(CW\*(C`ev_timer\*(C'\fR, periodic watchers are not based on real time (or
+relative time, the physical time that passes) but on wall clock time
+(absolute time, the thing you can read on your calender or clock). The
+difference is that wall clock time can run faster or slower than real
+time, and time jumps are not uncommon (e.g. when you adjust your
+wrist-watch).
+.PP
+You can tell a periodic watcher to trigger after some specific point
+in time: for example, if you tell a periodic watcher to trigger \*(L"in 10
+seconds\*(R" (by specifying e.g. \f(CW\*(C`ev_now () + 10.\*(C'\fR, that is, an absolute time
+not a delay) and then reset your system clock to January of the previous
+year, then it will take a year or more to trigger the event (unlike an
+\&\f(CW\*(C`ev_timer\*(C'\fR, which would still trigger roughly 10 seconds after starting
+it, as it uses a relative timeout).
+.PP
+\&\f(CW\*(C`ev_periodic\*(C'\fR watchers can also be used to implement vastly more complex
+timers, such as triggering an event on each \*(L"midnight, local time\*(R", or
+other complicated rules. This cannot be done with \f(CW\*(C`ev_timer\*(C'\fR watchers, as
+those cannot react to time jumps.
+.PP
+As with timers, the callback is guaranteed to be invoked only when the
+point in time where it is supposed to trigger has passed. If multiple
+timers become ready during the same loop iteration then the ones with
+earlier time-out values are invoked before ones with later time-out values
+(but this is no longer true when a callback calls \f(CW\*(C`ev_run\*(C'\fR recursively).
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)" 4
+.IX Item "ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)"
+.PD 0
+.IP "ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)" 4
+.IX Item "ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)"
+.PD
+Lots of arguments, let's sort it out... There are basically three modes of
+operation, and we will explain them from simplest to most complex:
+.RS 4
+.IP "\(bu" 4
+absolute timer (offset = absolute time, interval = 0, reschedule_cb = 0)
+.Sp
+In this configuration the watcher triggers an event after the wall clock
+time \f(CW\*(C`offset\*(C'\fR has passed. It will not repeat and will not adjust when a
+time jump occurs, that is, if it is to be run at January 1st 2011 then it
+will be stopped and invoked when the system clock reaches or surpasses
+this point in time.
+.IP "\(bu" 4
+repeating interval timer (offset = offset within interval, interval > 0, reschedule_cb = 0)
+.Sp
+In this mode the watcher will always be scheduled to time out at the next
+\&\f(CW\*(C`offset + N * interval\*(C'\fR time (for some integer N, which can also be
+negative) and then repeat, regardless of any time jumps. The \f(CW\*(C`offset\*(C'\fR
+argument is merely an offset into the \f(CW\*(C`interval\*(C'\fR periods.
+.Sp
+This can be used to create timers that do not drift with respect to the
+system clock, for example, here is an \f(CW\*(C`ev_periodic\*(C'\fR that triggers each
+hour, on the hour (with respect to \s-1UTC\s0):
+.Sp
+.Vb 1
+\&   ev_periodic_set (&periodic, 0., 3600., 0);
+.Ve
+.Sp
+This doesn't mean there will always be 3600 seconds in between triggers,
+but only that the callback will be called when the system time shows a
+full hour (\s-1UTC\s0), or more correctly, when the system time is evenly divisible
+by 3600.
+.Sp
+Another way to think about it (for the mathematically inclined) is that
+\&\f(CW\*(C`ev_periodic\*(C'\fR will try to run the callback in this mode at the next possible
+time where \f(CW\*(C`time = offset (mod interval)\*(C'\fR, regardless of any time jumps.
+.Sp
+The \f(CW\*(C`interval\*(C'\fR \fI\s-1MUST\s0\fR be positive, and for numerical stability, the
+interval value should be higher than \f(CW\*(C`1/8192\*(C'\fR (which is around 100
+microseconds) and \f(CW\*(C`offset\*(C'\fR should be higher than \f(CW0\fR and should have
+at most a similar magnitude as the current time (say, within a factor of
+ten). Typical values for offset are, in fact, \f(CW0\fR or something between
+\&\f(CW0\fR and \f(CW\*(C`interval\*(C'\fR, which is also the recommended range.
+.Sp
+Note also that there is an upper limit to how often a timer can fire (\s-1CPU\s0
+speed for example), so if \f(CW\*(C`interval\*(C'\fR is very small then timing stability
+will of course deteriorate. Libev itself tries to be exact to be about one
+millisecond (if the \s-1OS\s0 supports it and the machine is fast enough).
+.IP "\(bu" 4
+manual reschedule mode (offset ignored, interval ignored, reschedule_cb = callback)
+.Sp
+In this mode the values for \f(CW\*(C`interval\*(C'\fR and \f(CW\*(C`offset\*(C'\fR are both being
+ignored. Instead, each time the periodic watcher gets scheduled, the
+reschedule callback will be called with the watcher as first, and the
+current time as second argument.
+.Sp
+\&\s-1NOTE: \s0\fIThis callback \s-1MUST NOT\s0 stop or destroy any periodic watcher, ever,
+or make \s-1ANY\s0 other event loop modifications whatsoever, unless explicitly
+allowed by documentation here\fR.
+.Sp
+If you need to stop it, return \f(CW\*(C`now + 1e30\*(C'\fR (or so, fudge fudge) and stop
+it afterwards (e.g. by starting an \f(CW\*(C`ev_prepare\*(C'\fR watcher, which is the
+only event loop modification you are allowed to do).
+.Sp
+The callback prototype is \f(CW\*(C`ev_tstamp (*reschedule_cb)(ev_periodic
+*w, ev_tstamp now)\*(C'\fR, e.g.:
+.Sp
+.Vb 5
+\&   static ev_tstamp
+\&   my_rescheduler (ev_periodic *w, ev_tstamp now)
+\&   {
+\&     return now + 60.;
+\&   }
+.Ve
+.Sp
+It must return the next time to trigger, based on the passed time value
+(that is, the lowest time value larger than to the second argument). It
+will usually be called just before the callback will be triggered, but
+might be called at other times, too.
+.Sp
+\&\s-1NOTE: \s0\fIThis callback must always return a time that is higher than or
+equal to the passed \f(CI\*(C`now\*(C'\fI value\fR.
+.Sp
+This can be used to create very complex timers, such as a timer that
+triggers on \*(L"next midnight, local time\*(R". To do this, you would calculate the
+next midnight after \f(CW\*(C`now\*(C'\fR and return the timestamp value for this. How
+you do this is, again, up to you (but it is not trivial, which is the main
+reason I omitted it as an example).
+.RE
+.RS 4
+.RE
+.IP "ev_periodic_again (loop, ev_periodic *)" 4
+.IX Item "ev_periodic_again (loop, ev_periodic *)"
+Simply stops and restarts the periodic watcher again. This is only useful
+when you changed some parameters or the reschedule callback would return
+a different time than the last time it was called (e.g. in a crond like
+program when the crontabs have changed).
+.IP "ev_tstamp ev_periodic_at (ev_periodic *)" 4
+.IX Item "ev_tstamp ev_periodic_at (ev_periodic *)"
+When active, returns the absolute time that the watcher is supposed
+to trigger next. This is not the same as the \f(CW\*(C`offset\*(C'\fR argument to
+\&\f(CW\*(C`ev_periodic_set\*(C'\fR, but indeed works even in interval and manual
+rescheduling modes.
+.IP "ev_tstamp offset [read\-write]" 4
+.IX Item "ev_tstamp offset [read-write]"
+When repeating, this contains the offset value, otherwise this is the
+absolute point in time (the \f(CW\*(C`offset\*(C'\fR value passed to \f(CW\*(C`ev_periodic_set\*(C'\fR,
+although libev might modify this value for better numerical stability).
+.Sp
+Can be modified any time, but changes only take effect when the periodic
+timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being called.
+.IP "ev_tstamp interval [read\-write]" 4
+.IX Item "ev_tstamp interval [read-write]"
+The current interval value. Can be modified any time, but changes only
+take effect when the periodic timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being
+called.
+.IP "ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read\-write]" 4
+.IX Item "ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read-write]"
+The current reschedule callback, or \f(CW0\fR, if this functionality is
+switched off. Can be changed any time, but changes only take effect when
+the periodic timer fires or \f(CW\*(C`ev_periodic_again\*(C'\fR is being called.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Call a callback every hour, or, more precisely, whenever the
+system time is divisible by 3600. The callback invocation times have
+potentially a lot of jitter, but good long-term stability.
+.PP
+.Vb 5
+\&   static void
+\&   clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
+\&   {
+\&     ... its now a full hour (UTC, or TAI or whatever your clock follows)
+\&   }
+\&
+\&   ev_periodic hourly_tick;
+\&   ev_periodic_init (&hourly_tick, clock_cb, 0., 3600., 0);
+\&   ev_periodic_start (loop, &hourly_tick);
+.Ve
+.PP
+Example: The same as above, but use a reschedule callback to do it:
+.PP
+.Vb 1
+\&   #include <math.h>
+\&
+\&   static ev_tstamp
+\&   my_scheduler_cb (ev_periodic *w, ev_tstamp now)
+\&   {
+\&     return now + (3600. \- fmod (now, 3600.));
+\&   }
+\&
+\&   ev_periodic_init (&hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
+.Ve
+.PP
+Example: Call a callback every hour, starting now:
+.PP
+.Vb 4
+\&   ev_periodic hourly_tick;
+\&   ev_periodic_init (&hourly_tick, clock_cb,
+\&                     fmod (ev_now (loop), 3600.), 3600., 0);
+\&   ev_periodic_start (loop, &hourly_tick);
+.Ve
+.ie n .SS """ev_signal"" \- signal me when a signal gets signalled!"
+.el .SS "\f(CWev_signal\fP \- signal me when a signal gets signalled!"
+.IX Subsection "ev_signal - signal me when a signal gets signalled!"
+Signal watchers will trigger an event when the process receives a specific
+signal one or more times. Even though signals are very asynchronous, libev
+will try its best to deliver signals synchronously, i.e. as part of the
+normal event processing, like any other event.
+.PP
+If you want signals to be delivered truly asynchronously, just use
+\&\f(CW\*(C`sigaction\*(C'\fR as you would do without libev and forget about sharing
+the signal. You can even use \f(CW\*(C`ev_async\*(C'\fR from a signal handler to
+synchronously wake up an event loop.
+.PP
+You can configure as many watchers as you like for the same signal, but
+only within the same loop, i.e. you can watch for \f(CW\*(C`SIGINT\*(C'\fR in your
+default loop and for \f(CW\*(C`SIGIO\*(C'\fR in another loop, but you cannot watch for
+\&\f(CW\*(C`SIGINT\*(C'\fR in both the default loop and another loop at the same time. At
+the moment, \f(CW\*(C`SIGCHLD\*(C'\fR is permanently tied to the default loop.
+.PP
+Only after the first watcher for a signal is started will libev actually
+register something with the kernel. It thus coexists with your own signal
+handlers as long as you don't register any with libev for the same signal.
+.PP
+If possible and supported, libev will install its handlers with
+\&\f(CW\*(C`SA_RESTART\*(C'\fR (or equivalent) behaviour enabled, so system calls should
+not be unduly interrupted. If you have a problem with system calls getting
+interrupted by signals you can block all signals in an \f(CW\*(C`ev_check\*(C'\fR watcher
+and unblock them in an \f(CW\*(C`ev_prepare\*(C'\fR watcher.
+.PP
+\fIThe special problem of inheritance over fork/execve/pthread_create\fR
+.IX Subsection "The special problem of inheritance over fork/execve/pthread_create"
+.PP
+Both the signal mask (\f(CW\*(C`sigprocmask\*(C'\fR) and the signal disposition
+(\f(CW\*(C`sigaction\*(C'\fR) are unspecified after starting a signal watcher (and after
+stopping it again), that is, libev might or might not block the signal,
+and might or might not set or restore the installed signal handler (but
+see \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR).
+.PP
+While this does not matter for the signal disposition (libev never
+sets signals to \f(CW\*(C`SIG_IGN\*(C'\fR, so handlers will be reset to \f(CW\*(C`SIG_DFL\*(C'\fR on
+\&\f(CW\*(C`execve\*(C'\fR), this matters for the signal mask: many programs do not expect
+certain signals to be blocked.
+.PP
+This means that before calling \f(CW\*(C`exec\*(C'\fR (from the child) you should reset
+the signal mask to whatever \*(L"default\*(R" you expect (all clear is a good
+choice usually).
+.PP
+The simplest way to ensure that the signal mask is reset in the child is
+to install a fork handler with \f(CW\*(C`pthread_atfork\*(C'\fR that resets it. That will
+catch fork calls done by libraries (such as the libc) as well.
+.PP
+In current versions of libev, the signal will not be blocked indefinitely
+unless you use the \f(CW\*(C`signalfd\*(C'\fR \s-1API \s0(\f(CW\*(C`EV_SIGNALFD\*(C'\fR). While this reduces
+the window of opportunity for problems, it will not go away, as libev
+\&\fIhas\fR to modify the signal mask, at least temporarily.
+.PP
+So I can't stress this enough: \fIIf you do not reset your signal mask when
+you expect it to be empty, you have a race condition in your code\fR. This
+is not a libev-specific thing, this is true for most event libraries.
+.PP
+\fIThe special problem of threads signal handling\fR
+.IX Subsection "The special problem of threads signal handling"
+.PP
+\&\s-1POSIX\s0 threads has problematic signal handling semantics, specifically,
+a lot of functionality (sigfd, sigwait etc.) only really works if all
+threads in a process block signals, which is hard to achieve.
+.PP
+When you want to use sigwait (or mix libev signal handling with your own
+for the same signals), you can tackle this problem by globally blocking
+all signals before creating any threads (or creating them with a fully set
+sigprocmask) and also specifying the \f(CW\*(C`EVFLAG_NOSIGMASK\*(C'\fR when creating
+loops. Then designate one thread as \*(L"signal receiver thread\*(R" which handles
+these signals. You can pass on any signals that libev might be interested
+in by calling \f(CW\*(C`ev_feed_signal\*(C'\fR.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_signal_init (ev_signal *, callback, int signum)" 4
+.IX Item "ev_signal_init (ev_signal *, callback, int signum)"
+.PD 0
+.IP "ev_signal_set (ev_signal *, int signum)" 4
+.IX Item "ev_signal_set (ev_signal *, int signum)"
+.PD
+Configures the watcher to trigger on the given signal number (usually one
+of the \f(CW\*(C`SIGxxx\*(C'\fR constants).
+.IP "int signum [read\-only]" 4
+.IX Item "int signum [read-only]"
+The signal the watcher watches out for.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Try to exit cleanly on \s-1SIGINT.\s0
+.PP
+.Vb 5
+\&   static void
+\&   sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
+\&   {
+\&     ev_break (loop, EVBREAK_ALL);
+\&   }
+\&
+\&   ev_signal signal_watcher;
+\&   ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
+\&   ev_signal_start (loop, &signal_watcher);
+.Ve
+.ie n .SS """ev_child"" \- watch out for process status changes"
+.el .SS "\f(CWev_child\fP \- watch out for process status changes"
+.IX Subsection "ev_child - watch out for process status changes"
+Child watchers trigger when your process receives a \s-1SIGCHLD\s0 in response to
+some child status changes (most typically when a child of yours dies or
+exits). It is permissible to install a child watcher \fIafter\fR the child
+has been forked (which implies it might have already exited), as long
+as the event loop isn't entered (or is continued from a watcher), i.e.,
+forking and then immediately registering a watcher for the child is fine,
+but forking and registering a watcher a few event loop iterations later or
+in the next callback invocation is not.
+.PP
+Only the default event loop is capable of handling signals, and therefore
+you can only register child watchers in the default event loop.
+.PP
+Due to some design glitches inside libev, child watchers will always be
+handled at maximum priority (their priority is set to \f(CW\*(C`EV_MAXPRI\*(C'\fR by
+libev)
+.PP
+\fIProcess Interaction\fR
+.IX Subsection "Process Interaction"
+.PP
+Libev grabs \f(CW\*(C`SIGCHLD\*(C'\fR as soon as the default event loop is
+initialised. This is necessary to guarantee proper behaviour even if the
+first child watcher is started after the child exits. The occurrence
+of \f(CW\*(C`SIGCHLD\*(C'\fR is recorded asynchronously, but child reaping is done
+synchronously as part of the event loop processing. Libev always reaps all
+children, even ones not watched.
+.PP
+\fIOverriding the Built-In Processing\fR
+.IX Subsection "Overriding the Built-In Processing"
+.PP
+Libev offers no special support for overriding the built-in child
+processing, but if your application collides with libev's default child
+handler, you can override it easily by installing your own handler for
+\&\f(CW\*(C`SIGCHLD\*(C'\fR after initialising the default loop, and making sure the
+default loop never gets destroyed. You are encouraged, however, to use an
+event-based approach to child reaping and thus use libev's support for
+that, so other libev users can use \f(CW\*(C`ev_child\*(C'\fR watchers freely.
+.PP
+\fIStopping the Child Watcher\fR
+.IX Subsection "Stopping the Child Watcher"
+.PP
+Currently, the child watcher never gets stopped, even when the
+child terminates, so normally one needs to stop the watcher in the
+callback. Future versions of libev might stop the watcher automatically
+when a child exit is detected (calling \f(CW\*(C`ev_child_stop\*(C'\fR twice is not a
+problem).
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_child_init (ev_child *, callback, int pid, int trace)" 4
+.IX Item "ev_child_init (ev_child *, callback, int pid, int trace)"
+.PD 0
+.IP "ev_child_set (ev_child *, int pid, int trace)" 4
+.IX Item "ev_child_set (ev_child *, int pid, int trace)"
+.PD
+Configures the watcher to wait for status changes of process \f(CW\*(C`pid\*(C'\fR (or
+\&\fIany\fR process if \f(CW\*(C`pid\*(C'\fR is specified as \f(CW0\fR). The callback can look
+at the \f(CW\*(C`rstatus\*(C'\fR member of the \f(CW\*(C`ev_child\*(C'\fR watcher structure to see
+the status word (use the macros from \f(CW\*(C`sys/wait.h\*(C'\fR and see your systems
+\&\f(CW\*(C`waitpid\*(C'\fR documentation). The \f(CW\*(C`rpid\*(C'\fR member contains the pid of the
+process causing the status change. \f(CW\*(C`trace\*(C'\fR must be either \f(CW0\fR (only
+activate the watcher when the process terminates) or \f(CW1\fR (additionally
+activate the watcher when the process is stopped or continued).
+.IP "int pid [read\-only]" 4
+.IX Item "int pid [read-only]"
+The process id this watcher watches out for, or \f(CW0\fR, meaning any process id.
+.IP "int rpid [read\-write]" 4
+.IX Item "int rpid [read-write]"
+The process id that detected a status change.
+.IP "int rstatus [read\-write]" 4
+.IX Item "int rstatus [read-write]"
+The process exit/trace status caused by \f(CW\*(C`rpid\*(C'\fR (see your systems
+\&\f(CW\*(C`waitpid\*(C'\fR and \f(CW\*(C`sys/wait.h\*(C'\fR documentation for details).
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: \f(CW\*(C`fork()\*(C'\fR a new process and install a child handler to wait for
+its completion.
+.PP
+.Vb 1
+\&   ev_child cw;
+\&
+\&   static void
+\&   child_cb (EV_P_ ev_child *w, int revents)
+\&   {
+\&     ev_child_stop (EV_A_ w);
+\&     printf ("process %d exited with status %x\en", w\->rpid, w\->rstatus);
+\&   }
+\&
+\&   pid_t pid = fork ();
+\&
+\&   if (pid < 0)
+\&     // error
+\&   else if (pid == 0)
+\&     {
+\&       // the forked child executes here
+\&       exit (1);
+\&     }
+\&   else
+\&     {
+\&       ev_child_init (&cw, child_cb, pid, 0);
+\&       ev_child_start (EV_DEFAULT_ &cw);
+\&     }
+.Ve
+.ie n .SS """ev_stat"" \- did the file attributes just change?"
+.el .SS "\f(CWev_stat\fP \- did the file attributes just change?"
+.IX Subsection "ev_stat - did the file attributes just change?"
+This watches a file system path for attribute changes. That is, it calls
+\&\f(CW\*(C`stat\*(C'\fR on that path in regular intervals (or when the \s-1OS\s0 says it changed)
+and sees if it changed compared to the last time, invoking the callback
+if it did. Starting the watcher \f(CW\*(C`stat\*(C'\fR's the file, so only changes that
+happen after the watcher has been started will be reported.
+.PP
+The path does not need to exist: changing from \*(L"path exists\*(R" to \*(L"path does
+not exist\*(R" is a status change like any other. The condition \*(L"path does not
+exist\*(R" (or more correctly \*(L"path cannot be stat'ed\*(R") is signified by the
+\&\f(CW\*(C`st_nlink\*(C'\fR field being zero (which is otherwise always forced to be at
+least one) and all the other fields of the stat buffer having unspecified
+contents.
+.PP
+The path \fImust not\fR end in a slash or contain special components such as
+\&\f(CW\*(C`.\*(C'\fR or \f(CW\*(C`..\*(C'\fR. The path \fIshould\fR be absolute: If it is relative and
+your working directory changes, then the behaviour is undefined.
+.PP
+Since there is no portable change notification interface available, the
+portable implementation simply calls \f(CWstat(2)\fR regularly on the path
+to see if it changed somehow. You can specify a recommended polling
+interval for this case. If you specify a polling interval of \f(CW0\fR (highly
+recommended!) then a \fIsuitable, unspecified default\fR value will be used
+(which you can expect to be around five seconds, although this might
+change dynamically). Libev will also impose a minimum interval which is
+currently around \f(CW0.1\fR, but that's usually overkill.
+.PP
+This watcher type is not meant for massive numbers of stat watchers,
+as even with OS-supported change notifications, this can be
+resource-intensive.
+.PP
+At the time of this writing, the only OS-specific interface implemented
+is the Linux inotify interface (implementing kqueue support is left as an
+exercise for the reader. Note, however, that the author sees no way of
+implementing \f(CW\*(C`ev_stat\*(C'\fR semantics with kqueue, except as a hint).
+.PP
+\fI\s-1ABI\s0 Issues (Largefile Support)\fR
+.IX Subsection "ABI Issues (Largefile Support)"
+.PP
+Libev by default (unless the user overrides this) uses the default
+compilation environment, which means that on systems with large file
+support disabled by default, you get the 32 bit version of the stat
+structure. When using the library from programs that change the \s-1ABI\s0 to
+use 64 bit file offsets the programs will fail. In that case you have to
+compile libev with the same flags to get binary compatibility. This is
+obviously the case with any flags that change the \s-1ABI,\s0 but the problem is
+most noticeably displayed with ev_stat and large file support.
+.PP
+The solution for this is to lobby your distribution maker to make large
+file interfaces available by default (as e.g. FreeBSD does) and not
+optional. Libev cannot simply switch on large file support because it has
+to exchange stat structures with application programs compiled using the
+default compilation environment.
+.PP
+\fIInotify and Kqueue\fR
+.IX Subsection "Inotify and Kqueue"
+.PP
+When \f(CW\*(C`inotify (7)\*(C'\fR support has been compiled into libev and present at
+runtime, it will be used to speed up change detection where possible. The
+inotify descriptor will be created lazily when the first \f(CW\*(C`ev_stat\*(C'\fR
+watcher is being started.
+.PP
+Inotify presence does not change the semantics of \f(CW\*(C`ev_stat\*(C'\fR watchers
+except that changes might be detected earlier, and in some cases, to avoid
+making regular \f(CW\*(C`stat\*(C'\fR calls. Even in the presence of inotify support
+there are many cases where libev has to resort to regular \f(CW\*(C`stat\*(C'\fR polling,
+but as long as kernel 2.6.25 or newer is used (2.6.24 and older have too
+many bugs), the path exists (i.e. stat succeeds), and the path resides on
+a local filesystem (libev currently assumes only ext2/3, jfs, reiserfs and
+xfs are fully working) libev usually gets away without polling.
+.PP
+There is no support for kqueue, as apparently it cannot be used to
+implement this functionality, due to the requirement of having a file
+descriptor open on the object at all times, and detecting renames, unlinks
+etc. is difficult.
+.PP
+\fI\f(CI\*(C`stat ()\*(C'\fI is a synchronous operation\fR
+.IX Subsection "stat () is a synchronous operation"
+.PP
+Libev doesn't normally do any kind of I/O itself, and so is not blocking
+the process. The exception are \f(CW\*(C`ev_stat\*(C'\fR watchers \- those call \f(CW\*(C`stat
+()\*(C'\fR, which is a synchronous operation.
+.PP
+For local paths, this usually doesn't matter: unless the system is very
+busy or the intervals between stat's are large, a stat call will be fast,
+as the path data is usually in memory already (except when starting the
+watcher).
+.PP
+For networked file systems, calling \f(CW\*(C`stat ()\*(C'\fR can block an indefinite
+time due to network issues, and even under good conditions, a stat call
+often takes multiple milliseconds.
+.PP
+Therefore, it is best to avoid using \f(CW\*(C`ev_stat\*(C'\fR watchers on networked
+paths, although this is fully supported by libev.
+.PP
+\fIThe special problem of stat time resolution\fR
+.IX Subsection "The special problem of stat time resolution"
+.PP
+The \f(CW\*(C`stat ()\*(C'\fR system call only supports full-second resolution portably,
+and even on systems where the resolution is higher, most file systems
+still only support whole seconds.
+.PP
+That means that, if the time is the only thing that changes, you can
+easily miss updates: on the first update, \f(CW\*(C`ev_stat\*(C'\fR detects a change and
+calls your callback, which does something. When there is another update
+within the same second, \f(CW\*(C`ev_stat\*(C'\fR will be unable to detect unless the
+stat data does change in other ways (e.g. file size).
+.PP
+The solution to this is to delay acting on a change for slightly more
+than a second (or till slightly after the next full second boundary), using
+a roughly one-second-delay \f(CW\*(C`ev_timer\*(C'\fR (e.g. \f(CW\*(C`ev_timer_set (w, 0., 1.02);
+ev_timer_again (loop, w)\*(C'\fR).
+.PP
+The \f(CW.02\fR offset is added to work around small timing inconsistencies
+of some operating systems (where the second counter of the current time
+might be be delayed. One such system is the Linux kernel, where a call to
+\&\f(CW\*(C`gettimeofday\*(C'\fR might return a timestamp with a full second later than
+a subsequent \f(CW\*(C`time\*(C'\fR call \- if the equivalent of \f(CW\*(C`time ()\*(C'\fR is used to
+update file times then there will be a small window where the kernel uses
+the previous second to update file times but libev might already execute
+the timer callback).
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)" 4
+.IX Item "ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)"
+.PD 0
+.IP "ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)" 4
+.IX Item "ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)"
+.PD
+Configures the watcher to wait for status changes of the given
+\&\f(CW\*(C`path\*(C'\fR. The \f(CW\*(C`interval\*(C'\fR is a hint on how quickly a change is expected to
+be detected and should normally be specified as \f(CW0\fR to let libev choose
+a suitable value. The memory pointed to by \f(CW\*(C`path\*(C'\fR must point to the same
+path for as long as the watcher is active.
+.Sp
+The callback will receive an \f(CW\*(C`EV_STAT\*(C'\fR event when a change was detected,
+relative to the attributes at the time the watcher was started (or the
+last change was detected).
+.IP "ev_stat_stat (loop, ev_stat *)" 4
+.IX Item "ev_stat_stat (loop, ev_stat *)"
+Updates the stat buffer immediately with new values. If you change the
+watched path in your callback, you could call this function to avoid
+detecting this change (while introducing a race condition if you are not
+the only one changing the path). Can also be useful simply to find out the
+new values.
+.IP "ev_statdata attr [read\-only]" 4
+.IX Item "ev_statdata attr [read-only]"
+The most-recently detected attributes of the file. Although the type is
+\&\f(CW\*(C`ev_statdata\*(C'\fR, this is usually the (or one of the) \f(CW\*(C`struct stat\*(C'\fR types
+suitable for your system, but you can only rely on the POSIX-standardised
+members to be present. If the \f(CW\*(C`st_nlink\*(C'\fR member is \f(CW0\fR, then there was
+some error while \f(CW\*(C`stat\*(C'\fRing the file.
+.IP "ev_statdata prev [read\-only]" 4
+.IX Item "ev_statdata prev [read-only]"
+The previous attributes of the file. The callback gets invoked whenever
+\&\f(CW\*(C`prev\*(C'\fR != \f(CW\*(C`attr\*(C'\fR, or, more precisely, one or more of these members
+differ: \f(CW\*(C`st_dev\*(C'\fR, \f(CW\*(C`st_ino\*(C'\fR, \f(CW\*(C`st_mode\*(C'\fR, \f(CW\*(C`st_nlink\*(C'\fR, \f(CW\*(C`st_uid\*(C'\fR,
+\&\f(CW\*(C`st_gid\*(C'\fR, \f(CW\*(C`st_rdev\*(C'\fR, \f(CW\*(C`st_size\*(C'\fR, \f(CW\*(C`st_atime\*(C'\fR, \f(CW\*(C`st_mtime\*(C'\fR, \f(CW\*(C`st_ctime\*(C'\fR.
+.IP "ev_tstamp interval [read\-only]" 4
+.IX Item "ev_tstamp interval [read-only]"
+The specified interval.
+.IP "const char *path [read\-only]" 4
+.IX Item "const char *path [read-only]"
+The file system path that is being watched.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Watch \f(CW\*(C`/etc/passwd\*(C'\fR for attribute changes.
+.PP
+.Vb 10
+\&   static void
+\&   passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
+\&   {
+\&     /* /etc/passwd changed in some way */
+\&     if (w\->attr.st_nlink)
+\&       {
+\&         printf ("passwd current size  %ld\en", (long)w\->attr.st_size);
+\&         printf ("passwd current atime %ld\en", (long)w\->attr.st_mtime);
+\&         printf ("passwd current mtime %ld\en", (long)w\->attr.st_mtime);
+\&       }
+\&     else
+\&       /* you shalt not abuse printf for puts */
+\&       puts ("wow, /etc/passwd is not there, expect problems. "
+\&             "if this is windows, they already arrived\en");
+\&   }
+\&
+\&   ...
+\&   ev_stat passwd;
+\&
+\&   ev_stat_init (&passwd, passwd_cb, "/etc/passwd", 0.);
+\&   ev_stat_start (loop, &passwd);
+.Ve
+.PP
+Example: Like above, but additionally use a one-second delay so we do not
+miss updates (however, frequent updates will delay processing, too, so
+one might do the work both on \f(CW\*(C`ev_stat\*(C'\fR callback invocation \fIand\fR on
+\&\f(CW\*(C`ev_timer\*(C'\fR callback invocation).
+.PP
+.Vb 2
+\&   static ev_stat passwd;
+\&   static ev_timer timer;
+\&
+\&   static void
+\&   timer_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     ev_timer_stop (EV_A_ w);
+\&
+\&     /* now it\*(Aqs one second after the most recent passwd change */
+\&   }
+\&
+\&   static void
+\&   stat_cb (EV_P_ ev_stat *w, int revents)
+\&   {
+\&     /* reset the one\-second timer */
+\&     ev_timer_again (EV_A_ &timer);
+\&   }
+\&
+\&   ...
+\&   ev_stat_init (&passwd, stat_cb, "/etc/passwd", 0.);
+\&   ev_stat_start (loop, &passwd);
+\&   ev_timer_init (&timer, timer_cb, 0., 1.02);
+.Ve
+.ie n .SS """ev_idle"" \- when you've got nothing better to do..."
+.el .SS "\f(CWev_idle\fP \- when you've got nothing better to do..."
+.IX Subsection "ev_idle - when you've got nothing better to do..."
+Idle watchers trigger events when no other events of the same or higher
+priority are pending (prepare, check and other idle watchers do not count
+as receiving \*(L"events\*(R").
+.PP
+That is, as long as your process is busy handling sockets or timeouts
+(or even signals, imagine) of the same or higher priority it will not be
+triggered. But when your process is idle (or only lower-priority watchers
+are pending), the idle watchers are being called once per event loop
+iteration \- until stopped, that is, or your process receives more events
+and becomes busy again with higher priority stuff.
+.PP
+The most noteworthy effect is that as long as any idle watchers are
+active, the process will not block when waiting for new events.
+.PP
+Apart from keeping your process non-blocking (which is a useful
+effect on its own sometimes), idle watchers are a good place to do
+\&\*(L"pseudo-background processing\*(R", or delay processing stuff to after the
+event loop has handled all outstanding events.
+.PP
+\fIAbusing an \f(CI\*(C`ev_idle\*(C'\fI watcher for its side-effect\fR
+.IX Subsection "Abusing an ev_idle watcher for its side-effect"
+.PP
+As long as there is at least one active idle watcher, libev will never
+sleep unnecessarily. Or in other words, it will loop as fast as possible.
+For this to work, the idle watcher doesn't need to be invoked at all \- the
+lowest priority will do.
+.PP
+This mode of operation can be useful together with an \f(CW\*(C`ev_check\*(C'\fR watcher,
+to do something on each event loop iteration \- for example to balance load
+between different connections.
+.PP
+See \*(L"Abusing an ev_check watcher for its side-effect\*(R" for a longer
+example.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_idle_init (ev_idle *, callback)" 4
+.IX Item "ev_idle_init (ev_idle *, callback)"
+Initialises and configures the idle watcher \- it has no parameters of any
+kind. There is a \f(CW\*(C`ev_idle_set\*(C'\fR macro, but using it is utterly pointless,
+believe me.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Dynamically allocate an \f(CW\*(C`ev_idle\*(C'\fR watcher, start it, and in the
+callback, free it. Also, use no error checking, as usual.
+.PP
+.Vb 5
+\&   static void
+\&   idle_cb (struct ev_loop *loop, ev_idle *w, int revents)
+\&   {
+\&     // stop the watcher
+\&     ev_idle_stop (loop, w);
+\&
+\&     // now we can free it
+\&     free (w);
+\&
+\&     // now do something you wanted to do when the program has
+\&     // no longer anything immediate to do.
+\&   }
+\&
+\&   ev_idle *idle_watcher = malloc (sizeof (ev_idle));
+\&   ev_idle_init (idle_watcher, idle_cb);
+\&   ev_idle_start (loop, idle_watcher);
+.Ve
+.ie n .SS """ev_prepare"" and ""ev_check"" \- customise your event loop!"
+.el .SS "\f(CWev_prepare\fP and \f(CWev_check\fP \- customise your event loop!"
+.IX Subsection "ev_prepare and ev_check - customise your event loop!"
+Prepare and check watchers are often (but not always) used in pairs:
+prepare watchers get invoked before the process blocks and check watchers
+afterwards.
+.PP
+You \fImust not\fR call \f(CW\*(C`ev_run\*(C'\fR (or similar functions that enter the
+current event loop) or \f(CW\*(C`ev_loop_fork\*(C'\fR from either \f(CW\*(C`ev_prepare\*(C'\fR or
+\&\f(CW\*(C`ev_check\*(C'\fR watchers. Other loops than the current one are fine,
+however. The rationale behind this is that you do not need to check
+for recursion in those watchers, i.e. the sequence will always be
+\&\f(CW\*(C`ev_prepare\*(C'\fR, blocking, \f(CW\*(C`ev_check\*(C'\fR so if you have one watcher of each
+kind they will always be called in pairs bracketing the blocking call.
+.PP
+Their main purpose is to integrate other event mechanisms into libev and
+their use is somewhat advanced. They could be used, for example, to track
+variable changes, implement your own watchers, integrate net-snmp or a
+coroutine library and lots more. They are also occasionally useful if
+you cache some data and want to flush it before blocking (for example,
+in X programs you might want to do an \f(CW\*(C`XFlush ()\*(C'\fR in an \f(CW\*(C`ev_prepare\*(C'\fR
+watcher).
+.PP
+This is done by examining in each prepare call which file descriptors
+need to be watched by the other library, registering \f(CW\*(C`ev_io\*(C'\fR watchers
+for them and starting an \f(CW\*(C`ev_timer\*(C'\fR watcher for any timeouts (many
+libraries provide exactly this functionality). Then, in the check watcher,
+you check for any events that occurred (by checking the pending status
+of all watchers and stopping them) and call back into the library. The
+I/O and timer callbacks will never actually be called (but must be valid
+nevertheless, because you never know, you know?).
+.PP
+As another example, the Perl Coro module uses these hooks to integrate
+coroutines into libev programs, by yielding to other active coroutines
+during each prepare and only letting the process block if no coroutines
+are ready to run (it's actually more complicated: it only runs coroutines
+with priority higher than or equal to the event loop and one coroutine
+of lower priority, but only once, using idle watchers to keep the event
+loop from blocking if lower-priority coroutines are active, thus mapping
+low-priority coroutines to idle/background tasks).
+.PP
+When used for this purpose, it is recommended to give \f(CW\*(C`ev_check\*(C'\fR watchers
+highest (\f(CW\*(C`EV_MAXPRI\*(C'\fR) priority, to ensure that they are being run before
+any other watchers after the poll (this doesn't matter for \f(CW\*(C`ev_prepare\*(C'\fR
+watchers).
+.PP
+Also, \f(CW\*(C`ev_check\*(C'\fR watchers (and \f(CW\*(C`ev_prepare\*(C'\fR watchers, too) should not
+activate (\*(L"feed\*(R") events into libev. While libev fully supports this, they
+might get executed before other \f(CW\*(C`ev_check\*(C'\fR watchers did their job. As
+\&\f(CW\*(C`ev_check\*(C'\fR watchers are often used to embed other (non-libev) event
+loops those other event loops might be in an unusable state until their
+\&\f(CW\*(C`ev_check\*(C'\fR watcher ran (always remind yourself to coexist peacefully with
+others).
+.PP
+\fIAbusing an \f(CI\*(C`ev_check\*(C'\fI watcher for its side-effect\fR
+.IX Subsection "Abusing an ev_check watcher for its side-effect"
+.PP
+\&\f(CW\*(C`ev_check\*(C'\fR (and less often also \f(CW\*(C`ev_prepare\*(C'\fR) watchers can also be
+useful because they are called once per event loop iteration. For
+example, if you want to handle a large number of connections fairly, you
+normally only do a bit of work for each active connection, and if there
+is more work to do, you wait for the next event loop iteration, so other
+connections have a chance of making progress.
+.PP
+Using an \f(CW\*(C`ev_check\*(C'\fR watcher is almost enough: it will be called on the
+next event loop iteration. However, that isn't as soon as possible \-
+without external events, your \f(CW\*(C`ev_check\*(C'\fR watcher will not be invoked.
+.PP
+This is where \f(CW\*(C`ev_idle\*(C'\fR watchers come in handy \- all you need is a
+single global idle watcher that is active as long as you have one active
+\&\f(CW\*(C`ev_check\*(C'\fR watcher. The \f(CW\*(C`ev_idle\*(C'\fR watcher makes sure the event loop
+will not sleep, and the \f(CW\*(C`ev_check\*(C'\fR watcher makes sure a callback gets
+invoked. Neither watcher alone can do that.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_prepare_init (ev_prepare *, callback)" 4
+.IX Item "ev_prepare_init (ev_prepare *, callback)"
+.PD 0
+.IP "ev_check_init (ev_check *, callback)" 4
+.IX Item "ev_check_init (ev_check *, callback)"
+.PD
+Initialises and configures the prepare or check watcher \- they have no
+parameters of any kind. There are \f(CW\*(C`ev_prepare_set\*(C'\fR and \f(CW\*(C`ev_check_set\*(C'\fR
+macros, but using them is utterly, utterly, utterly and completely
+pointless.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+There are a number of principal ways to embed other event loops or modules
+into libev. Here are some ideas on how to include libadns into libev
+(there is a Perl module named \f(CW\*(C`EV::ADNS\*(C'\fR that does this, which you could
+use as a working example. Another Perl module named \f(CW\*(C`EV::Glib\*(C'\fR embeds a
+Glib main context into libev, and finally, \f(CW\*(C`Glib::EV\*(C'\fR embeds \s-1EV\s0 into the
+Glib event loop).
+.PP
+Method 1: Add \s-1IO\s0 watchers and a timeout watcher in a prepare handler,
+and in a check watcher, destroy them and call into libadns. What follows
+is pseudo-code only of course. This requires you to either use a low
+priority for the check watcher or use \f(CW\*(C`ev_clear_pending\*(C'\fR explicitly, as
+the callbacks for the IO/timeout watchers might not have been called yet.
+.PP
+.Vb 2
+\&   static ev_io iow [nfd];
+\&   static ev_timer tw;
+\&
+\&   static void
+\&   io_cb (struct ev_loop *loop, ev_io *w, int revents)
+\&   {
+\&   }
+\&
+\&   // create io watchers for each fd and a timer before blocking
+\&   static void
+\&   adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int revents)
+\&   {
+\&     int timeout = 3600000;
+\&     struct pollfd fds [nfd];
+\&     // actual code will need to loop here and realloc etc.
+\&     adns_beforepoll (ads, fds, &nfd, &timeout, timeval_from (ev_time ()));
+\&
+\&     /* the callback is illegal, but won\*(Aqt be called as we stop during check */
+\&     ev_timer_init (&tw, 0, timeout * 1e\-3, 0.);
+\&     ev_timer_start (loop, &tw);
+\&
+\&     // create one ev_io per pollfd
+\&     for (int i = 0; i < nfd; ++i)
+\&       {
+\&         ev_io_init (iow + i, io_cb, fds [i].fd,
+\&           ((fds [i].events & POLLIN ? EV_READ : 0)
+\&            | (fds [i].events & POLLOUT ? EV_WRITE : 0)));
+\&
+\&         fds [i].revents = 0;
+\&         ev_io_start (loop, iow + i);
+\&       }
+\&   }
+\&
+\&   // stop all watchers after blocking
+\&   static void
+\&   adns_check_cb (struct ev_loop *loop, ev_check *w, int revents)
+\&   {
+\&     ev_timer_stop (loop, &tw);
+\&
+\&     for (int i = 0; i < nfd; ++i)
+\&       {
+\&         // set the relevant poll flags
+\&         // could also call adns_processreadable etc. here
+\&         struct pollfd *fd = fds + i;
+\&         int revents = ev_clear_pending (iow + i);
+\&         if (revents & EV_READ ) fd\->revents |= fd\->events & POLLIN;
+\&         if (revents & EV_WRITE) fd\->revents |= fd\->events & POLLOUT;
+\&
+\&         // now stop the watcher
+\&         ev_io_stop (loop, iow + i);
+\&       }
+\&
+\&     adns_afterpoll (adns, fds, nfd, timeval_from (ev_now (loop));
+\&   }
+.Ve
+.PP
+Method 2: This would be just like method 1, but you run \f(CW\*(C`adns_afterpoll\*(C'\fR
+in the prepare watcher and would dispose of the check watcher.
+.PP
+Method 3: If the module to be embedded supports explicit event
+notification (libadns does), you can also make use of the actual watcher
+callbacks, and only destroy/create the watchers in the prepare watcher.
+.PP
+.Vb 5
+\&   static void
+\&   timer_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     adns_state ads = (adns_state)w\->data;
+\&     update_now (EV_A);
+\&
+\&     adns_processtimeouts (ads, &tv_now);
+\&   }
+\&
+\&   static void
+\&   io_cb (EV_P_ ev_io *w, int revents)
+\&   {
+\&     adns_state ads = (adns_state)w\->data;
+\&     update_now (EV_A);
+\&
+\&     if (revents & EV_READ ) adns_processreadable  (ads, w\->fd, &tv_now);
+\&     if (revents & EV_WRITE) adns_processwriteable (ads, w\->fd, &tv_now);
+\&   }
+\&
+\&   // do not ever call adns_afterpoll
+.Ve
+.PP
+Method 4: Do not use a prepare or check watcher because the module you
+want to embed is not flexible enough to support it. Instead, you can
+override their poll function. The drawback with this solution is that the
+main loop is now no longer controllable by \s-1EV.\s0 The \f(CW\*(C`Glib::EV\*(C'\fR module uses
+this approach, effectively embedding \s-1EV\s0 as a client into the horrible
+libglib event loop.
+.PP
+.Vb 4
+\&   static gint
+\&   event_poll_func (GPollFD *fds, guint nfds, gint timeout)
+\&   {
+\&     int got_events = 0;
+\&
+\&     for (n = 0; n < nfds; ++n)
+\&       // create/start io watcher that sets the relevant bits in fds[n] and increment got_events
+\&
+\&     if (timeout >= 0)
+\&       // create/start timer
+\&
+\&     // poll
+\&     ev_run (EV_A_ 0);
+\&
+\&     // stop timer again
+\&     if (timeout >= 0)
+\&       ev_timer_stop (EV_A_ &to);
+\&
+\&     // stop io watchers again \- their callbacks should have set
+\&     for (n = 0; n < nfds; ++n)
+\&       ev_io_stop (EV_A_ iow [n]);
+\&
+\&     return got_events;
+\&   }
+.Ve
+.ie n .SS """ev_embed"" \- when one backend isn't enough..."
+.el .SS "\f(CWev_embed\fP \- when one backend isn't enough..."
+.IX Subsection "ev_embed - when one backend isn't enough..."
+This is a rather advanced watcher type that lets you embed one event loop
+into another (currently only \f(CW\*(C`ev_io\*(C'\fR events are supported in the embedded
+loop, other types of watchers might be handled in a delayed or incorrect
+fashion and must not be used).
+.PP
+There are primarily two reasons you would want that: work around bugs and
+prioritise I/O.
+.PP
+As an example for a bug workaround, the kqueue backend might only support
+sockets on some platform, so it is unusable as generic backend, but you
+still want to make use of it because you have many sockets and it scales
+so nicely. In this case, you would create a kqueue-based loop and embed
+it into your default loop (which might use e.g. poll). Overall operation
+will be a bit slower because first libev has to call \f(CW\*(C`poll\*(C'\fR and then
+\&\f(CW\*(C`kevent\*(C'\fR, but at least you can use both mechanisms for what they are
+best: \f(CW\*(C`kqueue\*(C'\fR for scalable sockets and \f(CW\*(C`poll\*(C'\fR if you want it to work :)
+.PP
+As for prioritising I/O: under rare circumstances you have the case where
+some fds have to be watched and handled very quickly (with low latency),
+and even priorities and idle watchers might have too much overhead. In
+this case you would put all the high priority stuff in one loop and all
+the rest in a second one, and embed the second one in the first.
+.PP
+As long as the watcher is active, the callback will be invoked every
+time there might be events pending in the embedded loop. The callback
+must then call \f(CW\*(C`ev_embed_sweep (mainloop, watcher)\*(C'\fR to make a single
+sweep and invoke their callbacks (the callback doesn't need to invoke the
+\&\f(CW\*(C`ev_embed_sweep\*(C'\fR function directly, it could also start an idle watcher
+to give the embedded loop strictly lower priority for example).
+.PP
+You can also set the callback to \f(CW0\fR, in which case the embed watcher
+will automatically execute the embedded loop sweep whenever necessary.
+.PP
+Fork detection will be handled transparently while the \f(CW\*(C`ev_embed\*(C'\fR watcher
+is active, i.e., the embedded loop will automatically be forked when the
+embedding loop forks. In other cases, the user is responsible for calling
+\&\f(CW\*(C`ev_loop_fork\*(C'\fR on the embedded loop.
+.PP
+Unfortunately, not all backends are embeddable: only the ones returned by
+\&\f(CW\*(C`ev_embeddable_backends\*(C'\fR are, which, unfortunately, does not include any
+portable one.
+.PP
+So when you want to use this feature you will always have to be prepared
+that you cannot get an embeddable loop. The recommended way to get around
+this is to have a separate variables for your embeddable loop, try to
+create it, and if that fails, use the normal loop for everything.
+.PP
+\fI\f(CI\*(C`ev_embed\*(C'\fI and fork\fR
+.IX Subsection "ev_embed and fork"
+.PP
+While the \f(CW\*(C`ev_embed\*(C'\fR watcher is running, forks in the embedding loop will
+automatically be applied to the embedded loop as well, so no special
+fork handling is required in that case. When the watcher is not running,
+however, it is still the task of the libev user to call \f(CW\*(C`ev_loop_fork ()\*(C'\fR
+as applicable.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)" 4
+.IX Item "ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)"
+.PD 0
+.IP "ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)" 4
+.IX Item "ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)"
+.PD
+Configures the watcher to embed the given loop, which must be
+embeddable. If the callback is \f(CW0\fR, then \f(CW\*(C`ev_embed_sweep\*(C'\fR will be
+invoked automatically, otherwise it is the responsibility of the callback
+to invoke it (it will continue to be called until the sweep has been done,
+if you do not want that, you need to temporarily stop the embed watcher).
+.IP "ev_embed_sweep (loop, ev_embed *)" 4
+.IX Item "ev_embed_sweep (loop, ev_embed *)"
+Make a single, non-blocking sweep over the embedded loop. This works
+similarly to \f(CW\*(C`ev_run (embedded_loop, EVRUN_NOWAIT)\*(C'\fR, but in the most
+appropriate way for embedded loops.
+.IP "struct ev_loop *other [read\-only]" 4
+.IX Item "struct ev_loop *other [read-only]"
+The embedded event loop.
+.PP
+\fIExamples\fR
+.IX Subsection "Examples"
+.PP
+Example: Try to get an embeddable event loop and embed it into the default
+event loop. If that is not possible, use the default loop. The default
+loop is stored in \f(CW\*(C`loop_hi\*(C'\fR, while the embeddable loop is stored in
+\&\f(CW\*(C`loop_lo\*(C'\fR (which is \f(CW\*(C`loop_hi\*(C'\fR in the case no embeddable loop can be
+used).
+.PP
+.Vb 3
+\&   struct ev_loop *loop_hi = ev_default_init (0);
+\&   struct ev_loop *loop_lo = 0;
+\&   ev_embed embed;
+\&
+\&   // see if there is a chance of getting one that works
+\&   // (remember that a flags value of 0 means autodetection)
+\&   loop_lo = ev_embeddable_backends () & ev_recommended_backends ()
+\&     ? ev_loop_new (ev_embeddable_backends () & ev_recommended_backends ())
+\&     : 0;
+\&
+\&   // if we got one, then embed it, otherwise default to loop_hi
+\&   if (loop_lo)
+\&     {
+\&       ev_embed_init (&embed, 0, loop_lo);
+\&       ev_embed_start (loop_hi, &embed);
+\&     }
+\&   else
+\&     loop_lo = loop_hi;
+.Ve
+.PP
+Example: Check if kqueue is available but not recommended and create
+a kqueue backend for use with sockets (which usually work with any
+kqueue implementation). Store the kqueue/socket\-only event loop in
+\&\f(CW\*(C`loop_socket\*(C'\fR. (One might optionally use \f(CW\*(C`EVFLAG_NOENV\*(C'\fR, too).
+.PP
+.Vb 3
+\&   struct ev_loop *loop = ev_default_init (0);
+\&   struct ev_loop *loop_socket = 0;
+\&   ev_embed embed;
+\&
+\&   if (ev_supported_backends () & ~ev_recommended_backends () & EVBACKEND_KQUEUE)
+\&     if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE))
+\&       {
+\&         ev_embed_init (&embed, 0, loop_socket);
+\&         ev_embed_start (loop, &embed);
+\&       }
+\&
+\&   if (!loop_socket)
+\&     loop_socket = loop;
+\&
+\&   // now use loop_socket for all sockets, and loop for everything else
+.Ve
+.ie n .SS """ev_fork"" \- the audacity to resume the event loop after a fork"
+.el .SS "\f(CWev_fork\fP \- the audacity to resume the event loop after a fork"
+.IX Subsection "ev_fork - the audacity to resume the event loop after a fork"
+Fork watchers are called when a \f(CW\*(C`fork ()\*(C'\fR was detected (usually because
+whoever is a good citizen cared to tell libev about it by calling
+\&\f(CW\*(C`ev_loop_fork\*(C'\fR). The invocation is done before the event loop blocks next
+and before \f(CW\*(C`ev_check\*(C'\fR watchers are being called, and only in the child
+after the fork. If whoever good citizen calling \f(CW\*(C`ev_default_fork\*(C'\fR cheats
+and calls it in the wrong process, the fork handlers will be invoked, too,
+of course.
+.PP
+\fIThe special problem of life after fork \- how is it possible?\fR
+.IX Subsection "The special problem of life after fork - how is it possible?"
+.PP
+Most uses of \f(CW\*(C`fork ()\*(C'\fR consist of forking, then some simple calls to set
+up/change the process environment, followed by a call to \f(CW\*(C`exec()\*(C'\fR. This
+sequence should be handled by libev without any problems.
+.PP
+This changes when the application actually wants to do event handling
+in the child, or both parent in child, in effect \*(L"continuing\*(R" after the
+fork.
+.PP
+The default mode of operation (for libev, with application help to detect
+forks) is to duplicate all the state in the child, as would be expected
+when \fIeither\fR the parent \fIor\fR the child process continues.
+.PP
+When both processes want to continue using libev, then this is usually the
+wrong result. In that case, usually one process (typically the parent) is
+supposed to continue with all watchers in place as before, while the other
+process typically wants to start fresh, i.e. without any active watchers.
+.PP
+The cleanest and most efficient way to achieve that with libev is to
+simply create a new event loop, which of course will be \*(L"empty\*(R", and
+use that for new watchers. This has the advantage of not touching more
+memory than necessary, and thus avoiding the copy-on-write, and the
+disadvantage of having to use multiple event loops (which do not support
+signal watchers).
+.PP
+When this is not possible, or you want to use the default loop for
+other reasons, then in the process that wants to start \*(L"fresh\*(R", call
+\&\f(CW\*(C`ev_loop_destroy (EV_DEFAULT)\*(C'\fR followed by \f(CW\*(C`ev_default_loop (...)\*(C'\fR.
+Destroying the default loop will \*(L"orphan\*(R" (not stop) all registered
+watchers, so you have to be careful not to execute code that modifies
+those watchers. Note also that in that case, you have to re-register any
+signal watchers.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_fork_init (ev_fork *, callback)" 4
+.IX Item "ev_fork_init (ev_fork *, callback)"
+Initialises and configures the fork watcher \- it has no parameters of any
+kind. There is a \f(CW\*(C`ev_fork_set\*(C'\fR macro, but using it is utterly pointless,
+really.
+.ie n .SS """ev_cleanup"" \- even the best things end"
+.el .SS "\f(CWev_cleanup\fP \- even the best things end"
+.IX Subsection "ev_cleanup - even the best things end"
+Cleanup watchers are called just before the event loop is being destroyed
+by a call to \f(CW\*(C`ev_loop_destroy\*(C'\fR.
+.PP
+While there is no guarantee that the event loop gets destroyed, cleanup
+watchers provide a convenient method to install cleanup hooks for your
+program, worker threads and so on \- you just to make sure to destroy the
+loop when you want them to be invoked.
+.PP
+Cleanup watchers are invoked in the same way as any other watcher. Unlike
+all other watchers, they do not keep a reference to the event loop (which
+makes a lot of sense if you think about it). Like all other watchers, you
+can call libev functions in the callback, except \f(CW\*(C`ev_cleanup_start\*(C'\fR.
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_cleanup_init (ev_cleanup *, callback)" 4
+.IX Item "ev_cleanup_init (ev_cleanup *, callback)"
+Initialises and configures the cleanup watcher \- it has no parameters of
+any kind. There is a \f(CW\*(C`ev_cleanup_set\*(C'\fR macro, but using it is utterly
+pointless, I assure you.
+.PP
+Example: Register an atexit handler to destroy the default loop, so any
+cleanup functions are called.
+.PP
+.Vb 5
+\&   static void
+\&   program_exits (void)
+\&   {
+\&     ev_loop_destroy (EV_DEFAULT_UC);
+\&   }
+\&
+\&   ...
+\&   atexit (program_exits);
+.Ve
+.ie n .SS """ev_async"" \- how to wake up an event loop"
+.el .SS "\f(CWev_async\fP \- how to wake up an event loop"
+.IX Subsection "ev_async - how to wake up an event loop"
+In general, you cannot use an \f(CW\*(C`ev_loop\*(C'\fR from multiple threads or other
+asynchronous sources such as signal handlers (as opposed to multiple event
+loops \- those are of course safe to use in different threads).
+.PP
+Sometimes, however, you need to wake up an event loop you do not control,
+for example because it belongs to another thread. This is what \f(CW\*(C`ev_async\*(C'\fR
+watchers do: as long as the \f(CW\*(C`ev_async\*(C'\fR watcher is active, you can signal
+it by calling \f(CW\*(C`ev_async_send\*(C'\fR, which is thread\- and signal safe.
+.PP
+This functionality is very similar to \f(CW\*(C`ev_signal\*(C'\fR watchers, as signals,
+too, are asynchronous in nature, and signals, too, will be compressed
+(i.e. the number of callback invocations may be less than the number of
+\&\f(CW\*(C`ev_async_send\*(C'\fR calls). In fact, you could use signal watchers as a kind
+of \*(L"global async watchers\*(R" by using a watcher on an otherwise unused
+signal, and \f(CW\*(C`ev_feed_signal\*(C'\fR to signal this watcher from another thread,
+even without knowing which loop owns the signal.
+.PP
+\fIQueueing\fR
+.IX Subsection "Queueing"
+.PP
+\&\f(CW\*(C`ev_async\*(C'\fR does not support queueing of data in any way. The reason
+is that the author does not know of a simple (or any) algorithm for a
+multiple-writer-single-reader queue that works in all cases and doesn't
+need elaborate support such as pthreads or unportable memory access
+semantics.
+.PP
+That means that if you want to queue data, you have to provide your own
+queue. But at least I can tell you how to implement locking around your
+queue:
+.IP "queueing from a signal handler context" 4
+.IX Item "queueing from a signal handler context"
+To implement race-free queueing, you simply add to the queue in the signal
+handler but you block the signal handler in the watcher callback. Here is
+an example that does that for some fictitious \s-1SIGUSR1\s0 handler:
+.Sp
+.Vb 1
+\&   static ev_async mysig;
+\&
+\&   static void
+\&   sigusr1_handler (void)
+\&   {
+\&     sometype data;
+\&
+\&     // no locking etc.
+\&     queue_put (data);
+\&     ev_async_send (EV_DEFAULT_ &mysig);
+\&   }
+\&
+\&   static void
+\&   mysig_cb (EV_P_ ev_async *w, int revents)
+\&   {
+\&     sometype data;
+\&     sigset_t block, prev;
+\&
+\&     sigemptyset (&block);
+\&     sigaddset (&block, SIGUSR1);
+\&     sigprocmask (SIG_BLOCK, &block, &prev);
+\&
+\&     while (queue_get (&data))
+\&       process (data);
+\&
+\&     if (sigismember (&prev, SIGUSR1)
+\&       sigprocmask (SIG_UNBLOCK, &block, 0);
+\&   }
+.Ve
+.Sp
+(Note: pthreads in theory requires you to use \f(CW\*(C`pthread_setmask\*(C'\fR
+instead of \f(CW\*(C`sigprocmask\*(C'\fR when you use threads, but libev doesn't do it
+either...).
+.IP "queueing from a thread context" 4
+.IX Item "queueing from a thread context"
+The strategy for threads is different, as you cannot (easily) block
+threads but you can easily preempt them, so to queue safely you need to
+employ a traditional mutex lock, such as in this pthread example:
+.Sp
+.Vb 2
+\&   static ev_async mysig;
+\&   static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
+\&
+\&   static void
+\&   otherthread (void)
+\&   {
+\&     // only need to lock the actual queueing operation
+\&     pthread_mutex_lock (&mymutex);
+\&     queue_put (data);
+\&     pthread_mutex_unlock (&mymutex);
+\&
+\&     ev_async_send (EV_DEFAULT_ &mysig);
+\&   }
+\&
+\&   static void
+\&   mysig_cb (EV_P_ ev_async *w, int revents)
+\&   {
+\&     pthread_mutex_lock (&mymutex);
+\&
+\&     while (queue_get (&data))
+\&       process (data);
+\&
+\&     pthread_mutex_unlock (&mymutex);
+\&   }
+.Ve
+.PP
+\fIWatcher-Specific Functions and Data Members\fR
+.IX Subsection "Watcher-Specific Functions and Data Members"
+.IP "ev_async_init (ev_async *, callback)" 4
+.IX Item "ev_async_init (ev_async *, callback)"
+Initialises and configures the async watcher \- it has no parameters of any
+kind. There is a \f(CW\*(C`ev_async_set\*(C'\fR macro, but using it is utterly pointless,
+trust me.
+.IP "ev_async_send (loop, ev_async *)" 4
+.IX Item "ev_async_send (loop, ev_async *)"
+Sends/signals/activates the given \f(CW\*(C`ev_async\*(C'\fR watcher, that is, feeds
+an \f(CW\*(C`EV_ASYNC\*(C'\fR event on the watcher into the event loop, and instantly
+returns.
+.Sp
+Unlike \f(CW\*(C`ev_feed_event\*(C'\fR, this call is safe to do from other threads,
+signal or similar contexts (see the discussion of \f(CW\*(C`EV_ATOMIC_T\*(C'\fR in the
+embedding section below on what exactly this means).
+.Sp
+Note that, as with other watchers in libev, multiple events might get
+compressed into a single callback invocation (another way to look at
+this is that \f(CW\*(C`ev_async\*(C'\fR watchers are level-triggered: they are set on
+\&\f(CW\*(C`ev_async_send\*(C'\fR, reset when the event loop detects that).
+.Sp
+This call incurs the overhead of at most one extra system call per event
+loop iteration, if the event loop is blocked, and no syscall at all if
+the event loop (or your program) is processing events. That means that
+repeated calls are basically free (there is no need to avoid calls for
+performance reasons) and that the overhead becomes smaller (typically
+zero) under load.
+.IP "bool = ev_async_pending (ev_async *)" 4
+.IX Item "bool = ev_async_pending (ev_async *)"
+Returns a non-zero value when \f(CW\*(C`ev_async_send\*(C'\fR has been called on the
+watcher but the event has not yet been processed (or even noted) by the
+event loop.
+.Sp
+\&\f(CW\*(C`ev_async_send\*(C'\fR sets a flag in the watcher and wakes up the loop. When
+the loop iterates next and checks for the watcher to have become active,
+it will reset the flag again. \f(CW\*(C`ev_async_pending\*(C'\fR can be used to very
+quickly check whether invoking the loop might be a good idea.
+.Sp
+Not that this does \fInot\fR check whether the watcher itself is pending,
+only whether it has been requested to make this watcher pending: there
+is a time window between the event loop checking and resetting the async
+notification, and the callback being invoked.
+.SH "OTHER FUNCTIONS"
+.IX Header "OTHER FUNCTIONS"
+There are some other functions of possible interest. Described. Here. Now.
+.IP "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)" 4
+.IX Item "ev_once (loop, int fd, int events, ev_tstamp timeout, callback)"
+This function combines a simple timer and an I/O watcher, calls your
+callback on whichever event happens first and automatically stops both
+watchers. This is useful if you want to wait for a single event on an fd
+or timeout without having to allocate/configure/start/stop/free one or
+more watchers yourself.
+.Sp
+If \f(CW\*(C`fd\*(C'\fR is less than 0, then no I/O watcher will be started and the
+\&\f(CW\*(C`events\*(C'\fR argument is being ignored. Otherwise, an \f(CW\*(C`ev_io\*(C'\fR watcher for
+the given \f(CW\*(C`fd\*(C'\fR and \f(CW\*(C`events\*(C'\fR set will be created and started.
+.Sp
+If \f(CW\*(C`timeout\*(C'\fR is less than 0, then no timeout watcher will be
+started. Otherwise an \f(CW\*(C`ev_timer\*(C'\fR watcher with after = \f(CW\*(C`timeout\*(C'\fR (and
+repeat = 0) will be started. \f(CW0\fR is a valid timeout.
+.Sp
+The callback has the type \f(CW\*(C`void (*cb)(int revents, void *arg)\*(C'\fR and is
+passed an \f(CW\*(C`revents\*(C'\fR set like normal event callbacks (a combination of
+\&\f(CW\*(C`EV_ERROR\*(C'\fR, \f(CW\*(C`EV_READ\*(C'\fR, \f(CW\*(C`EV_WRITE\*(C'\fR or \f(CW\*(C`EV_TIMER\*(C'\fR) and the \f(CW\*(C`arg\*(C'\fR
+value passed to \f(CW\*(C`ev_once\*(C'\fR. Note that it is possible to receive \fIboth\fR
+a timeout and an io event at the same time \- you probably should give io
+events precedence.
+.Sp
+Example: wait up to ten seconds for data to appear on \s-1STDIN_FILENO.\s0
+.Sp
+.Vb 7
+\&   static void stdin_ready (int revents, void *arg)
+\&   {
+\&     if (revents & EV_READ)
+\&       /* stdin might have data for us, joy! */;
+\&     else if (revents & EV_TIMER)
+\&       /* doh, nothing entered */;
+\&   }
+\&
+\&   ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
+.Ve
+.IP "ev_feed_fd_event (loop, int fd, int revents)" 4
+.IX Item "ev_feed_fd_event (loop, int fd, int revents)"
+Feed an event on the given fd, as if a file descriptor backend detected
+the given events.
+.IP "ev_feed_signal_event (loop, int signum)" 4
+.IX Item "ev_feed_signal_event (loop, int signum)"
+Feed an event as if the given signal occurred. See also \f(CW\*(C`ev_feed_signal\*(C'\fR,
+which is async-safe.
+.SH "COMMON OR USEFUL IDIOMS (OR BOTH)"
+.IX Header "COMMON OR USEFUL IDIOMS (OR BOTH)"
+This section explains some common idioms that are not immediately
+obvious. Note that examples are sprinkled over the whole manual, and this
+section only contains stuff that wouldn't fit anywhere else.
+.SS "\s-1ASSOCIATING CUSTOM DATA WITH A WATCHER\s0"
+.IX Subsection "ASSOCIATING CUSTOM DATA WITH A WATCHER"
+Each watcher has, by default, a \f(CW\*(C`void *data\*(C'\fR member that you can read
+or modify at any time: libev will completely ignore it. This can be used
+to associate arbitrary data with your watcher. If you need more data and
+don't want to allocate memory separately and store a pointer to it in that
+data member, you can also \*(L"subclass\*(R" the watcher type and provide your own
+data:
+.PP
+.Vb 7
+\&   struct my_io
+\&   {
+\&     ev_io io;
+\&     int otherfd;
+\&     void *somedata;
+\&     struct whatever *mostinteresting;
+\&   };
+\&
+\&   ...
+\&   struct my_io w;
+\&   ev_io_init (&w.io, my_cb, fd, EV_READ);
+.Ve
+.PP
+And since your callback will be called with a pointer to the watcher, you
+can cast it back to your own type:
+.PP
+.Vb 5
+\&   static void my_cb (struct ev_loop *loop, ev_io *w_, int revents)
+\&   {
+\&     struct my_io *w = (struct my_io *)w_;
+\&     ...
+\&   }
+.Ve
+.PP
+More interesting and less C\-conformant ways of casting your callback
+function type instead have been omitted.
+.SS "\s-1BUILDING YOUR OWN COMPOSITE WATCHERS\s0"
+.IX Subsection "BUILDING YOUR OWN COMPOSITE WATCHERS"
+Another common scenario is to use some data structure with multiple
+embedded watchers, in effect creating your own watcher that combines
+multiple libev event sources into one \*(L"super-watcher\*(R":
+.PP
+.Vb 6
+\&   struct my_biggy
+\&   {
+\&     int some_data;
+\&     ev_timer t1;
+\&     ev_timer t2;
+\&   }
+.Ve
+.PP
+In this case getting the pointer to \f(CW\*(C`my_biggy\*(C'\fR is a bit more
+complicated: Either you store the address of your \f(CW\*(C`my_biggy\*(C'\fR struct in
+the \f(CW\*(C`data\*(C'\fR member of the watcher (for woozies or \*(C+ coders), or you need
+to use some pointer arithmetic using \f(CW\*(C`offsetof\*(C'\fR inside your watchers (for
+real programmers):
+.PP
+.Vb 1
+\&   #include <stddef.h>
+\&
+\&   static void
+\&   t1_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     struct my_biggy big = (struct my_biggy *)
+\&       (((char *)w) \- offsetof (struct my_biggy, t1));
+\&   }
+\&
+\&   static void
+\&   t2_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     struct my_biggy big = (struct my_biggy *)
+\&       (((char *)w) \- offsetof (struct my_biggy, t2));
+\&   }
+.Ve
+.SS "\s-1AVOIDING FINISHING BEFORE RETURNING\s0"
+.IX Subsection "AVOIDING FINISHING BEFORE RETURNING"
+Often you have structures like this in event-based programs:
+.PP
+.Vb 4
+\&  callback ()
+\&  {
+\&    free (request);
+\&  }
+\&
+\&  request = start_new_request (..., callback);
+.Ve
+.PP
+The intent is to start some \*(L"lengthy\*(R" operation. The \f(CW\*(C`request\*(C'\fR could be
+used to cancel the operation, or do other things with it.
+.PP
+It's not uncommon to have code paths in \f(CW\*(C`start_new_request\*(C'\fR that
+immediately invoke the callback, for example, to report errors. Or you add
+some caching layer that finds that it can skip the lengthy aspects of the
+operation and simply invoke the callback with the result.
+.PP
+The problem here is that this will happen \fIbefore\fR \f(CW\*(C`start_new_request\*(C'\fR
+has returned, so \f(CW\*(C`request\*(C'\fR is not set.
+.PP
+Even if you pass the request by some safer means to the callback, you
+might want to do something to the request after starting it, such as
+canceling it, which probably isn't working so well when the callback has
+already been invoked.
+.PP
+A common way around all these issues is to make sure that
+\&\f(CW\*(C`start_new_request\*(C'\fR \fIalways\fR returns before the callback is invoked. If
+\&\f(CW\*(C`start_new_request\*(C'\fR immediately knows the result, it can artificially
+delay invoking the callback by using a \f(CW\*(C`prepare\*(C'\fR or \f(CW\*(C`idle\*(C'\fR watcher for
+example, or more sneakily, by reusing an existing (stopped) watcher and
+pushing it into the pending queue:
+.PP
+.Vb 2
+\&   ev_set_cb (watcher, callback);
+\&   ev_feed_event (EV_A_ watcher, 0);
+.Ve
+.PP
+This way, \f(CW\*(C`start_new_request\*(C'\fR can safely return before the callback is
+invoked, while not delaying callback invocation too much.
+.SS "\s-1MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS\s0"
+.IX Subsection "MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS"
+Often (especially in \s-1GUI\s0 toolkits) there are places where you have
+\&\fImodal\fR interaction, which is most easily implemented by recursively
+invoking \f(CW\*(C`ev_run\*(C'\fR.
+.PP
+This brings the problem of exiting \- a callback might want to finish the
+main \f(CW\*(C`ev_run\*(C'\fR call, but not the nested one (e.g. user clicked \*(L"Quit\*(R", but
+a modal \*(L"Are you sure?\*(R" dialog is still waiting), or just the nested one
+and not the main one (e.g. user clocked \*(L"Ok\*(R" in a modal dialog), or some
+other combination: In these cases, a simple \f(CW\*(C`ev_break\*(C'\fR will not work.
+.PP
+The solution is to maintain \*(L"break this loop\*(R" variable for each \f(CW\*(C`ev_run\*(C'\fR
+invocation, and use a loop around \f(CW\*(C`ev_run\*(C'\fR until the condition is
+triggered, using \f(CW\*(C`EVRUN_ONCE\*(C'\fR:
+.PP
+.Vb 2
+\&   // main loop
+\&   int exit_main_loop = 0;
+\&
+\&   while (!exit_main_loop)
+\&     ev_run (EV_DEFAULT_ EVRUN_ONCE);
+\&
+\&   // in a modal watcher
+\&   int exit_nested_loop = 0;
+\&
+\&   while (!exit_nested_loop)
+\&     ev_run (EV_A_ EVRUN_ONCE);
+.Ve
+.PP
+To exit from any of these loops, just set the corresponding exit variable:
+.PP
+.Vb 2
+\&   // exit modal loop
+\&   exit_nested_loop = 1;
+\&
+\&   // exit main program, after modal loop is finished
+\&   exit_main_loop = 1;
+\&
+\&   // exit both
+\&   exit_main_loop = exit_nested_loop = 1;
+.Ve
+.SS "\s-1THREAD LOCKING EXAMPLE\s0"
+.IX Subsection "THREAD LOCKING EXAMPLE"
+Here is a fictitious example of how to run an event loop in a different
+thread from where callbacks are being invoked and watchers are
+created/added/removed.
+.PP
+For a real-world example, see the \f(CW\*(C`EV::Loop::Async\*(C'\fR perl module,
+which uses exactly this technique (which is suited for many high-level
+languages).
+.PP
+The example uses a pthread mutex to protect the loop data, a condition
+variable to wait for callback invocations, an async watcher to notify the
+event loop thread and an unspecified mechanism to wake up the main thread.
+.PP
+First, you need to associate some data with the event loop:
+.PP
+.Vb 6
+\&   typedef struct {
+\&     mutex_t lock; /* global loop lock */
+\&     ev_async async_w;
+\&     thread_t tid;
+\&     cond_t invoke_cv;
+\&   } userdata;
+\&
+\&   void prepare_loop (EV_P)
+\&   {
+\&      // for simplicity, we use a static userdata struct.
+\&      static userdata u;
+\&
+\&      ev_async_init (&u\->async_w, async_cb);
+\&      ev_async_start (EV_A_ &u\->async_w);
+\&
+\&      pthread_mutex_init (&u\->lock, 0);
+\&      pthread_cond_init (&u\->invoke_cv, 0);
+\&
+\&      // now associate this with the loop
+\&      ev_set_userdata (EV_A_ u);
+\&      ev_set_invoke_pending_cb (EV_A_ l_invoke);
+\&      ev_set_loop_release_cb (EV_A_ l_release, l_acquire);
+\&
+\&      // then create the thread running ev_run
+\&      pthread_create (&u\->tid, 0, l_run, EV_A);
+\&   }
+.Ve
+.PP
+The callback for the \f(CW\*(C`ev_async\*(C'\fR watcher does nothing: the watcher is used
+solely to wake up the event loop so it takes notice of any new watchers
+that might have been added:
+.PP
+.Vb 5
+\&   static void
+\&   async_cb (EV_P_ ev_async *w, int revents)
+\&   {
+\&      // just used for the side effects
+\&   }
+.Ve
+.PP
+The \f(CW\*(C`l_release\*(C'\fR and \f(CW\*(C`l_acquire\*(C'\fR callbacks simply unlock/lock the mutex
+protecting the loop data, respectively.
+.PP
+.Vb 6
+\&   static void
+\&   l_release (EV_P)
+\&   {
+\&     userdata *u = ev_userdata (EV_A);
+\&     pthread_mutex_unlock (&u\->lock);
+\&   }
+\&
+\&   static void
+\&   l_acquire (EV_P)
+\&   {
+\&     userdata *u = ev_userdata (EV_A);
+\&     pthread_mutex_lock (&u\->lock);
+\&   }
+.Ve
+.PP
+The event loop thread first acquires the mutex, and then jumps straight
+into \f(CW\*(C`ev_run\*(C'\fR:
+.PP
+.Vb 4
+\&   void *
+\&   l_run (void *thr_arg)
+\&   {
+\&     struct ev_loop *loop = (struct ev_loop *)thr_arg;
+\&
+\&     l_acquire (EV_A);
+\&     pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0);
+\&     ev_run (EV_A_ 0);
+\&     l_release (EV_A);
+\&
+\&     return 0;
+\&   }
+.Ve
+.PP
+Instead of invoking all pending watchers, the \f(CW\*(C`l_invoke\*(C'\fR callback will
+signal the main thread via some unspecified mechanism (signals? pipe
+writes? \f(CW\*(C`Async::Interrupt\*(C'\fR?) and then waits until all pending watchers
+have been called (in a while loop because a) spurious wakeups are possible
+and b) skipping inter-thread-communication when there are no pending
+watchers is very beneficial):
+.PP
+.Vb 4
+\&   static void
+\&   l_invoke (EV_P)
+\&   {
+\&     userdata *u = ev_userdata (EV_A);
+\&
+\&     while (ev_pending_count (EV_A))
+\&       {
+\&         wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
+\&         pthread_cond_wait (&u\->invoke_cv, &u\->lock);
+\&       }
+\&   }
+.Ve
+.PP
+Now, whenever the main thread gets told to invoke pending watchers, it
+will grab the lock, call \f(CW\*(C`ev_invoke_pending\*(C'\fR and then signal the loop
+thread to continue:
+.PP
+.Vb 4
+\&   static void
+\&   real_invoke_pending (EV_P)
+\&   {
+\&     userdata *u = ev_userdata (EV_A);
+\&
+\&     pthread_mutex_lock (&u\->lock);
+\&     ev_invoke_pending (EV_A);
+\&     pthread_cond_signal (&u\->invoke_cv);
+\&     pthread_mutex_unlock (&u\->lock);
+\&   }
+.Ve
+.PP
+Whenever you want to start/stop a watcher or do other modifications to an
+event loop, you will now have to lock:
+.PP
+.Vb 2
+\&   ev_timer timeout_watcher;
+\&   userdata *u = ev_userdata (EV_A);
+\&
+\&   ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
+\&
+\&   pthread_mutex_lock (&u\->lock);
+\&   ev_timer_start (EV_A_ &timeout_watcher);
+\&   ev_async_send (EV_A_ &u\->async_w);
+\&   pthread_mutex_unlock (&u\->lock);
+.Ve
+.PP
+Note that sending the \f(CW\*(C`ev_async\*(C'\fR watcher is required because otherwise
+an event loop currently blocking in the kernel will have no knowledge
+about the newly added timer. By waking up the loop it will pick up any new
+watchers in the next event loop iteration.
+.SS "\s-1THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS\s0"
+.IX Subsection "THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS"
+While the overhead of a callback that e.g. schedules a thread is small, it
+is still an overhead. If you embed libev, and your main usage is with some
+kind of threads or coroutines, you might want to customise libev so that
+doesn't need callbacks anymore.
+.PP
+Imagine you have coroutines that you can switch to using a function
+\&\f(CW\*(C`switch_to (coro)\*(C'\fR, that libev runs in a coroutine called \f(CW\*(C`libev_coro\*(C'\fR
+and that due to some magic, the currently active coroutine is stored in a
+global called \f(CW\*(C`current_coro\*(C'\fR. Then you can build your own \*(L"wait for libev
+event\*(R" primitive by changing \f(CW\*(C`EV_CB_DECLARE\*(C'\fR and \f(CW\*(C`EV_CB_INVOKE\*(C'\fR (note
+the differing \f(CW\*(C`;\*(C'\fR conventions):
+.PP
+.Vb 2
+\&   #define EV_CB_DECLARE(type)   struct my_coro *cb;
+\&   #define EV_CB_INVOKE(watcher) switch_to ((watcher)\->cb)
+.Ve
+.PP
+That means instead of having a C callback function, you store the
+coroutine to switch to in each watcher, and instead of having libev call
+your callback, you instead have it switch to that coroutine.
+.PP
+A coroutine might now wait for an event with a function called
+\&\f(CW\*(C`wait_for_event\*(C'\fR. (the watcher needs to be started, as always, but it doesn't
+matter when, or whether the watcher is active or not when this function is
+called):
+.PP
+.Vb 6
+\&   void
+\&   wait_for_event (ev_watcher *w)
+\&   {
+\&     ev_set_cb (w, current_coro);
+\&     switch_to (libev_coro);
+\&   }
+.Ve
+.PP
+That basically suspends the coroutine inside \f(CW\*(C`wait_for_event\*(C'\fR and
+continues the libev coroutine, which, when appropriate, switches back to
+this or any other coroutine.
+.PP
+You can do similar tricks if you have, say, threads with an event queue \-
+instead of storing a coroutine, you store the queue object and instead of
+switching to a coroutine, you push the watcher onto the queue and notify
+any waiters.
+.PP
+To embed libev, see \*(L"\s-1EMBEDDING\*(R"\s0, but in short, it's easiest to create two
+files, \fImy_ev.h\fR and \fImy_ev.c\fR that include the respective libev files:
+.PP
+.Vb 4
+\&   // my_ev.h
+\&   #define EV_CB_DECLARE(type)   struct my_coro *cb;
+\&   #define EV_CB_INVOKE(watcher) switch_to ((watcher)\->cb)
+\&   #include "../libev/ev.h"
+\&
+\&   // my_ev.c
+\&   #define EV_H "my_ev.h"
+\&   #include "../libev/ev.c"
+.Ve
+.PP
+And then use \fImy_ev.h\fR when you would normally use \fIev.h\fR, and compile
+\&\fImy_ev.c\fR into your project. When properly specifying include paths, you
+can even use \fIev.h\fR as header file name directly.
+.SH "LIBEVENT EMULATION"
+.IX Header "LIBEVENT EMULATION"
+Libev offers a compatibility emulation layer for libevent. It cannot
+emulate the internals of libevent, so here are some usage hints:
+.IP "\(bu" 4
+Only the libevent\-1.4.1\-beta \s-1API\s0 is being emulated.
+.Sp
+This was the newest libevent version available when libev was implemented,
+and is still mostly unchanged in 2010.
+.IP "\(bu" 4
+Use it by including <event.h>, as usual.
+.IP "\(bu" 4
+The following members are fully supported: ev_base, ev_callback,
+ev_arg, ev_fd, ev_res, ev_events.
+.IP "\(bu" 4
+Avoid using ev_flags and the EVLIST_*\-macros, while it is
+maintained by libev, it does not work exactly the same way as in libevent (consider
+it a private \s-1API\s0).
+.IP "\(bu" 4
+Priorities are not currently supported. Initialising priorities
+will fail and all watchers will have the same priority, even though there
+is an ev_pri field.
+.IP "\(bu" 4
+In libevent, the last base created gets the signals, in libev, the
+base that registered the signal gets the signals.
+.IP "\(bu" 4
+Other members are not supported.
+.IP "\(bu" 4
+The libev emulation is \fInot\fR \s-1ABI\s0 compatible to libevent, you need
+to use the libev header file and library.
+.SH "\*(C+ SUPPORT"
+.IX Header " SUPPORT"
+.SS "C \s-1API\s0"
+.IX Subsection "C API"
+The normal C \s-1API\s0 should work fine when used from \*(C+: both ev.h and the
+libev sources can be compiled as \*(C+. Therefore, code that uses the C \s-1API\s0
+will work fine.
+.PP
+Proper exception specifications might have to be added to callbacks passed
+to libev: exceptions may be thrown only from watcher callbacks, all
+other callbacks (allocator, syserr, loop acquire/release and periodic
+reschedule callbacks) must not throw exceptions, and might need a \f(CW\*(C`throw
+()\*(C'\fR specification. If you have code that needs to be compiled as both C
+and \*(C+ you can use the \f(CW\*(C`EV_THROW\*(C'\fR macro for this:
+.PP
+.Vb 6
+\&   static void
+\&   fatal_error (const char *msg) EV_THROW
+\&   {
+\&     perror (msg);
+\&     abort ();
+\&   }
+\&
+\&   ...
+\&   ev_set_syserr_cb (fatal_error);
+.Ve
+.PP
+The only \s-1API\s0 functions that can currently throw exceptions are \f(CW\*(C`ev_run\*(C'\fR,
+\&\f(CW\*(C`ev_invoke\*(C'\fR, \f(CW\*(C`ev_invoke_pending\*(C'\fR and \f(CW\*(C`ev_loop_destroy\*(C'\fR (the latter
+because it runs cleanup watchers).
+.PP
+Throwing exceptions in watcher callbacks is only supported if libev itself
+is compiled with a \*(C+ compiler or your C and \*(C+ environments allow
+throwing exceptions through C libraries (most do).
+.SS "\*(C+ \s-1API\s0"
+.IX Subsection " API"
+Libev comes with some simplistic wrapper classes for \*(C+ that mainly allow
+you to use some convenience methods to start/stop watchers and also change
+the callback model to a model using method callbacks on objects.
+.PP
+To use it,
+.PP
+.Vb 1
+\&   #include <ev++.h>
+.Ve
+.PP
+This automatically includes \fIev.h\fR and puts all of its definitions (many
+of them macros) into the global namespace. All \*(C+ specific things are
+put into the \f(CW\*(C`ev\*(C'\fR namespace. It should support all the same embedding
+options as \fIev.h\fR, most notably \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR.
+.PP
+Care has been taken to keep the overhead low. The only data member the \*(C+
+classes add (compared to plain C\-style watchers) is the event loop pointer
+that the watcher is associated with (or no additional members at all if
+you disable \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR when embedding libev).
+.PP
+Currently, functions, static and non-static member functions and classes
+with \f(CW\*(C`operator ()\*(C'\fR can be used as callbacks. Other types should be easy
+to add as long as they only need one additional pointer for context. If
+you need support for other types of functors please contact the author
+(preferably after implementing it).
+.PP
+For all this to work, your \*(C+ compiler either has to use the same calling
+conventions as your C compiler (for static member functions), or you have
+to embed libev and compile libev itself as \*(C+.
+.PP
+Here is a list of things available in the \f(CW\*(C`ev\*(C'\fR namespace:
+.ie n .IP """ev::READ"", ""ev::WRITE"" etc." 4
+.el .IP "\f(CWev::READ\fR, \f(CWev::WRITE\fR etc." 4
+.IX Item "ev::READ, ev::WRITE etc."
+These are just enum values with the same values as the \f(CW\*(C`EV_READ\*(C'\fR etc.
+macros from \fIev.h\fR.
+.ie n .IP """ev::tstamp"", ""ev::now""" 4
+.el .IP "\f(CWev::tstamp\fR, \f(CWev::now\fR" 4
+.IX Item "ev::tstamp, ev::now"
+Aliases to the same types/functions as with the \f(CW\*(C`ev_\*(C'\fR prefix.
+.ie n .IP """ev::io"", ""ev::timer"", ""ev::periodic"", ""ev::idle"", ""ev::sig"" etc." 4
+.el .IP "\f(CWev::io\fR, \f(CWev::timer\fR, \f(CWev::periodic\fR, \f(CWev::idle\fR, \f(CWev::sig\fR etc." 4
+.IX Item "ev::io, ev::timer, ev::periodic, ev::idle, ev::sig etc."
+For each \f(CW\*(C`ev_TYPE\*(C'\fR watcher in \fIev.h\fR there is a corresponding class of
+the same name in the \f(CW\*(C`ev\*(C'\fR namespace, with the exception of \f(CW\*(C`ev_signal\*(C'\fR
+which is called \f(CW\*(C`ev::sig\*(C'\fR to avoid clashes with the \f(CW\*(C`signal\*(C'\fR macro
+defined by many implementations.
+.Sp
+All of those classes have these methods:
+.RS 4
+.IP "ev::TYPE::TYPE ()" 4
+.IX Item "ev::TYPE::TYPE ()"
+.PD 0
+.IP "ev::TYPE::TYPE (loop)" 4
+.IX Item "ev::TYPE::TYPE (loop)"
+.IP "ev::TYPE::~TYPE" 4
+.IX Item "ev::TYPE::~TYPE"
+.PD
+The constructor (optionally) takes an event loop to associate the watcher
+with. If it is omitted, it will use \f(CW\*(C`EV_DEFAULT\*(C'\fR.
+.Sp
+The constructor calls \f(CW\*(C`ev_init\*(C'\fR for you, which means you have to call the
+\&\f(CW\*(C`set\*(C'\fR method before starting it.
+.Sp
+It will not set a callback, however: You have to call the templated \f(CW\*(C`set\*(C'\fR
+method to set a callback before you can start the watcher.
+.Sp
+(The reason why you have to use a method is a limitation in \*(C+ which does
+not allow explicit template arguments for constructors).
+.Sp
+The destructor automatically stops the watcher if it is active.
+.IP "w\->set<class, &class::method> (object *)" 4
+.IX Item "w->set<class, &class::method> (object *)"
+This method sets the callback method to call. The method has to have a
+signature of \f(CW\*(C`void (*)(ev_TYPE &, int)\*(C'\fR, it receives the watcher as
+first argument and the \f(CW\*(C`revents\*(C'\fR as second. The object must be given as
+parameter and is stored in the \f(CW\*(C`data\*(C'\fR member of the watcher.
+.Sp
+This method synthesizes efficient thunking code to call your method from
+the C callback that libev requires. If your compiler can inline your
+callback (i.e. it is visible to it at the place of the \f(CW\*(C`set\*(C'\fR call and
+your compiler is good :), then the method will be fully inlined into the
+thunking function, making it as fast as a direct C callback.
+.Sp
+Example: simple class declaration and watcher initialisation
+.Sp
+.Vb 4
+\&   struct myclass
+\&   {
+\&     void io_cb (ev::io &w, int revents) { }
+\&   }
+\&
+\&   myclass obj;
+\&   ev::io iow;
+\&   iow.set <myclass, &myclass::io_cb> (&obj);
+.Ve
+.IP "w\->set (object *)" 4
+.IX Item "w->set (object *)"
+This is a variation of a method callback \- leaving out the method to call
+will default the method to \f(CW\*(C`operator ()\*(C'\fR, which makes it possible to use
+functor objects without having to manually specify the \f(CW\*(C`operator ()\*(C'\fR all
+the time. Incidentally, you can then also leave out the template argument
+list.
+.Sp
+The \f(CW\*(C`operator ()\*(C'\fR method prototype must be \f(CW\*(C`void operator ()(watcher &w,
+int revents)\*(C'\fR.
+.Sp
+See the method\-\f(CW\*(C`set\*(C'\fR above for more details.
+.Sp
+Example: use a functor object as callback.
+.Sp
+.Vb 7
+\&   struct myfunctor
+\&   {
+\&     void operator() (ev::io &w, int revents)
+\&     {
+\&       ...
+\&     }
+\&   }
+\&
+\&   myfunctor f;
+\&
+\&   ev::io w;
+\&   w.set (&f);
+.Ve
+.IP "w\->set<function> (void *data = 0)" 4
+.IX Item "w->set<function> (void *data = 0)"
+Also sets a callback, but uses a static method or plain function as
+callback. The optional \f(CW\*(C`data\*(C'\fR argument will be stored in the watcher's
+\&\f(CW\*(C`data\*(C'\fR member and is free for you to use.
+.Sp
+The prototype of the \f(CW\*(C`function\*(C'\fR must be \f(CW\*(C`void (*)(ev::TYPE &w, int)\*(C'\fR.
+.Sp
+See the method\-\f(CW\*(C`set\*(C'\fR above for more details.
+.Sp
+Example: Use a plain function as callback.
+.Sp
+.Vb 2
+\&   static void io_cb (ev::io &w, int revents) { }
+\&   iow.set <io_cb> ();
+.Ve
+.IP "w\->set (loop)" 4
+.IX Item "w->set (loop)"
+Associates a different \f(CW\*(C`struct ev_loop\*(C'\fR with this watcher. You can only
+do this when the watcher is inactive (and not pending either).
+.IP "w\->set ([arguments])" 4
+.IX Item "w->set ([arguments])"
+Basically the same as \f(CW\*(C`ev_TYPE_set\*(C'\fR (except for \f(CW\*(C`ev::embed\*(C'\fR watchers>),
+with the same arguments. Either this method or a suitable start method
+must be called at least once. Unlike the C counterpart, an active watcher
+gets automatically stopped and restarted when reconfiguring it with this
+method.
+.Sp
+For \f(CW\*(C`ev::embed\*(C'\fR watchers this method is called \f(CW\*(C`set_embed\*(C'\fR, to avoid
+clashing with the \f(CW\*(C`set (loop)\*(C'\fR method.
+.IP "w\->start ()" 4
+.IX Item "w->start ()"
+Starts the watcher. Note that there is no \f(CW\*(C`loop\*(C'\fR argument, as the
+constructor already stores the event loop.
+.IP "w\->start ([arguments])" 4
+.IX Item "w->start ([arguments])"
+Instead of calling \f(CW\*(C`set\*(C'\fR and \f(CW\*(C`start\*(C'\fR methods separately, it is often
+convenient to wrap them in one call. Uses the same type of arguments as
+the configure \f(CW\*(C`set\*(C'\fR method of the watcher.
+.IP "w\->stop ()" 4
+.IX Item "w->stop ()"
+Stops the watcher if it is active. Again, no \f(CW\*(C`loop\*(C'\fR argument.
+.ie n .IP "w\->again () (""ev::timer"", ""ev::periodic"" only)" 4
+.el .IP "w\->again () (\f(CWev::timer\fR, \f(CWev::periodic\fR only)" 4
+.IX Item "w->again () (ev::timer, ev::periodic only)"
+For \f(CW\*(C`ev::timer\*(C'\fR and \f(CW\*(C`ev::periodic\*(C'\fR, this invokes the corresponding
+\&\f(CW\*(C`ev_TYPE_again\*(C'\fR function.
+.ie n .IP "w\->sweep () (""ev::embed"" only)" 4
+.el .IP "w\->sweep () (\f(CWev::embed\fR only)" 4
+.IX Item "w->sweep () (ev::embed only)"
+Invokes \f(CW\*(C`ev_embed_sweep\*(C'\fR.
+.ie n .IP "w\->update () (""ev::stat"" only)" 4
+.el .IP "w\->update () (\f(CWev::stat\fR only)" 4
+.IX Item "w->update () (ev::stat only)"
+Invokes \f(CW\*(C`ev_stat_stat\*(C'\fR.
+.RE
+.RS 4
+.RE
+.PP
+Example: Define a class with two I/O and idle watchers, start the I/O
+watchers in the constructor.
+.PP
+.Vb 5
+\&   class myclass
+\&   {
+\&     ev::io   io  ; void io_cb   (ev::io   &w, int revents);
+\&     ev::io   io2 ; void io2_cb  (ev::io   &w, int revents);
+\&     ev::idle idle; void idle_cb (ev::idle &w, int revents);
+\&
+\&     myclass (int fd)
+\&     {
+\&       io  .set <myclass, &myclass::io_cb  > (this);
+\&       io2 .set <myclass, &myclass::io2_cb > (this);
+\&       idle.set <myclass, &myclass::idle_cb> (this);
+\&
+\&       io.set (fd, ev::WRITE); // configure the watcher
+\&       io.start ();            // start it whenever convenient
+\&
+\&       io2.start (fd, ev::READ); // set + start in one call
+\&     }
+\&   };
+.Ve
+.SH "OTHER LANGUAGE BINDINGS"
+.IX Header "OTHER LANGUAGE BINDINGS"
+Libev does not offer other language bindings itself, but bindings for a
+number of languages exist in the form of third-party packages. If you know
+any interesting language binding in addition to the ones listed here, drop
+me a note.
+.IP "Perl" 4
+.IX Item "Perl"
+The \s-1EV\s0 module implements the full libev \s-1API\s0 and is actually used to test
+libev. \s-1EV\s0 is developed together with libev. Apart from the \s-1EV\s0 core module,
+there are additional modules that implement libev-compatible interfaces
+to \f(CW\*(C`libadns\*(C'\fR (\f(CW\*(C`EV::ADNS\*(C'\fR, but \f(CW\*(C`AnyEvent::DNS\*(C'\fR is preferred nowadays),
+\&\f(CW\*(C`Net::SNMP\*(C'\fR (\f(CW\*(C`Net::SNMP::EV\*(C'\fR) and the \f(CW\*(C`libglib\*(C'\fR event core (\f(CW\*(C`Glib::EV\*(C'\fR
+and \f(CW\*(C`EV::Glib\*(C'\fR).
+.Sp
+It can be found and installed via \s-1CPAN,\s0 its homepage is at
+<http://software.schmorp.de/pkg/EV>.
+.IP "Python" 4
+.IX Item "Python"
+Python bindings can be found at <http://code.google.com/p/pyev/>. It
+seems to be quite complete and well-documented.
+.IP "Ruby" 4
+.IX Item "Ruby"
+Tony Arcieri has written a ruby extension that offers access to a subset
+of the libev \s-1API\s0 and adds file handle abstractions, asynchronous \s-1DNS\s0 and
+more on top of it. It can be found via gem servers. Its homepage is at
+<http://rev.rubyforge.org/>.
+.Sp
+Roger Pack reports that using the link order \f(CW\*(C`\-lws2_32 \-lmsvcrt\-ruby\-190\*(C'\fR
+makes rev work even on mingw.
+.IP "Haskell" 4
+.IX Item "Haskell"
+A haskell binding to libev is available at
+<http://hackage.haskell.org/cgi\-bin/hackage\-scripts/package/hlibev>.
+.IP "D" 4
+.IX Item "D"
+Leandro Lucarella has written a D language binding (\fIev.d\fR) for libev, to
+be found at <http://www.llucax.com.ar/proj/ev.d/index.html>.
+.IP "Ocaml" 4
+.IX Item "Ocaml"
+Erkki Seppala has written Ocaml bindings for libev, to be found at
+<http://modeemi.cs.tut.fi/~flux/software/ocaml\-ev/>.
+.IP "Lua" 4
+.IX Item "Lua"
+Brian Maher has written a partial interface to libev for lua (at the
+time of this writing, only \f(CW\*(C`ev_io\*(C'\fR and \f(CW\*(C`ev_timer\*(C'\fR), to be found at
+<http://github.com/brimworks/lua\-ev>.
+.IP "Javascript" 4
+.IX Item "Javascript"
+Node.js (<http://nodejs.org>) uses libev as the underlying event library.
+.IP "Others" 4
+.IX Item "Others"
+There are others, and I stopped counting.
+.SH "MACRO MAGIC"
+.IX Header "MACRO MAGIC"
+Libev can be compiled with a variety of options, the most fundamental
+of which is \f(CW\*(C`EV_MULTIPLICITY\*(C'\fR. This option determines whether (most)
+functions and callbacks have an initial \f(CW\*(C`struct ev_loop *\*(C'\fR argument.
+.PP
+To make it easier to write programs that cope with either variant, the
+following macros are defined:
+.ie n .IP """EV_A"", ""EV_A_""" 4
+.el .IP "\f(CWEV_A\fR, \f(CWEV_A_\fR" 4
+.IX Item "EV_A, EV_A_"
+This provides the loop \fIargument\fR for functions, if one is required (\*(L"ev
+loop argument\*(R"). The \f(CW\*(C`EV_A\*(C'\fR form is used when this is the sole argument,
+\&\f(CW\*(C`EV_A_\*(C'\fR is used when other arguments are following. Example:
+.Sp
+.Vb 3
+\&   ev_unref (EV_A);
+\&   ev_timer_add (EV_A_ watcher);
+\&   ev_run (EV_A_ 0);
+.Ve
+.Sp
+It assumes the variable \f(CW\*(C`loop\*(C'\fR of type \f(CW\*(C`struct ev_loop *\*(C'\fR is in scope,
+which is often provided by the following macro.
+.ie n .IP """EV_P"", ""EV_P_""" 4
+.el .IP "\f(CWEV_P\fR, \f(CWEV_P_\fR" 4
+.IX Item "EV_P, EV_P_"
+This provides the loop \fIparameter\fR for functions, if one is required (\*(L"ev
+loop parameter\*(R"). The \f(CW\*(C`EV_P\*(C'\fR form is used when this is the sole parameter,
+\&\f(CW\*(C`EV_P_\*(C'\fR is used when other parameters are following. Example:
+.Sp
+.Vb 2
+\&   // this is how ev_unref is being declared
+\&   static void ev_unref (EV_P);
+\&
+\&   // this is how you can declare your typical callback
+\&   static void cb (EV_P_ ev_timer *w, int revents)
+.Ve
+.Sp
+It declares a parameter \f(CW\*(C`loop\*(C'\fR of type \f(CW\*(C`struct ev_loop *\*(C'\fR, quite
+suitable for use with \f(CW\*(C`EV_A\*(C'\fR.
+.ie n .IP """EV_DEFAULT"", ""EV_DEFAULT_""" 4
+.el .IP "\f(CWEV_DEFAULT\fR, \f(CWEV_DEFAULT_\fR" 4
+.IX Item "EV_DEFAULT, EV_DEFAULT_"
+Similar to the other two macros, this gives you the value of the default
+loop, if multiple loops are supported (\*(L"ev loop default\*(R"). The default loop
+will be initialised if it isn't already initialised.
+.Sp
+For non-multiplicity builds, these macros do nothing, so you always have
+to initialise the loop somewhere.
+.ie n .IP """EV_DEFAULT_UC"", ""EV_DEFAULT_UC_""" 4
+.el .IP "\f(CWEV_DEFAULT_UC\fR, \f(CWEV_DEFAULT_UC_\fR" 4
+.IX Item "EV_DEFAULT_UC, EV_DEFAULT_UC_"
+Usage identical to \f(CW\*(C`EV_DEFAULT\*(C'\fR and \f(CW\*(C`EV_DEFAULT_\*(C'\fR, but requires that the
+default loop has been initialised (\f(CW\*(C`UC\*(C'\fR == unchecked). Their behaviour
+is undefined when the default loop has not been initialised by a previous
+execution of \f(CW\*(C`EV_DEFAULT\*(C'\fR, \f(CW\*(C`EV_DEFAULT_\*(C'\fR or \f(CW\*(C`ev_default_init (...)\*(C'\fR.
+.Sp
+It is often prudent to use \f(CW\*(C`EV_DEFAULT\*(C'\fR when initialising the first
+watcher in a function but use \f(CW\*(C`EV_DEFAULT_UC\*(C'\fR afterwards.
+.PP
+Example: Declare and initialise a check watcher, utilising the above
+macros so it will work regardless of whether multiple loops are supported
+or not.
+.PP
+.Vb 5
+\&   static void
+\&   check_cb (EV_P_ ev_timer *w, int revents)
+\&   {
+\&     ev_check_stop (EV_A_ w);
+\&   }
+\&
+\&   ev_check check;
+\&   ev_check_init (&check, check_cb);
+\&   ev_check_start (EV_DEFAULT_ &check);
+\&   ev_run (EV_DEFAULT_ 0);
+.Ve
+.SH "EMBEDDING"
+.IX Header "EMBEDDING"
+Libev can (and often is) directly embedded into host
+applications. Examples of applications that embed it include the Deliantra
+Game Server, the \s-1EV\s0 perl module, the \s-1GNU\s0 Virtual Private Ethernet (gvpe)
+and rxvt-unicode.
+.PP
+The goal is to enable you to just copy the necessary files into your
+source directory without having to change even a single line in them, so
+you can easily upgrade by simply copying (or having a checked-out copy of
+libev somewhere in your source tree).
+.SS "\s-1FILESETS\s0"
+.IX Subsection "FILESETS"
+Depending on what features you need you need to include one or more sets of files
+in your application.
+.PP
+\fI\s-1CORE EVENT LOOP\s0\fR
+.IX Subsection "CORE EVENT LOOP"
+.PP
+To include only the libev core (all the \f(CW\*(C`ev_*\*(C'\fR functions), with manual
+configuration (no autoconf):
+.PP
+.Vb 2
+\&   #define EV_STANDALONE 1
+\&   #include "ev.c"
+.Ve
+.PP
+This will automatically include \fIev.h\fR, too, and should be done in a
+single C source file only to provide the function implementations. To use
+it, do the same for \fIev.h\fR in all files wishing to use this \s-1API \s0(best
+done by writing a wrapper around \fIev.h\fR that you can include instead and
+where you can put other configuration options):
+.PP
+.Vb 2
+\&   #define EV_STANDALONE 1
+\&   #include "ev.h"
+.Ve
+.PP
+Both header files and implementation files can be compiled with a \*(C+
+compiler (at least, that's a stated goal, and breakage will be treated
+as a bug).
+.PP
+You need the following files in your source tree, or in a directory
+in your include path (e.g. in libev/ when using \-Ilibev):
+.PP
+.Vb 4
+\&   ev.h
+\&   ev.c
+\&   ev_vars.h
+\&   ev_wrap.h
+\&
+\&   ev_win32.c      required on win32 platforms only
+\&
+\&   ev_select.c     only when select backend is enabled (which is enabled by default)
+\&   ev_poll.c       only when poll backend is enabled (disabled by default)
+\&   ev_epoll.c      only when the epoll backend is enabled (disabled by default)
+\&   ev_kqueue.c     only when the kqueue backend is enabled (disabled by default)
+\&   ev_port.c       only when the solaris port backend is enabled (disabled by default)
+.Ve
+.PP
+\&\fIev.c\fR includes the backend files directly when enabled, so you only need
+to compile this single file.
+.PP
+\fI\s-1LIBEVENT COMPATIBILITY API\s0\fR
+.IX Subsection "LIBEVENT COMPATIBILITY API"
+.PP
+To include the libevent compatibility \s-1API,\s0 also include:
+.PP
+.Vb 1
+\&   #include "event.c"
+.Ve
+.PP
+in the file including \fIev.c\fR, and:
+.PP
+.Vb 1
+\&   #include "event.h"
+.Ve
+.PP
+in the files that want to use the libevent \s-1API.\s0 This also includes \fIev.h\fR.
+.PP
+You need the following additional files for this:
+.PP
+.Vb 2
+\&   event.h
+\&   event.c
+.Ve
+.PP
+\fI\s-1AUTOCONF SUPPORT\s0\fR
+.IX Subsection "AUTOCONF SUPPORT"
+.PP
+Instead of using \f(CW\*(C`EV_STANDALONE=1\*(C'\fR and providing your configuration in
+whatever way you want, you can also \f(CW\*(C`m4_include([libev.m4])\*(C'\fR in your
+\&\fIconfigure.ac\fR and leave \f(CW\*(C`EV_STANDALONE\*(C'\fR undefined. \fIev.c\fR will then
+include \fIconfig.h\fR and configure itself accordingly.
+.PP
+For this of course you need the m4 file:
+.PP
+.Vb 1
+\&   libev.m4
+.Ve
+.SS "\s-1PREPROCESSOR SYMBOLS/MACROS\s0"
+.IX Subsection "PREPROCESSOR SYMBOLS/MACROS"
+Libev can be configured via a variety of preprocessor symbols you have to
+define before including (or compiling) any of its files. The default in
+the absence of autoconf is documented for every option.
+.PP
+Symbols marked with \*(L"(h)\*(R" do not change the \s-1ABI,\s0 and can have different
+values when compiling libev vs. including \fIev.h\fR, so it is permissible
+to redefine them before including \fIev.h\fR without breaking compatibility
+to a compiled library. All other symbols change the \s-1ABI,\s0 which means all
+users of libev and the libev code itself must be compiled with compatible
+settings.
+.IP "\s-1EV_COMPAT3 \s0(h)" 4
+.IX Item "EV_COMPAT3 (h)"
+Backwards compatibility is a major concern for libev. This is why this
+release of libev comes with wrappers for the functions and symbols that
+have been renamed between libev version 3 and 4.
+.Sp
+You can disable these wrappers (to test compatibility with future
+versions) by defining \f(CW\*(C`EV_COMPAT3\*(C'\fR to \f(CW0\fR when compiling your
+sources. This has the additional advantage that you can drop the \f(CW\*(C`struct\*(C'\fR
+from \f(CW\*(C`struct ev_loop\*(C'\fR declarations, as libev will provide an \f(CW\*(C`ev_loop\*(C'\fR
+typedef in that case.
+.Sp
+In some future version, the default for \f(CW\*(C`EV_COMPAT3\*(C'\fR will become \f(CW0\fR,
+and in some even more future version the compatibility code will be
+removed completely.
+.IP "\s-1EV_STANDALONE \s0(h)" 4
+.IX Item "EV_STANDALONE (h)"
+Must always be \f(CW1\fR if you do not use autoconf configuration, which
+keeps libev from including \fIconfig.h\fR, and it also defines dummy
+implementations for some libevent functions (such as logging, which is not
+supported). It will also not define any of the structs usually found in
+\&\fIevent.h\fR that are not directly supported by the libev core alone.
+.Sp
+In standalone mode, libev will still try to automatically deduce the
+configuration, but has to be more conservative.
+.IP "\s-1EV_USE_FLOOR\s0" 4
+.IX Item "EV_USE_FLOOR"
+If defined to be \f(CW1\fR, libev will use the \f(CW\*(C`floor ()\*(C'\fR function for its
+periodic reschedule calculations, otherwise libev will fall back on a
+portable (slower) implementation. If you enable this, you usually have to
+link against libm or something equivalent. Enabling this when the \f(CW\*(C`floor\*(C'\fR
+function is not available will fail, so the safe default is to not enable
+this.
+.IP "\s-1EV_USE_MONOTONIC\s0" 4
+.IX Item "EV_USE_MONOTONIC"
+If defined to be \f(CW1\fR, libev will try to detect the availability of the
+monotonic clock option at both compile time and runtime. Otherwise no
+use of the monotonic clock option will be attempted. If you enable this,
+you usually have to link against librt or something similar. Enabling it
+when the functionality isn't available is safe, though, although you have
+to make sure you link against any libraries where the \f(CW\*(C`clock_gettime\*(C'\fR
+function is hiding in (often \fI\-lrt\fR). See also \f(CW\*(C`EV_USE_CLOCK_SYSCALL\*(C'\fR.
+.IP "\s-1EV_USE_REALTIME\s0" 4
+.IX Item "EV_USE_REALTIME"
+If defined to be \f(CW1\fR, libev will try to detect the availability of the
+real-time clock option at compile time (and assume its availability
+at runtime if successful). Otherwise no use of the real-time clock
+option will be attempted. This effectively replaces \f(CW\*(C`gettimeofday\*(C'\fR
+by \f(CW\*(C`clock_get (CLOCK_REALTIME, ...)\*(C'\fR and will not normally affect
+correctness. See the note about libraries in the description of
+\&\f(CW\*(C`EV_USE_MONOTONIC\*(C'\fR, though. Defaults to the opposite value of
+\&\f(CW\*(C`EV_USE_CLOCK_SYSCALL\*(C'\fR.
+.IP "\s-1EV_USE_CLOCK_SYSCALL\s0" 4
+.IX Item "EV_USE_CLOCK_SYSCALL"
+If defined to be \f(CW1\fR, libev will try to use a direct syscall instead
+of calling the system-provided \f(CW\*(C`clock_gettime\*(C'\fR function. This option
+exists because on GNU/Linux, \f(CW\*(C`clock_gettime\*(C'\fR is in \f(CW\*(C`librt\*(C'\fR, but \f(CW\*(C`librt\*(C'\fR
+unconditionally pulls in \f(CW\*(C`libpthread\*(C'\fR, slowing down single-threaded
+programs needlessly. Using a direct syscall is slightly slower (in
+theory), because no optimised vdso implementation can be used, but avoids
+the pthread dependency. Defaults to \f(CW1\fR on GNU/Linux with glibc 2.x or
+higher, as it simplifies linking (no need for \f(CW\*(C`\-lrt\*(C'\fR).
+.IP "\s-1EV_USE_NANOSLEEP\s0" 4
+.IX Item "EV_USE_NANOSLEEP"
+If defined to be \f(CW1\fR, libev will assume that \f(CW\*(C`nanosleep ()\*(C'\fR is available
+and will use it for delays. Otherwise it will use \f(CW\*(C`select ()\*(C'\fR.
+.IP "\s-1EV_USE_EVENTFD\s0" 4
+.IX Item "EV_USE_EVENTFD"
+If defined to be \f(CW1\fR, then libev will assume that \f(CW\*(C`eventfd ()\*(C'\fR is
+available and will probe for kernel support at runtime. This will improve
+\&\f(CW\*(C`ev_signal\*(C'\fR and \f(CW\*(C`ev_async\*(C'\fR performance and reduce resource consumption.
+If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc
+2.7 or newer, otherwise disabled.
+.IP "\s-1EV_USE_SELECT\s0" 4
+.IX Item "EV_USE_SELECT"
+If undefined or defined to be \f(CW1\fR, libev will compile in support for the
+\&\f(CW\*(C`select\*(C'\fR(2) backend. No attempt at auto-detection will be done: if no
+other method takes over, select will be it. Otherwise the select backend
+will not be compiled in.
+.IP "\s-1EV_SELECT_USE_FD_SET\s0" 4
+.IX Item "EV_SELECT_USE_FD_SET"
+If defined to \f(CW1\fR, then the select backend will use the system \f(CW\*(C`fd_set\*(C'\fR
+structure. This is useful if libev doesn't compile due to a missing
+\&\f(CW\*(C`NFDBITS\*(C'\fR or \f(CW\*(C`fd_mask\*(C'\fR definition or it mis-guesses the bitset layout
+on exotic systems. This usually limits the range of file descriptors to
+some low limit such as 1024 or might have other limitations (winsocket
+only allows 64 sockets). The \f(CW\*(C`FD_SETSIZE\*(C'\fR macro, set before compilation,
+configures the maximum size of the \f(CW\*(C`fd_set\*(C'\fR.
+.IP "\s-1EV_SELECT_IS_WINSOCKET\s0" 4
+.IX Item "EV_SELECT_IS_WINSOCKET"
+When defined to \f(CW1\fR, the select backend will assume that
+select/socket/connect etc. don't understand file descriptors but
+wants osf handles on win32 (this is the case when the select to
+be used is the winsock select). This means that it will call
+\&\f(CW\*(C`_get_osfhandle\*(C'\fR on the fd to convert it to an \s-1OS\s0 handle. Otherwise,
+it is assumed that all these functions actually work on fds, even
+on win32. Should not be defined on non\-win32 platforms.
+.IP "\s-1EV_FD_TO_WIN32_HANDLE\s0(fd)" 4
+.IX Item "EV_FD_TO_WIN32_HANDLE(fd)"
+If \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR is enabled, then libev needs a way to map
+file descriptors to socket handles. When not defining this symbol (the
+default), then libev will call \f(CW\*(C`_get_osfhandle\*(C'\fR, which is usually
+correct. In some cases, programs use their own file descriptor management,
+in which case they can provide this function to map fds to socket handles.
+.IP "\s-1EV_WIN32_HANDLE_TO_FD\s0(handle)" 4
+.IX Item "EV_WIN32_HANDLE_TO_FD(handle)"
+If \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR then libev maps handles to file descriptors
+using the standard \f(CW\*(C`_open_osfhandle\*(C'\fR function. For programs implementing
+their own fd to handle mapping, overwriting this function makes it easier
+to do so. This can be done by defining this macro to an appropriate value.
+.IP "\s-1EV_WIN32_CLOSE_FD\s0(fd)" 4
+.IX Item "EV_WIN32_CLOSE_FD(fd)"
+If programs implement their own fd to handle mapping on win32, then this
+macro can be used to override the \f(CW\*(C`close\*(C'\fR function, useful to unregister
+file descriptors again. Note that the replacement function has to close
+the underlying \s-1OS\s0 handle.
+.IP "\s-1EV_USE_WSASOCKET\s0" 4
+.IX Item "EV_USE_WSASOCKET"
+If defined to be \f(CW1\fR, libev will use \f(CW\*(C`WSASocket\*(C'\fR to create its internal
+communication socket, which works better in some environments. Otherwise,
+the normal \f(CW\*(C`socket\*(C'\fR function will be used, which works better in other
+environments.
+.IP "\s-1EV_USE_POLL\s0" 4
+.IX Item "EV_USE_POLL"
+If defined to be \f(CW1\fR, libev will compile in support for the \f(CW\*(C`poll\*(C'\fR(2)
+backend. Otherwise it will be enabled on non\-win32 platforms. It
+takes precedence over select.
+.IP "\s-1EV_USE_EPOLL\s0" 4
+.IX Item "EV_USE_EPOLL"
+If defined to be \f(CW1\fR, libev will compile in support for the Linux
+\&\f(CW\*(C`epoll\*(C'\fR(7) backend. Its availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for GNU/Linux systems. If undefined, it will be enabled if the
+headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
+.IP "\s-1EV_USE_KQUEUE\s0" 4
+.IX Item "EV_USE_KQUEUE"
+If defined to be \f(CW1\fR, libev will compile in support for the \s-1BSD\s0 style
+\&\f(CW\*(C`kqueue\*(C'\fR(2) backend. Its actual availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for \s-1BSD\s0 and BSD-like systems, although on most BSDs kqueue only
+supports some types of fds correctly (the only platform we found that
+supports ptys for example was NetBSD), so kqueue might be compiled in, but
+not be used unless explicitly requested. The best way to use it is to find
+out whether kqueue supports your type of fd properly and use an embedded
+kqueue loop.
+.IP "\s-1EV_USE_PORT\s0" 4
+.IX Item "EV_USE_PORT"
+If defined to be \f(CW1\fR, libev will compile in support for the Solaris
+10 port style backend. Its availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for Solaris 10 systems.
+.IP "\s-1EV_USE_DEVPOLL\s0" 4
+.IX Item "EV_USE_DEVPOLL"
+Reserved for future expansion, works like the \s-1USE\s0 symbols above.
+.IP "\s-1EV_USE_INOTIFY\s0" 4
+.IX Item "EV_USE_INOTIFY"
+If defined to be \f(CW1\fR, libev will compile in support for the Linux inotify
+interface to speed up \f(CW\*(C`ev_stat\*(C'\fR watchers. Its actual availability will
+be detected at runtime. If undefined, it will be enabled if the headers
+indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
+.IP "\s-1EV_NO_SMP\s0" 4
+.IX Item "EV_NO_SMP"
+If defined to be \f(CW1\fR, libev will assume that memory is always coherent
+between threads, that is, threads can be used, but threads never run on
+different cpus (or different cpu cores). This reduces dependencies
+and makes libev faster.
+.IP "\s-1EV_NO_THREADS\s0" 4
+.IX Item "EV_NO_THREADS"
+If defined to be \f(CW1\fR, libev will assume that it will never be called from
+different threads (that includes signal handlers), which is a stronger
+assumption than \f(CW\*(C`EV_NO_SMP\*(C'\fR, above. This reduces dependencies and makes
+libev faster.
+.IP "\s-1EV_ATOMIC_T\s0" 4
+.IX Item "EV_ATOMIC_T"
+Libev requires an integer type (suitable for storing \f(CW0\fR or \f(CW1\fR) whose
+access is atomic with respect to other threads or signal contexts. No
+such type is easily found in the C language, so you can provide your own
+type that you know is safe for your purposes. It is used both for signal
+handler \*(L"locking\*(R" as well as for signal and thread safety in \f(CW\*(C`ev_async\*(C'\fR
+watchers.
+.Sp
+In the absence of this define, libev will use \f(CW\*(C`sig_atomic_t volatile\*(C'\fR
+(from \fIsignal.h\fR), which is usually good enough on most platforms.
+.IP "\s-1EV_H \s0(h)" 4
+.IX Item "EV_H (h)"
+The name of the \fIev.h\fR header file used to include it. The default if
+undefined is \f(CW"ev.h"\fR in \fIevent.h\fR, \fIev.c\fR and \fIev++.h\fR. This can be
+used to virtually rename the \fIev.h\fR header file in case of conflicts.
+.IP "\s-1EV_CONFIG_H \s0(h)" 4
+.IX Item "EV_CONFIG_H (h)"
+If \f(CW\*(C`EV_STANDALONE\*(C'\fR isn't \f(CW1\fR, this variable can be used to override
+\&\fIev.c\fR's idea of where to find the \fIconfig.h\fR file, similarly to
+\&\f(CW\*(C`EV_H\*(C'\fR, above.
+.IP "\s-1EV_EVENT_H \s0(h)" 4
+.IX Item "EV_EVENT_H (h)"
+Similarly to \f(CW\*(C`EV_H\*(C'\fR, this macro can be used to override \fIevent.c\fR's idea
+of how the \fIevent.h\fR header can be found, the default is \f(CW"event.h"\fR.
+.IP "\s-1EV_PROTOTYPES \s0(h)" 4
+.IX Item "EV_PROTOTYPES (h)"
+If defined to be \f(CW0\fR, then \fIev.h\fR will not define any function
+prototypes, but still define all the structs and other symbols. This is
+occasionally useful if you want to provide your own wrapper functions
+around libev functions.
+.IP "\s-1EV_MULTIPLICITY\s0" 4
+.IX Item "EV_MULTIPLICITY"
+If undefined or defined to \f(CW1\fR, then all event-loop-specific functions
+will have the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument, and you can create
+additional independent event loops. Otherwise there will be no support
+for multiple event loops and there is no first event loop pointer
+argument. Instead, all functions act on the single default loop.
+.Sp
+Note that \f(CW\*(C`EV_DEFAULT\*(C'\fR and \f(CW\*(C`EV_DEFAULT_\*(C'\fR will no longer provide a
+default loop when multiplicity is switched off \- you always have to
+initialise the loop manually in this case.
+.IP "\s-1EV_MINPRI\s0" 4
+.IX Item "EV_MINPRI"
+.PD 0
+.IP "\s-1EV_MAXPRI\s0" 4
+.IX Item "EV_MAXPRI"
+.PD
+The range of allowed priorities. \f(CW\*(C`EV_MINPRI\*(C'\fR must be smaller or equal to
+\&\f(CW\*(C`EV_MAXPRI\*(C'\fR, but otherwise there are no non-obvious limitations. You can
+provide for more priorities by overriding those symbols (usually defined
+to be \f(CW\*(C`\-2\*(C'\fR and \f(CW2\fR, respectively).
+.Sp
+When doing priority-based operations, libev usually has to linearly search
+all the priorities, so having many of them (hundreds) uses a lot of space
+and time, so using the defaults of five priorities (\-2 .. +2) is usually
+fine.
+.Sp
+If your embedding application does not need any priorities, defining these
+both to \f(CW0\fR will save some memory and \s-1CPU.\s0
+.IP "\s-1EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE, EV_ASYNC_ENABLE, EV_CHILD_ENABLE.\s0" 4
+.IX Item "EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE, EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE, EV_ASYNC_ENABLE, EV_CHILD_ENABLE."
+If undefined or defined to be \f(CW1\fR (and the platform supports it), then
+the respective watcher type is supported. If defined to be \f(CW0\fR, then it
+is not. Disabling watcher types mainly saves code size.
+.IP "\s-1EV_FEATURES\s0" 4
+.IX Item "EV_FEATURES"
+If you need to shave off some kilobytes of code at the expense of some
+speed (but with the full \s-1API\s0), you can define this symbol to request
+certain subsets of functionality. The default is to enable all features
+that can be enabled on the platform.
+.Sp
+A typical way to use this symbol is to define it to \f(CW0\fR (or to a bitset
+with some broad features you want) and then selectively re-enable
+additional parts you want, for example if you want everything minimal,
+but multiple event loop support, async and child watchers and the poll
+backend, use this:
+.Sp
+.Vb 5
+\&   #define EV_FEATURES 0
+\&   #define EV_MULTIPLICITY 1
+\&   #define EV_USE_POLL 1
+\&   #define EV_CHILD_ENABLE 1
+\&   #define EV_ASYNC_ENABLE 1
+.Ve
+.Sp
+The actual value is a bitset, it can be a combination of the following
+values (by default, all of these are enabled):
+.RS 4
+.ie n .IP "1 \- faster/larger code" 4
+.el .IP "\f(CW1\fR \- faster/larger code" 4
+.IX Item "1 - faster/larger code"
+Use larger code to speed up some operations.
+.Sp
+Currently this is used to override some inlining decisions (enlarging the
+code size by roughly 30% on amd64).
+.Sp
+When optimising for size, use of compiler flags such as \f(CW\*(C`\-Os\*(C'\fR with
+gcc is recommended, as well as \f(CW\*(C`\-DNDEBUG\*(C'\fR, as libev contains a number of
+assertions.
+.Sp
+The default is off when \f(CW\*(C`_\|_OPTIMIZE_SIZE_\|_\*(C'\fR is defined by your compiler
+(e.g. gcc with \f(CW\*(C`\-Os\*(C'\fR).
+.ie n .IP "2 \- faster/larger data structures" 4
+.el .IP "\f(CW2\fR \- faster/larger data structures" 4
+.IX Item "2 - faster/larger data structures"
+Replaces the small 2\-heap for timer management by a faster 4\-heap, larger
+hash table sizes and so on. This will usually further increase code size
+and can additionally have an effect on the size of data structures at
+runtime.
+.Sp
+The default is off when \f(CW\*(C`_\|_OPTIMIZE_SIZE_\|_\*(C'\fR is defined by your compiler
+(e.g. gcc with \f(CW\*(C`\-Os\*(C'\fR).
+.ie n .IP "4 \- full \s-1API\s0 configuration" 4
+.el .IP "\f(CW4\fR \- full \s-1API\s0 configuration" 4
+.IX Item "4 - full API configuration"
+This enables priorities (sets \f(CW\*(C`EV_MAXPRI\*(C'\fR=2 and \f(CW\*(C`EV_MINPRI\*(C'\fR=\-2), and
+enables multiplicity (\f(CW\*(C`EV_MULTIPLICITY\*(C'\fR=1).
+.ie n .IP "8 \- full \s-1API\s0" 4
+.el .IP "\f(CW8\fR \- full \s-1API\s0" 4
+.IX Item "8 - full API"
+This enables a lot of the \*(L"lesser used\*(R" \s-1API\s0 functions. See \f(CW\*(C`ev.h\*(C'\fR for
+details on which parts of the \s-1API\s0 are still available without this
+feature, and do not complain if this subset changes over time.
+.ie n .IP "16 \- enable all optional watcher types" 4
+.el .IP "\f(CW16\fR \- enable all optional watcher types" 4
+.IX Item "16 - enable all optional watcher types"
+Enables all optional watcher types.  If you want to selectively enable
+only some watcher types other than I/O and timers (e.g. prepare,
+embed, async, child...) you can enable them manually by defining
+\&\f(CW\*(C`EV_watchertype_ENABLE\*(C'\fR to \f(CW1\fR instead.
+.ie n .IP "32 \- enable all backends" 4
+.el .IP "\f(CW32\fR \- enable all backends" 4
+.IX Item "32 - enable all backends"
+This enables all backends \- without this feature, you need to enable at
+least one backend manually (\f(CW\*(C`EV_USE_SELECT\*(C'\fR is a good choice).
+.ie n .IP "64 \- enable OS-specific ""helper"" APIs" 4
+.el .IP "\f(CW64\fR \- enable OS-specific ``helper'' APIs" 4
+.IX Item "64 - enable OS-specific helper APIs"
+Enable inotify, eventfd, signalfd and similar OS-specific helper APIs by
+default.
+.RE
+.RS 4
+.Sp
+Compiling with \f(CW\*(C`gcc \-Os \-DEV_STANDALONE \-DEV_USE_EPOLL=1 \-DEV_FEATURES=0\*(C'\fR
+reduces the compiled size of libev from 24.7Kb code/2.8Kb data to 6.5Kb
+code/0.3Kb data on my GNU/Linux amd64 system, while still giving you I/O
+watchers, timers and monotonic clock support.
+.Sp
+With an intelligent-enough linker (gcc+binutils are intelligent enough
+when you use \f(CW\*(C`\-Wl,\-\-gc\-sections \-ffunction\-sections\*(C'\fR) functions unused by
+your program might be left out as well \- a binary starting a timer and an
+I/O watcher then might come out at only 5Kb.
+.RE
+.IP "\s-1EV_API_STATIC\s0" 4
+.IX Item "EV_API_STATIC"
+If this symbol is defined (by default it is not), then all identifiers
+will have static linkage. This means that libev will not export any
+identifiers, and you cannot link against libev anymore. This can be useful
+when you embed libev, only want to use libev functions in a single file,
+and do not want its identifiers to be visible.
+.Sp
+To use this, define \f(CW\*(C`EV_API_STATIC\*(C'\fR and include \fIev.c\fR in the file that
+wants to use libev.
+.Sp
+This option only works when libev is compiled with a C compiler, as \*(C+
+doesn't support the required declaration syntax.
+.IP "\s-1EV_AVOID_STDIO\s0" 4
+.IX Item "EV_AVOID_STDIO"
+If this is set to \f(CW1\fR at compiletime, then libev will avoid using stdio
+functions (printf, scanf, perror etc.). This will increase the code size
+somewhat, but if your program doesn't otherwise depend on stdio and your
+libc allows it, this avoids linking in the stdio library which is quite
+big.
+.Sp
+Note that error messages might become less precise when this option is
+enabled.
+.IP "\s-1EV_NSIG\s0" 4
+.IX Item "EV_NSIG"
+The highest supported signal number, +1 (or, the number of
+signals): Normally, libev tries to deduce the maximum number of signals
+automatically, but sometimes this fails, in which case it can be
+specified. Also, using a lower number than detected (\f(CW32\fR should be
+good for about any system in existence) can save some memory, as libev
+statically allocates some 12\-24 bytes per signal number.
+.IP "\s-1EV_PID_HASHSIZE\s0" 4
+.IX Item "EV_PID_HASHSIZE"
+\&\f(CW\*(C`ev_child\*(C'\fR watchers use a small hash table to distribute workload by
+pid. The default size is \f(CW16\fR (or \f(CW1\fR with \f(CW\*(C`EV_FEATURES\*(C'\fR disabled),
+usually more than enough. If you need to manage thousands of children you
+might want to increase this value (\fImust\fR be a power of two).
+.IP "\s-1EV_INOTIFY_HASHSIZE\s0" 4
+.IX Item "EV_INOTIFY_HASHSIZE"
+\&\f(CW\*(C`ev_stat\*(C'\fR watchers use a small hash table to distribute workload by
+inotify watch id. The default size is \f(CW16\fR (or \f(CW1\fR with \f(CW\*(C`EV_FEATURES\*(C'\fR
+disabled), usually more than enough. If you need to manage thousands of
+\&\f(CW\*(C`ev_stat\*(C'\fR watchers you might want to increase this value (\fImust\fR be a
+power of two).
+.IP "\s-1EV_USE_4HEAP\s0" 4
+.IX Item "EV_USE_4HEAP"
+Heaps are not very cache-efficient. To improve the cache-efficiency of the
+timer and periodics heaps, libev uses a 4\-heap when this symbol is defined
+to \f(CW1\fR. The 4\-heap uses more complicated (longer) code but has noticeably
+faster performance with many (thousands) of watchers.
+.Sp
+The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
+will be \f(CW0\fR.
+.IP "\s-1EV_HEAP_CACHE_AT\s0" 4
+.IX Item "EV_HEAP_CACHE_AT"
+Heaps are not very cache-efficient. To improve the cache-efficiency of the
+timer and periodics heaps, libev can cache the timestamp (\fIat\fR) within
+the heap structure (selected by defining \f(CW\*(C`EV_HEAP_CACHE_AT\*(C'\fR to \f(CW1\fR),
+which uses 8\-12 bytes more per watcher and a few hundred bytes more code,
+but avoids random read accesses on heap changes. This improves performance
+noticeably with many (hundreds) of watchers.
+.Sp
+The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
+will be \f(CW0\fR.
+.IP "\s-1EV_VERIFY\s0" 4
+.IX Item "EV_VERIFY"
+Controls how much internal verification (see \f(CW\*(C`ev_verify ()\*(C'\fR) will
+be done: If set to \f(CW0\fR, no internal verification code will be compiled
+in. If set to \f(CW1\fR, then verification code will be compiled in, but not
+called. If set to \f(CW2\fR, then the internal verification code will be
+called once per loop, which can slow down libev. If set to \f(CW3\fR, then the
+verification code will be called very frequently, which will slow down
+libev considerably.
+.Sp
+The default is \f(CW1\fR, unless \f(CW\*(C`EV_FEATURES\*(C'\fR overrides it, in which case it
+will be \f(CW0\fR.
+.IP "\s-1EV_COMMON\s0" 4
+.IX Item "EV_COMMON"
+By default, all watchers have a \f(CW\*(C`void *data\*(C'\fR member. By redefining
+this macro to something else you can include more and other types of
+members. You have to define it each time you include one of the files,
+though, and it must be identical each time.
+.Sp
+For example, the perl \s-1EV\s0 module uses something like this:
+.Sp
+.Vb 3
+\&   #define EV_COMMON                       \e
+\&     SV *self; /* contains this struct */  \e
+\&     SV *cb_sv, *fh /* note no trailing ";" */
+.Ve
+.IP "\s-1EV_CB_DECLARE \s0(type)" 4
+.IX Item "EV_CB_DECLARE (type)"
+.PD 0
+.IP "\s-1EV_CB_INVOKE \s0(watcher, revents)" 4
+.IX Item "EV_CB_INVOKE (watcher, revents)"
+.IP "ev_set_cb (ev, cb)" 4
+.IX Item "ev_set_cb (ev, cb)"
+.PD
+Can be used to change the callback member declaration in each watcher,
+and the way callbacks are invoked and set. Must expand to a struct member
+definition and a statement, respectively. See the \fIev.h\fR header file for
+their default definitions. One possible use for overriding these is to
+avoid the \f(CW\*(C`struct ev_loop *\*(C'\fR as first argument in all cases, or to use
+method calls instead of plain function calls in \*(C+.
+.SS "\s-1EXPORTED API SYMBOLS\s0"
+.IX Subsection "EXPORTED API SYMBOLS"
+If you need to re-export the \s-1API \s0(e.g. via a \s-1DLL\s0) and you need a list of
+exported symbols, you can use the provided \fISymbol.*\fR files which list
+all public symbols, one per line:
+.PP
+.Vb 2
+\&   Symbols.ev      for libev proper
+\&   Symbols.event   for the libevent emulation
+.Ve
+.PP
+This can also be used to rename all public symbols to avoid clashes with
+multiple versions of libev linked together (which is obviously bad in
+itself, but sometimes it is inconvenient to avoid this).
+.PP
+A sed command like this will create wrapper \f(CW\*(C`#define\*(C'\fR's that you need to
+include before including \fIev.h\fR:
+.PP
+.Vb 1
+\&   <Symbols.ev sed \-e "s/.*/#define & myprefix_&/" >wrap.h
+.Ve
+.PP
+This would create a file \fIwrap.h\fR which essentially looks like this:
+.PP
+.Vb 4
+\&   #define ev_backend     myprefix_ev_backend
+\&   #define ev_check_start myprefix_ev_check_start
+\&   #define ev_check_stop  myprefix_ev_check_stop
+\&   ...
+.Ve
+.SS "\s-1EXAMPLES\s0"
+.IX Subsection "EXAMPLES"
+For a real-world example of a program the includes libev
+verbatim, you can have a look at the \s-1EV\s0 perl module
+(<http://software.schmorp.de/pkg/EV.html>). It has the libev files in
+the \fIlibev/\fR subdirectory and includes them in the \fI\s-1EV/EVAPI\s0.h\fR (public
+interface) and \fI\s-1EV\s0.xs\fR (implementation) files. Only the \fI\s-1EV\s0.xs\fR file
+will be compiled. It is pretty complex because it provides its own header
+file.
+.PP
+The usage in rxvt-unicode is simpler. It has a \fIev_cpp.h\fR header file
+that everybody includes and which overrides some configure choices:
+.PP
+.Vb 8
+\&   #define EV_FEATURES 8
+\&   #define EV_USE_SELECT 1
+\&   #define EV_PREPARE_ENABLE 1
+\&   #define EV_IDLE_ENABLE 1
+\&   #define EV_SIGNAL_ENABLE 1
+\&   #define EV_CHILD_ENABLE 1
+\&   #define EV_USE_STDEXCEPT 0
+\&   #define EV_CONFIG_H <config.h>
+\&
+\&   #include "ev++.h"
+.Ve
+.PP
+And a \fIev_cpp.C\fR implementation file that contains libev proper and is compiled:
+.PP
+.Vb 2
+\&   #include "ev_cpp.h"
+\&   #include "ev.c"
+.Ve
+.SH "INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT"
+.IX Header "INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT"
+.SS "\s-1THREADS AND COROUTINES\s0"
+.IX Subsection "THREADS AND COROUTINES"
+\fI\s-1THREADS\s0\fR
+.IX Subsection "THREADS"
+.PP
+All libev functions are reentrant and thread-safe unless explicitly
+documented otherwise, but libev implements no locking itself. This means
+that you can use as many loops as you want in parallel, as long as there
+are no concurrent calls into any libev function with the same loop
+parameter (\f(CW\*(C`ev_default_*\*(C'\fR calls have an implicit default loop parameter,
+of course): libev guarantees that different event loops share no data
+structures that need any locking.
+.PP
+Or to put it differently: calls with different loop parameters can be done
+concurrently from multiple threads, calls with the same loop parameter
+must be done serially (but can be done from different threads, as long as
+only one thread ever is inside a call at any point in time, e.g. by using
+a mutex per loop).
+.PP
+Specifically to support threads (and signal handlers), libev implements
+so-called \f(CW\*(C`ev_async\*(C'\fR watchers, which allow some limited form of
+concurrency on the same event loop, namely waking it up \*(L"from the
+outside\*(R".
+.PP
+If you want to know which design (one loop, locking, or multiple loops
+without or something else still) is best for your problem, then I cannot
+help you, but here is some generic advice:
+.IP "\(bu" 4
+most applications have a main thread: use the default libev loop
+in that thread, or create a separate thread running only the default loop.
+.Sp
+This helps integrating other libraries or software modules that use libev
+themselves and don't care/know about threading.
+.IP "\(bu" 4
+one loop per thread is usually a good model.
+.Sp
+Doing this is almost never wrong, sometimes a better-performance model
+exists, but it is always a good start.
+.IP "\(bu" 4
+other models exist, such as the leader/follower pattern, where one
+loop is handed through multiple threads in a kind of round-robin fashion.
+.Sp
+Choosing a model is hard \- look around, learn, know that usually you can do
+better than you currently do :\-)
+.IP "\(bu" 4
+often you need to talk to some other thread which blocks in the
+event loop.
+.Sp
+\&\f(CW\*(C`ev_async\*(C'\fR watchers can be used to wake them up from other threads safely
+(or from signal contexts...).
+.Sp
+An example use would be to communicate signals or other events that only
+work in the default loop by registering the signal watcher with the
+default loop and triggering an \f(CW\*(C`ev_async\*(C'\fR watcher from the default loop
+watcher callback into the event loop interested in the signal.
+.PP
+See also \*(L"\s-1THREAD LOCKING EXAMPLE\*(R"\s0.
+.PP
+\fI\s-1COROUTINES\s0\fR
+.IX Subsection "COROUTINES"
+.PP
+Libev is very accommodating to coroutines (\*(L"cooperative threads\*(R"):
+libev fully supports nesting calls to its functions from different
+coroutines (e.g. you can call \f(CW\*(C`ev_run\*(C'\fR on the same loop from two
+different coroutines, and switch freely between both coroutines running
+the loop, as long as you don't confuse yourself). The only exception is
+that you must not do this from \f(CW\*(C`ev_periodic\*(C'\fR reschedule callbacks.
+.PP
+Care has been taken to ensure that libev does not keep local state inside
+\&\f(CW\*(C`ev_run\*(C'\fR, and other calls do not usually allow for coroutine switches as
+they do not call any callbacks.
+.SS "\s-1COMPILER WARNINGS\s0"
+.IX Subsection "COMPILER WARNINGS"
+Depending on your compiler and compiler settings, you might get no or a
+lot of warnings when compiling libev code. Some people are apparently
+scared by this.
+.PP
+However, these are unavoidable for many reasons. For one, each compiler
+has different warnings, and each user has different tastes regarding
+warning options. \*(L"Warn-free\*(R" code therefore cannot be a goal except when
+targeting a specific compiler and compiler-version.
+.PP
+Another reason is that some compiler warnings require elaborate
+workarounds, or other changes to the code that make it less clear and less
+maintainable.
+.PP
+And of course, some compiler warnings are just plain stupid, or simply
+wrong (because they don't actually warn about the condition their message
+seems to warn about). For example, certain older gcc versions had some
+warnings that resulted in an extreme number of false positives. These have
+been fixed, but some people still insist on making code warn-free with
+such buggy versions.
+.PP
+While libev is written to generate as few warnings as possible,
+\&\*(L"warn-free\*(R" code is not a goal, and it is recommended not to build libev
+with any compiler warnings enabled unless you are prepared to cope with
+them (e.g. by ignoring them). Remember that warnings are just that:
+warnings, not errors, or proof of bugs.
+.SS "\s-1VALGRIND\s0"
+.IX Subsection "VALGRIND"
+Valgrind has a special section here because it is a popular tool that is
+highly useful. Unfortunately, valgrind reports are very hard to interpret.
+.PP
+If you think you found a bug (memory leak, uninitialised data access etc.)
+in libev, then check twice: If valgrind reports something like:
+.PP
+.Vb 3
+\&   ==2274==    definitely lost: 0 bytes in 0 blocks.
+\&   ==2274==      possibly lost: 0 bytes in 0 blocks.
+\&   ==2274==    still reachable: 256 bytes in 1 blocks.
+.Ve
+.PP
+Then there is no memory leak, just as memory accounted to global variables
+is not a memleak \- the memory is still being referenced, and didn't leak.
+.PP
+Similarly, under some circumstances, valgrind might report kernel bugs
+as if it were a bug in libev (e.g. in realloc or in the poll backend,
+although an acceptable workaround has been found here), or it might be
+confused.
+.PP
+Keep in mind that valgrind is a very good tool, but only a tool. Don't
+make it into some kind of religion.
+.PP
+If you are unsure about something, feel free to contact the mailing list
+with the full valgrind report and an explanation on why you think this
+is a bug in libev (best check the archives, too :). However, don't be
+annoyed when you get a brisk \*(L"this is no bug\*(R" answer and take the chance
+of learning how to interpret valgrind properly.
+.PP
+If you need, for some reason, empty reports from valgrind for your project
+I suggest using suppression lists.
+.SH "PORTABILITY NOTES"
+.IX Header "PORTABILITY NOTES"
+.SS "\s-1GNU/LINUX 32 BIT LIMITATIONS\s0"
+.IX Subsection "GNU/LINUX 32 BIT LIMITATIONS"
+GNU/Linux is the only common platform that supports 64 bit file/large file
+interfaces but \fIdisables\fR them by default.
+.PP
+That means that libev compiled in the default environment doesn't support
+files larger than 2GiB or so, which mainly affects \f(CW\*(C`ev_stat\*(C'\fR watchers.
+.PP
+Unfortunately, many programs try to work around this GNU/Linux issue
+by enabling the large file \s-1API,\s0 which makes them incompatible with the
+standard libev compiled for their system.
+.PP
+Likewise, libev cannot enable the large file \s-1API\s0 itself as this would
+suddenly make it incompatible to the default compile time environment,
+i.e. all programs not using special compile switches.
+.SS "\s-1OS/X AND DARWIN BUGS\s0"
+.IX Subsection "OS/X AND DARWIN BUGS"
+The whole thing is a bug if you ask me \- basically any system interface
+you touch is broken, whether it is locales, poll, kqueue or even the
+OpenGL drivers.
+.PP
+\fI\f(CI\*(C`kqueue\*(C'\fI is buggy\fR
+.IX Subsection "kqueue is buggy"
+.PP
+The kqueue syscall is broken in all known versions \- most versions support
+only sockets, many support pipes.
+.PP
+Libev tries to work around this by not using \f(CW\*(C`kqueue\*(C'\fR by default on this
+rotten platform, but of course you can still ask for it when creating a
+loop \- embedding a socket-only kqueue loop into a select-based one is
+probably going to work well.
+.PP
+\fI\f(CI\*(C`poll\*(C'\fI is buggy\fR
+.IX Subsection "poll is buggy"
+.PP
+Instead of fixing \f(CW\*(C`kqueue\*(C'\fR, Apple replaced their (working) \f(CW\*(C`poll\*(C'\fR
+implementation by something calling \f(CW\*(C`kqueue\*(C'\fR internally around the 10.5.6
+release, so now \f(CW\*(C`kqueue\*(C'\fR \fIand\fR \f(CW\*(C`poll\*(C'\fR are broken.
+.PP
+Libev tries to work around this by not using \f(CW\*(C`poll\*(C'\fR by default on
+this rotten platform, but of course you can still ask for it when creating
+a loop.
+.PP
+\fI\f(CI\*(C`select\*(C'\fI is buggy\fR
+.IX Subsection "select is buggy"
+.PP
+All that's left is \f(CW\*(C`select\*(C'\fR, and of course Apple found a way to fuck this
+one up as well: On \s-1OS/X, \s0\f(CW\*(C`select\*(C'\fR actively limits the number of file
+descriptors you can pass in to 1024 \- your program suddenly crashes when
+you use more.
+.PP
+There is an undocumented \*(L"workaround\*(R" for this \- defining
+\&\f(CW\*(C`_DARWIN_UNLIMITED_SELECT\*(C'\fR, which libev tries to use, so select \fIshould\fR
+work on \s-1OS/X.\s0
+.SS "\s-1SOLARIS PROBLEMS AND WORKAROUNDS\s0"
+.IX Subsection "SOLARIS PROBLEMS AND WORKAROUNDS"
+\fI\f(CI\*(C`errno\*(C'\fI reentrancy\fR
+.IX Subsection "errno reentrancy"
+.PP
+The default compile environment on Solaris is unfortunately so
+thread-unsafe that you can't even use components/libraries compiled
+without \f(CW\*(C`\-D_REENTRANT\*(C'\fR in a threaded program, which, of course, isn't
+defined by default. A valid, if stupid, implementation choice.
+.PP
+If you want to use libev in threaded environments you have to make sure
+it's compiled with \f(CW\*(C`_REENTRANT\*(C'\fR defined.
+.PP
+\fIEvent port backend\fR
+.IX Subsection "Event port backend"
+.PP
+The scalable event interface for Solaris is called \*(L"event
+ports\*(R". Unfortunately, this mechanism is very buggy in all major
+releases. If you run into high \s-1CPU\s0 usage, your program freezes or you get
+a large number of spurious wakeups, make sure you have all the relevant
+and latest kernel patches applied. No, I don't know which ones, but there
+are multiple ones to apply, and afterwards, event ports actually work
+great.
+.PP
+If you can't get it to work, you can try running the program by setting
+the environment variable \f(CW\*(C`LIBEV_FLAGS=3\*(C'\fR to only allow \f(CW\*(C`poll\*(C'\fR and
+\&\f(CW\*(C`select\*(C'\fR backends.
+.SS "\s-1AIX POLL BUG\s0"
+.IX Subsection "AIX POLL BUG"
+\&\s-1AIX\s0 unfortunately has a broken \f(CW\*(C`poll.h\*(C'\fR header. Libev works around
+this by trying to avoid the poll backend altogether (i.e. it's not even
+compiled in), which normally isn't a big problem as \f(CW\*(C`select\*(C'\fR works fine
+with large bitsets on \s-1AIX,\s0 and \s-1AIX\s0 is dead anyway.
+.SS "\s-1WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS\s0"
+.IX Subsection "WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS"
+\fIGeneral issues\fR
+.IX Subsection "General issues"
+.PP
+Win32 doesn't support any of the standards (e.g. \s-1POSIX\s0) that libev
+requires, and its I/O model is fundamentally incompatible with the \s-1POSIX\s0
+model. Libev still offers limited functionality on this platform in
+the form of the \f(CW\*(C`EVBACKEND_SELECT\*(C'\fR backend, and only supports socket
+descriptors. This only applies when using Win32 natively, not when using
+e.g. cygwin. Actually, it only applies to the microsofts own compilers,
+as every compiler comes with a slightly differently broken/incompatible
+environment.
+.PP
+Lifting these limitations would basically require the full
+re-implementation of the I/O system. If you are into this kind of thing,
+then note that glib does exactly that for you in a very portable way (note
+also that glib is the slowest event library known to man).
+.PP
+There is no supported compilation method available on windows except
+embedding it into other applications.
+.PP
+Sensible signal handling is officially unsupported by Microsoft \- libev
+tries its best, but under most conditions, signals will simply not work.
+.PP
+Not a libev limitation but worth mentioning: windows apparently doesn't
+accept large writes: instead of resulting in a partial write, windows will
+either accept everything or return \f(CW\*(C`ENOBUFS\*(C'\fR if the buffer is too large,
+so make sure you only write small amounts into your sockets (less than a
+megabyte seems safe, but this apparently depends on the amount of memory
+available).
+.PP
+Due to the many, low, and arbitrary limits on the win32 platform and
+the abysmal performance of winsockets, using a large number of sockets
+is not recommended (and not reasonable). If your program needs to use
+more than a hundred or so sockets, then likely it needs to use a totally
+different implementation for windows, as libev offers the \s-1POSIX\s0 readiness
+notification model, which cannot be implemented efficiently on windows
+(due to Microsoft monopoly games).
+.PP
+A typical way to use libev under windows is to embed it (see the embedding
+section for details) and use the following \fIevwrap.h\fR header file instead
+of \fIev.h\fR:
+.PP
+.Vb 2
+\&   #define EV_STANDALONE              /* keeps ev from requiring config.h */
+\&   #define EV_SELECT_IS_WINSOCKET 1   /* configure libev for windows select */
+\&
+\&   #include "ev.h"
+.Ve
+.PP
+And compile the following \fIevwrap.c\fR file into your project (make sure
+you do \fInot\fR compile the \fIev.c\fR or any other embedded source files!):
+.PP
+.Vb 2
+\&   #include "evwrap.h"
+\&   #include "ev.c"
+.Ve
+.PP
+\fIThe winsocket \f(CI\*(C`select\*(C'\fI function\fR
+.IX Subsection "The winsocket select function"
+.PP
+The winsocket \f(CW\*(C`select\*(C'\fR function doesn't follow \s-1POSIX\s0 in that it
+requires socket \fIhandles\fR and not socket \fIfile descriptors\fR (it is
+also extremely buggy). This makes select very inefficient, and also
+requires a mapping from file descriptors to socket handles (the Microsoft
+C runtime provides the function \f(CW\*(C`_open_osfhandle\*(C'\fR for this). See the
+discussion of the \f(CW\*(C`EV_SELECT_USE_FD_SET\*(C'\fR, \f(CW\*(C`EV_SELECT_IS_WINSOCKET\*(C'\fR and
+\&\f(CW\*(C`EV_FD_TO_WIN32_HANDLE\*(C'\fR preprocessor symbols for more info.
+.PP
+The configuration for a \*(L"naked\*(R" win32 using the Microsoft runtime
+libraries and raw winsocket select is:
+.PP
+.Vb 2
+\&   #define EV_USE_SELECT 1
+\&   #define EV_SELECT_IS_WINSOCKET 1   /* forces EV_SELECT_USE_FD_SET, too */
+.Ve
+.PP
+Note that winsockets handling of fd sets is O(n), so you can easily get a
+complexity in the O(nX) range when using win32.
+.PP
+\fILimited number of file descriptors\fR
+.IX Subsection "Limited number of file descriptors"
+.PP
+Windows has numerous arbitrary (and low) limits on things.
+.PP
+Early versions of winsocket's select only supported waiting for a maximum
+of \f(CW64\fR handles (probably owning to the fact that all windows kernels
+can only wait for \f(CW64\fR things at the same time internally; Microsoft
+recommends spawning a chain of threads and wait for 63 handles and the
+previous thread in each. Sounds great!).
+.PP
+Newer versions support more handles, but you need to define \f(CW\*(C`FD_SETSIZE\*(C'\fR
+to some high number (e.g. \f(CW2048\fR) before compiling the winsocket select
+call (which might be in libev or elsewhere, for example, perl and many
+other interpreters do their own select emulation on windows).
+.PP
+Another limit is the number of file descriptors in the Microsoft runtime
+libraries, which by default is \f(CW64\fR (there must be a hidden \fI64\fR
+fetish or something like this inside Microsoft). You can increase this
+by calling \f(CW\*(C`_setmaxstdio\*(C'\fR, which can increase this limit to \f(CW2048\fR
+(another arbitrary limit), but is broken in many versions of the Microsoft
+runtime libraries. This might get you to about \f(CW512\fR or \f(CW2048\fR sockets
+(depending on windows version and/or the phase of the moon). To get more,
+you need to wrap all I/O functions and provide your own fd management, but
+the cost of calling select (O(nX)) will likely make this unworkable.
+.SS "\s-1PORTABILITY REQUIREMENTS\s0"
+.IX Subsection "PORTABILITY REQUIREMENTS"
+In addition to a working ISO-C implementation and of course the
+backend-specific APIs, libev relies on a few additional extensions:
+.ie n .IP """void (*)(ev_watcher_type *, int revents)"" must have compatible calling conventions regardless of ""ev_watcher_type *""." 4
+.el .IP "\f(CWvoid (*)(ev_watcher_type *, int revents)\fR must have compatible calling conventions regardless of \f(CWev_watcher_type *\fR." 4
+.IX Item "void (*)(ev_watcher_type *, int revents) must have compatible calling conventions regardless of ev_watcher_type *."
+Libev assumes not only that all watcher pointers have the same internal
+structure (guaranteed by \s-1POSIX\s0 but not by \s-1ISO C\s0 for example), but it also
+assumes that the same (machine) code can be used to call any watcher
+callback: The watcher callbacks have different type signatures, but libev
+calls them using an \f(CW\*(C`ev_watcher *\*(C'\fR internally.
+.IP "pointer accesses must be thread-atomic" 4
+.IX Item "pointer accesses must be thread-atomic"
+Accessing a pointer value must be atomic, it must both be readable and
+writable in one piece \- this is the case on all current architectures.
+.ie n .IP """sig_atomic_t volatile"" must be thread-atomic as well" 4
+.el .IP "\f(CWsig_atomic_t volatile\fR must be thread-atomic as well" 4
+.IX Item "sig_atomic_t volatile must be thread-atomic as well"
+The type \f(CW\*(C`sig_atomic_t volatile\*(C'\fR (or whatever is defined as
+\&\f(CW\*(C`EV_ATOMIC_T\*(C'\fR) must be atomic with respect to accesses from different
+threads. This is not part of the specification for \f(CW\*(C`sig_atomic_t\*(C'\fR, but is
+believed to be sufficiently portable.
+.ie n .IP """sigprocmask"" must work in a threaded environment" 4
+.el .IP "\f(CWsigprocmask\fR must work in a threaded environment" 4
+.IX Item "sigprocmask must work in a threaded environment"
+Libev uses \f(CW\*(C`sigprocmask\*(C'\fR to temporarily block signals. This is not
+allowed in a threaded program (\f(CW\*(C`pthread_sigmask\*(C'\fR has to be used). Typical
+pthread implementations will either allow \f(CW\*(C`sigprocmask\*(C'\fR in the \*(L"main
+thread\*(R" or will block signals process-wide, both behaviours would
+be compatible with libev. Interaction between \f(CW\*(C`sigprocmask\*(C'\fR and
+\&\f(CW\*(C`pthread_sigmask\*(C'\fR could complicate things, however.
+.Sp
+The most portable way to handle signals is to block signals in all threads
+except the initial one, and run the signal handling loop in the initial
+thread as well.
+.ie n .IP """long"" must be large enough for common memory allocation sizes" 4
+.el .IP "\f(CWlong\fR must be large enough for common memory allocation sizes" 4
+.IX Item "long must be large enough for common memory allocation sizes"
+To improve portability and simplify its \s-1API,\s0 libev uses \f(CW\*(C`long\*(C'\fR internally
+instead of \f(CW\*(C`size_t\*(C'\fR when allocating its data structures. On non-POSIX
+systems (Microsoft...) this might be unexpectedly low, but is still at
+least 31 bits everywhere, which is enough for hundreds of millions of
+watchers.
+.ie n .IP """double"" must hold a time value in seconds with enough accuracy" 4
+.el .IP "\f(CWdouble\fR must hold a time value in seconds with enough accuracy" 4
+.IX Item "double must hold a time value in seconds with enough accuracy"
+The type \f(CW\*(C`double\*(C'\fR is used to represent timestamps. It is required to
+have at least 51 bits of mantissa (and 9 bits of exponent), which is
+good enough for at least into the year 4000 with millisecond accuracy
+(the design goal for libev). This requirement is overfulfilled by
+implementations using \s-1IEEE 754,\s0 which is basically all existing ones.
+.Sp
+With \s-1IEEE 754\s0 doubles, you get microsecond accuracy until at least the
+year 2255 (and millisecond accuracy till the year 287396 \- by then, libev
+is either obsolete or somebody patched it to use \f(CW\*(C`long double\*(C'\fR or
+something like that, just kidding).
+.PP
+If you know of other additional requirements drop me a note.
+.SH "ALGORITHMIC COMPLEXITIES"
+.IX Header "ALGORITHMIC COMPLEXITIES"
+In this section the complexities of (many of) the algorithms used inside
+libev will be documented. For complexity discussions about backends see
+the documentation for \f(CW\*(C`ev_default_init\*(C'\fR.
+.PP
+All of the following are about amortised time: If an array needs to be
+extended, libev needs to realloc and move the whole array, but this
+happens asymptotically rarer with higher number of elements, so O(1) might
+mean that libev does a lengthy realloc operation in rare cases, but on
+average it is much faster and asymptotically approaches constant time.
+.IP "Starting and stopping timer/periodic watchers: O(log skipped_other_timers)" 4
+.IX Item "Starting and stopping timer/periodic watchers: O(log skipped_other_timers)"
+This means that, when you have a watcher that triggers in one hour and
+there are 100 watchers that would trigger before that, then inserting will
+have to skip roughly seven (\f(CW\*(C`ld 100\*(C'\fR) of these watchers.
+.IP "Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)" 4
+.IX Item "Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)"
+That means that changing a timer costs less than removing/adding them,
+as only the relative motion in the event queue has to be paid for.
+.IP "Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)" 4
+.IX Item "Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)"
+These just add the watcher into an array or at the head of a list.
+.IP "Stopping check/prepare/idle/fork/async watchers: O(1)" 4
+.IX Item "Stopping check/prepare/idle/fork/async watchers: O(1)"
+.PD 0
+.IP "Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % \s-1EV_PID_HASHSIZE\s0))" 4
+.IX Item "Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % EV_PID_HASHSIZE))"
+.PD
+These watchers are stored in lists, so they need to be walked to find the
+correct watcher to remove. The lists are usually short (you don't usually
+have many watchers waiting for the same fd or signal: one is typical, two
+is rare).
+.IP "Finding the next timer in each loop iteration: O(1)" 4
+.IX Item "Finding the next timer in each loop iteration: O(1)"
+By virtue of using a binary or 4\-heap, the next timer is always found at a
+fixed position in the storage array.
+.IP "Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)" 4
+.IX Item "Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)"
+A change means an I/O watcher gets started or stopped, which requires
+libev to recalculate its status (and possibly tell the kernel, depending
+on backend and whether \f(CW\*(C`ev_io_set\*(C'\fR was used).
+.IP "Activating one watcher (putting it into the pending state): O(1)" 4
+.IX Item "Activating one watcher (putting it into the pending state): O(1)"
+.PD 0
+.IP "Priority handling: O(number_of_priorities)" 4
+.IX Item "Priority handling: O(number_of_priorities)"
+.PD
+Priorities are implemented by allocating some space for each
+priority. When doing priority-based operations, libev usually has to
+linearly search all the priorities, but starting/stopping and activating
+watchers becomes O(1) with respect to priority handling.
+.IP "Sending an ev_async: O(1)" 4
+.IX Item "Sending an ev_async: O(1)"
+.PD 0
+.IP "Processing ev_async_send: O(number_of_async_watchers)" 4
+.IX Item "Processing ev_async_send: O(number_of_async_watchers)"
+.IP "Processing signals: O(max_signal_number)" 4
+.IX Item "Processing signals: O(max_signal_number)"
+.PD
+Sending involves a system call \fIiff\fR there were no other \f(CW\*(C`ev_async_send\*(C'\fR
+calls in the current loop iteration and the loop is currently
+blocked. Checking for async and signal events involves iterating over all
+running async watchers or all signal numbers.
+.SH "PORTING FROM LIBEV 3.X TO 4.X"
+.IX Header "PORTING FROM LIBEV 3.X TO 4.X"
+The major version 4 introduced some incompatible changes to the \s-1API.\s0
+.PP
+At the moment, the \f(CW\*(C`ev.h\*(C'\fR header file provides compatibility definitions
+for all changes, so most programs should still compile. The compatibility
+layer might be removed in later versions of libev, so better update to the
+new \s-1API\s0 early than late.
+.ie n .IP """EV_COMPAT3"" backwards compatibility mechanism" 4
+.el .IP "\f(CWEV_COMPAT3\fR backwards compatibility mechanism" 4
+.IX Item "EV_COMPAT3 backwards compatibility mechanism"
+The backward compatibility mechanism can be controlled by
+\&\f(CW\*(C`EV_COMPAT3\*(C'\fR. See \*(L"\s-1PREPROCESSOR SYMBOLS/MACROS\*(R"\s0 in the \*(L"\s-1EMBEDDING\*(R"\s0
+section.
+.ie n .IP """ev_default_destroy"" and ""ev_default_fork"" have been removed" 4
+.el .IP "\f(CWev_default_destroy\fR and \f(CWev_default_fork\fR have been removed" 4
+.IX Item "ev_default_destroy and ev_default_fork have been removed"
+These calls can be replaced easily by their \f(CW\*(C`ev_loop_xxx\*(C'\fR counterparts:
+.Sp
+.Vb 2
+\&   ev_loop_destroy (EV_DEFAULT_UC);
+\&   ev_loop_fork (EV_DEFAULT);
+.Ve
+.IP "function/symbol renames" 4
+.IX Item "function/symbol renames"
+A number of functions and symbols have been renamed:
+.Sp
+.Vb 3
+\&  ev_loop         => ev_run
+\&  EVLOOP_NONBLOCK => EVRUN_NOWAIT
+\&  EVLOOP_ONESHOT  => EVRUN_ONCE
+\&
+\&  ev_unloop       => ev_break
+\&  EVUNLOOP_CANCEL => EVBREAK_CANCEL
+\&  EVUNLOOP_ONE    => EVBREAK_ONE
+\&  EVUNLOOP_ALL    => EVBREAK_ALL
+\&
+\&  EV_TIMEOUT      => EV_TIMER
+\&
+\&  ev_loop_count   => ev_iteration
+\&  ev_loop_depth   => ev_depth
+\&  ev_loop_verify  => ev_verify
+.Ve
+.Sp
+Most functions working on \f(CW\*(C`struct ev_loop\*(C'\fR objects don't have an
+\&\f(CW\*(C`ev_loop_\*(C'\fR prefix, so it was removed; \f(CW\*(C`ev_loop\*(C'\fR, \f(CW\*(C`ev_unloop\*(C'\fR and
+associated constants have been renamed to not collide with the \f(CW\*(C`struct
+ev_loop\*(C'\fR anymore and \f(CW\*(C`EV_TIMER\*(C'\fR now follows the same naming scheme
+as all other watcher types. Note that \f(CW\*(C`ev_loop_fork\*(C'\fR is still called
+\&\f(CW\*(C`ev_loop_fork\*(C'\fR because it would otherwise clash with the \f(CW\*(C`ev_fork\*(C'\fR
+typedef.
+.ie n .IP """EV_MINIMAL"" mechanism replaced by ""EV_FEATURES""" 4
+.el .IP "\f(CWEV_MINIMAL\fR mechanism replaced by \f(CWEV_FEATURES\fR" 4
+.IX Item "EV_MINIMAL mechanism replaced by EV_FEATURES"
+The preprocessor symbol \f(CW\*(C`EV_MINIMAL\*(C'\fR has been replaced by a different
+mechanism, \f(CW\*(C`EV_FEATURES\*(C'\fR. Programs using \f(CW\*(C`EV_MINIMAL\*(C'\fR usually compile
+and work, but the library code will of course be larger.
+.SH "GLOSSARY"
+.IX Header "GLOSSARY"
+.IP "active" 4
+.IX Item "active"
+A watcher is active as long as it has been started and not yet stopped.
+See \*(L"\s-1WATCHER STATES\*(R"\s0 for details.
+.IP "application" 4
+.IX Item "application"
+In this document, an application is whatever is using libev.
+.IP "backend" 4
+.IX Item "backend"
+The part of the code dealing with the operating system interfaces.
+.IP "callback" 4
+.IX Item "callback"
+The address of a function that is called when some event has been
+detected. Callbacks are being passed the event loop, the watcher that
+received the event, and the actual event bitset.
+.IP "callback/watcher invocation" 4
+.IX Item "callback/watcher invocation"
+The act of calling the callback associated with a watcher.
+.IP "event" 4
+.IX Item "event"
+A change of state of some external event, such as data now being available
+for reading on a file descriptor, time having passed or simply not having
+any other events happening anymore.
+.Sp
+In libev, events are represented as single bits (such as \f(CW\*(C`EV_READ\*(C'\fR or
+\&\f(CW\*(C`EV_TIMER\*(C'\fR).
+.IP "event library" 4
+.IX Item "event library"
+A software package implementing an event model and loop.
+.IP "event loop" 4
+.IX Item "event loop"
+An entity that handles and processes external events and converts them
+into callback invocations.
+.IP "event model" 4
+.IX Item "event model"
+The model used to describe how an event loop handles and processes
+watchers and events.
+.IP "pending" 4
+.IX Item "pending"
+A watcher is pending as soon as the corresponding event has been
+detected. See \*(L"\s-1WATCHER STATES\*(R"\s0 for details.
+.IP "real time" 4
+.IX Item "real time"
+The physical time that is observed. It is apparently strictly monotonic :)
+.IP "wall-clock time" 4
+.IX Item "wall-clock time"
+The time and date as shown on clocks. Unlike real time, it can actually
+be wrong and jump forwards and backwards, e.g. when you adjust your
+clock.
+.IP "watcher" 4
+.IX Item "watcher"
+A data structure that describes interest in certain events. Watchers need
+to be started (attached to an event loop) before they can receive events.
+.SH "AUTHOR"
+.IX Header "AUTHOR"
+Marc Lehmann <libev@schmorp.de>, with repeated corrections by Mikael
+Magnusson and Emanuele Giaquinta, and minor corrections by many others.
diff --git a/release/src/router/libev-4.22/ev.c b/release/src/router/libev-4.22/ev.c
new file mode 100644
index 0000000000..cf55835965
--- /dev/null
+++ b/release/src/router/libev-4.22/ev.c
@@ -0,0 +1,5097 @@
+/*
+ * libev event processing core, watcher management
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+/* this big block deduces configuration from config.h */
+#ifndef EV_STANDALONE
+# ifdef EV_CONFIG_H
+#  include EV_CONFIG_H
+# else
+#  include "config.h"
+# endif
+
+# if HAVE_FLOOR
+#  ifndef EV_USE_FLOOR
+#   define EV_USE_FLOOR 1
+#  endif
+# endif
+
+# if HAVE_CLOCK_SYSCALL
+#  ifndef EV_USE_CLOCK_SYSCALL
+#   define EV_USE_CLOCK_SYSCALL 1
+#   ifndef EV_USE_REALTIME
+#    define EV_USE_REALTIME  0
+#   endif
+#   ifndef EV_USE_MONOTONIC
+#    define EV_USE_MONOTONIC 1
+#   endif
+#  endif
+# elif !defined EV_USE_CLOCK_SYSCALL
+#  define EV_USE_CLOCK_SYSCALL 0
+# endif
+
+# if HAVE_CLOCK_GETTIME
+#  ifndef EV_USE_MONOTONIC
+#   define EV_USE_MONOTONIC 1
+#  endif
+#  ifndef EV_USE_REALTIME
+#   define EV_USE_REALTIME  0
+#  endif
+# else
+#  ifndef EV_USE_MONOTONIC
+#   define EV_USE_MONOTONIC 0
+#  endif
+#  ifndef EV_USE_REALTIME
+#   define EV_USE_REALTIME  0
+#  endif
+# endif
+
+# if HAVE_NANOSLEEP
+#  ifndef EV_USE_NANOSLEEP
+#    define EV_USE_NANOSLEEP EV_FEATURE_OS
+#  endif
+# else
+#   undef EV_USE_NANOSLEEP
+#   define EV_USE_NANOSLEEP 0
+# endif
+
+# if HAVE_SELECT && HAVE_SYS_SELECT_H
+#  ifndef EV_USE_SELECT
+#   define EV_USE_SELECT EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_SELECT
+#  define EV_USE_SELECT 0
+# endif
+
+# if HAVE_POLL && HAVE_POLL_H
+#  ifndef EV_USE_POLL
+#   define EV_USE_POLL EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_POLL
+#  define EV_USE_POLL 0
+# endif
+   
+# if HAVE_EPOLL_CTL && HAVE_SYS_EPOLL_H
+#  ifndef EV_USE_EPOLL
+#   define EV_USE_EPOLL EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_EPOLL
+#  define EV_USE_EPOLL 0
+# endif
+   
+# if HAVE_KQUEUE && HAVE_SYS_EVENT_H
+#  ifndef EV_USE_KQUEUE
+#   define EV_USE_KQUEUE EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_KQUEUE
+#  define EV_USE_KQUEUE 0
+# endif
+   
+# if HAVE_PORT_H && HAVE_PORT_CREATE
+#  ifndef EV_USE_PORT
+#   define EV_USE_PORT EV_FEATURE_BACKENDS
+#  endif
+# else
+#  undef EV_USE_PORT
+#  define EV_USE_PORT 0
+# endif
+
+# if HAVE_INOTIFY_INIT && HAVE_SYS_INOTIFY_H
+#  ifndef EV_USE_INOTIFY
+#   define EV_USE_INOTIFY EV_FEATURE_OS
+#  endif
+# else
+#  undef EV_USE_INOTIFY
+#  define EV_USE_INOTIFY 0
+# endif
+
+# if HAVE_SIGNALFD && HAVE_SYS_SIGNALFD_H
+#  ifndef EV_USE_SIGNALFD
+#   define EV_USE_SIGNALFD EV_FEATURE_OS
+#  endif
+# else
+#  undef EV_USE_SIGNALFD
+#  define EV_USE_SIGNALFD 0
+# endif
+
+# if HAVE_EVENTFD
+#  ifndef EV_USE_EVENTFD
+#   define EV_USE_EVENTFD EV_FEATURE_OS
+#  endif
+# else
+#  undef EV_USE_EVENTFD
+#  define EV_USE_EVENTFD 0
+# endif
+ 
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <stddef.h>
+
+#include <stdio.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <time.h>
+#include <limits.h>
+
+#include <signal.h>
+
+#ifdef EV_H
+# include EV_H
+#else
+# include "ev.h"
+#endif
+
+#if EV_NO_THREADS
+# undef EV_NO_SMP
+# define EV_NO_SMP 1
+# undef ECB_NO_THREADS
+# define ECB_NO_THREADS 1
+#endif
+#if EV_NO_SMP
+# undef EV_NO_SMP
+# define ECB_NO_SMP 1
+#endif
+
+#ifndef _WIN32
+# include <sys/time.h>
+# include <sys/wait.h>
+# include <unistd.h>
+#else
+# include <io.h>
+# define WIN32_LEAN_AND_MEAN
+# include <winsock2.h>
+# include <windows.h>
+# ifndef EV_SELECT_IS_WINSOCKET
+#  define EV_SELECT_IS_WINSOCKET 1
+# endif
+# undef EV_AVOID_STDIO
+#endif
+
+/* OS X, in its infinite idiocy, actually HARDCODES
+ * a limit of 1024 into their select. Where people have brains,
+ * OS X engineers apparently have a vacuum. Or maybe they were
+ * ordered to have a vacuum, or they do anything for money.
+ * This might help. Or not.
+ */
+#define _DARWIN_UNLIMITED_SELECT 1
+
+/* this block tries to deduce configuration from header-defined symbols and defaults */
+
+/* try to deduce the maximum number of signals on this platform */
+#if defined EV_NSIG
+/* use what's provided */
+#elif defined NSIG
+# define EV_NSIG (NSIG)
+#elif defined _NSIG
+# define EV_NSIG (_NSIG)
+#elif defined SIGMAX
+# define EV_NSIG (SIGMAX+1)
+#elif defined SIG_MAX
+# define EV_NSIG (SIG_MAX+1)
+#elif defined _SIG_MAX
+# define EV_NSIG (_SIG_MAX+1)
+#elif defined MAXSIG
+# define EV_NSIG (MAXSIG+1)
+#elif defined MAX_SIG
+# define EV_NSIG (MAX_SIG+1)
+#elif defined SIGARRAYSIZE
+# define EV_NSIG (SIGARRAYSIZE) /* Assume ary[SIGARRAYSIZE] */
+#elif defined _sys_nsig
+# define EV_NSIG (_sys_nsig) /* Solaris 2.5 */
+#else
+# define EV_NSIG (8 * sizeof (sigset_t) + 1)
+#endif
+
+#ifndef EV_USE_FLOOR
+# define EV_USE_FLOOR 0
+#endif
+
+#ifndef EV_USE_CLOCK_SYSCALL
+# if __linux && __GLIBC__ == 2 && __GLIBC_MINOR__ < 17
+#  define EV_USE_CLOCK_SYSCALL EV_FEATURE_OS
+# else
+#  define EV_USE_CLOCK_SYSCALL 0
+# endif
+#endif
+
+#if !(_POSIX_TIMERS > 0)
+# ifndef EV_USE_MONOTONIC
+#  define EV_USE_MONOTONIC 0
+# endif
+# ifndef EV_USE_REALTIME
+#  define EV_USE_REALTIME 0
+# endif
+#endif
+
+#ifndef EV_USE_MONOTONIC
+# if defined _POSIX_MONOTONIC_CLOCK && _POSIX_MONOTONIC_CLOCK >= 0
+#  define EV_USE_MONOTONIC EV_FEATURE_OS
+# else
+#  define EV_USE_MONOTONIC 0
+# endif
+#endif
+
+#ifndef EV_USE_REALTIME
+# define EV_USE_REALTIME !EV_USE_CLOCK_SYSCALL
+#endif
+
+#ifndef EV_USE_NANOSLEEP
+# if _POSIX_C_SOURCE >= 199309L
+#  define EV_USE_NANOSLEEP EV_FEATURE_OS
+# else
+#  define EV_USE_NANOSLEEP 0
+# endif
+#endif
+
+#ifndef EV_USE_SELECT
+# define EV_USE_SELECT EV_FEATURE_BACKENDS
+#endif
+
+#ifndef EV_USE_POLL
+# ifdef _WIN32
+#  define EV_USE_POLL 0
+# else
+#  define EV_USE_POLL EV_FEATURE_BACKENDS
+# endif
+#endif
+
+#ifndef EV_USE_EPOLL
+# if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 4))
+#  define EV_USE_EPOLL EV_FEATURE_BACKENDS
+# else
+#  define EV_USE_EPOLL 0
+# endif
+#endif
+
+#ifndef EV_USE_KQUEUE
+# define EV_USE_KQUEUE 0
+#endif
+
+#ifndef EV_USE_PORT
+# define EV_USE_PORT 0
+#endif
+
+#ifndef EV_USE_INOTIFY
+# if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 4))
+#  define EV_USE_INOTIFY EV_FEATURE_OS
+# else
+#  define EV_USE_INOTIFY 0
+# endif
+#endif
+
+#ifndef EV_PID_HASHSIZE
+# define EV_PID_HASHSIZE EV_FEATURE_DATA ? 16 : 1
+#endif
+
+#ifndef EV_INOTIFY_HASHSIZE
+# define EV_INOTIFY_HASHSIZE EV_FEATURE_DATA ? 16 : 1
+#endif
+
+#ifndef EV_USE_EVENTFD
+# if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 7))
+#  define EV_USE_EVENTFD EV_FEATURE_OS
+# else
+#  define EV_USE_EVENTFD 0
+# endif
+#endif
+
+#ifndef EV_USE_SIGNALFD
+# if __linux && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 7))
+#  define EV_USE_SIGNALFD EV_FEATURE_OS
+# else
+#  define EV_USE_SIGNALFD 0
+# endif
+#endif
+
+#if 0 /* debugging */
+# define EV_VERIFY 3
+# define EV_USE_4HEAP 1
+# define EV_HEAP_CACHE_AT 1
+#endif
+
+#ifndef EV_VERIFY
+# define EV_VERIFY (EV_FEATURE_API ? 1 : 0)
+#endif
+
+#ifndef EV_USE_4HEAP
+# define EV_USE_4HEAP EV_FEATURE_DATA
+#endif
+
+#ifndef EV_HEAP_CACHE_AT
+# define EV_HEAP_CACHE_AT EV_FEATURE_DATA
+#endif
+
+#ifdef ANDROID
+/* supposedly, android doesn't typedef fd_mask */
+# undef EV_USE_SELECT
+# define EV_USE_SELECT 0
+/* supposedly, we need to include syscall.h, not sys/syscall.h, so just disable */
+# undef EV_USE_CLOCK_SYSCALL
+# define EV_USE_CLOCK_SYSCALL 0
+#endif
+
+/* aix's poll.h seems to cause lots of trouble */
+#ifdef _AIX
+/* AIX has a completely broken poll.h header */
+# undef EV_USE_POLL
+# define EV_USE_POLL 0
+#endif
+
+/* on linux, we can use a (slow) syscall to avoid a dependency on pthread, */
+/* which makes programs even slower. might work on other unices, too. */
+#if EV_USE_CLOCK_SYSCALL
+# include <sys/syscall.h>
+# ifdef SYS_clock_gettime
+#  define clock_gettime(id, ts) syscall (SYS_clock_gettime, (id), (ts))
+#  undef EV_USE_MONOTONIC
+#  define EV_USE_MONOTONIC 1
+# else
+#  undef EV_USE_CLOCK_SYSCALL
+#  define EV_USE_CLOCK_SYSCALL 0
+# endif
+#endif
+
+/* this block fixes any misconfiguration where we know we run into trouble otherwise */
+
+#ifndef CLOCK_MONOTONIC
+# undef EV_USE_MONOTONIC
+# define EV_USE_MONOTONIC 0
+#endif
+
+#ifndef CLOCK_REALTIME
+# undef EV_USE_REALTIME
+# define EV_USE_REALTIME 0
+#endif
+
+#if !EV_STAT_ENABLE
+# undef EV_USE_INOTIFY
+# define EV_USE_INOTIFY 0
+#endif
+
+#if !EV_USE_NANOSLEEP
+/* hp-ux has it in sys/time.h, which we unconditionally include above */
+# if !defined _WIN32 && !defined __hpux
+#  include <sys/select.h>
+# endif
+#endif
+
+#if EV_USE_INOTIFY
+# include <sys/statfs.h>
+# include <sys/inotify.h>
+/* some very old inotify.h headers don't have IN_DONT_FOLLOW */
+# ifndef IN_DONT_FOLLOW
+#  undef EV_USE_INOTIFY
+#  define EV_USE_INOTIFY 0
+# endif
+#endif
+
+#if EV_USE_EVENTFD
+/* our minimum requirement is glibc 2.7 which has the stub, but not the header */
+# include <stdint.h>
+# ifndef EFD_NONBLOCK
+#  define EFD_NONBLOCK O_NONBLOCK
+# endif
+# ifndef EFD_CLOEXEC
+#  ifdef O_CLOEXEC
+#   define EFD_CLOEXEC O_CLOEXEC
+#  else
+#   define EFD_CLOEXEC 02000000
+#  endif
+# endif
+EV_CPP(extern "C") int (eventfd) (unsigned int initval, int flags);
+#endif
+
+#if EV_USE_SIGNALFD
+/* our minimum requirement is glibc 2.7 which has the stub, but not the header */
+# include <stdint.h>
+# ifndef SFD_NONBLOCK
+#  define SFD_NONBLOCK O_NONBLOCK
+# endif
+# ifndef SFD_CLOEXEC
+#  ifdef O_CLOEXEC
+#   define SFD_CLOEXEC O_CLOEXEC
+#  else
+#   define SFD_CLOEXEC 02000000
+#  endif
+# endif
+EV_CPP (extern "C") int signalfd (int fd, const sigset_t *mask, int flags);
+
+struct signalfd_siginfo
+{
+  uint32_t ssi_signo;
+  char pad[128 - sizeof (uint32_t)];
+};
+#endif
+
+/**/
+
+#if EV_VERIFY >= 3
+# define EV_FREQUENT_CHECK ev_verify (EV_A)
+#else
+# define EV_FREQUENT_CHECK do { } while (0)
+#endif
+
+/*
+ * This is used to work around floating point rounding problems.
+ * This value is good at least till the year 4000.
+ */
+#define MIN_INTERVAL  0.0001220703125 /* 1/2**13, good till 4000 */
+/*#define MIN_INTERVAL  0.00000095367431640625 /* 1/2**20, good till 2200 */
+
+#define MIN_TIMEJUMP  1. /* minimum timejump that gets detected (if monotonic clock available) */
+#define MAX_BLOCKTIME 59.743 /* never wait longer than this time (to detect time jumps) */
+
+#define EV_TV_SET(tv,t) do { tv.tv_sec = (long)t; tv.tv_usec = (long)((t - tv.tv_sec) * 1e6); } while (0)
+#define EV_TS_SET(ts,t) do { ts.tv_sec = (long)t; ts.tv_nsec = (long)((t - ts.tv_sec) * 1e9); } while (0)
+
+/* the following is ecb.h embedded into libev - use update_ev_c to update from an external copy */
+/* ECB.H BEGIN */
+/*
+ * libecb - http://software.schmorp.de/pkg/libecb
+ *
+ * Copyright (©) 2009-2015 Marc Alexander Lehmann <libecb@schmorp.de>
+ * Copyright (©) 2011 Emanuele Giaquinta
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef ECB_H
+#define ECB_H
+
+/* 16 bits major, 16 bits minor */
+#define ECB_VERSION 0x00010005
+
+#ifdef _WIN32
+  typedef   signed char   int8_t;
+  typedef unsigned char  uint8_t;
+  typedef   signed short  int16_t;
+  typedef unsigned short uint16_t;
+  typedef   signed int    int32_t;
+  typedef unsigned int   uint32_t;
+  #if __GNUC__
+    typedef   signed long long int64_t;
+    typedef unsigned long long uint64_t;
+  #else /* _MSC_VER || __BORLANDC__ */
+    typedef   signed __int64   int64_t;
+    typedef unsigned __int64   uint64_t;
+  #endif
+  #ifdef _WIN64
+    #define ECB_PTRSIZE 8
+    typedef uint64_t uintptr_t;
+    typedef  int64_t  intptr_t;
+  #else
+    #define ECB_PTRSIZE 4
+    typedef uint32_t uintptr_t;
+    typedef  int32_t  intptr_t;
+  #endif
+#else
+  #include <inttypes.h>
+  #if (defined INTPTR_MAX ? INTPTR_MAX : ULONG_MAX) > 0xffffffffU
+    #define ECB_PTRSIZE 8
+  #else
+    #define ECB_PTRSIZE 4
+  #endif
+#endif
+
+#define ECB_GCC_AMD64 (__amd64 || __amd64__ || __x86_64 || __x86_64__)
+#define ECB_MSVC_AMD64 (_M_AMD64 || _M_X64)
+
+/* work around x32 idiocy by defining proper macros */
+#if ECB_GCC_AMD64 || ECB_MSVC_AMD64
+  #if _ILP32
+    #define ECB_AMD64_X32 1
+  #else
+    #define ECB_AMD64 1
+  #endif
+#endif
+
+/* many compilers define _GNUC_ to some versions but then only implement
+ * what their idiot authors think are the "more important" extensions,
+ * causing enormous grief in return for some better fake benchmark numbers.
+ * or so.
+ * we try to detect these and simply assume they are not gcc - if they have
+ * an issue with that they should have done it right in the first place.
+ */
+#if !defined __GNUC_MINOR__ || defined __INTEL_COMPILER || defined __SUNPRO_C || defined __SUNPRO_CC || defined __llvm__ || defined __clang__
+  #define ECB_GCC_VERSION(major,minor) 0
+#else
+  #define ECB_GCC_VERSION(major,minor) (__GNUC__ > (major) || (__GNUC__ == (major) && __GNUC_MINOR__ >= (minor)))
+#endif
+
+#define ECB_CLANG_VERSION(major,minor) (__clang_major__ > (major) || (__clang_major__ == (major) && __clang_minor__ >= (minor)))
+
+#if __clang__ && defined __has_builtin
+  #define ECB_CLANG_BUILTIN(x) __has_builtin (x)
+#else
+  #define ECB_CLANG_BUILTIN(x) 0
+#endif
+
+#if __clang__ && defined __has_extension
+  #define ECB_CLANG_EXTENSION(x) __has_extension (x)
+#else
+  #define ECB_CLANG_EXTENSION(x) 0
+#endif
+
+#define ECB_CPP   (__cplusplus+0)
+#define ECB_CPP11 (__cplusplus >= 201103L)
+
+#if ECB_CPP
+  #define ECB_C            0
+  #define ECB_STDC_VERSION 0
+#else
+  #define ECB_C            1
+  #define ECB_STDC_VERSION __STDC_VERSION__
+#endif
+
+#define ECB_C99   (ECB_STDC_VERSION >= 199901L)
+#define ECB_C11   (ECB_STDC_VERSION >= 201112L)
+
+#if ECB_CPP
+  #define ECB_EXTERN_C extern "C"
+  #define ECB_EXTERN_C_BEG ECB_EXTERN_C {
+  #define ECB_EXTERN_C_END }
+#else
+  #define ECB_EXTERN_C extern
+  #define ECB_EXTERN_C_BEG
+  #define ECB_EXTERN_C_END
+#endif
+
+/*****************************************************************************/
+
+/* ECB_NO_THREADS - ecb is not used by multiple threads, ever */
+/* ECB_NO_SMP     - ecb might be used in multiple threads, but only on a single cpu */
+
+#if ECB_NO_THREADS
+  #define ECB_NO_SMP 1
+#endif
+
+#if ECB_NO_SMP
+  #define ECB_MEMORY_FENCE do { } while (0)
+#endif
+
+/* http://www-01.ibm.com/support/knowledgecenter/SSGH3R_13.1.0/com.ibm.xlcpp131.aix.doc/compiler_ref/compiler_builtins.html */
+#if __xlC__ && ECB_CPP
+  #include <builtins.h>
+#endif
+
+#if 1400 <= _MSC_VER
+  #include <intrin.h> /* fence functions _ReadBarrier, also bit search functions _BitScanReverse */
+#endif
+
+#ifndef ECB_MEMORY_FENCE
+  #if ECB_GCC_VERSION(2,5) || defined __INTEL_COMPILER || (__llvm__ && __GNUC__) || __SUNPRO_C >= 0x5110 || __SUNPRO_CC >= 0x5110
+    #if __i386 || __i386__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("lock; orb $0, -1(%%esp)" : : : "memory")
+      #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ (""                        : : : "memory")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("")
+    #elif ECB_GCC_AMD64
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("mfence"   : : : "memory")
+      #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ (""         : : : "memory")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("")
+    #elif __powerpc__ || __ppc__ || __powerpc64__ || __ppc64__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("sync"     : : : "memory")
+    #elif defined __ARM_ARCH_2__ \
+      || defined __ARM_ARCH_3__  || defined __ARM_ARCH_3M__  \
+      || defined __ARM_ARCH_4__  || defined __ARM_ARCH_4T__  \
+      || defined __ARM_ARCH_5__  || defined __ARM_ARCH_5E__  \
+      || defined __ARM_ARCH_5T__ || defined __ARM_ARCH_5TE__ \
+      || defined __ARM_ARCH_5TEJ__
+      /* should not need any, unless running old code on newer cpu - arm doesn't support that */
+    #elif defined __ARM_ARCH_6__  || defined __ARM_ARCH_6J__  \
+       || defined __ARM_ARCH_6K__ || defined __ARM_ARCH_6ZK__ \
+       || defined __ARM_ARCH_6T2__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("mcr p15,0,%0,c7,c10,5" : : "r" (0) : "memory")
+    #elif defined __ARM_ARCH_7__  || defined __ARM_ARCH_7A__  \
+       || defined __ARM_ARCH_7R__ || defined __ARM_ARCH_7M__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("dmb"      : : : "memory")
+    #elif __aarch64__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("dmb ish"  : : : "memory")
+    #elif (__sparc || __sparc__) && !(__sparc_v8__ || defined __sparcv8)
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("membar #LoadStore | #LoadLoad | #StoreStore | #StoreLoad" : : : "memory")
+      #define ECB_MEMORY_FENCE_ACQUIRE __asm__ __volatile__ ("membar #LoadStore | #LoadLoad"                            : : : "memory")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("membar #LoadStore             | #StoreStore")
+    #elif defined __s390__ || defined __s390x__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("bcr 15,0" : : : "memory")
+    #elif defined __mips__
+      /* GNU/Linux emulates sync on mips1 architectures, so we force its use */
+      /* anybody else who still uses mips1 is supposed to send in their version, with detection code. */
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (".set mips2; sync; .set mips0" : : : "memory")
+    #elif defined __alpha__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("mb"       : : : "memory")
+    #elif defined __hppa__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (""         : : : "memory")
+      #define ECB_MEMORY_FENCE_RELEASE __asm__ __volatile__ ("")
+    #elif defined __ia64__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("mf"       : : : "memory")
+    #elif defined __m68k__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (""         : : : "memory")
+    #elif defined __m88k__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ ("tb1 0,%%r0,128" : : : "memory")
+    #elif defined __sh__
+      #define ECB_MEMORY_FENCE         __asm__ __volatile__ (""         : : : "memory")
+    #endif
+  #endif
+#endif
+
+#ifndef ECB_MEMORY_FENCE
+  #if ECB_GCC_VERSION(4,7)
+    /* see comment below (stdatomic.h) about the C11 memory model. */
+    #define ECB_MEMORY_FENCE         __atomic_thread_fence (__ATOMIC_SEQ_CST)
+    #define ECB_MEMORY_FENCE_ACQUIRE __atomic_thread_fence (__ATOMIC_ACQUIRE)
+    #define ECB_MEMORY_FENCE_RELEASE __atomic_thread_fence (__ATOMIC_RELEASE)
+
+  #elif ECB_CLANG_EXTENSION(c_atomic)
+    /* see comment below (stdatomic.h) about the C11 memory model. */
+    #define ECB_MEMORY_FENCE         __c11_atomic_thread_fence (__ATOMIC_SEQ_CST)
+    #define ECB_MEMORY_FENCE_ACQUIRE __c11_atomic_thread_fence (__ATOMIC_ACQUIRE)
+    #define ECB_MEMORY_FENCE_RELEASE __c11_atomic_thread_fence (__ATOMIC_RELEASE)
+
+  #elif ECB_GCC_VERSION(4,4) || defined __INTEL_COMPILER || defined __clang__
+    #define ECB_MEMORY_FENCE         __sync_synchronize ()
+  #elif _MSC_VER >= 1500 /* VC++ 2008 */
+    /* apparently, microsoft broke all the memory barrier stuff in Visual Studio 2008... */
+    #pragma intrinsic(_ReadBarrier,_WriteBarrier,_ReadWriteBarrier)
+    #define ECB_MEMORY_FENCE         _ReadWriteBarrier (); MemoryBarrier()
+    #define ECB_MEMORY_FENCE_ACQUIRE _ReadWriteBarrier (); MemoryBarrier() /* according to msdn, _ReadBarrier is not a load fence */
+    #define ECB_MEMORY_FENCE_RELEASE _WriteBarrier (); MemoryBarrier()
+  #elif _MSC_VER >= 1400 /* VC++ 2005 */
+    #pragma intrinsic(_ReadBarrier,_WriteBarrier,_ReadWriteBarrier)
+    #define ECB_MEMORY_FENCE         _ReadWriteBarrier ()
+    #define ECB_MEMORY_FENCE_ACQUIRE _ReadWriteBarrier () /* according to msdn, _ReadBarrier is not a load fence */
+    #define ECB_MEMORY_FENCE_RELEASE _WriteBarrier ()
+  #elif defined _WIN32
+    #include <WinNT.h>
+    #define ECB_MEMORY_FENCE         MemoryBarrier () /* actually just xchg on x86... scary */
+  #elif __SUNPRO_C >= 0x5110 || __SUNPRO_CC >= 0x5110
+    #include <mbarrier.h>
+    #define ECB_MEMORY_FENCE         __machine_rw_barrier ()
+    #define ECB_MEMORY_FENCE_ACQUIRE __machine_r_barrier  ()
+    #define ECB_MEMORY_FENCE_RELEASE __machine_w_barrier  ()
+  #elif __xlC__
+    #define ECB_MEMORY_FENCE         __sync ()
+  #endif
+#endif
+
+#ifndef ECB_MEMORY_FENCE
+  #if ECB_C11 && !defined __STDC_NO_ATOMICS__
+    /* we assume that these memory fences work on all variables/all memory accesses, */
+    /* not just C11 atomics and atomic accesses */
+    #include <stdatomic.h>
+    /* Unfortunately, neither gcc 4.7 nor clang 3.1 generate any instructions for */
+    /* any fence other than seq_cst, which isn't very efficient for us. */
+    /* Why that is, we don't know - either the C11 memory model is quite useless */
+    /* for most usages, or gcc and clang have a bug */
+    /* I *currently* lean towards the latter, and inefficiently implement */
+    /* all three of ecb's fences as a seq_cst fence */
+    /* Update, gcc-4.8 generates mfence for all c++ fences, but nothing */
+    /* for all __atomic_thread_fence's except seq_cst */
+    #define ECB_MEMORY_FENCE         atomic_thread_fence (memory_order_seq_cst)
+  #endif
+#endif
+
+#ifndef ECB_MEMORY_FENCE
+  #if !ECB_AVOID_PTHREADS
+    /*
+     * if you get undefined symbol references to pthread_mutex_lock,
+     * or failure to find pthread.h, then you should implement
+     * the ECB_MEMORY_FENCE operations for your cpu/compiler
+     * OR provide pthread.h and link against the posix thread library
+     * of your system.
+     */
+    #include <pthread.h>
+    #define ECB_NEEDS_PTHREADS 1
+    #define ECB_MEMORY_FENCE_NEEDS_PTHREADS 1
+
+    static pthread_mutex_t ecb_mf_lock = PTHREAD_MUTEX_INITIALIZER;
+    #define ECB_MEMORY_FENCE do { pthread_mutex_lock (&ecb_mf_lock); pthread_mutex_unlock (&ecb_mf_lock); } while (0)
+  #endif
+#endif
+
+#if !defined ECB_MEMORY_FENCE_ACQUIRE && defined ECB_MEMORY_FENCE
+  #define ECB_MEMORY_FENCE_ACQUIRE ECB_MEMORY_FENCE
+#endif
+
+#if !defined ECB_MEMORY_FENCE_RELEASE && defined ECB_MEMORY_FENCE
+  #define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE
+#endif
+
+/*****************************************************************************/
+
+#if ECB_CPP
+  #define ecb_inline static inline
+#elif ECB_GCC_VERSION(2,5)
+  #define ecb_inline static __inline__
+#elif ECB_C99
+  #define ecb_inline static inline
+#else
+  #define ecb_inline static
+#endif
+
+#if ECB_GCC_VERSION(3,3)
+  #define ecb_restrict __restrict__
+#elif ECB_C99
+  #define ecb_restrict restrict
+#else
+  #define ecb_restrict
+#endif
+
+typedef int ecb_bool;
+
+#define ECB_CONCAT_(a, b) a ## b
+#define ECB_CONCAT(a, b) ECB_CONCAT_(a, b)
+#define ECB_STRINGIFY_(a) # a
+#define ECB_STRINGIFY(a) ECB_STRINGIFY_(a)
+#define ECB_STRINGIFY_EXPR(expr) ((expr), ECB_STRINGIFY_ (expr))
+
+#define ecb_function_ ecb_inline
+
+#if ECB_GCC_VERSION(3,1) || ECB_CLANG_VERSION(2,8)
+  #define ecb_attribute(attrlist)        __attribute__ (attrlist)
+#else
+  #define ecb_attribute(attrlist)
+#endif
+
+#if ECB_GCC_VERSION(3,1) || ECB_CLANG_BUILTIN(__builtin_constant_p)
+  #define ecb_is_constant(expr)          __builtin_constant_p (expr)
+#else
+  /* possible C11 impl for integral types
+  typedef struct ecb_is_constant_struct ecb_is_constant_struct;
+  #define ecb_is_constant(expr)          _Generic ((1 ? (struct ecb_is_constant_struct *)0 : (void *)((expr) - (expr)), ecb_is_constant_struct *: 0, default: 1)) */
+
+  #define ecb_is_constant(expr)          0
+#endif
+
+#if ECB_GCC_VERSION(3,1) || ECB_CLANG_BUILTIN(__builtin_expect)
+  #define ecb_expect(expr,value)         __builtin_expect ((expr),(value))
+#else
+  #define ecb_expect(expr,value)         (expr)
+#endif
+
+#if ECB_GCC_VERSION(3,1) || ECB_CLANG_BUILTIN(__builtin_prefetch)
+  #define ecb_prefetch(addr,rw,locality) __builtin_prefetch (addr, rw, locality)
+#else
+  #define ecb_prefetch(addr,rw,locality)
+#endif
+
+/* no emulation for ecb_decltype */
+#if ECB_CPP11
+  // older implementations might have problems with decltype(x)::type, work around it
+  template<class T> struct ecb_decltype_t { typedef T type; };
+  #define ecb_decltype(x) ecb_decltype_t<decltype (x)>::type
+#elif ECB_GCC_VERSION(3,0) || ECB_CLANG_VERSION(2,8)
+  #define ecb_decltype(x) __typeof__ (x)
+#endif
+
+#if _MSC_VER >= 1300
+  #define ecb_deprecated __declspec (deprecated)
+#else
+  #define ecb_deprecated ecb_attribute ((__deprecated__))
+#endif
+
+#if _MSC_VER >= 1500
+  #define ecb_deprecated_message(msg) __declspec (deprecated (msg))
+#elif ECB_GCC_VERSION(4,5)
+  #define ecb_deprecated_message(msg) ecb_attribute ((__deprecated__ (msg))
+#else
+  #define ecb_deprecated_message(msg) ecb_deprecated
+#endif
+
+#if _MSC_VER >= 1400
+  #define ecb_noinline __declspec (noinline)
+#else
+  #define ecb_noinline ecb_attribute ((__noinline__))
+#endif
+
+#define ecb_unused     ecb_attribute ((__unused__))
+#define ecb_const      ecb_attribute ((__const__))
+#define ecb_pure       ecb_attribute ((__pure__))
+
+#if ECB_C11 || __IBMC_NORETURN
+  /* http://www-01.ibm.com/support/knowledgecenter/SSGH3R_13.1.0/com.ibm.xlcpp131.aix.doc/language_ref/noreturn.html */
+  #define ecb_noreturn   _Noreturn
+#elif ECB_CPP11
+  #define ecb_noreturn   [[noreturn]]
+#elif _MSC_VER >= 1200
+  /* http://msdn.microsoft.com/en-us/library/k6ktzx3s.aspx */
+  #define ecb_noreturn   __declspec (noreturn)
+#else
+  #define ecb_noreturn   ecb_attribute ((__noreturn__))
+#endif
+
+#if ECB_GCC_VERSION(4,3)
+  #define ecb_artificial ecb_attribute ((__artificial__))
+  #define ecb_hot        ecb_attribute ((__hot__))
+  #define ecb_cold       ecb_attribute ((__cold__))
+#else
+  #define ecb_artificial
+  #define ecb_hot
+  #define ecb_cold
+#endif
+
+/* put around conditional expressions if you are very sure that the  */
+/* expression is mostly true or mostly false. note that these return */
+/* booleans, not the expression.                                     */
+#define ecb_expect_false(expr) ecb_expect (!!(expr), 0)
+#define ecb_expect_true(expr)  ecb_expect (!!(expr), 1)
+/* for compatibility to the rest of the world */
+#define ecb_likely(expr)   ecb_expect_true  (expr)
+#define ecb_unlikely(expr) ecb_expect_false (expr)
+
+/* count trailing zero bits and count # of one bits */
+#if ECB_GCC_VERSION(3,4) \
+    || (ECB_CLANG_BUILTIN(__builtin_clz) && ECB_CLANG_BUILTIN(__builtin_clzll) \
+        && ECB_CLANG_BUILTIN(__builtin_ctz) && ECB_CLANG_BUILTIN(__builtin_ctzll) \
+        && ECB_CLANG_BUILTIN(__builtin_popcount))
+  /* we assume int == 32 bit, long == 32 or 64 bit and long long == 64 bit */
+  #define ecb_ld32(x)      (__builtin_clz      (x) ^ 31)
+  #define ecb_ld64(x)      (__builtin_clzll    (x) ^ 63)
+  #define ecb_ctz32(x)      __builtin_ctz      (x)
+  #define ecb_ctz64(x)      __builtin_ctzll    (x)
+  #define ecb_popcount32(x) __builtin_popcount (x)
+  /* no popcountll */
+#else
+  ecb_function_ ecb_const int ecb_ctz32 (uint32_t x);
+  ecb_function_ ecb_const int
+  ecb_ctz32 (uint32_t x)
+  {
+#if 1400 <= _MSC_VER && (_M_IX86 || _M_X64 || _M_IA64 || _M_ARM)
+    unsigned long r;
+    _BitScanForward (&r, x);
+    return (int)r;
+#else
+    int r = 0;
+
+    x &= ~x + 1; /* this isolates the lowest bit */
+
+#if ECB_branchless_on_i386
+    r += !!(x & 0xaaaaaaaa) << 0;
+    r += !!(x & 0xcccccccc) << 1;
+    r += !!(x & 0xf0f0f0f0) << 2;
+    r += !!(x & 0xff00ff00) << 3;
+    r += !!(x & 0xffff0000) << 4;
+#else
+    if (x & 0xaaaaaaaa) r +=  1;
+    if (x & 0xcccccccc) r +=  2;
+    if (x & 0xf0f0f0f0) r +=  4;
+    if (x & 0xff00ff00) r +=  8;
+    if (x & 0xffff0000) r += 16;
+#endif
+
+    return r;
+#endif
+  }
+
+  ecb_function_ ecb_const int ecb_ctz64 (uint64_t x);
+  ecb_function_ ecb_const int
+  ecb_ctz64 (uint64_t x)
+  {
+#if 1400 <= _MSC_VER && (_M_X64 || _M_IA64 || _M_ARM)
+    unsigned long r;
+    _BitScanForward64 (&r, x);
+    return (int)r;
+#else
+    int shift = x & 0xffffffff ? 0 : 32;
+    return ecb_ctz32 (x >> shift) + shift;
+#endif
+  }
+
+  ecb_function_ ecb_const int ecb_popcount32 (uint32_t x);
+  ecb_function_ ecb_const int
+  ecb_popcount32 (uint32_t x)
+  {
+    x -=  (x >> 1) & 0x55555555;
+    x  = ((x >> 2) & 0x33333333) + (x & 0x33333333);
+    x  = ((x >> 4) + x) & 0x0f0f0f0f;
+    x *= 0x01010101;
+
+    return x >> 24;
+  }
+
+  ecb_function_ ecb_const int ecb_ld32 (uint32_t x);
+  ecb_function_ ecb_const int ecb_ld32 (uint32_t x)
+  {
+#if 1400 <= _MSC_VER && (_M_IX86 || _M_X64 || _M_IA64 || _M_ARM)
+    unsigned long r;
+    _BitScanReverse (&r, x);
+    return (int)r;
+#else
+    int r = 0;
+
+    if (x >> 16) { x >>= 16; r += 16; }
+    if (x >>  8) { x >>=  8; r +=  8; }
+    if (x >>  4) { x >>=  4; r +=  4; }
+    if (x >>  2) { x >>=  2; r +=  2; }
+    if (x >>  1) {           r +=  1; }
+
+    return r;
+#endif
+  }
+
+  ecb_function_ ecb_const int ecb_ld64 (uint64_t x);
+  ecb_function_ ecb_const int ecb_ld64 (uint64_t x)
+  {
+#if 1400 <= _MSC_VER && (_M_X64 || _M_IA64 || _M_ARM)
+    unsigned long r;
+    _BitScanReverse64 (&r, x);
+    return (int)r;
+#else
+    int r = 0;
+
+    if (x >> 32) { x >>= 32; r += 32; }
+
+    return r + ecb_ld32 (x);
+#endif
+  }
+#endif
+
+ecb_function_ ecb_const ecb_bool ecb_is_pot32 (uint32_t x);
+ecb_function_ ecb_const ecb_bool ecb_is_pot32 (uint32_t x) { return !(x & (x - 1)); }
+ecb_function_ ecb_const ecb_bool ecb_is_pot64 (uint64_t x);
+ecb_function_ ecb_const ecb_bool ecb_is_pot64 (uint64_t x) { return !(x & (x - 1)); }
+
+ecb_function_ ecb_const uint8_t  ecb_bitrev8  (uint8_t  x);
+ecb_function_ ecb_const uint8_t  ecb_bitrev8  (uint8_t  x)
+{
+  return (  (x * 0x0802U & 0x22110U)
+          | (x * 0x8020U & 0x88440U)) * 0x10101U >> 16;
+}
+
+ecb_function_ ecb_const uint16_t ecb_bitrev16 (uint16_t x);
+ecb_function_ ecb_const uint16_t ecb_bitrev16 (uint16_t x)
+{
+  x = ((x >>  1) &     0x5555) | ((x &     0x5555) <<  1);
+  x = ((x >>  2) &     0x3333) | ((x &     0x3333) <<  2);
+  x = ((x >>  4) &     0x0f0f) | ((x &     0x0f0f) <<  4);
+  x = ( x >>  8              ) | ( x               <<  8);
+
+  return x;
+}
+
+ecb_function_ ecb_const uint32_t ecb_bitrev32 (uint32_t x);
+ecb_function_ ecb_const uint32_t ecb_bitrev32 (uint32_t x)
+{
+  x = ((x >>  1) & 0x55555555) | ((x & 0x55555555) <<  1);
+  x = ((x >>  2) & 0x33333333) | ((x & 0x33333333) <<  2);
+  x = ((x >>  4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) <<  4);
+  x = ((x >>  8) & 0x00ff00ff) | ((x & 0x00ff00ff) <<  8);
+  x = ( x >> 16              ) | ( x               << 16);
+
+  return x;
+}
+
+/* popcount64 is only available on 64 bit cpus as gcc builtin */
+/* so for this version we are lazy */
+ecb_function_ ecb_const int ecb_popcount64 (uint64_t x);
+ecb_function_ ecb_const int
+ecb_popcount64 (uint64_t x)
+{
+  return ecb_popcount32 (x) + ecb_popcount32 (x >> 32);
+}
+
+ecb_inline ecb_const uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count);
+ecb_inline ecb_const uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count);
+ecb_inline ecb_const uint16_t ecb_rotl16 (uint16_t x, unsigned int count);
+ecb_inline ecb_const uint16_t ecb_rotr16 (uint16_t x, unsigned int count);
+ecb_inline ecb_const uint32_t ecb_rotl32 (uint32_t x, unsigned int count);
+ecb_inline ecb_const uint32_t ecb_rotr32 (uint32_t x, unsigned int count);
+ecb_inline ecb_const uint64_t ecb_rotl64 (uint64_t x, unsigned int count);
+ecb_inline ecb_const uint64_t ecb_rotr64 (uint64_t x, unsigned int count);
+
+ecb_inline ecb_const uint8_t  ecb_rotl8  (uint8_t  x, unsigned int count) { return (x >> ( 8 - count)) | (x << count); }
+ecb_inline ecb_const uint8_t  ecb_rotr8  (uint8_t  x, unsigned int count) { return (x << ( 8 - count)) | (x >> count); }
+ecb_inline ecb_const uint16_t ecb_rotl16 (uint16_t x, unsigned int count) { return (x >> (16 - count)) | (x << count); }
+ecb_inline ecb_const uint16_t ecb_rotr16 (uint16_t x, unsigned int count) { return (x << (16 - count)) | (x >> count); }
+ecb_inline ecb_const uint32_t ecb_rotl32 (uint32_t x, unsigned int count) { return (x >> (32 - count)) | (x << count); }
+ecb_inline ecb_const uint32_t ecb_rotr32 (uint32_t x, unsigned int count) { return (x << (32 - count)) | (x >> count); }
+ecb_inline ecb_const uint64_t ecb_rotl64 (uint64_t x, unsigned int count) { return (x >> (64 - count)) | (x << count); }
+ecb_inline ecb_const uint64_t ecb_rotr64 (uint64_t x, unsigned int count) { return (x << (64 - count)) | (x >> count); }
+
+#if ECB_GCC_VERSION(4,3) || (ECB_CLANG_BUILTIN(__builtin_bswap32) && ECB_CLANG_BUILTIN(__builtin_bswap64))
+  #if ECB_GCC_VERSION(4,8) || ECB_CLANG_BUILTIN(__builtin_bswap16)
+  #define ecb_bswap16(x)  __builtin_bswap16 (x)
+  #else
+  #define ecb_bswap16(x) (__builtin_bswap32 (x) >> 16)
+  #endif
+  #define ecb_bswap32(x)  __builtin_bswap32 (x)
+  #define ecb_bswap64(x)  __builtin_bswap64 (x)
+#elif _MSC_VER
+  #include <stdlib.h>
+  #define ecb_bswap16(x) ((uint16_t)_byteswap_ushort ((uint16_t)(x)))
+  #define ecb_bswap32(x) ((uint32_t)_byteswap_ulong  ((uint32_t)(x)))
+  #define ecb_bswap64(x) ((uint64_t)_byteswap_uint64 ((uint64_t)(x)))
+#else
+  ecb_function_ ecb_const uint16_t ecb_bswap16 (uint16_t x);
+  ecb_function_ ecb_const uint16_t
+  ecb_bswap16 (uint16_t x)
+  {
+    return ecb_rotl16 (x, 8);
+  }
+
+  ecb_function_ ecb_const uint32_t ecb_bswap32 (uint32_t x);
+  ecb_function_ ecb_const uint32_t
+  ecb_bswap32 (uint32_t x)
+  {
+    return (((uint32_t)ecb_bswap16 (x)) << 16) | ecb_bswap16 (x >> 16);
+  }
+
+  ecb_function_ ecb_const uint64_t ecb_bswap64 (uint64_t x);
+  ecb_function_ ecb_const uint64_t
+  ecb_bswap64 (uint64_t x)
+  {
+    return (((uint64_t)ecb_bswap32 (x)) << 32) | ecb_bswap32 (x >> 32);
+  }
+#endif
+
+#if ECB_GCC_VERSION(4,5) || ECB_CLANG_BUILTIN(__builtin_unreachable)
+  #define ecb_unreachable() __builtin_unreachable ()
+#else
+  /* this seems to work fine, but gcc always emits a warning for it :/ */
+  ecb_inline ecb_noreturn void ecb_unreachable (void);
+  ecb_inline ecb_noreturn void ecb_unreachable (void) { }
+#endif
+
+/* try to tell the compiler that some condition is definitely true */
+#define ecb_assume(cond) if (!(cond)) ecb_unreachable (); else 0
+
+ecb_inline ecb_const uint32_t ecb_byteorder_helper (void);
+ecb_inline ecb_const uint32_t
+ecb_byteorder_helper (void)
+{
+  /* the union code still generates code under pressure in gcc, */
+  /* but less than using pointers, and always seems to */
+  /* successfully return a constant. */
+  /* the reason why we have this horrible preprocessor mess */
+  /* is to avoid it in all cases, at least on common architectures */
+  /* or when using a recent enough gcc version (>= 4.6) */
+#if (defined __BYTE_ORDER__ && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) \
+    || ((__i386 || __i386__ || _M_IX86 || ECB_GCC_AMD64 || ECB_MSVC_AMD64) && !__VOS__)
+  #define ECB_LITTLE_ENDIAN 1
+  return 0x44332211;
+#elif (defined __BYTE_ORDER__ && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__) \
+      || ((__AARCH64EB__ || __MIPSEB__ || __ARMEB__) && !__VOS__)
+  #define ECB_BIG_ENDIAN 1
+  return 0x11223344;
+#else
+  union
+  {
+    uint8_t c[4];
+    uint32_t u;
+  } u = { 0x11, 0x22, 0x33, 0x44 };
+  return u.u;
+#endif
+}
+
+ecb_inline ecb_const ecb_bool ecb_big_endian    (void);
+ecb_inline ecb_const ecb_bool ecb_big_endian    (void) { return ecb_byteorder_helper () == 0x11223344; }
+ecb_inline ecb_const ecb_bool ecb_little_endian (void);
+ecb_inline ecb_const ecb_bool ecb_little_endian (void) { return ecb_byteorder_helper () == 0x44332211; }
+
+#if ECB_GCC_VERSION(3,0) || ECB_C99
+  #define ecb_mod(m,n) ((m) % (n) + ((m) % (n) < 0 ? (n) : 0))
+#else
+  #define ecb_mod(m,n) ((m) < 0 ? ((n) - 1 - ((-1 - (m)) % (n))) : ((m) % (n)))
+#endif
+
+#if ECB_CPP
+  template<typename T>
+  static inline T ecb_div_rd (T val, T div)
+  {
+    return val < 0 ? - ((-val + div - 1) / div) : (val          ) / div;
+  }
+  template<typename T>
+  static inline T ecb_div_ru (T val, T div)
+  {
+    return val < 0 ? - ((-val          ) / div) : (val + div - 1) / div;
+  }
+#else
+  #define ecb_div_rd(val,div) ((val) < 0 ? - ((-(val) + (div) - 1) / (div)) : ((val)            ) / (div))
+  #define ecb_div_ru(val,div) ((val) < 0 ? - ((-(val)            ) / (div)) : ((val) + (div) - 1) / (div))
+#endif
+
+#if ecb_cplusplus_does_not_suck
+  /* does not work for local types (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm) */
+  template<typename T, int N>
+  static inline int ecb_array_length (const T (&arr)[N])
+  {
+    return N;
+  }
+#else
+  #define ecb_array_length(name) (sizeof (name) / sizeof (name [0]))
+#endif
+
+ecb_function_ ecb_const uint32_t ecb_binary16_to_binary32 (uint32_t x);
+ecb_function_ ecb_const uint32_t
+ecb_binary16_to_binary32 (uint32_t x)
+{
+  unsigned int s = (x & 0x8000) << (31 - 15);
+  int          e = (x >> 10) & 0x001f;
+  unsigned int m =  x        & 0x03ff;
+
+  if (ecb_expect_false (e == 31))
+    /* infinity or NaN */
+    e = 255 - (127 - 15);
+  else if (ecb_expect_false (!e))
+    {
+      if (ecb_expect_true (!m))
+        /* zero, handled by code below by forcing e to 0 */
+        e = 0 - (127 - 15);
+      else
+        {
+          /* subnormal, renormalise */
+          unsigned int s = 10 - ecb_ld32 (m);
+
+          m = (m << s) & 0x3ff; /* mask implicit bit */
+          e -= s - 1;
+        }
+    }
+
+  /* e and m now are normalised, or zero, (or inf or nan) */
+  e += 127 - 15;
+
+  return s | (e << 23) | (m << (23 - 10));
+}
+
+ecb_function_ ecb_const uint16_t ecb_binary32_to_binary16 (uint32_t x);
+ecb_function_ ecb_const uint16_t
+ecb_binary32_to_binary16 (uint32_t x)
+{
+  unsigned int s =  (x >> 16) & 0x00008000; /* sign bit, the easy part */
+  unsigned int e = ((x >> 23) & 0x000000ff) - (127 - 15); /* the desired exponent */
+  unsigned int m =   x        & 0x007fffff;
+
+  x &= 0x7fffffff;
+
+  /* if it's within range of binary16 normals, use fast path */
+  if (ecb_expect_true (0x38800000 <= x && x <= 0x477fefff))
+    {
+      /* mantissa round-to-even */
+      m += 0x00000fff + ((m >> (23 - 10)) & 1);
+
+      /* handle overflow */
+      if (ecb_expect_false (m >= 0x00800000))
+        {
+          m >>= 1;
+          e +=  1;
+        }
+
+      return s | (e << 10) | (m >> (23 - 10));
+    }
+
+  /* handle large numbers and infinity */
+  if (ecb_expect_true (0x477fefff < x && x <= 0x7f800000))
+    return s | 0x7c00;
+
+  /* handle zero, subnormals and small numbers */
+  if (ecb_expect_true (x < 0x38800000))
+    {
+      /* zero */
+      if (ecb_expect_true (!x))
+        return s;
+
+      /* handle subnormals */
+
+      /* too small, will be zero */
+      if (e < (14 - 24)) /* might not be sharp, but is good enough */
+        return s;
+
+      m |= 0x00800000; /* make implicit bit explicit */
+
+      /* very tricky - we need to round to the nearest e (+10) bit value */
+      {
+        unsigned int bits = 14 - e;
+        unsigned int half = (1 << (bits - 1)) - 1;
+        unsigned int even = (m >> bits) & 1;
+
+        /* if this overflows, we will end up with a normalised number */
+        m = (m + half + even) >> bits;
+      }
+
+      return s | m;
+    }
+
+  /* handle NaNs, preserve leftmost nan bits, but make sure we don't turn them into infinities */
+  m >>= 13;
+
+  return s | 0x7c00 | m | !m;
+}
+
+/*******************************************************************************/
+/* floating point stuff, can be disabled by defining ECB_NO_LIBM */
+
+/* basically, everything uses "ieee pure-endian" floating point numbers */
+/* the only noteworthy exception is ancient armle, which uses order 43218765 */
+#if 0 \
+    || __i386 || __i386__ \
+    || ECB_GCC_AMD64 \
+    || __powerpc__ || __ppc__ || __powerpc64__ || __ppc64__ \
+    || defined __s390__ || defined __s390x__ \
+    || defined __mips__ \
+    || defined __alpha__ \
+    || defined __hppa__ \
+    || defined __ia64__ \
+    || defined __m68k__ \
+    || defined __m88k__ \
+    || defined __sh__ \
+    || defined _M_IX86 || defined ECB_MSVC_AMD64 || defined _M_IA64 \
+    || (defined __arm__ && (defined __ARM_EABI__ || defined __EABI__ || defined __VFP_FP__ || defined _WIN32_WCE || defined __ANDROID__)) \
+    || defined __aarch64__
+  #define ECB_STDFP 1
+  #include <string.h> /* for memcpy */
+#else
+  #define ECB_STDFP 0
+#endif
+
+#ifndef ECB_NO_LIBM
+
+  #include <math.h> /* for frexp*, ldexp*, INFINITY, NAN */
+
+  /* only the oldest of old doesn't have this one. solaris. */
+  #ifdef INFINITY
+    #define ECB_INFINITY INFINITY
+  #else
+    #define ECB_INFINITY HUGE_VAL
+  #endif
+
+  #ifdef NAN
+    #define ECB_NAN NAN
+  #else
+    #define ECB_NAN ECB_INFINITY
+  #endif
+
+  #if ECB_C99 || _XOPEN_VERSION >= 600 || _POSIX_VERSION >= 200112L
+    #define ecb_ldexpf(x,e) ldexpf ((x), (e))
+    #define ecb_frexpf(x,e) frexpf ((x), (e))
+  #else
+    #define ecb_ldexpf(x,e) (float) ldexp ((double) (x), (e))
+    #define ecb_frexpf(x,e) (float) frexp ((double) (x), (e))
+  #endif
+
+  /* convert a float to ieee single/binary32 */
+  ecb_function_ ecb_const uint32_t ecb_float_to_binary32 (float x);
+  ecb_function_ ecb_const uint32_t
+  ecb_float_to_binary32 (float x)
+  {
+    uint32_t r;
+
+    #if ECB_STDFP
+      memcpy (&r, &x, 4);
+    #else
+      /* slow emulation, works for anything but -0 */
+      uint32_t m;
+      int e;
+
+      if (x == 0e0f                    ) return 0x00000000U;
+      if (x > +3.40282346638528860e+38f) return 0x7f800000U;
+      if (x < -3.40282346638528860e+38f) return 0xff800000U;
+      if (x != x                       ) return 0x7fbfffffU;
+
+      m = ecb_frexpf (x, &e) * 0x1000000U;
+
+      r = m & 0x80000000U;
+
+      if (r)
+        m = -m;
+
+      if (e <= -126)
+        {
+          m &= 0xffffffU;
+          m >>= (-125 - e);
+          e = -126;
+        }
+
+      r |= (e + 126) << 23;
+      r |= m & 0x7fffffU;
+    #endif
+
+    return r;
+  }
+
+  /* converts an ieee single/binary32 to a float */
+  ecb_function_ ecb_const float ecb_binary32_to_float (uint32_t x);
+  ecb_function_ ecb_const float
+  ecb_binary32_to_float (uint32_t x)
+  {
+    float r;
+
+    #if ECB_STDFP
+      memcpy (&r, &x, 4);
+    #else
+      /* emulation, only works for normals and subnormals and +0 */
+      int neg = x >> 31;
+      int e = (x >> 23) & 0xffU;
+
+      x &= 0x7fffffU;
+
+      if (e)
+        x |= 0x800000U;
+      else
+        e = 1;
+
+      /* we distrust ldexpf a bit and do the 2**-24 scaling by an extra multiply */
+      r = ecb_ldexpf (x * (0.5f / 0x800000U), e - 126);
+
+      r = neg ? -r : r;
+    #endif
+
+    return r;
+  }
+
+  /* convert a double to ieee double/binary64 */
+  ecb_function_ ecb_const uint64_t ecb_double_to_binary64 (double x);
+  ecb_function_ ecb_const uint64_t
+  ecb_double_to_binary64 (double x)
+  {
+    uint64_t r;
+
+    #if ECB_STDFP
+      memcpy (&r, &x, 8);
+    #else
+      /* slow emulation, works for anything but -0 */
+      uint64_t m;
+      int e;
+
+      if (x == 0e0                     ) return 0x0000000000000000U;
+      if (x > +1.79769313486231470e+308) return 0x7ff0000000000000U;
+      if (x < -1.79769313486231470e+308) return 0xfff0000000000000U;
+      if (x != x                       ) return 0X7ff7ffffffffffffU;
+
+      m = frexp (x, &e) * 0x20000000000000U;
+
+      r = m & 0x8000000000000000;;
+
+      if (r)
+        m = -m;
+
+      if (e <= -1022)
+        {
+          m &= 0x1fffffffffffffU;
+          m >>= (-1021 - e);
+          e = -1022;
+        }
+
+      r |= ((uint64_t)(e + 1022)) << 52;
+      r |= m & 0xfffffffffffffU;
+    #endif
+
+    return r;
+  }
+
+  /* converts an ieee double/binary64 to a double */
+  ecb_function_ ecb_const double ecb_binary64_to_double (uint64_t x);
+  ecb_function_ ecb_const double
+  ecb_binary64_to_double (uint64_t x)
+  {
+    double r;
+
+    #if ECB_STDFP
+      memcpy (&r, &x, 8);
+    #else
+      /* emulation, only works for normals and subnormals and +0 */
+      int neg = x >> 63;
+      int e = (x >> 52) & 0x7ffU;
+
+      x &= 0xfffffffffffffU;
+
+      if (e)
+        x |= 0x10000000000000U;
+      else
+        e = 1;
+
+      /* we distrust ldexp a bit and do the 2**-53 scaling by an extra multiply */
+      r = ldexp (x * (0.5 / 0x10000000000000U), e - 1022);
+
+      r = neg ? -r : r;
+    #endif
+
+    return r;
+  }
+
+  /* convert a float to ieee half/binary16 */
+  ecb_function_ ecb_const uint16_t ecb_float_to_binary16 (float x);
+  ecb_function_ ecb_const uint16_t
+  ecb_float_to_binary16 (float x)
+  {
+    return ecb_binary32_to_binary16 (ecb_float_to_binary32 (x));
+  }
+
+  /* convert an ieee half/binary16 to float */
+  ecb_function_ ecb_const float ecb_binary16_to_float (uint16_t x);
+  ecb_function_ ecb_const float
+  ecb_binary16_to_float (uint16_t x)
+  {
+    return ecb_binary32_to_float (ecb_binary16_to_binary32 (x));
+  }
+
+#endif
+
+#endif
+
+/* ECB.H END */
+
+#if ECB_MEMORY_FENCE_NEEDS_PTHREADS
+/* if your architecture doesn't need memory fences, e.g. because it is
+ * single-cpu/core, or if you use libev in a project that doesn't use libev
+ * from multiple threads, then you can define ECB_AVOID_PTHREADS when compiling
+ * libev, in which cases the memory fences become nops.
+ * alternatively, you can remove this #error and link against libpthread,
+ * which will then provide the memory fences.
+ */
+# error "memory fences not defined for your architecture, please report"
+#endif
+
+#ifndef ECB_MEMORY_FENCE
+# define ECB_MEMORY_FENCE do { } while (0)
+# define ECB_MEMORY_FENCE_ACQUIRE ECB_MEMORY_FENCE
+# define ECB_MEMORY_FENCE_RELEASE ECB_MEMORY_FENCE
+#endif
+
+#define expect_false(cond) ecb_expect_false (cond)
+#define expect_true(cond)  ecb_expect_true  (cond)
+#define noinline           ecb_noinline
+
+#define inline_size        ecb_inline
+
+#if EV_FEATURE_CODE
+# define inline_speed      ecb_inline
+#else
+# define inline_speed      static noinline
+#endif
+
+#define NUMPRI (EV_MAXPRI - EV_MINPRI + 1)
+
+#if EV_MINPRI == EV_MAXPRI
+# define ABSPRI(w) (((W)w), 0)
+#else
+# define ABSPRI(w) (((W)w)->priority - EV_MINPRI)
+#endif
+
+#define EMPTY       /* required for microsofts broken pseudo-c compiler */
+#define EMPTY2(a,b) /* used to suppress some warnings */
+
+typedef ev_watcher *W;
+typedef ev_watcher_list *WL;
+typedef ev_watcher_time *WT;
+
+#define ev_active(w) ((W)(w))->active
+#define ev_at(w) ((WT)(w))->at
+
+#if EV_USE_REALTIME
+/* sig_atomic_t is used to avoid per-thread variables or locking but still */
+/* giving it a reasonably high chance of working on typical architectures */
+static EV_ATOMIC_T have_realtime; /* did clock_gettime (CLOCK_REALTIME) work? */
+#endif
+
+#if EV_USE_MONOTONIC
+static EV_ATOMIC_T have_monotonic; /* did clock_gettime (CLOCK_MONOTONIC) work? */
+#endif
+
+#ifndef EV_FD_TO_WIN32_HANDLE
+# define EV_FD_TO_WIN32_HANDLE(fd) _get_osfhandle (fd)
+#endif
+#ifndef EV_WIN32_HANDLE_TO_FD
+# define EV_WIN32_HANDLE_TO_FD(handle) _open_osfhandle (handle, 0)
+#endif
+#ifndef EV_WIN32_CLOSE_FD
+# define EV_WIN32_CLOSE_FD(fd) close (fd)
+#endif
+
+#ifdef _WIN32
+# include "ev_win32.c"
+#endif
+
+/*****************************************************************************/
+
+/* define a suitable floor function (only used by periodics atm) */
+
+#if EV_USE_FLOOR
+# include <math.h>
+# define ev_floor(v) floor (v)
+#else
+
+#include <float.h>
+
+/* a floor() replacement function, should be independent of ev_tstamp type */
+static ev_tstamp noinline
+ev_floor (ev_tstamp v)
+{
+  /* the choice of shift factor is not terribly important */
+#if FLT_RADIX != 2 /* assume FLT_RADIX == 10 */
+  const ev_tstamp shift = sizeof (unsigned long) >= 8 ? 10000000000000000000. : 1000000000.;
+#else
+  const ev_tstamp shift = sizeof (unsigned long) >= 8 ? 18446744073709551616. : 4294967296.;
+#endif
+
+  /* argument too large for an unsigned long? */
+  if (expect_false (v >= shift))
+    {
+      ev_tstamp f;
+
+      if (v == v - 1.)
+        return v; /* very large number */
+
+      f = shift * ev_floor (v * (1. / shift));
+      return f + ev_floor (v - f);
+    }
+
+  /* special treatment for negative args? */
+  if (expect_false (v < 0.))
+    {
+      ev_tstamp f = -ev_floor (-v);
+
+      return f - (f == v ? 0 : 1);
+    }
+
+  /* fits into an unsigned long */
+  return (unsigned long)v;
+}
+
+#endif
+
+/*****************************************************************************/
+
+#ifdef __linux
+# include <sys/utsname.h>
+#endif
+
+static unsigned int noinline ecb_cold
+ev_linux_version (void)
+{
+#ifdef __linux
+  unsigned int v = 0;
+  struct utsname buf;
+  int i;
+  char *p = buf.release;
+
+  if (uname (&buf))
+    return 0;
+
+  for (i = 3+1; --i; )
+    {
+      unsigned int c = 0;
+
+      for (;;)
+        {
+          if (*p >= '0' && *p <= '9')
+            c = c * 10 + *p++ - '0';
+          else
+            {
+              p += *p == '.';
+              break;
+            }
+        }
+
+      v = (v << 8) | c;
+    }
+
+  return v;
+#else
+  return 0;
+#endif
+}
+
+/*****************************************************************************/
+
+#if EV_AVOID_STDIO
+static void noinline ecb_cold
+ev_printerr (const char *msg)
+{
+  write (STDERR_FILENO, msg, strlen (msg));
+}
+#endif
+
+static void (*syserr_cb)(const char *msg) EV_THROW;
+
+void ecb_cold
+ev_set_syserr_cb (void (*cb)(const char *msg) EV_THROW) EV_THROW
+{
+  syserr_cb = cb;
+}
+
+static void noinline ecb_cold
+ev_syserr (const char *msg)
+{
+  if (!msg)
+    msg = "(libev) system error";
+
+  if (syserr_cb)
+    syserr_cb (msg);
+  else
+    {
+#if EV_AVOID_STDIO
+      ev_printerr (msg);
+      ev_printerr (": ");
+      ev_printerr (strerror (errno));
+      ev_printerr ("\n");
+#else
+      perror (msg);
+#endif
+      abort ();
+    }
+}
+
+static void *
+ev_realloc_emul (void *ptr, long size) EV_THROW
+{
+  /* some systems, notably openbsd and darwin, fail to properly
+   * implement realloc (x, 0) (as required by both ansi c-89 and
+   * the single unix specification, so work around them here.
+   * recently, also (at least) fedora and debian started breaking it,
+   * despite documenting it otherwise.
+   */
+
+  if (size)
+    return realloc (ptr, size);
+
+  free (ptr);
+  return 0;
+}
+
+static void *(*alloc)(void *ptr, long size) EV_THROW = ev_realloc_emul;
+
+void ecb_cold
+ev_set_allocator (void *(*cb)(void *ptr, long size) EV_THROW) EV_THROW
+{
+  alloc = cb;
+}
+
+inline_speed void *
+ev_realloc (void *ptr, long size)
+{
+  ptr = alloc (ptr, size);
+
+  if (!ptr && size)
+    {
+#if EV_AVOID_STDIO
+      ev_printerr ("(libev) memory allocation failed, aborting.\n");
+#else
+      fprintf (stderr, "(libev) cannot allocate %ld bytes, aborting.", size);
+#endif
+      abort ();
+    }
+
+  return ptr;
+}
+
+#define ev_malloc(size) ev_realloc (0, (size))
+#define ev_free(ptr)    ev_realloc ((ptr), 0)
+
+/*****************************************************************************/
+
+/* set in reify when reification needed */
+#define EV_ANFD_REIFY 1
+
+/* file descriptor info structure */
+typedef struct
+{
+  WL head;
+  unsigned char events; /* the events watched for */
+  unsigned char reify;  /* flag set when this ANFD needs reification (EV_ANFD_REIFY, EV__IOFDSET) */
+  unsigned char emask;  /* the epoll backend stores the actual kernel mask in here */
+  unsigned char unused;
+#if EV_USE_EPOLL
+  unsigned int egen;    /* generation counter to counter epoll bugs */
+#endif
+#if EV_SELECT_IS_WINSOCKET || EV_USE_IOCP
+  SOCKET handle;
+#endif
+#if EV_USE_IOCP
+  OVERLAPPED or, ow;
+#endif
+} ANFD;
+
+/* stores the pending event set for a given watcher */
+typedef struct
+{
+  W w;
+  int events; /* the pending event set for the given watcher */
+} ANPENDING;
+
+#if EV_USE_INOTIFY
+/* hash table entry per inotify-id */
+typedef struct
+{
+  WL head;
+} ANFS;
+#endif
+
+/* Heap Entry */
+#if EV_HEAP_CACHE_AT
+  /* a heap element */
+  typedef struct {
+    ev_tstamp at;
+    WT w;
+  } ANHE;
+
+  #define ANHE_w(he)        (he).w     /* access watcher, read-write */
+  #define ANHE_at(he)       (he).at    /* access cached at, read-only */
+  #define ANHE_at_cache(he) (he).at = (he).w->at /* update at from watcher */
+#else
+  /* a heap element */
+  typedef WT ANHE;
+
+  #define ANHE_w(he)        (he)
+  #define ANHE_at(he)       (he)->at
+  #define ANHE_at_cache(he)
+#endif
+
+#if EV_MULTIPLICITY
+
+  struct ev_loop
+  {
+    ev_tstamp ev_rt_now;
+    #define ev_rt_now ((loop)->ev_rt_now)
+    #define VAR(name,decl) decl;
+      #include "ev_vars.h"
+    #undef VAR
+  };
+  #include "ev_wrap.h"
+
+  static struct ev_loop default_loop_struct;
+  EV_API_DECL struct ev_loop *ev_default_loop_ptr = 0; /* needs to be initialised to make it a definition despite extern */
+
+#else
+
+  EV_API_DECL ev_tstamp ev_rt_now = 0; /* needs to be initialised to make it a definition despite extern */
+  #define VAR(name,decl) static decl;
+    #include "ev_vars.h"
+  #undef VAR
+
+  static int ev_default_loop_ptr;
+
+#endif
+
+#if EV_FEATURE_API
+# define EV_RELEASE_CB if (expect_false (release_cb)) release_cb (EV_A)
+# define EV_ACQUIRE_CB if (expect_false (acquire_cb)) acquire_cb (EV_A)
+# define EV_INVOKE_PENDING invoke_cb (EV_A)
+#else
+# define EV_RELEASE_CB (void)0
+# define EV_ACQUIRE_CB (void)0
+# define EV_INVOKE_PENDING ev_invoke_pending (EV_A)
+#endif
+
+#define EVBREAK_RECURSE 0x80
+
+/*****************************************************************************/
+
+#ifndef EV_HAVE_EV_TIME
+ev_tstamp
+ev_time (void) EV_THROW
+{
+#if EV_USE_REALTIME
+  if (expect_true (have_realtime))
+    {
+      struct timespec ts;
+      clock_gettime (CLOCK_REALTIME, &ts);
+      return ts.tv_sec + ts.tv_nsec * 1e-9;
+    }
+#endif
+
+  struct timeval tv;
+  gettimeofday (&tv, 0);
+  return tv.tv_sec + tv.tv_usec * 1e-6;
+}
+#endif
+
+inline_size ev_tstamp
+get_clock (void)
+{
+#if EV_USE_MONOTONIC
+  if (expect_true (have_monotonic))
+    {
+      struct timespec ts;
+      clock_gettime (CLOCK_MONOTONIC, &ts);
+      return ts.tv_sec + ts.tv_nsec * 1e-9;
+    }
+#endif
+
+  return ev_time ();
+}
+
+#if EV_MULTIPLICITY
+ev_tstamp
+ev_now (EV_P) EV_THROW
+{
+  return ev_rt_now;
+}
+#endif
+
+void
+ev_sleep (ev_tstamp delay) EV_THROW
+{
+  if (delay > 0.)
+    {
+#if EV_USE_NANOSLEEP
+      struct timespec ts;
+
+      EV_TS_SET (ts, delay);
+      nanosleep (&ts, 0);
+#elif defined _WIN32
+      Sleep ((unsigned long)(delay * 1e3));
+#else
+      struct timeval tv;
+
+      /* here we rely on sys/time.h + sys/types.h + unistd.h providing select */
+      /* something not guaranteed by newer posix versions, but guaranteed */
+      /* by older ones */
+      EV_TV_SET (tv, delay);
+      select (0, 0, 0, 0, &tv);
+#endif
+    }
+}
+
+/*****************************************************************************/
+
+#define MALLOC_ROUND 4096 /* prefer to allocate in chunks of this size, must be 2**n and >> 4 longs */
+
+/* find a suitable new size for the given array, */
+/* hopefully by rounding to a nice-to-malloc size */
+inline_size int
+array_nextsize (int elem, int cur, int cnt)
+{
+  int ncur = cur + 1;
+
+  do
+    ncur <<= 1;
+  while (cnt > ncur);
+
+  /* if size is large, round to MALLOC_ROUND - 4 * longs to accommodate malloc overhead */
+  if (elem * ncur > MALLOC_ROUND - sizeof (void *) * 4)
+    {
+      ncur *= elem;
+      ncur = (ncur + elem + (MALLOC_ROUND - 1) + sizeof (void *) * 4) & ~(MALLOC_ROUND - 1);
+      ncur = ncur - sizeof (void *) * 4;
+      ncur /= elem;
+    }
+
+  return ncur;
+}
+
+static void * noinline ecb_cold
+array_realloc (int elem, void *base, int *cur, int cnt)
+{
+  *cur = array_nextsize (elem, *cur, cnt);
+  return ev_realloc (base, elem * *cur);
+}
+
+#define array_init_zero(base,count)	\
+  memset ((void *)(base), 0, sizeof (*(base)) * (count))
+
+#define array_needsize(type,base,cur,cnt,init)			\
+  if (expect_false ((cnt) > (cur)))				\
+    {								\
+      int ecb_unused ocur_ = (cur);					\
+      (base) = (type *)array_realloc				\
+         (sizeof (type), (base), &(cur), (cnt));		\
+      init ((base) + (ocur_), (cur) - ocur_);			\
+    }
+
+#if 0
+#define array_slim(type,stem)					\
+  if (stem ## max < array_roundsize (stem ## cnt >> 2))		\
+    {								\
+      stem ## max = array_roundsize (stem ## cnt >> 1);		\
+      base = (type *)ev_realloc (base, sizeof (type) * (stem ## max));\
+      fprintf (stderr, "slimmed down " # stem " to %d\n", stem ## max);/*D*/\
+    }
+#endif
+
+#define array_free(stem, idx) \
+  ev_free (stem ## s idx); stem ## cnt idx = stem ## max idx = 0; stem ## s idx = 0
+
+/*****************************************************************************/
+
+/* dummy callback for pending events */
+static void noinline
+pendingcb (EV_P_ ev_prepare *w, int revents)
+{
+}
+
+void noinline
+ev_feed_event (EV_P_ void *w, int revents) EV_THROW
+{
+  W w_ = (W)w;
+  int pri = ABSPRI (w_);
+
+  if (expect_false (w_->pending))
+    pendings [pri][w_->pending - 1].events |= revents;
+  else
+    {
+      w_->pending = ++pendingcnt [pri];
+      array_needsize (ANPENDING, pendings [pri], pendingmax [pri], w_->pending, EMPTY2);
+      pendings [pri][w_->pending - 1].w      = w_;
+      pendings [pri][w_->pending - 1].events = revents;
+    }
+
+  pendingpri = NUMPRI - 1;
+}
+
+inline_speed void
+feed_reverse (EV_P_ W w)
+{
+  array_needsize (W, rfeeds, rfeedmax, rfeedcnt + 1, EMPTY2);
+  rfeeds [rfeedcnt++] = w;
+}
+
+inline_size void
+feed_reverse_done (EV_P_ int revents)
+{
+  do
+    ev_feed_event (EV_A_ rfeeds [--rfeedcnt], revents);
+  while (rfeedcnt);
+}
+
+inline_speed void
+queue_events (EV_P_ W *events, int eventcnt, int type)
+{
+  int i;
+
+  for (i = 0; i < eventcnt; ++i)
+    ev_feed_event (EV_A_ events [i], type);
+}
+
+/*****************************************************************************/
+
+inline_speed void
+fd_event_nocheck (EV_P_ int fd, int revents)
+{
+  ANFD *anfd = anfds + fd;
+  ev_io *w;
+
+  for (w = (ev_io *)anfd->head; w; w = (ev_io *)((WL)w)->next)
+    {
+      int ev = w->events & revents;
+
+      if (ev)
+        ev_feed_event (EV_A_ (W)w, ev);
+    }
+}
+
+/* do not submit kernel events for fds that have reify set */
+/* because that means they changed while we were polling for new events */
+inline_speed void
+fd_event (EV_P_ int fd, int revents)
+{
+  ANFD *anfd = anfds + fd;
+
+  if (expect_true (!anfd->reify))
+    fd_event_nocheck (EV_A_ fd, revents);
+}
+
+void
+ev_feed_fd_event (EV_P_ int fd, int revents) EV_THROW
+{
+  if (fd >= 0 && fd < anfdmax)
+    fd_event_nocheck (EV_A_ fd, revents);
+}
+
+/* make sure the external fd watch events are in-sync */
+/* with the kernel/libev internal state */
+inline_size void
+fd_reify (EV_P)
+{
+  int i;
+
+#if EV_SELECT_IS_WINSOCKET || EV_USE_IOCP
+  for (i = 0; i < fdchangecnt; ++i)
+    {
+      int fd = fdchanges [i];
+      ANFD *anfd = anfds + fd;
+
+      if (anfd->reify & EV__IOFDSET && anfd->head)
+        {
+          SOCKET handle = EV_FD_TO_WIN32_HANDLE (fd);
+
+          if (handle != anfd->handle)
+            {
+              unsigned long arg;
+
+              assert (("libev: only socket fds supported in this configuration", ioctlsocket (handle, FIONREAD, &arg) == 0));
+
+              /* handle changed, but fd didn't - we need to do it in two steps */
+              backend_modify (EV_A_ fd, anfd->events, 0);
+              anfd->events = 0;
+              anfd->handle = handle;
+            }
+        }
+    }
+#endif
+
+  for (i = 0; i < fdchangecnt; ++i)
+    {
+      int fd = fdchanges [i];
+      ANFD *anfd = anfds + fd;
+      ev_io *w;
+
+      unsigned char o_events = anfd->events;
+      unsigned char o_reify  = anfd->reify;
+
+      anfd->reify  = 0;
+
+      /*if (expect_true (o_reify & EV_ANFD_REIFY)) probably a deoptimisation */
+        {
+          anfd->events = 0;
+
+          for (w = (ev_io *)anfd->head; w; w = (ev_io *)((WL)w)->next)
+            anfd->events |= (unsigned char)w->events;
+
+          if (o_events != anfd->events)
+            o_reify = EV__IOFDSET; /* actually |= */
+        }
+
+      if (o_reify & EV__IOFDSET)
+        backend_modify (EV_A_ fd, o_events, anfd->events);
+    }
+
+  fdchangecnt = 0;
+}
+
+/* something about the given fd changed */
+inline_size void
+fd_change (EV_P_ int fd, int flags)
+{
+  unsigned char reify = anfds [fd].reify;
+  anfds [fd].reify |= flags;
+
+  if (expect_true (!reify))
+    {
+      ++fdchangecnt;
+      array_needsize (int, fdchanges, fdchangemax, fdchangecnt, EMPTY2);
+      fdchanges [fdchangecnt - 1] = fd;
+    }
+}
+
+/* the given fd is invalid/unusable, so make sure it doesn't hurt us anymore */
+inline_speed void ecb_cold
+fd_kill (EV_P_ int fd)
+{
+  ev_io *w;
+
+  while ((w = (ev_io *)anfds [fd].head))
+    {
+      ev_io_stop (EV_A_ w);
+      ev_feed_event (EV_A_ (W)w, EV_ERROR | EV_READ | EV_WRITE);
+    }
+}
+
+/* check whether the given fd is actually valid, for error recovery */
+inline_size int ecb_cold
+fd_valid (int fd)
+{
+#ifdef _WIN32
+  return EV_FD_TO_WIN32_HANDLE (fd) != -1;
+#else
+  return fcntl (fd, F_GETFD) != -1;
+#endif
+}
+
+/* called on EBADF to verify fds */
+static void noinline ecb_cold
+fd_ebadf (EV_P)
+{
+  int fd;
+
+  for (fd = 0; fd < anfdmax; ++fd)
+    if (anfds [fd].events)
+      if (!fd_valid (fd) && errno == EBADF)
+        fd_kill (EV_A_ fd);
+}
+
+/* called on ENOMEM in select/poll to kill some fds and retry */
+static void noinline ecb_cold
+fd_enomem (EV_P)
+{
+  int fd;
+
+  for (fd = anfdmax; fd--; )
+    if (anfds [fd].events)
+      {
+        fd_kill (EV_A_ fd);
+        break;
+      }
+}
+
+/* usually called after fork if backend needs to re-arm all fds from scratch */
+static void noinline
+fd_rearm_all (EV_P)
+{
+  int fd;
+
+  for (fd = 0; fd < anfdmax; ++fd)
+    if (anfds [fd].events)
+      {
+        anfds [fd].events = 0;
+        anfds [fd].emask  = 0;
+        fd_change (EV_A_ fd, EV__IOFDSET | EV_ANFD_REIFY);
+      }
+}
+
+/* used to prepare libev internal fd's */
+/* this is not fork-safe */
+inline_speed void
+fd_intern (int fd)
+{
+#ifdef _WIN32
+  unsigned long arg = 1;
+  ioctlsocket (EV_FD_TO_WIN32_HANDLE (fd), FIONBIO, &arg);
+#else
+  fcntl (fd, F_SETFD, FD_CLOEXEC);
+  fcntl (fd, F_SETFL, O_NONBLOCK);
+#endif
+}
+
+/*****************************************************************************/
+
+/*
+ * the heap functions want a real array index. array index 0 is guaranteed to not
+ * be in-use at any time. the first heap entry is at array [HEAP0]. DHEAP gives
+ * the branching factor of the d-tree.
+ */
+
+/*
+ * at the moment we allow libev the luxury of two heaps,
+ * a small-code-size 2-heap one and a ~1.5kb larger 4-heap
+ * which is more cache-efficient.
+ * the difference is about 5% with 50000+ watchers.
+ */
+#if EV_USE_4HEAP
+
+#define DHEAP 4
+#define HEAP0 (DHEAP - 1) /* index of first element in heap */
+#define HPARENT(k) ((((k) - HEAP0 - 1) / DHEAP) + HEAP0)
+#define UPHEAP_DONE(p,k) ((p) == (k))
+
+/* away from the root */
+inline_speed void
+downheap (ANHE *heap, int N, int k)
+{
+  ANHE he = heap [k];
+  ANHE *E = heap + N + HEAP0;
+
+  for (;;)
+    {
+      ev_tstamp minat;
+      ANHE *minpos;
+      ANHE *pos = heap + DHEAP * (k - HEAP0) + HEAP0 + 1;
+
+      /* find minimum child */
+      if (expect_true (pos + DHEAP - 1 < E))
+        {
+          /* fast path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));
+          if (               ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));
+          if (               ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));
+          if (               ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));
+        }
+      else if (pos < E)
+        {
+          /* slow path */                               (minpos = pos + 0), (minat = ANHE_at (*minpos));
+          if (pos + 1 < E && ANHE_at (pos [1]) < minat) (minpos = pos + 1), (minat = ANHE_at (*minpos));
+          if (pos + 2 < E && ANHE_at (pos [2]) < minat) (minpos = pos + 2), (minat = ANHE_at (*minpos));
+          if (pos + 3 < E && ANHE_at (pos [3]) < minat) (minpos = pos + 3), (minat = ANHE_at (*minpos));
+        }
+      else
+        break;
+
+      if (ANHE_at (he) <= minat)
+        break;
+
+      heap [k] = *minpos;
+      ev_active (ANHE_w (*minpos)) = k;
+
+      k = minpos - heap;
+    }
+
+  heap [k] = he;
+  ev_active (ANHE_w (he)) = k;
+}
+
+#else /* 4HEAP */
+
+#define HEAP0 1
+#define HPARENT(k) ((k) >> 1)
+#define UPHEAP_DONE(p,k) (!(p))
+
+/* away from the root */
+inline_speed void
+downheap (ANHE *heap, int N, int k)
+{
+  ANHE he = heap [k];
+
+  for (;;)
+    {
+      int c = k << 1;
+
+      if (c >= N + HEAP0)
+        break;
+
+      c += c + 1 < N + HEAP0 && ANHE_at (heap [c]) > ANHE_at (heap [c + 1])
+           ? 1 : 0;
+
+      if (ANHE_at (he) <= ANHE_at (heap [c]))
+        break;
+
+      heap [k] = heap [c];
+      ev_active (ANHE_w (heap [k])) = k;
+      
+      k = c;
+    }
+
+  heap [k] = he;
+  ev_active (ANHE_w (he)) = k;
+}
+#endif
+
+/* towards the root */
+inline_speed void
+upheap (ANHE *heap, int k)
+{
+  ANHE he = heap [k];
+
+  for (;;)
+    {
+      int p = HPARENT (k);
+
+      if (UPHEAP_DONE (p, k) || ANHE_at (heap [p]) <= ANHE_at (he))
+        break;
+
+      heap [k] = heap [p];
+      ev_active (ANHE_w (heap [k])) = k;
+      k = p;
+    }
+
+  heap [k] = he;
+  ev_active (ANHE_w (he)) = k;
+}
+
+/* move an element suitably so it is in a correct place */
+inline_size void
+adjustheap (ANHE *heap, int N, int k)
+{
+  if (k > HEAP0 && ANHE_at (heap [k]) <= ANHE_at (heap [HPARENT (k)]))
+    upheap (heap, k);
+  else
+    downheap (heap, N, k);
+}
+
+/* rebuild the heap: this function is used only once and executed rarely */
+inline_size void
+reheap (ANHE *heap, int N)
+{
+  int i;
+
+  /* we don't use floyds algorithm, upheap is simpler and is more cache-efficient */
+  /* also, this is easy to implement and correct for both 2-heaps and 4-heaps */
+  for (i = 0; i < N; ++i)
+    upheap (heap, i + HEAP0);
+}
+
+/*****************************************************************************/
+
+/* associate signal watchers to a signal signal */
+typedef struct
+{
+  EV_ATOMIC_T pending;
+#if EV_MULTIPLICITY
+  EV_P;
+#endif
+  WL head;
+} ANSIG;
+
+static ANSIG signals [EV_NSIG - 1];
+
+/*****************************************************************************/
+
+#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
+
+static void noinline ecb_cold
+evpipe_init (EV_P)
+{
+  if (!ev_is_active (&pipe_w))
+    {
+      int fds [2];
+
+# if EV_USE_EVENTFD
+      fds [0] = -1;
+      fds [1] = eventfd (0, EFD_NONBLOCK | EFD_CLOEXEC);
+      if (fds [1] < 0 && errno == EINVAL)
+        fds [1] = eventfd (0, 0);
+
+      if (fds [1] < 0)
+# endif
+        {
+          while (pipe (fds))
+            ev_syserr ("(libev) error creating signal/async pipe");
+
+          fd_intern (fds [0]);
+        }
+
+      evpipe [0] = fds [0];
+
+      if (evpipe [1] < 0)
+        evpipe [1] = fds [1]; /* first call, set write fd */
+      else
+        {
+          /* on subsequent calls, do not change evpipe [1] */
+          /* so that evpipe_write can always rely on its value. */
+          /* this branch does not do anything sensible on windows, */
+          /* so must not be executed on windows */
+
+          dup2 (fds [1], evpipe [1]);
+          close (fds [1]);
+        }
+
+      fd_intern (evpipe [1]);
+
+      ev_io_set (&pipe_w, evpipe [0] < 0 ? evpipe [1] : evpipe [0], EV_READ);
+      ev_io_start (EV_A_ &pipe_w);
+      ev_unref (EV_A); /* watcher should not keep loop alive */
+    }
+}
+
+inline_speed void
+evpipe_write (EV_P_ EV_ATOMIC_T *flag)
+{
+  ECB_MEMORY_FENCE; /* push out the write before this function was called, acquire flag */
+
+  if (expect_true (*flag))
+    return;
+
+  *flag = 1;
+  ECB_MEMORY_FENCE_RELEASE; /* make sure flag is visible before the wakeup */
+
+  pipe_write_skipped = 1;
+
+  ECB_MEMORY_FENCE; /* make sure pipe_write_skipped is visible before we check pipe_write_wanted */
+
+  if (pipe_write_wanted)
+    {
+      int old_errno;
+
+      pipe_write_skipped = 0;
+      ECB_MEMORY_FENCE_RELEASE;
+
+      old_errno = errno; /* save errno because write will clobber it */
+
+#if EV_USE_EVENTFD
+      if (evpipe [0] < 0)
+        {
+          uint64_t counter = 1;
+          write (evpipe [1], &counter, sizeof (uint64_t));
+        }
+      else
+#endif
+        {
+#ifdef _WIN32
+          WSABUF buf;
+          DWORD sent;
+          buf.buf = &buf;
+          buf.len = 1;
+          WSASend (EV_FD_TO_WIN32_HANDLE (evpipe [1]), &buf, 1, &sent, 0, 0, 0);
+#else
+          write (evpipe [1], &(evpipe [1]), 1);
+#endif
+        }
+
+      errno = old_errno;
+    }
+}
+
+/* called whenever the libev signal pipe */
+/* got some events (signal, async) */
+static void
+pipecb (EV_P_ ev_io *iow, int revents)
+{
+  int i;
+
+  if (revents & EV_READ)
+    {
+#if EV_USE_EVENTFD
+      if (evpipe [0] < 0)
+        {
+          uint64_t counter;
+          read (evpipe [1], &counter, sizeof (uint64_t));
+        }
+      else
+#endif
+        {
+          char dummy[4];
+#ifdef _WIN32
+          WSABUF buf;
+          DWORD recvd;
+          DWORD flags = 0;
+          buf.buf = dummy;
+          buf.len = sizeof (dummy);
+          WSARecv (EV_FD_TO_WIN32_HANDLE (evpipe [0]), &buf, 1, &recvd, &flags, 0, 0);
+#else
+          read (evpipe [0], &dummy, sizeof (dummy));
+#endif
+        }
+    }
+
+  pipe_write_skipped = 0;
+
+  ECB_MEMORY_FENCE; /* push out skipped, acquire flags */
+
+#if EV_SIGNAL_ENABLE
+  if (sig_pending)
+    {
+      sig_pending = 0;
+
+      ECB_MEMORY_FENCE;
+
+      for (i = EV_NSIG - 1; i--; )
+        if (expect_false (signals [i].pending))
+          ev_feed_signal_event (EV_A_ i + 1);
+    }
+#endif
+
+#if EV_ASYNC_ENABLE
+  if (async_pending)
+    {
+      async_pending = 0;
+
+      ECB_MEMORY_FENCE;
+
+      for (i = asynccnt; i--; )
+        if (asyncs [i]->sent)
+          {
+            asyncs [i]->sent = 0;
+            ECB_MEMORY_FENCE_RELEASE;
+            ev_feed_event (EV_A_ asyncs [i], EV_ASYNC);
+          }
+    }
+#endif
+}
+
+/*****************************************************************************/
+
+void
+ev_feed_signal (int signum) EV_THROW
+{
+#if EV_MULTIPLICITY
+  EV_P;
+  ECB_MEMORY_FENCE_ACQUIRE;
+  EV_A = signals [signum - 1].loop;
+
+  if (!EV_A)
+    return;
+#endif
+
+  signals [signum - 1].pending = 1;
+  evpipe_write (EV_A_ &sig_pending);
+}
+
+static void
+ev_sighandler (int signum)
+{
+#ifdef _WIN32
+  signal (signum, ev_sighandler);
+#endif
+
+  ev_feed_signal (signum);
+}
+
+void noinline
+ev_feed_signal_event (EV_P_ int signum) EV_THROW
+{
+  WL w;
+
+  if (expect_false (signum <= 0 || signum >= EV_NSIG))
+    return;
+
+  --signum;
+
+#if EV_MULTIPLICITY
+  /* it is permissible to try to feed a signal to the wrong loop */
+  /* or, likely more useful, feeding a signal nobody is waiting for */
+
+  if (expect_false (signals [signum].loop != EV_A))
+    return;
+#endif
+
+  signals [signum].pending = 0;
+  ECB_MEMORY_FENCE_RELEASE;
+
+  for (w = signals [signum].head; w; w = w->next)
+    ev_feed_event (EV_A_ (W)w, EV_SIGNAL);
+}
+
+#if EV_USE_SIGNALFD
+static void
+sigfdcb (EV_P_ ev_io *iow, int revents)
+{
+  struct signalfd_siginfo si[2], *sip; /* these structs are big */
+
+  for (;;)
+    {
+      ssize_t res = read (sigfd, si, sizeof (si));
+
+      /* not ISO-C, as res might be -1, but works with SuS */
+      for (sip = si; (char *)sip < (char *)si + res; ++sip)
+        ev_feed_signal_event (EV_A_ sip->ssi_signo);
+
+      if (res < (ssize_t)sizeof (si))
+        break;
+    }
+}
+#endif
+
+#endif
+
+/*****************************************************************************/
+
+#if EV_CHILD_ENABLE
+static WL childs [EV_PID_HASHSIZE];
+
+static ev_signal childev;
+
+#ifndef WIFCONTINUED
+# define WIFCONTINUED(status) 0
+#endif
+
+/* handle a single child status event */
+inline_speed void
+child_reap (EV_P_ int chain, int pid, int status)
+{
+  ev_child *w;
+  int traced = WIFSTOPPED (status) || WIFCONTINUED (status);
+
+  for (w = (ev_child *)childs [chain & ((EV_PID_HASHSIZE) - 1)]; w; w = (ev_child *)((WL)w)->next)
+    {
+      if ((w->pid == pid || !w->pid)
+          && (!traced || (w->flags & 1)))
+        {
+          ev_set_priority (w, EV_MAXPRI); /* need to do it *now*, this *must* be the same prio as the signal watcher itself */
+          w->rpid    = pid;
+          w->rstatus = status;
+          ev_feed_event (EV_A_ (W)w, EV_CHILD);
+        }
+    }
+}
+
+#ifndef WCONTINUED
+# define WCONTINUED 0
+#endif
+
+/* called on sigchld etc., calls waitpid */
+static void
+childcb (EV_P_ ev_signal *sw, int revents)
+{
+  int pid, status;
+
+  /* some systems define WCONTINUED but then fail to support it (linux 2.4) */
+  if (0 >= (pid = waitpid (-1, &status, WNOHANG | WUNTRACED | WCONTINUED)))
+    if (!WCONTINUED
+        || errno != EINVAL
+        || 0 >= (pid = waitpid (-1, &status, WNOHANG | WUNTRACED)))
+      return;
+
+  /* make sure we are called again until all children have been reaped */
+  /* we need to do it this way so that the callback gets called before we continue */
+  ev_feed_event (EV_A_ (W)sw, EV_SIGNAL);
+
+  child_reap (EV_A_ pid, pid, status);
+  if ((EV_PID_HASHSIZE) > 1)
+    child_reap (EV_A_ 0, pid, status); /* this might trigger a watcher twice, but feed_event catches that */
+}
+
+#endif
+
+/*****************************************************************************/
+
+#if EV_USE_IOCP
+# include "ev_iocp.c"
+#endif
+#if EV_USE_PORT
+# include "ev_port.c"
+#endif
+#if EV_USE_KQUEUE
+# include "ev_kqueue.c"
+#endif
+#if EV_USE_EPOLL
+# include "ev_epoll.c"
+#endif
+#if EV_USE_POLL
+# include "ev_poll.c"
+#endif
+#if EV_USE_SELECT
+# include "ev_select.c"
+#endif
+
+int ecb_cold
+ev_version_major (void) EV_THROW
+{
+  return EV_VERSION_MAJOR;
+}
+
+int ecb_cold
+ev_version_minor (void) EV_THROW
+{
+  return EV_VERSION_MINOR;
+}
+
+/* return true if we are running with elevated privileges and should ignore env variables */
+int inline_size ecb_cold
+enable_secure (void)
+{
+#ifdef _WIN32
+  return 0;
+#else
+  return getuid () != geteuid ()
+      || getgid () != getegid ();
+#endif
+}
+
+unsigned int ecb_cold
+ev_supported_backends (void) EV_THROW
+{
+  unsigned int flags = 0;
+
+  if (EV_USE_PORT  ) flags |= EVBACKEND_PORT;
+  if (EV_USE_KQUEUE) flags |= EVBACKEND_KQUEUE;
+  if (EV_USE_EPOLL ) flags |= EVBACKEND_EPOLL;
+  if (EV_USE_POLL  ) flags |= EVBACKEND_POLL;
+  if (EV_USE_SELECT) flags |= EVBACKEND_SELECT;
+  
+  return flags;
+}
+
+unsigned int ecb_cold
+ev_recommended_backends (void) EV_THROW
+{
+  unsigned int flags = ev_supported_backends ();
+
+#ifndef __NetBSD__
+  /* kqueue is borked on everything but netbsd apparently */
+  /* it usually doesn't work correctly on anything but sockets and pipes */
+  flags &= ~EVBACKEND_KQUEUE;
+#endif
+#ifdef __APPLE__
+  /* only select works correctly on that "unix-certified" platform */
+  flags &= ~EVBACKEND_KQUEUE; /* horribly broken, even for sockets */
+  flags &= ~EVBACKEND_POLL;   /* poll is based on kqueue from 10.5 onwards */
+#endif
+#ifdef __FreeBSD__
+  flags &= ~EVBACKEND_POLL;   /* poll return value is unusable (http://forums.freebsd.org/archive/index.php/t-10270.html) */
+#endif
+
+  return flags;
+}
+
+unsigned int ecb_cold
+ev_embeddable_backends (void) EV_THROW
+{
+  int flags = EVBACKEND_EPOLL | EVBACKEND_KQUEUE | EVBACKEND_PORT;
+
+  /* epoll embeddability broken on all linux versions up to at least 2.6.23 */
+  if (ev_linux_version () < 0x020620) /* disable it on linux < 2.6.32 */
+    flags &= ~EVBACKEND_EPOLL;
+
+  return flags;
+}
+
+unsigned int
+ev_backend (EV_P) EV_THROW
+{
+  return backend;
+}
+
+#if EV_FEATURE_API
+unsigned int
+ev_iteration (EV_P) EV_THROW
+{
+  return loop_count;
+}
+
+unsigned int
+ev_depth (EV_P) EV_THROW
+{
+  return loop_depth;
+}
+
+void
+ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_THROW
+{
+  io_blocktime = interval;
+}
+
+void
+ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_THROW
+{
+  timeout_blocktime = interval;
+}
+
+void
+ev_set_userdata (EV_P_ void *data) EV_THROW
+{
+  userdata = data;
+}
+
+void *
+ev_userdata (EV_P) EV_THROW
+{
+  return userdata;
+}
+
+void
+ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_THROW
+{
+  invoke_cb = invoke_pending_cb;
+}
+
+void
+ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV_P) EV_THROW) EV_THROW
+{
+  release_cb = release;
+  acquire_cb = acquire;
+}
+#endif
+
+/* initialise a loop structure, must be zero-initialised */
+static void noinline ecb_cold
+loop_init (EV_P_ unsigned int flags) EV_THROW
+{
+  if (!backend)
+    {
+      origflags = flags;
+
+#if EV_USE_REALTIME
+      if (!have_realtime)
+        {
+          struct timespec ts;
+
+          if (!clock_gettime (CLOCK_REALTIME, &ts))
+            have_realtime = 1;
+        }
+#endif
+
+#if EV_USE_MONOTONIC
+      if (!have_monotonic)
+        {
+          struct timespec ts;
+
+          if (!clock_gettime (CLOCK_MONOTONIC, &ts))
+            have_monotonic = 1;
+        }
+#endif
+
+      /* pid check not overridable via env */
+#ifndef _WIN32
+      if (flags & EVFLAG_FORKCHECK)
+        curpid = getpid ();
+#endif
+
+      if (!(flags & EVFLAG_NOENV)
+          && !enable_secure ()
+          && getenv ("LIBEV_FLAGS"))
+        flags = atoi (getenv ("LIBEV_FLAGS"));
+
+      ev_rt_now          = ev_time ();
+      mn_now             = get_clock ();
+      now_floor          = mn_now;
+      rtmn_diff          = ev_rt_now - mn_now;
+#if EV_FEATURE_API
+      invoke_cb          = ev_invoke_pending;
+#endif
+
+      io_blocktime       = 0.;
+      timeout_blocktime  = 0.;
+      backend            = 0;
+      backend_fd         = -1;
+      sig_pending        = 0;
+#if EV_ASYNC_ENABLE
+      async_pending      = 0;
+#endif
+      pipe_write_skipped = 0;
+      pipe_write_wanted  = 0;
+      evpipe [0]         = -1;
+      evpipe [1]         = -1;
+#if EV_USE_INOTIFY
+      fs_fd              = flags & EVFLAG_NOINOTIFY ? -1 : -2;
+#endif
+#if EV_USE_SIGNALFD
+      sigfd              = flags & EVFLAG_SIGNALFD  ? -2 : -1;
+#endif
+
+      if (!(flags & EVBACKEND_MASK))
+        flags |= ev_recommended_backends ();
+
+#if EV_USE_IOCP
+      if (!backend && (flags & EVBACKEND_IOCP  )) backend = iocp_init   (EV_A_ flags);
+#endif
+#if EV_USE_PORT
+      if (!backend && (flags & EVBACKEND_PORT  )) backend = port_init   (EV_A_ flags);
+#endif
+#if EV_USE_KQUEUE
+      if (!backend && (flags & EVBACKEND_KQUEUE)) backend = kqueue_init (EV_A_ flags);
+#endif
+#if EV_USE_EPOLL
+      if (!backend && (flags & EVBACKEND_EPOLL )) backend = epoll_init  (EV_A_ flags);
+#endif
+#if EV_USE_POLL
+      if (!backend && (flags & EVBACKEND_POLL  )) backend = poll_init   (EV_A_ flags);
+#endif
+#if EV_USE_SELECT
+      if (!backend && (flags & EVBACKEND_SELECT)) backend = select_init (EV_A_ flags);
+#endif
+
+      ev_prepare_init (&pending_w, pendingcb);
+
+#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
+      ev_init (&pipe_w, pipecb);
+      ev_set_priority (&pipe_w, EV_MAXPRI);
+#endif
+    }
+}
+
+/* free up a loop structure */
+void ecb_cold
+ev_loop_destroy (EV_P)
+{
+  int i;
+
+#if EV_MULTIPLICITY
+  /* mimic free (0) */
+  if (!EV_A)
+    return;
+#endif
+
+#if EV_CLEANUP_ENABLE
+  /* queue cleanup watchers (and execute them) */
+  if (expect_false (cleanupcnt))
+    {
+      queue_events (EV_A_ (W *)cleanups, cleanupcnt, EV_CLEANUP);
+      EV_INVOKE_PENDING;
+    }
+#endif
+
+#if EV_CHILD_ENABLE
+  if (ev_is_default_loop (EV_A) && ev_is_active (&childev))
+    {
+      ev_ref (EV_A); /* child watcher */
+      ev_signal_stop (EV_A_ &childev);
+    }
+#endif
+
+  if (ev_is_active (&pipe_w))
+    {
+      /*ev_ref (EV_A);*/
+      /*ev_io_stop (EV_A_ &pipe_w);*/
+
+      if (evpipe [0] >= 0) EV_WIN32_CLOSE_FD (evpipe [0]);
+      if (evpipe [1] >= 0) EV_WIN32_CLOSE_FD (evpipe [1]);
+    }
+
+#if EV_USE_SIGNALFD
+  if (ev_is_active (&sigfd_w))
+    close (sigfd);
+#endif
+
+#if EV_USE_INOTIFY
+  if (fs_fd >= 0)
+    close (fs_fd);
+#endif
+
+  if (backend_fd >= 0)
+    close (backend_fd);
+
+#if EV_USE_IOCP
+  if (backend == EVBACKEND_IOCP  ) iocp_destroy   (EV_A);
+#endif
+#if EV_USE_PORT
+  if (backend == EVBACKEND_PORT  ) port_destroy   (EV_A);
+#endif
+#if EV_USE_KQUEUE
+  if (backend == EVBACKEND_KQUEUE) kqueue_destroy (EV_A);
+#endif
+#if EV_USE_EPOLL
+  if (backend == EVBACKEND_EPOLL ) epoll_destroy  (EV_A);
+#endif
+#if EV_USE_POLL
+  if (backend == EVBACKEND_POLL  ) poll_destroy   (EV_A);
+#endif
+#if EV_USE_SELECT
+  if (backend == EVBACKEND_SELECT) select_destroy (EV_A);
+#endif
+
+  for (i = NUMPRI; i--; )
+    {
+      array_free (pending, [i]);
+#if EV_IDLE_ENABLE
+      array_free (idle, [i]);
+#endif
+    }
+
+  ev_free (anfds); anfds = 0; anfdmax = 0;
+
+  /* have to use the microsoft-never-gets-it-right macro */
+  array_free (rfeed, EMPTY);
+  array_free (fdchange, EMPTY);
+  array_free (timer, EMPTY);
+#if EV_PERIODIC_ENABLE
+  array_free (periodic, EMPTY);
+#endif
+#if EV_FORK_ENABLE
+  array_free (fork, EMPTY);
+#endif
+#if EV_CLEANUP_ENABLE
+  array_free (cleanup, EMPTY);
+#endif
+  array_free (prepare, EMPTY);
+  array_free (check, EMPTY);
+#if EV_ASYNC_ENABLE
+  array_free (async, EMPTY);
+#endif
+
+  backend = 0;
+
+#if EV_MULTIPLICITY
+  if (ev_is_default_loop (EV_A))
+#endif
+    ev_default_loop_ptr = 0;
+#if EV_MULTIPLICITY
+  else
+    ev_free (EV_A);
+#endif
+}
+
+#if EV_USE_INOTIFY
+inline_size void infy_fork (EV_P);
+#endif
+
+inline_size void
+loop_fork (EV_P)
+{
+#if EV_USE_PORT
+  if (backend == EVBACKEND_PORT  ) port_fork   (EV_A);
+#endif
+#if EV_USE_KQUEUE
+  if (backend == EVBACKEND_KQUEUE) kqueue_fork (EV_A);
+#endif
+#if EV_USE_EPOLL
+  if (backend == EVBACKEND_EPOLL ) epoll_fork  (EV_A);
+#endif
+#if EV_USE_INOTIFY
+  infy_fork (EV_A);
+#endif
+
+#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
+  if (ev_is_active (&pipe_w) && postfork != 2)
+    {
+      /* pipe_write_wanted must be false now, so modifying fd vars should be safe */
+
+      ev_ref (EV_A);
+      ev_io_stop (EV_A_ &pipe_w);
+
+      if (evpipe [0] >= 0)
+        EV_WIN32_CLOSE_FD (evpipe [0]);
+
+      evpipe_init (EV_A);
+      /* iterate over everything, in case we missed something before */
+      ev_feed_event (EV_A_ &pipe_w, EV_CUSTOM);
+    }
+#endif
+
+  postfork = 0;
+}
+
+#if EV_MULTIPLICITY
+
+struct ev_loop * ecb_cold
+ev_loop_new (unsigned int flags) EV_THROW
+{
+  EV_P = (struct ev_loop *)ev_malloc (sizeof (struct ev_loop));
+
+  memset (EV_A, 0, sizeof (struct ev_loop));
+  loop_init (EV_A_ flags);
+
+  if (ev_backend (EV_A))
+    return EV_A;
+
+  ev_free (EV_A);
+  return 0;
+}
+
+#endif /* multiplicity */
+
+#if EV_VERIFY
+static void noinline ecb_cold
+verify_watcher (EV_P_ W w)
+{
+  assert (("libev: watcher has invalid priority", ABSPRI (w) >= 0 && ABSPRI (w) < NUMPRI));
+
+  if (w->pending)
+    assert (("libev: pending watcher not on pending queue", pendings [ABSPRI (w)][w->pending - 1].w == w));
+}
+
+static void noinline ecb_cold
+verify_heap (EV_P_ ANHE *heap, int N)
+{
+  int i;
+
+  for (i = HEAP0; i < N + HEAP0; ++i)
+    {
+      assert (("libev: active index mismatch in heap", ev_active (ANHE_w (heap [i])) == i));
+      assert (("libev: heap condition violated", i == HEAP0 || ANHE_at (heap [HPARENT (i)]) <= ANHE_at (heap [i])));
+      assert (("libev: heap at cache mismatch", ANHE_at (heap [i]) == ev_at (ANHE_w (heap [i]))));
+
+      verify_watcher (EV_A_ (W)ANHE_w (heap [i]));
+    }
+}
+
+static void noinline ecb_cold
+array_verify (EV_P_ W *ws, int cnt)
+{
+  while (cnt--)
+    {
+      assert (("libev: active index mismatch", ev_active (ws [cnt]) == cnt + 1));
+      verify_watcher (EV_A_ ws [cnt]);
+    }
+}
+#endif
+
+#if EV_FEATURE_API
+void ecb_cold
+ev_verify (EV_P) EV_THROW
+{
+#if EV_VERIFY
+  int i;
+  WL w, w2;
+
+  assert (activecnt >= -1);
+
+  assert (fdchangemax >= fdchangecnt);
+  for (i = 0; i < fdchangecnt; ++i)
+    assert (("libev: negative fd in fdchanges", fdchanges [i] >= 0));
+
+  assert (anfdmax >= 0);
+  for (i = 0; i < anfdmax; ++i)
+    {
+      int j = 0;
+
+      for (w = w2 = anfds [i].head; w; w = w->next)
+        {
+          verify_watcher (EV_A_ (W)w);
+
+          if (j++ & 1)
+            {
+              assert (("libev: io watcher list contains a loop", w != w2));
+              w2 = w2->next;
+            }
+
+          assert (("libev: inactive fd watcher on anfd list", ev_active (w) == 1));
+          assert (("libev: fd mismatch between watcher and anfd", ((ev_io *)w)->fd == i));
+        }
+    }
+
+  assert (timermax >= timercnt);
+  verify_heap (EV_A_ timers, timercnt);
+
+#if EV_PERIODIC_ENABLE
+  assert (periodicmax >= periodiccnt);
+  verify_heap (EV_A_ periodics, periodiccnt);
+#endif
+
+  for (i = NUMPRI; i--; )
+    {
+      assert (pendingmax [i] >= pendingcnt [i]);
+#if EV_IDLE_ENABLE
+      assert (idleall >= 0);
+      assert (idlemax [i] >= idlecnt [i]);
+      array_verify (EV_A_ (W *)idles [i], idlecnt [i]);
+#endif
+    }
+
+#if EV_FORK_ENABLE
+  assert (forkmax >= forkcnt);
+  array_verify (EV_A_ (W *)forks, forkcnt);
+#endif
+
+#if EV_CLEANUP_ENABLE
+  assert (cleanupmax >= cleanupcnt);
+  array_verify (EV_A_ (W *)cleanups, cleanupcnt);
+#endif
+
+#if EV_ASYNC_ENABLE
+  assert (asyncmax >= asynccnt);
+  array_verify (EV_A_ (W *)asyncs, asynccnt);
+#endif
+
+#if EV_PREPARE_ENABLE
+  assert (preparemax >= preparecnt);
+  array_verify (EV_A_ (W *)prepares, preparecnt);
+#endif
+
+#if EV_CHECK_ENABLE
+  assert (checkmax >= checkcnt);
+  array_verify (EV_A_ (W *)checks, checkcnt);
+#endif
+
+# if 0
+#if EV_CHILD_ENABLE
+  for (w = (ev_child *)childs [chain & ((EV_PID_HASHSIZE) - 1)]; w; w = (ev_child *)((WL)w)->next)
+  for (signum = EV_NSIG; signum--; ) if (signals [signum].pending)
+#endif
+# endif
+#endif
+}
+#endif
+
+#if EV_MULTIPLICITY
+struct ev_loop * ecb_cold
+#else
+int
+#endif
+ev_default_loop (unsigned int flags) EV_THROW
+{
+  if (!ev_default_loop_ptr)
+    {
+#if EV_MULTIPLICITY
+      EV_P = ev_default_loop_ptr = &default_loop_struct;
+#else
+      ev_default_loop_ptr = 1;
+#endif
+
+      loop_init (EV_A_ flags);
+
+      if (ev_backend (EV_A))
+        {
+#if EV_CHILD_ENABLE
+          ev_signal_init (&childev, childcb, SIGCHLD);
+          ev_set_priority (&childev, EV_MAXPRI);
+          ev_signal_start (EV_A_ &childev);
+          ev_unref (EV_A); /* child watcher should not keep loop alive */
+#endif
+        }
+      else
+        ev_default_loop_ptr = 0;
+    }
+
+  return ev_default_loop_ptr;
+}
+
+void
+ev_loop_fork (EV_P) EV_THROW
+{
+  postfork = 1;
+}
+
+/*****************************************************************************/
+
+void
+ev_invoke (EV_P_ void *w, int revents)
+{
+  EV_CB_INVOKE ((W)w, revents);
+}
+
+unsigned int
+ev_pending_count (EV_P) EV_THROW
+{
+  int pri;
+  unsigned int count = 0;
+
+  for (pri = NUMPRI; pri--; )
+    count += pendingcnt [pri];
+
+  return count;
+}
+
+void noinline
+ev_invoke_pending (EV_P)
+{
+  pendingpri = NUMPRI;
+
+  while (pendingpri) /* pendingpri possibly gets modified in the inner loop */
+    {
+      --pendingpri;
+
+      while (pendingcnt [pendingpri])
+        {
+          ANPENDING *p = pendings [pendingpri] + --pendingcnt [pendingpri];
+
+          p->w->pending = 0;
+          EV_CB_INVOKE (p->w, p->events);
+          EV_FREQUENT_CHECK;
+        }
+    }
+}
+
+#if EV_IDLE_ENABLE
+/* make idle watchers pending. this handles the "call-idle */
+/* only when higher priorities are idle" logic */
+inline_size void
+idle_reify (EV_P)
+{
+  if (expect_false (idleall))
+    {
+      int pri;
+
+      for (pri = NUMPRI; pri--; )
+        {
+          if (pendingcnt [pri])
+            break;
+
+          if (idlecnt [pri])
+            {
+              queue_events (EV_A_ (W *)idles [pri], idlecnt [pri], EV_IDLE);
+              break;
+            }
+        }
+    }
+}
+#endif
+
+/* make timers pending */
+inline_size void
+timers_reify (EV_P)
+{
+  EV_FREQUENT_CHECK;
+
+  if (timercnt && ANHE_at (timers [HEAP0]) < mn_now)
+    {
+      do
+        {
+          ev_timer *w = (ev_timer *)ANHE_w (timers [HEAP0]);
+
+          /*assert (("libev: inactive timer on timer heap detected", ev_is_active (w)));*/
+
+          /* first reschedule or stop timer */
+          if (w->repeat)
+            {
+              ev_at (w) += w->repeat;
+              if (ev_at (w) < mn_now)
+                ev_at (w) = mn_now;
+
+              assert (("libev: negative ev_timer repeat value found while processing timers", w->repeat > 0.));
+
+              ANHE_at_cache (timers [HEAP0]);
+              downheap (timers, timercnt, HEAP0);
+            }
+          else
+            ev_timer_stop (EV_A_ w); /* nonrepeating: stop timer */
+
+          EV_FREQUENT_CHECK;
+          feed_reverse (EV_A_ (W)w);
+        }
+      while (timercnt && ANHE_at (timers [HEAP0]) < mn_now);
+
+      feed_reverse_done (EV_A_ EV_TIMER);
+    }
+}
+
+#if EV_PERIODIC_ENABLE
+
+static void noinline
+periodic_recalc (EV_P_ ev_periodic *w)
+{
+  ev_tstamp interval = w->interval > MIN_INTERVAL ? w->interval : MIN_INTERVAL;
+  ev_tstamp at = w->offset + interval * ev_floor ((ev_rt_now - w->offset) / interval);
+
+  /* the above almost always errs on the low side */
+  while (at <= ev_rt_now)
+    {
+      ev_tstamp nat = at + w->interval;
+
+      /* when resolution fails us, we use ev_rt_now */
+      if (expect_false (nat == at))
+        {
+          at = ev_rt_now;
+          break;
+        }
+
+      at = nat;
+    }
+
+  ev_at (w) = at;
+}
+
+/* make periodics pending */
+inline_size void
+periodics_reify (EV_P)
+{
+  EV_FREQUENT_CHECK;
+
+  while (periodiccnt && ANHE_at (periodics [HEAP0]) < ev_rt_now)
+    {
+      do
+        {
+          ev_periodic *w = (ev_periodic *)ANHE_w (periodics [HEAP0]);
+
+          /*assert (("libev: inactive timer on periodic heap detected", ev_is_active (w)));*/
+
+          /* first reschedule or stop timer */
+          if (w->reschedule_cb)
+            {
+              ev_at (w) = w->reschedule_cb (w, ev_rt_now);
+
+              assert (("libev: ev_periodic reschedule callback returned time in the past", ev_at (w) >= ev_rt_now));
+
+              ANHE_at_cache (periodics [HEAP0]);
+              downheap (periodics, periodiccnt, HEAP0);
+            }
+          else if (w->interval)
+            {
+              periodic_recalc (EV_A_ w);
+              ANHE_at_cache (periodics [HEAP0]);
+              downheap (periodics, periodiccnt, HEAP0);
+            }
+          else
+            ev_periodic_stop (EV_A_ w); /* nonrepeating: stop timer */
+
+          EV_FREQUENT_CHECK;
+          feed_reverse (EV_A_ (W)w);
+        }
+      while (periodiccnt && ANHE_at (periodics [HEAP0]) < ev_rt_now);
+
+      feed_reverse_done (EV_A_ EV_PERIODIC);
+    }
+}
+
+/* simply recalculate all periodics */
+/* TODO: maybe ensure that at least one event happens when jumping forward? */
+static void noinline ecb_cold
+periodics_reschedule (EV_P)
+{
+  int i;
+
+  /* adjust periodics after time jump */
+  for (i = HEAP0; i < periodiccnt + HEAP0; ++i)
+    {
+      ev_periodic *w = (ev_periodic *)ANHE_w (periodics [i]);
+
+      if (w->reschedule_cb)
+        ev_at (w) = w->reschedule_cb (w, ev_rt_now);
+      else if (w->interval)
+        periodic_recalc (EV_A_ w);
+
+      ANHE_at_cache (periodics [i]);
+    }
+
+  reheap (periodics, periodiccnt);
+}
+#endif
+
+/* adjust all timers by a given offset */
+static void noinline ecb_cold
+timers_reschedule (EV_P_ ev_tstamp adjust)
+{
+  int i;
+
+  for (i = 0; i < timercnt; ++i)
+    {
+      ANHE *he = timers + i + HEAP0;
+      ANHE_w (*he)->at += adjust;
+      ANHE_at_cache (*he);
+    }
+}
+
+/* fetch new monotonic and realtime times from the kernel */
+/* also detect if there was a timejump, and act accordingly */
+inline_speed void
+time_update (EV_P_ ev_tstamp max_block)
+{
+#if EV_USE_MONOTONIC
+  if (expect_true (have_monotonic))
+    {
+      int i;
+      ev_tstamp odiff = rtmn_diff;
+
+      mn_now = get_clock ();
+
+      /* only fetch the realtime clock every 0.5*MIN_TIMEJUMP seconds */
+      /* interpolate in the meantime */
+      if (expect_true (mn_now - now_floor < MIN_TIMEJUMP * .5))
+        {
+          ev_rt_now = rtmn_diff + mn_now;
+          return;
+        }
+
+      now_floor = mn_now;
+      ev_rt_now = ev_time ();
+
+      /* loop a few times, before making important decisions.
+       * on the choice of "4": one iteration isn't enough,
+       * in case we get preempted during the calls to
+       * ev_time and get_clock. a second call is almost guaranteed
+       * to succeed in that case, though. and looping a few more times
+       * doesn't hurt either as we only do this on time-jumps or
+       * in the unlikely event of having been preempted here.
+       */
+      for (i = 4; --i; )
+        {
+          ev_tstamp diff;
+          rtmn_diff = ev_rt_now - mn_now;
+
+          diff = odiff - rtmn_diff;
+
+          if (expect_true ((diff < 0. ? -diff : diff) < MIN_TIMEJUMP))
+            return; /* all is well */
+
+          ev_rt_now = ev_time ();
+          mn_now    = get_clock ();
+          now_floor = mn_now;
+        }
+
+      /* no timer adjustment, as the monotonic clock doesn't jump */
+      /* timers_reschedule (EV_A_ rtmn_diff - odiff) */
+# if EV_PERIODIC_ENABLE
+      periodics_reschedule (EV_A);
+# endif
+    }
+  else
+#endif
+    {
+      ev_rt_now = ev_time ();
+
+      if (expect_false (mn_now > ev_rt_now || ev_rt_now > mn_now + max_block + MIN_TIMEJUMP))
+        {
+          /* adjust timers. this is easy, as the offset is the same for all of them */
+          timers_reschedule (EV_A_ ev_rt_now - mn_now);
+#if EV_PERIODIC_ENABLE
+          periodics_reschedule (EV_A);
+#endif
+        }
+
+      mn_now = ev_rt_now;
+    }
+}
+
+int
+ev_run (EV_P_ int flags)
+{
+#if EV_FEATURE_API
+  ++loop_depth;
+#endif
+
+  assert (("libev: ev_loop recursion during release detected", loop_done != EVBREAK_RECURSE));
+
+  loop_done = EVBREAK_CANCEL;
+
+  EV_INVOKE_PENDING; /* in case we recurse, ensure ordering stays nice and clean */
+
+  do
+    {
+#if EV_VERIFY >= 2
+      ev_verify (EV_A);
+#endif
+
+#ifndef _WIN32
+      if (expect_false (curpid)) /* penalise the forking check even more */
+        if (expect_false (getpid () != curpid))
+          {
+            curpid = getpid ();
+            postfork = 1;
+          }
+#endif
+
+#if EV_FORK_ENABLE
+      /* we might have forked, so queue fork handlers */
+      if (expect_false (postfork))
+        if (forkcnt)
+          {
+            queue_events (EV_A_ (W *)forks, forkcnt, EV_FORK);
+            EV_INVOKE_PENDING;
+          }
+#endif
+
+#if EV_PREPARE_ENABLE
+      /* queue prepare watchers (and execute them) */
+      if (expect_false (preparecnt))
+        {
+          queue_events (EV_A_ (W *)prepares, preparecnt, EV_PREPARE);
+          EV_INVOKE_PENDING;
+        }
+#endif
+
+      if (expect_false (loop_done))
+        break;
+
+      /* we might have forked, so reify kernel state if necessary */
+      if (expect_false (postfork))
+        loop_fork (EV_A);
+
+      /* update fd-related kernel structures */
+      fd_reify (EV_A);
+
+      /* calculate blocking time */
+      {
+        ev_tstamp waittime  = 0.;
+        ev_tstamp sleeptime = 0.;
+
+        /* remember old timestamp for io_blocktime calculation */
+        ev_tstamp prev_mn_now = mn_now;
+
+        /* update time to cancel out callback processing overhead */
+        time_update (EV_A_ 1e100);
+
+        /* from now on, we want a pipe-wake-up */
+        pipe_write_wanted = 1;
+
+        ECB_MEMORY_FENCE; /* make sure pipe_write_wanted is visible before we check for potential skips */
+
+        if (expect_true (!(flags & EVRUN_NOWAIT || idleall || !activecnt || pipe_write_skipped)))
+          {
+            waittime = MAX_BLOCKTIME;
+
+            if (timercnt)
+              {
+                ev_tstamp to = ANHE_at (timers [HEAP0]) - mn_now;
+                if (waittime > to) waittime = to;
+              }
+
+#if EV_PERIODIC_ENABLE
+            if (periodiccnt)
+              {
+                ev_tstamp to = ANHE_at (periodics [HEAP0]) - ev_rt_now;
+                if (waittime > to) waittime = to;
+              }
+#endif
+
+            /* don't let timeouts decrease the waittime below timeout_blocktime */
+            if (expect_false (waittime < timeout_blocktime))
+              waittime = timeout_blocktime;
+
+            /* at this point, we NEED to wait, so we have to ensure */
+            /* to pass a minimum nonzero value to the backend */
+            if (expect_false (waittime < backend_mintime))
+              waittime = backend_mintime;
+
+            /* extra check because io_blocktime is commonly 0 */
+            if (expect_false (io_blocktime))
+              {
+                sleeptime = io_blocktime - (mn_now - prev_mn_now);
+
+                if (sleeptime > waittime - backend_mintime)
+                  sleeptime = waittime - backend_mintime;
+
+                if (expect_true (sleeptime > 0.))
+                  {
+                    ev_sleep (sleeptime);
+                    waittime -= sleeptime;
+                  }
+              }
+          }
+
+#if EV_FEATURE_API
+        ++loop_count;
+#endif
+        assert ((loop_done = EVBREAK_RECURSE, 1)); /* assert for side effect */
+        backend_poll (EV_A_ waittime);
+        assert ((loop_done = EVBREAK_CANCEL, 1)); /* assert for side effect */
+
+        pipe_write_wanted = 0; /* just an optimisation, no fence needed */
+
+        ECB_MEMORY_FENCE_ACQUIRE;
+        if (pipe_write_skipped)
+          {
+            assert (("libev: pipe_w not active, but pipe not written", ev_is_active (&pipe_w)));
+            ev_feed_event (EV_A_ &pipe_w, EV_CUSTOM);
+          }
+
+
+        /* update ev_rt_now, do magic */
+        time_update (EV_A_ waittime + sleeptime);
+      }
+
+      /* queue pending timers and reschedule them */
+      timers_reify (EV_A); /* relative timers called last */
+#if EV_PERIODIC_ENABLE
+      periodics_reify (EV_A); /* absolute timers called first */
+#endif
+
+#if EV_IDLE_ENABLE
+      /* queue idle watchers unless other events are pending */
+      idle_reify (EV_A);
+#endif
+
+#if EV_CHECK_ENABLE
+      /* queue check watchers, to be executed first */
+      if (expect_false (checkcnt))
+        queue_events (EV_A_ (W *)checks, checkcnt, EV_CHECK);
+#endif
+
+      EV_INVOKE_PENDING;
+    }
+  while (expect_true (
+    activecnt
+    && !loop_done
+    && !(flags & (EVRUN_ONCE | EVRUN_NOWAIT))
+  ));
+
+  if (loop_done == EVBREAK_ONE)
+    loop_done = EVBREAK_CANCEL;
+
+#if EV_FEATURE_API
+  --loop_depth;
+#endif
+
+  return activecnt;
+}
+
+void
+ev_break (EV_P_ int how) EV_THROW
+{
+  loop_done = how;
+}
+
+void
+ev_ref (EV_P) EV_THROW
+{
+  ++activecnt;
+}
+
+void
+ev_unref (EV_P) EV_THROW
+{
+  --activecnt;
+}
+
+void
+ev_now_update (EV_P) EV_THROW
+{
+  time_update (EV_A_ 1e100);
+}
+
+void
+ev_suspend (EV_P) EV_THROW
+{
+  ev_now_update (EV_A);
+}
+
+void
+ev_resume (EV_P) EV_THROW
+{
+  ev_tstamp mn_prev = mn_now;
+
+  ev_now_update (EV_A);
+  timers_reschedule (EV_A_ mn_now - mn_prev);
+#if EV_PERIODIC_ENABLE
+  /* TODO: really do this? */
+  periodics_reschedule (EV_A);
+#endif
+}
+
+/*****************************************************************************/
+/* singly-linked list management, used when the expected list length is short */
+
+inline_size void
+wlist_add (WL *head, WL elem)
+{
+  elem->next = *head;
+  *head = elem;
+}
+
+inline_size void
+wlist_del (WL *head, WL elem)
+{
+  while (*head)
+    {
+      if (expect_true (*head == elem))
+        {
+          *head = elem->next;
+          break;
+        }
+
+      head = &(*head)->next;
+    }
+}
+
+/* internal, faster, version of ev_clear_pending */
+inline_speed void
+clear_pending (EV_P_ W w)
+{
+  if (w->pending)
+    {
+      pendings [ABSPRI (w)][w->pending - 1].w = (W)&pending_w;
+      w->pending = 0;
+    }
+}
+
+int
+ev_clear_pending (EV_P_ void *w) EV_THROW
+{
+  W w_ = (W)w;
+  int pending = w_->pending;
+
+  if (expect_true (pending))
+    {
+      ANPENDING *p = pendings [ABSPRI (w_)] + pending - 1;
+      p->w = (W)&pending_w;
+      w_->pending = 0;
+      return p->events;
+    }
+  else
+    return 0;
+}
+
+inline_size void
+pri_adjust (EV_P_ W w)
+{
+  int pri = ev_priority (w);
+  pri = pri < EV_MINPRI ? EV_MINPRI : pri;
+  pri = pri > EV_MAXPRI ? EV_MAXPRI : pri;
+  ev_set_priority (w, pri);
+}
+
+inline_speed void
+ev_start (EV_P_ W w, int active)
+{
+  pri_adjust (EV_A_ w);
+  w->active = active;
+  ev_ref (EV_A);
+}
+
+inline_size void
+ev_stop (EV_P_ W w)
+{
+  ev_unref (EV_A);
+  w->active = 0;
+}
+
+/*****************************************************************************/
+
+void noinline
+ev_io_start (EV_P_ ev_io *w) EV_THROW
+{
+  int fd = w->fd;
+
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  assert (("libev: ev_io_start called with negative fd", fd >= 0));
+  assert (("libev: ev_io_start called with illegal event mask", !(w->events & ~(EV__IOFDSET | EV_READ | EV_WRITE))));
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, 1);
+  array_needsize (ANFD, anfds, anfdmax, fd + 1, array_init_zero);
+  wlist_add (&anfds[fd].head, (WL)w);
+
+  /* common bug, apparently */
+  assert (("libev: ev_io_start called with corrupted watcher", ((WL)w)->next != (WL)w));
+
+  fd_change (EV_A_ fd, w->events & EV__IOFDSET | EV_ANFD_REIFY);
+  w->events &= ~EV__IOFDSET;
+
+  EV_FREQUENT_CHECK;
+}
+
+void noinline
+ev_io_stop (EV_P_ ev_io *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  assert (("libev: ev_io_stop called with illegal fd (must stay constant after start!)", w->fd >= 0 && w->fd < anfdmax));
+
+  EV_FREQUENT_CHECK;
+
+  wlist_del (&anfds[w->fd].head, (WL)w);
+  ev_stop (EV_A_ (W)w);
+
+  fd_change (EV_A_ w->fd, EV_ANFD_REIFY);
+
+  EV_FREQUENT_CHECK;
+}
+
+void noinline
+ev_timer_start (EV_P_ ev_timer *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  ev_at (w) += mn_now;
+
+  assert (("libev: ev_timer_start called with negative timer repeat value", w->repeat >= 0.));
+
+  EV_FREQUENT_CHECK;
+
+  ++timercnt;
+  ev_start (EV_A_ (W)w, timercnt + HEAP0 - 1);
+  array_needsize (ANHE, timers, timermax, ev_active (w) + 1, EMPTY2);
+  ANHE_w (timers [ev_active (w)]) = (WT)w;
+  ANHE_at_cache (timers [ev_active (w)]);
+  upheap (timers, ev_active (w));
+
+  EV_FREQUENT_CHECK;
+
+  /*assert (("libev: internal timer heap corruption", timers [ev_active (w)] == (WT)w));*/
+}
+
+void noinline
+ev_timer_stop (EV_P_ ev_timer *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    assert (("libev: internal timer heap corruption", ANHE_w (timers [active]) == (WT)w));
+
+    --timercnt;
+
+    if (expect_true (active < timercnt + HEAP0))
+      {
+        timers [active] = timers [timercnt + HEAP0];
+        adjustheap (timers, timercnt, active);
+      }
+  }
+
+  ev_at (w) -= mn_now;
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+
+void noinline
+ev_timer_again (EV_P_ ev_timer *w) EV_THROW
+{
+  EV_FREQUENT_CHECK;
+
+  clear_pending (EV_A_ (W)w);
+
+  if (ev_is_active (w))
+    {
+      if (w->repeat)
+        {
+          ev_at (w) = mn_now + w->repeat;
+          ANHE_at_cache (timers [ev_active (w)]);
+          adjustheap (timers, timercnt, ev_active (w));
+        }
+      else
+        ev_timer_stop (EV_A_ w);
+    }
+  else if (w->repeat)
+    {
+      ev_at (w) = w->repeat;
+      ev_timer_start (EV_A_ w);
+    }
+
+  EV_FREQUENT_CHECK;
+}
+
+ev_tstamp
+ev_timer_remaining (EV_P_ ev_timer *w) EV_THROW
+{
+  return ev_at (w) - (ev_is_active (w) ? mn_now : 0.);
+}
+
+#if EV_PERIODIC_ENABLE
+void noinline
+ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  if (w->reschedule_cb)
+    ev_at (w) = w->reschedule_cb (w, ev_rt_now);
+  else if (w->interval)
+    {
+      assert (("libev: ev_periodic_start called with negative interval value", w->interval >= 0.));
+      periodic_recalc (EV_A_ w);
+    }
+  else
+    ev_at (w) = w->offset;
+
+  EV_FREQUENT_CHECK;
+
+  ++periodiccnt;
+  ev_start (EV_A_ (W)w, periodiccnt + HEAP0 - 1);
+  array_needsize (ANHE, periodics, periodicmax, ev_active (w) + 1, EMPTY2);
+  ANHE_w (periodics [ev_active (w)]) = (WT)w;
+  ANHE_at_cache (periodics [ev_active (w)]);
+  upheap (periodics, ev_active (w));
+
+  EV_FREQUENT_CHECK;
+
+  /*assert (("libev: internal periodic heap corruption", ANHE_w (periodics [ev_active (w)]) == (WT)w));*/
+}
+
+void noinline
+ev_periodic_stop (EV_P_ ev_periodic *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    assert (("libev: internal periodic heap corruption", ANHE_w (periodics [active]) == (WT)w));
+
+    --periodiccnt;
+
+    if (expect_true (active < periodiccnt + HEAP0))
+      {
+        periodics [active] = periodics [periodiccnt + HEAP0];
+        adjustheap (periodics, periodiccnt, active);
+      }
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+
+void noinline
+ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW
+{
+  /* TODO: use adjustheap and recalculation */
+  ev_periodic_stop (EV_A_ w);
+  ev_periodic_start (EV_A_ w);
+}
+#endif
+
+#ifndef SA_RESTART
+# define SA_RESTART 0
+#endif
+
+#if EV_SIGNAL_ENABLE
+
+void noinline
+ev_signal_start (EV_P_ ev_signal *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  assert (("libev: ev_signal_start called with illegal signal number", w->signum > 0 && w->signum < EV_NSIG));
+
+#if EV_MULTIPLICITY
+  assert (("libev: a signal must not be attached to two different loops",
+           !signals [w->signum - 1].loop || signals [w->signum - 1].loop == loop));
+
+  signals [w->signum - 1].loop = EV_A;
+  ECB_MEMORY_FENCE_RELEASE;
+#endif
+
+  EV_FREQUENT_CHECK;
+
+#if EV_USE_SIGNALFD
+  if (sigfd == -2)
+    {
+      sigfd = signalfd (-1, &sigfd_set, SFD_NONBLOCK | SFD_CLOEXEC);
+      if (sigfd < 0 && errno == EINVAL)
+        sigfd = signalfd (-1, &sigfd_set, 0); /* retry without flags */
+
+      if (sigfd >= 0)
+        {
+          fd_intern (sigfd); /* doing it twice will not hurt */
+
+          sigemptyset (&sigfd_set);
+
+          ev_io_init (&sigfd_w, sigfdcb, sigfd, EV_READ);
+          ev_set_priority (&sigfd_w, EV_MAXPRI);
+          ev_io_start (EV_A_ &sigfd_w);
+          ev_unref (EV_A); /* signalfd watcher should not keep loop alive */
+        }
+    }
+
+  if (sigfd >= 0)
+    {
+      /* TODO: check .head */
+      sigaddset (&sigfd_set, w->signum);
+      sigprocmask (SIG_BLOCK, &sigfd_set, 0);
+
+      signalfd (sigfd, &sigfd_set, 0);
+    }
+#endif
+
+  ev_start (EV_A_ (W)w, 1);
+  wlist_add (&signals [w->signum - 1].head, (WL)w);
+
+  if (!((WL)w)->next)
+# if EV_USE_SIGNALFD
+    if (sigfd < 0) /*TODO*/
+# endif
+      {
+# ifdef _WIN32
+        evpipe_init (EV_A);
+
+        signal (w->signum, ev_sighandler);
+# else
+        struct sigaction sa;
+
+        evpipe_init (EV_A);
+
+        sa.sa_handler = ev_sighandler;
+        sigfillset (&sa.sa_mask);
+        sa.sa_flags = SA_RESTART; /* if restarting works we save one iteration */
+        sigaction (w->signum, &sa, 0);
+
+        if (origflags & EVFLAG_NOSIGMASK)
+          {
+            sigemptyset (&sa.sa_mask);
+            sigaddset (&sa.sa_mask, w->signum);
+            sigprocmask (SIG_UNBLOCK, &sa.sa_mask, 0);
+          }
+#endif
+      }
+
+  EV_FREQUENT_CHECK;
+}
+
+void noinline
+ev_signal_stop (EV_P_ ev_signal *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  wlist_del (&signals [w->signum - 1].head, (WL)w);
+  ev_stop (EV_A_ (W)w);
+
+  if (!signals [w->signum - 1].head)
+    {
+#if EV_MULTIPLICITY
+      signals [w->signum - 1].loop = 0; /* unattach from signal */
+#endif
+#if EV_USE_SIGNALFD
+      if (sigfd >= 0)
+        {
+          sigset_t ss;
+
+          sigemptyset (&ss);
+          sigaddset (&ss, w->signum);
+          sigdelset (&sigfd_set, w->signum);
+
+          signalfd (sigfd, &sigfd_set, 0);
+          sigprocmask (SIG_UNBLOCK, &ss, 0);
+        }
+      else
+#endif
+        signal (w->signum, SIG_DFL);
+    }
+
+  EV_FREQUENT_CHECK;
+}
+
+#endif
+
+#if EV_CHILD_ENABLE
+
+void
+ev_child_start (EV_P_ ev_child *w) EV_THROW
+{
+#if EV_MULTIPLICITY
+  assert (("libev: child watchers are only supported in the default loop", loop == ev_default_loop_ptr));
+#endif
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, 1);
+  wlist_add (&childs [w->pid & ((EV_PID_HASHSIZE) - 1)], (WL)w);
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_child_stop (EV_P_ ev_child *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  wlist_del (&childs [w->pid & ((EV_PID_HASHSIZE) - 1)], (WL)w);
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+
+#endif
+
+#if EV_STAT_ENABLE
+
+# ifdef _WIN32
+#  undef lstat
+#  define lstat(a,b) _stati64 (a,b)
+# endif
+
+#define DEF_STAT_INTERVAL  5.0074891
+#define NFS_STAT_INTERVAL 30.1074891 /* for filesystems potentially failing inotify */
+#define MIN_STAT_INTERVAL  0.1074891
+
+static void noinline stat_timer_cb (EV_P_ ev_timer *w_, int revents);
+
+#if EV_USE_INOTIFY
+
+/* the * 2 is to allow for alignment padding, which for some reason is >> 8 */
+# define EV_INOTIFY_BUFSIZE (sizeof (struct inotify_event) * 2 + NAME_MAX)
+
+static void noinline
+infy_add (EV_P_ ev_stat *w)
+{
+  w->wd = inotify_add_watch (fs_fd, w->path,
+                             IN_ATTRIB | IN_DELETE_SELF | IN_MOVE_SELF | IN_MODIFY
+                             | IN_CREATE | IN_DELETE | IN_MOVED_FROM | IN_MOVED_TO
+                             | IN_DONT_FOLLOW | IN_MASK_ADD);
+
+  if (w->wd >= 0)
+    {
+      struct statfs sfs;
+
+      /* now local changes will be tracked by inotify, but remote changes won't */
+      /* unless the filesystem is known to be local, we therefore still poll */
+      /* also do poll on <2.6.25, but with normal frequency */
+
+      if (!fs_2625)
+        w->timer.repeat = w->interval ? w->interval : DEF_STAT_INTERVAL;
+      else if (!statfs (w->path, &sfs)
+               && (sfs.f_type == 0x1373 /* devfs */
+                   || sfs.f_type == 0x4006 /* fat */
+                   || sfs.f_type == 0x4d44 /* msdos */
+                   || sfs.f_type == 0xEF53 /* ext2/3 */
+                   || sfs.f_type == 0x72b6 /* jffs2 */
+                   || sfs.f_type == 0x858458f6 /* ramfs */
+                   || sfs.f_type == 0x5346544e /* ntfs */
+                   || sfs.f_type == 0x3153464a /* jfs */
+                   || sfs.f_type == 0x9123683e /* btrfs */
+                   || sfs.f_type == 0x52654973 /* reiser3 */
+                   || sfs.f_type == 0x01021994 /* tmpfs */
+                   || sfs.f_type == 0x58465342 /* xfs */))
+        w->timer.repeat = 0.; /* filesystem is local, kernel new enough */
+      else
+        w->timer.repeat = w->interval ? w->interval : NFS_STAT_INTERVAL; /* remote, use reduced frequency */
+    }
+  else
+    {
+      /* can't use inotify, continue to stat */
+      w->timer.repeat = w->interval ? w->interval : DEF_STAT_INTERVAL;
+
+      /* if path is not there, monitor some parent directory for speedup hints */
+      /* note that exceeding the hardcoded path limit is not a correctness issue, */
+      /* but an efficiency issue only */
+      if ((errno == ENOENT || errno == EACCES) && strlen (w->path) < 4096)
+        {
+          char path [4096];
+          strcpy (path, w->path);
+
+          do
+            {
+              int mask = IN_MASK_ADD | IN_DELETE_SELF | IN_MOVE_SELF
+                       | (errno == EACCES ? IN_ATTRIB : IN_CREATE | IN_MOVED_TO);
+
+              char *pend = strrchr (path, '/');
+
+              if (!pend || pend == path)
+                break;
+
+              *pend = 0;
+              w->wd = inotify_add_watch (fs_fd, path, mask);
+            }
+          while (w->wd < 0 && (errno == ENOENT || errno == EACCES));
+        }
+    }
+
+  if (w->wd >= 0)
+    wlist_add (&fs_hash [w->wd & ((EV_INOTIFY_HASHSIZE) - 1)].head, (WL)w);
+
+  /* now re-arm timer, if required */
+  if (ev_is_active (&w->timer)) ev_ref (EV_A);
+  ev_timer_again (EV_A_ &w->timer);
+  if (ev_is_active (&w->timer)) ev_unref (EV_A);
+}
+
+static void noinline
+infy_del (EV_P_ ev_stat *w)
+{
+  int slot;
+  int wd = w->wd;
+
+  if (wd < 0)
+    return;
+
+  w->wd = -2;
+  slot = wd & ((EV_INOTIFY_HASHSIZE) - 1);
+  wlist_del (&fs_hash [slot].head, (WL)w);
+
+  /* remove this watcher, if others are watching it, they will rearm */
+  inotify_rm_watch (fs_fd, wd);
+}
+
+static void noinline
+infy_wd (EV_P_ int slot, int wd, struct inotify_event *ev)
+{
+  if (slot < 0)
+    /* overflow, need to check for all hash slots */
+    for (slot = 0; slot < (EV_INOTIFY_HASHSIZE); ++slot)
+      infy_wd (EV_A_ slot, wd, ev);
+  else
+    {
+      WL w_;
+
+      for (w_ = fs_hash [slot & ((EV_INOTIFY_HASHSIZE) - 1)].head; w_; )
+        {
+          ev_stat *w = (ev_stat *)w_;
+          w_ = w_->next; /* lets us remove this watcher and all before it */
+
+          if (w->wd == wd || wd == -1)
+            {
+              if (ev->mask & (IN_IGNORED | IN_UNMOUNT | IN_DELETE_SELF))
+                {
+                  wlist_del (&fs_hash [slot & ((EV_INOTIFY_HASHSIZE) - 1)].head, (WL)w);
+                  w->wd = -1;
+                  infy_add (EV_A_ w); /* re-add, no matter what */
+                }
+
+              stat_timer_cb (EV_A_ &w->timer, 0);
+            }
+        }
+    }
+}
+
+static void
+infy_cb (EV_P_ ev_io *w, int revents)
+{
+  char buf [EV_INOTIFY_BUFSIZE];
+  int ofs;
+  int len = read (fs_fd, buf, sizeof (buf));
+
+  for (ofs = 0; ofs < len; )
+    {
+      struct inotify_event *ev = (struct inotify_event *)(buf + ofs);
+      infy_wd (EV_A_ ev->wd, ev->wd, ev);
+      ofs += sizeof (struct inotify_event) + ev->len;
+    }
+}
+
+inline_size void ecb_cold
+ev_check_2625 (EV_P)
+{
+  /* kernels < 2.6.25 are borked
+   * http://www.ussg.indiana.edu/hypermail/linux/kernel/0711.3/1208.html
+   */
+  if (ev_linux_version () < 0x020619)
+    return;
+
+  fs_2625 = 1;
+}
+
+inline_size int
+infy_newfd (void)
+{
+#if defined IN_CLOEXEC && defined IN_NONBLOCK
+  int fd = inotify_init1 (IN_CLOEXEC | IN_NONBLOCK);
+  if (fd >= 0)
+    return fd;
+#endif
+  return inotify_init ();
+}
+
+inline_size void
+infy_init (EV_P)
+{
+  if (fs_fd != -2)
+    return;
+
+  fs_fd = -1;
+
+  ev_check_2625 (EV_A);
+
+  fs_fd = infy_newfd ();
+
+  if (fs_fd >= 0)
+    {
+      fd_intern (fs_fd);
+      ev_io_init (&fs_w, infy_cb, fs_fd, EV_READ);
+      ev_set_priority (&fs_w, EV_MAXPRI);
+      ev_io_start (EV_A_ &fs_w);
+      ev_unref (EV_A);
+    }
+}
+
+inline_size void
+infy_fork (EV_P)
+{
+  int slot;
+
+  if (fs_fd < 0)
+    return;
+
+  ev_ref (EV_A);
+  ev_io_stop (EV_A_ &fs_w);
+  close (fs_fd);
+  fs_fd = infy_newfd ();
+
+  if (fs_fd >= 0)
+    {
+      fd_intern (fs_fd);
+      ev_io_set (&fs_w, fs_fd, EV_READ);
+      ev_io_start (EV_A_ &fs_w);
+      ev_unref (EV_A);
+    }
+
+  for (slot = 0; slot < (EV_INOTIFY_HASHSIZE); ++slot)
+    {
+      WL w_ = fs_hash [slot].head;
+      fs_hash [slot].head = 0;
+
+      while (w_)
+        {
+          ev_stat *w = (ev_stat *)w_;
+          w_ = w_->next; /* lets us add this watcher */
+
+          w->wd = -1;
+
+          if (fs_fd >= 0)
+            infy_add (EV_A_ w); /* re-add, no matter what */
+          else
+            {
+              w->timer.repeat = w->interval ? w->interval : DEF_STAT_INTERVAL;
+              if (ev_is_active (&w->timer)) ev_ref (EV_A);
+              ev_timer_again (EV_A_ &w->timer);
+              if (ev_is_active (&w->timer)) ev_unref (EV_A);
+            }
+        }
+    }
+}
+
+#endif
+
+#ifdef _WIN32
+# define EV_LSTAT(p,b) _stati64 (p, b)
+#else
+# define EV_LSTAT(p,b) lstat (p, b)
+#endif
+
+void
+ev_stat_stat (EV_P_ ev_stat *w) EV_THROW
+{
+  if (lstat (w->path, &w->attr) < 0)
+    w->attr.st_nlink = 0;
+  else if (!w->attr.st_nlink)
+    w->attr.st_nlink = 1;
+}
+
+static void noinline
+stat_timer_cb (EV_P_ ev_timer *w_, int revents)
+{
+  ev_stat *w = (ev_stat *)(((char *)w_) - offsetof (ev_stat, timer));
+
+  ev_statdata prev = w->attr;
+  ev_stat_stat (EV_A_ w);
+
+  /* memcmp doesn't work on netbsd, they.... do stuff to their struct stat */
+  if (
+    prev.st_dev      != w->attr.st_dev
+    || prev.st_ino   != w->attr.st_ino
+    || prev.st_mode  != w->attr.st_mode
+    || prev.st_nlink != w->attr.st_nlink
+    || prev.st_uid   != w->attr.st_uid
+    || prev.st_gid   != w->attr.st_gid
+    || prev.st_rdev  != w->attr.st_rdev
+    || prev.st_size  != w->attr.st_size
+    || prev.st_atime != w->attr.st_atime
+    || prev.st_mtime != w->attr.st_mtime
+    || prev.st_ctime != w->attr.st_ctime
+  ) {
+      /* we only update w->prev on actual differences */
+      /* in case we test more often than invoke the callback, */
+      /* to ensure that prev is always different to attr */
+      w->prev = prev;
+
+      #if EV_USE_INOTIFY
+        if (fs_fd >= 0)
+          {
+            infy_del (EV_A_ w);
+            infy_add (EV_A_ w);
+            ev_stat_stat (EV_A_ w); /* avoid race... */
+          }
+      #endif
+
+      ev_feed_event (EV_A_ w, EV_STAT);
+    }
+}
+
+void
+ev_stat_start (EV_P_ ev_stat *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  ev_stat_stat (EV_A_ w);
+
+  if (w->interval < MIN_STAT_INTERVAL && w->interval)
+    w->interval = MIN_STAT_INTERVAL;
+
+  ev_timer_init (&w->timer, stat_timer_cb, 0., w->interval ? w->interval : DEF_STAT_INTERVAL);
+  ev_set_priority (&w->timer, ev_priority (w));
+
+#if EV_USE_INOTIFY
+  infy_init (EV_A);
+
+  if (fs_fd >= 0)
+    infy_add (EV_A_ w);
+  else
+#endif
+    {
+      ev_timer_again (EV_A_ &w->timer);
+      ev_unref (EV_A);
+    }
+
+  ev_start (EV_A_ (W)w, 1);
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_stat_stop (EV_P_ ev_stat *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+#if EV_USE_INOTIFY
+  infy_del (EV_A_ w);
+#endif
+
+  if (ev_is_active (&w->timer))
+    {
+      ev_ref (EV_A);
+      ev_timer_stop (EV_A_ &w->timer);
+    }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_IDLE_ENABLE
+void
+ev_idle_start (EV_P_ ev_idle *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  pri_adjust (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ++idlecnt [ABSPRI (w)];
+
+    ++idleall;
+    ev_start (EV_A_ (W)w, active);
+
+    array_needsize (ev_idle *, idles [ABSPRI (w)], idlemax [ABSPRI (w)], active, EMPTY2);
+    idles [ABSPRI (w)][active - 1] = w;
+  }
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_idle_stop (EV_P_ ev_idle *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    idles [ABSPRI (w)][active - 1] = idles [ABSPRI (w)][--idlecnt [ABSPRI (w)]];
+    ev_active (idles [ABSPRI (w)][active - 1]) = active;
+
+    ev_stop (EV_A_ (W)w);
+    --idleall;
+  }
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_PREPARE_ENABLE
+void
+ev_prepare_start (EV_P_ ev_prepare *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, ++preparecnt);
+  array_needsize (ev_prepare *, prepares, preparemax, preparecnt, EMPTY2);
+  prepares [preparecnt - 1] = w;
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_prepare_stop (EV_P_ ev_prepare *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    prepares [active - 1] = prepares [--preparecnt];
+    ev_active (prepares [active - 1]) = active;
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_CHECK_ENABLE
+void
+ev_check_start (EV_P_ ev_check *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, ++checkcnt);
+  array_needsize (ev_check *, checks, checkmax, checkcnt, EMPTY2);
+  checks [checkcnt - 1] = w;
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_check_stop (EV_P_ ev_check *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    checks [active - 1] = checks [--checkcnt];
+    ev_active (checks [active - 1]) = active;
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_EMBED_ENABLE
+void noinline
+ev_embed_sweep (EV_P_ ev_embed *w) EV_THROW
+{
+  ev_run (w->other, EVRUN_NOWAIT);
+}
+
+static void
+embed_io_cb (EV_P_ ev_io *io, int revents)
+{
+  ev_embed *w = (ev_embed *)(((char *)io) - offsetof (ev_embed, io));
+
+  if (ev_cb (w))
+    ev_feed_event (EV_A_ (W)w, EV_EMBED);
+  else
+    ev_run (w->other, EVRUN_NOWAIT);
+}
+
+static void
+embed_prepare_cb (EV_P_ ev_prepare *prepare, int revents)
+{
+  ev_embed *w = (ev_embed *)(((char *)prepare) - offsetof (ev_embed, prepare));
+
+  {
+    EV_P = w->other;
+
+    while (fdchangecnt)
+      {
+        fd_reify (EV_A);
+        ev_run (EV_A_ EVRUN_NOWAIT);
+      }
+  }
+}
+
+static void
+embed_fork_cb (EV_P_ ev_fork *fork_w, int revents)
+{
+  ev_embed *w = (ev_embed *)(((char *)fork_w) - offsetof (ev_embed, fork));
+
+  ev_embed_stop (EV_A_ w);
+
+  {
+    EV_P = w->other;
+
+    ev_loop_fork (EV_A);
+    ev_run (EV_A_ EVRUN_NOWAIT);
+  }
+
+  ev_embed_start (EV_A_ w);
+}
+
+#if 0
+static void
+embed_idle_cb (EV_P_ ev_idle *idle, int revents)
+{
+  ev_idle_stop (EV_A_ idle);
+}
+#endif
+
+void
+ev_embed_start (EV_P_ ev_embed *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  {
+    EV_P = w->other;
+    assert (("libev: loop to be embedded is not embeddable", backend & ev_embeddable_backends ()));
+    ev_io_init (&w->io, embed_io_cb, backend_fd, EV_READ);
+  }
+
+  EV_FREQUENT_CHECK;
+
+  ev_set_priority (&w->io, ev_priority (w));
+  ev_io_start (EV_A_ &w->io);
+
+  ev_prepare_init (&w->prepare, embed_prepare_cb);
+  ev_set_priority (&w->prepare, EV_MINPRI);
+  ev_prepare_start (EV_A_ &w->prepare);
+
+  ev_fork_init (&w->fork, embed_fork_cb);
+  ev_fork_start (EV_A_ &w->fork);
+
+  /*ev_idle_init (&w->idle, e,bed_idle_cb);*/
+
+  ev_start (EV_A_ (W)w, 1);
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_embed_stop (EV_P_ ev_embed *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_io_stop      (EV_A_ &w->io);
+  ev_prepare_stop (EV_A_ &w->prepare);
+  ev_fork_stop    (EV_A_ &w->fork);
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_FORK_ENABLE
+void
+ev_fork_start (EV_P_ ev_fork *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, ++forkcnt);
+  array_needsize (ev_fork *, forks, forkmax, forkcnt, EMPTY2);
+  forks [forkcnt - 1] = w;
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_fork_stop (EV_P_ ev_fork *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    forks [active - 1] = forks [--forkcnt];
+    ev_active (forks [active - 1]) = active;
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_CLEANUP_ENABLE
+void
+ev_cleanup_start (EV_P_ ev_cleanup *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, ++cleanupcnt);
+  array_needsize (ev_cleanup *, cleanups, cleanupmax, cleanupcnt, EMPTY2);
+  cleanups [cleanupcnt - 1] = w;
+
+  /* cleanup watchers should never keep a refcount on the loop */
+  ev_unref (EV_A);
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_cleanup_stop (EV_P_ ev_cleanup *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+  ev_ref (EV_A);
+
+  {
+    int active = ev_active (w);
+
+    cleanups [active - 1] = cleanups [--cleanupcnt];
+    ev_active (cleanups [active - 1]) = active;
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+#endif
+
+#if EV_ASYNC_ENABLE
+void
+ev_async_start (EV_P_ ev_async *w) EV_THROW
+{
+  if (expect_false (ev_is_active (w)))
+    return;
+
+  w->sent = 0;
+
+  evpipe_init (EV_A);
+
+  EV_FREQUENT_CHECK;
+
+  ev_start (EV_A_ (W)w, ++asynccnt);
+  array_needsize (ev_async *, asyncs, asyncmax, asynccnt, EMPTY2);
+  asyncs [asynccnt - 1] = w;
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_async_stop (EV_P_ ev_async *w) EV_THROW
+{
+  clear_pending (EV_A_ (W)w);
+  if (expect_false (!ev_is_active (w)))
+    return;
+
+  EV_FREQUENT_CHECK;
+
+  {
+    int active = ev_active (w);
+
+    asyncs [active - 1] = asyncs [--asynccnt];
+    ev_active (asyncs [active - 1]) = active;
+  }
+
+  ev_stop (EV_A_ (W)w);
+
+  EV_FREQUENT_CHECK;
+}
+
+void
+ev_async_send (EV_P_ ev_async *w) EV_THROW
+{
+  w->sent = 1;
+  evpipe_write (EV_A_ &async_pending);
+}
+#endif
+
+/*****************************************************************************/
+
+struct ev_once
+{
+  ev_io io;
+  ev_timer to;
+  void (*cb)(int revents, void *arg);
+  void *arg;
+};
+
+static void
+once_cb (EV_P_ struct ev_once *once, int revents)
+{
+  void (*cb)(int revents, void *arg) = once->cb;
+  void *arg = once->arg;
+
+  ev_io_stop    (EV_A_ &once->io);
+  ev_timer_stop (EV_A_ &once->to);
+  ev_free (once);
+
+  cb (revents, arg);
+}
+
+static void
+once_cb_io (EV_P_ ev_io *w, int revents)
+{
+  struct ev_once *once = (struct ev_once *)(((char *)w) - offsetof (struct ev_once, io));
+
+  once_cb (EV_A_ once, revents | ev_clear_pending (EV_A_ &once->to));
+}
+
+static void
+once_cb_to (EV_P_ ev_timer *w, int revents)
+{
+  struct ev_once *once = (struct ev_once *)(((char *)w) - offsetof (struct ev_once, to));
+
+  once_cb (EV_A_ once, revents | ev_clear_pending (EV_A_ &once->io));
+}
+
+void
+ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_THROW
+{
+  struct ev_once *once = (struct ev_once *)ev_malloc (sizeof (struct ev_once));
+
+  if (expect_false (!once))
+    {
+      cb (EV_ERROR | EV_READ | EV_WRITE | EV_TIMER, arg);
+      return;
+    }
+
+  once->cb  = cb;
+  once->arg = arg;
+
+  ev_init (&once->io, once_cb_io);
+  if (fd >= 0)
+    {
+      ev_io_set (&once->io, fd, events);
+      ev_io_start (EV_A_ &once->io);
+    }
+
+  ev_init (&once->to, once_cb_to);
+  if (timeout >= 0.)
+    {
+      ev_timer_set (&once->to, timeout, 0.);
+      ev_timer_start (EV_A_ &once->to);
+    }
+}
+
+/*****************************************************************************/
+
+#if EV_WALK_ENABLE
+void ecb_cold
+ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_THROW
+{
+  int i, j;
+  ev_watcher_list *wl, *wn;
+
+  if (types & (EV_IO | EV_EMBED))
+    for (i = 0; i < anfdmax; ++i)
+      for (wl = anfds [i].head; wl; )
+        {
+          wn = wl->next;
+
+#if EV_EMBED_ENABLE
+          if (ev_cb ((ev_io *)wl) == embed_io_cb)
+            {
+              if (types & EV_EMBED)
+                cb (EV_A_ EV_EMBED, ((char *)wl) - offsetof (struct ev_embed, io));
+            }
+          else
+#endif
+#if EV_USE_INOTIFY
+          if (ev_cb ((ev_io *)wl) == infy_cb)
+            ;
+          else
+#endif
+          if ((ev_io *)wl != &pipe_w)
+            if (types & EV_IO)
+              cb (EV_A_ EV_IO, wl);
+
+          wl = wn;
+        }
+
+  if (types & (EV_TIMER | EV_STAT))
+    for (i = timercnt + HEAP0; i-- > HEAP0; )
+#if EV_STAT_ENABLE
+      /*TODO: timer is not always active*/
+      if (ev_cb ((ev_timer *)ANHE_w (timers [i])) == stat_timer_cb)
+        {
+          if (types & EV_STAT)
+            cb (EV_A_ EV_STAT, ((char *)ANHE_w (timers [i])) - offsetof (struct ev_stat, timer));
+        }
+      else
+#endif
+      if (types & EV_TIMER)
+        cb (EV_A_ EV_TIMER, ANHE_w (timers [i]));
+
+#if EV_PERIODIC_ENABLE
+  if (types & EV_PERIODIC)
+    for (i = periodiccnt + HEAP0; i-- > HEAP0; )
+      cb (EV_A_ EV_PERIODIC, ANHE_w (periodics [i]));
+#endif
+
+#if EV_IDLE_ENABLE
+  if (types & EV_IDLE)
+    for (j = NUMPRI; j--; )
+      for (i = idlecnt [j]; i--; )
+        cb (EV_A_ EV_IDLE, idles [j][i]);
+#endif
+
+#if EV_FORK_ENABLE
+  if (types & EV_FORK)
+    for (i = forkcnt; i--; )
+      if (ev_cb (forks [i]) != embed_fork_cb)
+        cb (EV_A_ EV_FORK, forks [i]);
+#endif
+
+#if EV_ASYNC_ENABLE
+  if (types & EV_ASYNC)
+    for (i = asynccnt; i--; )
+      cb (EV_A_ EV_ASYNC, asyncs [i]);
+#endif
+
+#if EV_PREPARE_ENABLE
+  if (types & EV_PREPARE)
+    for (i = preparecnt; i--; )
+# if EV_EMBED_ENABLE
+      if (ev_cb (prepares [i]) != embed_prepare_cb)
+# endif
+        cb (EV_A_ EV_PREPARE, prepares [i]);
+#endif
+
+#if EV_CHECK_ENABLE
+  if (types & EV_CHECK)
+    for (i = checkcnt; i--; )
+      cb (EV_A_ EV_CHECK, checks [i]);
+#endif
+
+#if EV_SIGNAL_ENABLE
+  if (types & EV_SIGNAL)
+    for (i = 0; i < EV_NSIG - 1; ++i)
+      for (wl = signals [i].head; wl; )
+        {
+          wn = wl->next;
+          cb (EV_A_ EV_SIGNAL, wl);
+          wl = wn;
+        }
+#endif
+
+#if EV_CHILD_ENABLE
+  if (types & EV_CHILD)
+    for (i = (EV_PID_HASHSIZE); i--; )
+      for (wl = childs [i]; wl; )
+        {
+          wn = wl->next;
+          cb (EV_A_ EV_CHILD, wl);
+          wl = wn;
+        }
+#endif
+/* EV_STAT     0x00001000 /* stat data changed */
+/* EV_EMBED    0x00010000 /* embedded event loop needs sweep */
+}
+#endif
+
+#if EV_MULTIPLICITY
+  #include "ev_wrap.h"
+#endif
+
diff --git a/release/src/router/libev-4.22/ev.h b/release/src/router/libev-4.22/ev.h
new file mode 100644
index 0000000000..38f62d82ef
--- /dev/null
+++ b/release/src/router/libev-4.22/ev.h
@@ -0,0 +1,854 @@
+/*
+ * libev native API header
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2015 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef EV_H_
+#define EV_H_
+
+#ifdef __cplusplus
+# define EV_CPP(x) x
+# if __cplusplus >= 201103L
+#  define EV_THROW noexcept
+# else
+#  define EV_THROW throw ()
+# endif
+#else
+# define EV_CPP(x)
+# define EV_THROW
+#endif
+
+EV_CPP(extern "C" {)
+
+/*****************************************************************************/
+
+/* pre-4.0 compatibility */
+#ifndef EV_COMPAT3
+# define EV_COMPAT3 1
+#endif
+
+#ifndef EV_FEATURES
+# if defined __OPTIMIZE_SIZE__
+#  define EV_FEATURES 0x7c
+# else
+#  define EV_FEATURES 0x7f
+# endif
+#endif
+
+#define EV_FEATURE_CODE     ((EV_FEATURES) &  1)
+#define EV_FEATURE_DATA     ((EV_FEATURES) &  2)
+#define EV_FEATURE_CONFIG   ((EV_FEATURES) &  4)
+#define EV_FEATURE_API      ((EV_FEATURES) &  8)
+#define EV_FEATURE_WATCHERS ((EV_FEATURES) & 16)
+#define EV_FEATURE_BACKENDS ((EV_FEATURES) & 32)
+#define EV_FEATURE_OS       ((EV_FEATURES) & 64)
+
+/* these priorities are inclusive, higher priorities will be invoked earlier */
+#ifndef EV_MINPRI
+# define EV_MINPRI (EV_FEATURE_CONFIG ? -2 : 0)
+#endif
+#ifndef EV_MAXPRI
+# define EV_MAXPRI (EV_FEATURE_CONFIG ? +2 : 0)
+#endif
+
+#ifndef EV_MULTIPLICITY
+# define EV_MULTIPLICITY EV_FEATURE_CONFIG
+#endif
+
+#ifndef EV_PERIODIC_ENABLE
+# define EV_PERIODIC_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_STAT_ENABLE
+# define EV_STAT_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_PREPARE_ENABLE
+# define EV_PREPARE_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CHECK_ENABLE
+# define EV_CHECK_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_IDLE_ENABLE
+# define EV_IDLE_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_FORK_ENABLE
+# define EV_FORK_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CLEANUP_ENABLE
+# define EV_CLEANUP_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_SIGNAL_ENABLE
+# define EV_SIGNAL_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CHILD_ENABLE
+# ifdef _WIN32
+#  define EV_CHILD_ENABLE 0
+# else
+#  define EV_CHILD_ENABLE EV_FEATURE_WATCHERS
+#endif
+#endif
+
+#ifndef EV_ASYNC_ENABLE
+# define EV_ASYNC_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_EMBED_ENABLE
+# define EV_EMBED_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_WALK_ENABLE
+# define EV_WALK_ENABLE 0 /* not yet */
+#endif
+
+/*****************************************************************************/
+
+#if EV_CHILD_ENABLE && !EV_SIGNAL_ENABLE
+# undef EV_SIGNAL_ENABLE
+# define EV_SIGNAL_ENABLE 1
+#endif
+
+/*****************************************************************************/
+
+typedef double ev_tstamp;
+
+#include <string.h> /* for memmove */
+
+#ifndef EV_ATOMIC_T
+# include <signal.h>
+# define EV_ATOMIC_T sig_atomic_t volatile
+#endif
+
+#if EV_STAT_ENABLE
+# ifdef _WIN32
+#  include <time.h>
+#  include <sys/types.h>
+# endif
+# include <sys/stat.h>
+#endif
+
+/* support multiple event loops? */
+#if EV_MULTIPLICITY
+struct ev_loop;
+# define EV_P  struct ev_loop *loop               /* a loop as sole parameter in a declaration */
+# define EV_P_ EV_P,                              /* a loop as first of multiple parameters */
+# define EV_A  loop                               /* a loop as sole argument to a function call */
+# define EV_A_ EV_A,                              /* a loop as first of multiple arguments */
+# define EV_DEFAULT_UC  ev_default_loop_uc_ ()    /* the default loop, if initialised, as sole arg */
+# define EV_DEFAULT_UC_ EV_DEFAULT_UC,            /* the default loop as first of multiple arguments */
+# define EV_DEFAULT  ev_default_loop (0)          /* the default loop as sole arg */
+# define EV_DEFAULT_ EV_DEFAULT,                  /* the default loop as first of multiple arguments */
+#else
+# define EV_P void
+# define EV_P_
+# define EV_A
+# define EV_A_
+# define EV_DEFAULT
+# define EV_DEFAULT_
+# define EV_DEFAULT_UC
+# define EV_DEFAULT_UC_
+# undef EV_EMBED_ENABLE
+#endif
+
+/* EV_INLINE is used for functions in header files */
+#if __STDC_VERSION__ >= 199901L || __GNUC__ >= 3
+# define EV_INLINE static inline
+#else
+# define EV_INLINE static
+#endif
+
+#ifdef EV_API_STATIC
+# define EV_API_DECL static
+#else
+# define EV_API_DECL extern
+#endif
+
+/* EV_PROTOTYPES can be used to switch of prototype declarations */
+#ifndef EV_PROTOTYPES
+# define EV_PROTOTYPES 1
+#endif
+
+/*****************************************************************************/
+
+#define EV_VERSION_MAJOR 4
+#define EV_VERSION_MINOR 22
+
+/* eventmask, revents, events... */
+enum {
+  EV_UNDEF    = (int)0xFFFFFFFF, /* guaranteed to be invalid */
+  EV_NONE     =            0x00, /* no events */
+  EV_READ     =            0x01, /* ev_io detected read will not block */
+  EV_WRITE    =            0x02, /* ev_io detected write will not block */
+  EV__IOFDSET =            0x80, /* internal use only */
+  EV_IO       =         EV_READ, /* alias for type-detection */
+  EV_TIMER    =      0x00000100, /* timer timed out */
+#if EV_COMPAT3
+  EV_TIMEOUT  =        EV_TIMER, /* pre 4.0 API compatibility */
+#endif
+  EV_PERIODIC =      0x00000200, /* periodic timer timed out */
+  EV_SIGNAL   =      0x00000400, /* signal was received */
+  EV_CHILD    =      0x00000800, /* child/pid had status change */
+  EV_STAT     =      0x00001000, /* stat data changed */
+  EV_IDLE     =      0x00002000, /* event loop is idling */
+  EV_PREPARE  =      0x00004000, /* event loop about to poll */
+  EV_CHECK    =      0x00008000, /* event loop finished poll */
+  EV_EMBED    =      0x00010000, /* embedded event loop needs sweep */
+  EV_FORK     =      0x00020000, /* event loop resumed in child */
+  EV_CLEANUP  =      0x00040000, /* event loop resumed in child */
+  EV_ASYNC    =      0x00080000, /* async intra-loop signal */
+  EV_CUSTOM   =      0x01000000, /* for use by user code */
+  EV_ERROR    = (int)0x80000000  /* sent when an error occurs */
+};
+
+/* can be used to add custom fields to all watchers, while losing binary compatibility */
+#ifndef EV_COMMON
+# define EV_COMMON void *data;
+#endif
+
+#ifndef EV_CB_DECLARE
+# define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents);
+#endif
+#ifndef EV_CB_INVOKE
+# define EV_CB_INVOKE(watcher,revents) (watcher)->cb (EV_A_ (watcher), (revents))
+#endif
+
+/* not official, do not use */
+#define EV_CB(type,name) void name (EV_P_ struct ev_ ## type *w, int revents)
+
+/*
+ * struct member types:
+ * private: you may look at them, but not change them,
+ *          and they might not mean anything to you.
+ * ro: can be read anytime, but only changed when the watcher isn't active.
+ * rw: can be read and modified anytime, even when the watcher is active.
+ *
+ * some internal details that might be helpful for debugging:
+ *
+ * active is either 0, which means the watcher is not active,
+ *           or the array index of the watcher (periodics, timers)
+ *           or the array index + 1 (most other watchers)
+ *           or simply 1 for watchers that aren't in some array.
+ * pending is either 0, in which case the watcher isn't,
+ *           or the array index + 1 in the pendings array.
+ */
+
+#if EV_MINPRI == EV_MAXPRI
+# define EV_DECL_PRIORITY
+#elif !defined (EV_DECL_PRIORITY)
+# define EV_DECL_PRIORITY int priority;
+#endif
+
+/* shared by all watchers */
+#define EV_WATCHER(type)			\
+  int active; /* private */			\
+  int pending; /* private */			\
+  EV_DECL_PRIORITY /* private */		\
+  EV_COMMON /* rw */				\
+  EV_CB_DECLARE (type) /* private */
+
+#define EV_WATCHER_LIST(type)			\
+  EV_WATCHER (type)				\
+  struct ev_watcher_list *next; /* private */
+
+#define EV_WATCHER_TIME(type)			\
+  EV_WATCHER (type)				\
+  ev_tstamp at;     /* private */
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher
+{
+  EV_WATCHER (ev_watcher)
+} ev_watcher;
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher_list
+{
+  EV_WATCHER_LIST (ev_watcher_list)
+} ev_watcher_list;
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher_time
+{
+  EV_WATCHER_TIME (ev_watcher_time)
+} ev_watcher_time;
+
+/* invoked when fd is either EV_READable or EV_WRITEable */
+/* revent EV_READ, EV_WRITE */
+typedef struct ev_io
+{
+  EV_WATCHER_LIST (ev_io)
+
+  int fd;     /* ro */
+  int events; /* ro */
+} ev_io;
+
+/* invoked after a specific time, repeatable (based on monotonic clock) */
+/* revent EV_TIMEOUT */
+typedef struct ev_timer
+{
+  EV_WATCHER_TIME (ev_timer)
+
+  ev_tstamp repeat; /* rw */
+} ev_timer;
+
+/* invoked at some specific time, possibly repeating at regular intervals (based on UTC) */
+/* revent EV_PERIODIC */
+typedef struct ev_periodic
+{
+  EV_WATCHER_TIME (ev_periodic)
+
+  ev_tstamp offset; /* rw */
+  ev_tstamp interval; /* rw */
+  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; /* rw */
+} ev_periodic;
+
+/* invoked when the given signal has been received */
+/* revent EV_SIGNAL */
+typedef struct ev_signal
+{
+  EV_WATCHER_LIST (ev_signal)
+
+  int signum; /* ro */
+} ev_signal;
+
+/* invoked when sigchld is received and waitpid indicates the given pid */
+/* revent EV_CHILD */
+/* does not support priorities */
+typedef struct ev_child
+{
+  EV_WATCHER_LIST (ev_child)
+
+  int flags;   /* private */
+  int pid;     /* ro */
+  int rpid;    /* rw, holds the received pid */
+  int rstatus; /* rw, holds the exit status, use the macros from sys/wait.h */
+} ev_child;
+
+#if EV_STAT_ENABLE
+/* st_nlink = 0 means missing file or other error */
+# ifdef _WIN32
+typedef struct _stati64 ev_statdata;
+# else
+typedef struct stat ev_statdata;
+# endif
+
+/* invoked each time the stat data changes for a given path */
+/* revent EV_STAT */
+typedef struct ev_stat
+{
+  EV_WATCHER_LIST (ev_stat)
+
+  ev_timer timer;     /* private */
+  ev_tstamp interval; /* ro */
+  const char *path;   /* ro */
+  ev_statdata prev;   /* ro */
+  ev_statdata attr;   /* ro */
+
+  int wd; /* wd for inotify, fd for kqueue */
+} ev_stat;
+#endif
+
+#if EV_IDLE_ENABLE
+/* invoked when the nothing else needs to be done, keeps the process from blocking */
+/* revent EV_IDLE */
+typedef struct ev_idle
+{
+  EV_WATCHER (ev_idle)
+} ev_idle;
+#endif
+
+/* invoked for each run of the mainloop, just before the blocking call */
+/* you can still change events in any way you like */
+/* revent EV_PREPARE */
+typedef struct ev_prepare
+{
+  EV_WATCHER (ev_prepare)
+} ev_prepare;
+
+/* invoked for each run of the mainloop, just after the blocking call */
+/* revent EV_CHECK */
+typedef struct ev_check
+{
+  EV_WATCHER (ev_check)
+} ev_check;
+
+#if EV_FORK_ENABLE
+/* the callback gets invoked before check in the child process when a fork was detected */
+/* revent EV_FORK */
+typedef struct ev_fork
+{
+  EV_WATCHER (ev_fork)
+} ev_fork;
+#endif
+
+#if EV_CLEANUP_ENABLE
+/* is invoked just before the loop gets destroyed */
+/* revent EV_CLEANUP */
+typedef struct ev_cleanup
+{
+  EV_WATCHER (ev_cleanup)
+} ev_cleanup;
+#endif
+
+#if EV_EMBED_ENABLE
+/* used to embed an event loop inside another */
+/* the callback gets invoked when the event loop has handled events, and can be 0 */
+typedef struct ev_embed
+{
+  EV_WATCHER (ev_embed)
+
+  struct ev_loop *other; /* ro */
+  ev_io io;              /* private */
+  ev_prepare prepare;    /* private */
+  ev_check check;        /* unused */
+  ev_timer timer;        /* unused */
+  ev_periodic periodic;  /* unused */
+  ev_idle idle;          /* unused */
+  ev_fork fork;          /* private */
+#if EV_CLEANUP_ENABLE
+  ev_cleanup cleanup;    /* unused */
+#endif
+} ev_embed;
+#endif
+
+#if EV_ASYNC_ENABLE
+/* invoked when somebody calls ev_async_send on the watcher */
+/* revent EV_ASYNC */
+typedef struct ev_async
+{
+  EV_WATCHER (ev_async)
+
+  EV_ATOMIC_T sent; /* private */
+} ev_async;
+
+# define ev_async_pending(w) (+(w)->sent)
+#endif
+
+/* the presence of this union forces similar struct layout */
+union ev_any_watcher
+{
+  struct ev_watcher w;
+  struct ev_watcher_list wl;
+
+  struct ev_io io;
+  struct ev_timer timer;
+  struct ev_periodic periodic;
+  struct ev_signal signal;
+  struct ev_child child;
+#if EV_STAT_ENABLE
+  struct ev_stat stat;
+#endif
+#if EV_IDLE_ENABLE
+  struct ev_idle idle;
+#endif
+  struct ev_prepare prepare;
+  struct ev_check check;
+#if EV_FORK_ENABLE
+  struct ev_fork fork;
+#endif
+#if EV_CLEANUP_ENABLE
+  struct ev_cleanup cleanup;
+#endif
+#if EV_EMBED_ENABLE
+  struct ev_embed embed;
+#endif
+#if EV_ASYNC_ENABLE
+  struct ev_async async;
+#endif
+};
+
+/* flag bits for ev_default_loop and ev_loop_new */
+enum {
+  /* the default */
+  EVFLAG_AUTO      = 0x00000000U, /* not quite a mask */
+  /* flag bits */
+  EVFLAG_NOENV     = 0x01000000U, /* do NOT consult environment */
+  EVFLAG_FORKCHECK = 0x02000000U, /* check for a fork in each iteration */
+  /* debugging/feature disable */
+  EVFLAG_NOINOTIFY = 0x00100000U, /* do not attempt to use inotify */
+#if EV_COMPAT3
+  EVFLAG_NOSIGFD   = 0, /* compatibility to pre-3.9 */
+#endif
+  EVFLAG_SIGNALFD  = 0x00200000U, /* attempt to use signalfd */
+  EVFLAG_NOSIGMASK = 0x00400000U  /* avoid modifying the signal mask */
+};
+
+/* method bits to be ored together */
+enum {
+  EVBACKEND_SELECT  = 0x00000001U, /* about anywhere */
+  EVBACKEND_POLL    = 0x00000002U, /* !win */
+  EVBACKEND_EPOLL   = 0x00000004U, /* linux */
+  EVBACKEND_KQUEUE  = 0x00000008U, /* bsd */
+  EVBACKEND_DEVPOLL = 0x00000010U, /* solaris 8 */ /* NYI */
+  EVBACKEND_PORT    = 0x00000020U, /* solaris 10 */
+  EVBACKEND_ALL     = 0x0000003FU, /* all known backends */
+  EVBACKEND_MASK    = 0x0000FFFFU  /* all future backends */
+};
+
+#if EV_PROTOTYPES
+EV_API_DECL int ev_version_major (void) EV_THROW;
+EV_API_DECL int ev_version_minor (void) EV_THROW;
+
+EV_API_DECL unsigned int ev_supported_backends (void) EV_THROW;
+EV_API_DECL unsigned int ev_recommended_backends (void) EV_THROW;
+EV_API_DECL unsigned int ev_embeddable_backends (void) EV_THROW;
+
+EV_API_DECL ev_tstamp ev_time (void) EV_THROW;
+EV_API_DECL void ev_sleep (ev_tstamp delay) EV_THROW; /* sleep for a while */
+
+/* Sets the allocation function to use, works like realloc.
+ * It is used to allocate and free memory.
+ * If it returns zero when memory needs to be allocated, the library might abort
+ * or take some potentially destructive action.
+ * The default is your system realloc function.
+ */
+EV_API_DECL void ev_set_allocator (void *(*cb)(void *ptr, long size) EV_THROW) EV_THROW;
+
+/* set the callback function to call on a
+ * retryable syscall error
+ * (such as failed select, poll, epoll_wait)
+ */
+EV_API_DECL void ev_set_syserr_cb (void (*cb)(const char *msg) EV_THROW) EV_THROW;
+
+#if EV_MULTIPLICITY
+
+/* the default loop is the only one that handles signals and child watchers */
+/* you can call this as often as you like */
+EV_API_DECL struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW;
+
+#ifdef EV_API_STATIC
+EV_API_DECL struct ev_loop *ev_default_loop_ptr;
+#endif
+
+EV_INLINE struct ev_loop *
+ev_default_loop_uc_ (void) EV_THROW
+{
+  extern struct ev_loop *ev_default_loop_ptr;
+
+  return ev_default_loop_ptr;
+}
+
+EV_INLINE int
+ev_is_default_loop (EV_P) EV_THROW
+{
+  return EV_A == EV_DEFAULT_UC;
+}
+
+/* create and destroy alternative loops that don't handle signals */
+EV_API_DECL struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0)) EV_THROW;
+
+EV_API_DECL ev_tstamp ev_now (EV_P) EV_THROW; /* time w.r.t. timers and the eventloop, updated after each poll */
+
+#else
+
+EV_API_DECL int ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW; /* returns true when successful */
+
+EV_API_DECL ev_tstamp ev_rt_now;
+
+EV_INLINE ev_tstamp
+ev_now (void) EV_THROW
+{
+  return ev_rt_now;
+}
+
+/* looks weird, but ev_is_default_loop (EV_A) still works if this exists */
+EV_INLINE int
+ev_is_default_loop (void) EV_THROW
+{
+  return 1;
+}
+
+#endif /* multiplicity */
+
+/* destroy event loops, also works for the default loop */
+EV_API_DECL void ev_loop_destroy (EV_P);
+
+/* this needs to be called after fork, to duplicate the loop */
+/* when you want to re-use it in the child */
+/* you can call it in either the parent or the child */
+/* you can actually call it at any time, anywhere :) */
+EV_API_DECL void ev_loop_fork (EV_P) EV_THROW;
+
+EV_API_DECL unsigned int ev_backend (EV_P) EV_THROW; /* backend in use by loop */
+
+EV_API_DECL void ev_now_update (EV_P) EV_THROW; /* update event loop time */
+
+#if EV_WALK_ENABLE
+/* walk (almost) all watchers in the loop of a given type, invoking the */
+/* callback on every such watcher. The callback might stop the watcher, */
+/* but do nothing else with the loop */
+EV_API_DECL void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_THROW;
+#endif
+
+#endif /* prototypes */
+
+/* ev_run flags values */
+enum {
+  EVRUN_NOWAIT = 1, /* do not block/wait */
+  EVRUN_ONCE   = 2  /* block *once* only */
+};
+
+/* ev_break how values */
+enum {
+  EVBREAK_CANCEL = 0, /* undo unloop */
+  EVBREAK_ONE    = 1, /* unloop once */
+  EVBREAK_ALL    = 2  /* unloop all loops */
+};
+
+#if EV_PROTOTYPES
+EV_API_DECL int  ev_run (EV_P_ int flags EV_CPP (= 0));
+EV_API_DECL void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)) EV_THROW; /* break out of the loop */
+
+/*
+ * ref/unref can be used to add or remove a refcount on the mainloop. every watcher
+ * keeps one reference. if you have a long-running watcher you never unregister that
+ * should not keep ev_loop from running, unref() after starting, and ref() before stopping.
+ */
+EV_API_DECL void ev_ref   (EV_P) EV_THROW;
+EV_API_DECL void ev_unref (EV_P) EV_THROW;
+
+/*
+ * convenience function, wait for a single event, without registering an event watcher
+ * if timeout is < 0, do wait indefinitely
+ */
+EV_API_DECL void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_THROW;
+
+# if EV_FEATURE_API
+EV_API_DECL unsigned int ev_iteration (EV_P) EV_THROW; /* number of loop iterations */
+EV_API_DECL unsigned int ev_depth     (EV_P) EV_THROW; /* #ev_loop enters - #ev_loop leaves */
+EV_API_DECL void         ev_verify    (EV_P) EV_THROW; /* abort if loop data corrupted */
+
+EV_API_DECL void ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
+EV_API_DECL void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
+
+/* advanced stuff for threading etc. support, see docs */
+EV_API_DECL void ev_set_userdata (EV_P_ void *data) EV_THROW;
+EV_API_DECL void *ev_userdata (EV_P) EV_THROW;
+typedef void (*ev_loop_callback)(EV_P);
+EV_API_DECL void ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_THROW;
+/* C++ doesn't allow the use of the ev_loop_callback typedef here, so we need to spell it out */
+EV_API_DECL void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV_P) EV_THROW) EV_THROW;
+
+EV_API_DECL unsigned int ev_pending_count (EV_P) EV_THROW; /* number of pending events, if any */
+EV_API_DECL void ev_invoke_pending (EV_P); /* invoke all pending watchers */
+
+/*
+ * stop/start the timer handling.
+ */
+EV_API_DECL void ev_suspend (EV_P) EV_THROW;
+EV_API_DECL void ev_resume  (EV_P) EV_THROW;
+#endif
+
+#endif
+
+/* these may evaluate ev multiple times, and the other arguments at most once */
+/* either use ev_init + ev_TYPE_set, or the ev_TYPE_init macro, below, to first initialise a watcher */
+#define ev_init(ev,cb_) do {			\
+  ((ev_watcher *)(void *)(ev))->active  =	\
+  ((ev_watcher *)(void *)(ev))->pending = 0;	\
+  ev_set_priority ((ev), 0);			\
+  ev_set_cb ((ev), cb_);			\
+} while (0)
+
+#define ev_io_set(ev,fd_,events_)            do { (ev)->fd = (fd_); (ev)->events = (events_) | EV__IOFDSET; } while (0)
+#define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))->at = (after_); (ev)->repeat = (repeat_); } while (0)
+#define ev_periodic_set(ev,ofs_,ival_,rcb_)  do { (ev)->offset = (ofs_); (ev)->interval = (ival_); (ev)->reschedule_cb = (rcb_); } while (0)
+#define ev_signal_set(ev,signum_)            do { (ev)->signum = (signum_); } while (0)
+#define ev_child_set(ev,pid_,trace_)         do { (ev)->pid = (pid_); (ev)->flags = !!(trace_); } while (0)
+#define ev_stat_set(ev,path_,interval_)      do { (ev)->path = (path_); (ev)->interval = (interval_); (ev)->wd = -2; } while (0)
+#define ev_idle_set(ev)                      /* nop, yes, this is a serious in-joke */
+#define ev_prepare_set(ev)                   /* nop, yes, this is a serious in-joke */
+#define ev_check_set(ev)                     /* nop, yes, this is a serious in-joke */
+#define ev_embed_set(ev,other_)              do { (ev)->other = (other_); } while (0)
+#define ev_fork_set(ev)                      /* nop, yes, this is a serious in-joke */
+#define ev_cleanup_set(ev)                   /* nop, yes, this is a serious in-joke */
+#define ev_async_set(ev)                     /* nop, yes, this is a serious in-joke */
+
+#define ev_io_init(ev,cb,fd,events)          do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)
+#define ev_timer_init(ev,cb,after,repeat)    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)
+#define ev_periodic_init(ev,cb,ofs,ival,rcb) do { ev_init ((ev), (cb)); ev_periodic_set ((ev),(ofs),(ival),(rcb)); } while (0)
+#define ev_signal_init(ev,cb,signum)         do { ev_init ((ev), (cb)); ev_signal_set ((ev), (signum)); } while (0)
+#define ev_child_init(ev,cb,pid,trace)       do { ev_init ((ev), (cb)); ev_child_set ((ev),(pid),(trace)); } while (0)
+#define ev_stat_init(ev,cb,path,interval)    do { ev_init ((ev), (cb)); ev_stat_set ((ev),(path),(interval)); } while (0)
+#define ev_idle_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_idle_set ((ev)); } while (0)
+#define ev_prepare_init(ev,cb)               do { ev_init ((ev), (cb)); ev_prepare_set ((ev)); } while (0)
+#define ev_check_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_check_set ((ev)); } while (0)
+#define ev_embed_init(ev,cb,other)           do { ev_init ((ev), (cb)); ev_embed_set ((ev),(other)); } while (0)
+#define ev_fork_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_fork_set ((ev)); } while (0)
+#define ev_cleanup_init(ev,cb)               do { ev_init ((ev), (cb)); ev_cleanup_set ((ev)); } while (0)
+#define ev_async_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_async_set ((ev)); } while (0)
+
+#define ev_is_pending(ev)                    (0 + ((ev_watcher *)(void *)(ev))->pending) /* ro, true when watcher is waiting for callback invocation */
+#define ev_is_active(ev)                     (0 + ((ev_watcher *)(void *)(ev))->active) /* ro, true when the watcher has been started */
+
+#define ev_cb_(ev)                           (ev)->cb /* rw */
+#define ev_cb(ev)                            (memmove (&ev_cb_ (ev), &((ev_watcher *)(ev))->cb, sizeof (ev_cb_ (ev))), (ev)->cb)
+
+#if EV_MINPRI == EV_MAXPRI
+# define ev_priority(ev)                     ((ev), EV_MINPRI)
+# define ev_set_priority(ev,pri)             ((ev), (pri))
+#else
+# define ev_priority(ev)                     (+(((ev_watcher *)(void *)(ev))->priority))
+# define ev_set_priority(ev,pri)             (   (ev_watcher *)(void *)(ev))->priority = (pri)
+#endif
+
+#define ev_periodic_at(ev)                   (+((ev_watcher_time *)(ev))->at)
+
+#ifndef ev_set_cb
+# define ev_set_cb(ev,cb_)                   (ev_cb_ (ev) = (cb_), memmove (&((ev_watcher *)(ev))->cb, &ev_cb_ (ev), sizeof (ev_cb_ (ev))))
+#endif
+
+/* stopping (enabling, adding) a watcher does nothing if it is already running */
+/* stopping (disabling, deleting) a watcher does nothing unless it's already running */
+#if EV_PROTOTYPES
+
+/* feeds an event into a watcher as if the event actually occurred */
+/* accepts any ev_watcher type */
+EV_API_DECL void ev_feed_event     (EV_P_ void *w, int revents) EV_THROW;
+EV_API_DECL void ev_feed_fd_event  (EV_P_ int fd, int revents) EV_THROW;
+#if EV_SIGNAL_ENABLE
+EV_API_DECL void ev_feed_signal    (int signum) EV_THROW;
+EV_API_DECL void ev_feed_signal_event (EV_P_ int signum) EV_THROW;
+#endif
+EV_API_DECL void ev_invoke         (EV_P_ void *w, int revents);
+EV_API_DECL int  ev_clear_pending  (EV_P_ void *w) EV_THROW;
+
+EV_API_DECL void ev_io_start       (EV_P_ ev_io *w) EV_THROW;
+EV_API_DECL void ev_io_stop        (EV_P_ ev_io *w) EV_THROW;
+
+EV_API_DECL void ev_timer_start    (EV_P_ ev_timer *w) EV_THROW;
+EV_API_DECL void ev_timer_stop     (EV_P_ ev_timer *w) EV_THROW;
+/* stops if active and no repeat, restarts if active and repeating, starts if inactive and repeating */
+EV_API_DECL void ev_timer_again    (EV_P_ ev_timer *w) EV_THROW;
+/* return remaining time */
+EV_API_DECL ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w) EV_THROW;
+
+#if EV_PERIODIC_ENABLE
+EV_API_DECL void ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW;
+EV_API_DECL void ev_periodic_stop  (EV_P_ ev_periodic *w) EV_THROW;
+EV_API_DECL void ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW;
+#endif
+
+/* only supported in the default loop */
+#if EV_SIGNAL_ENABLE
+EV_API_DECL void ev_signal_start   (EV_P_ ev_signal *w) EV_THROW;
+EV_API_DECL void ev_signal_stop    (EV_P_ ev_signal *w) EV_THROW;
+#endif
+
+/* only supported in the default loop */
+# if EV_CHILD_ENABLE
+EV_API_DECL void ev_child_start    (EV_P_ ev_child *w) EV_THROW;
+EV_API_DECL void ev_child_stop     (EV_P_ ev_child *w) EV_THROW;
+# endif
+
+# if EV_STAT_ENABLE
+EV_API_DECL void ev_stat_start     (EV_P_ ev_stat *w) EV_THROW;
+EV_API_DECL void ev_stat_stop      (EV_P_ ev_stat *w) EV_THROW;
+EV_API_DECL void ev_stat_stat      (EV_P_ ev_stat *w) EV_THROW;
+# endif
+
+# if EV_IDLE_ENABLE
+EV_API_DECL void ev_idle_start     (EV_P_ ev_idle *w) EV_THROW;
+EV_API_DECL void ev_idle_stop      (EV_P_ ev_idle *w) EV_THROW;
+# endif
+
+#if EV_PREPARE_ENABLE
+EV_API_DECL void ev_prepare_start  (EV_P_ ev_prepare *w) EV_THROW;
+EV_API_DECL void ev_prepare_stop   (EV_P_ ev_prepare *w) EV_THROW;
+#endif
+
+#if EV_CHECK_ENABLE
+EV_API_DECL void ev_check_start    (EV_P_ ev_check *w) EV_THROW;
+EV_API_DECL void ev_check_stop     (EV_P_ ev_check *w) EV_THROW;
+#endif
+
+# if EV_FORK_ENABLE
+EV_API_DECL void ev_fork_start     (EV_P_ ev_fork *w) EV_THROW;
+EV_API_DECL void ev_fork_stop      (EV_P_ ev_fork *w) EV_THROW;
+# endif
+
+# if EV_CLEANUP_ENABLE
+EV_API_DECL void ev_cleanup_start  (EV_P_ ev_cleanup *w) EV_THROW;
+EV_API_DECL void ev_cleanup_stop   (EV_P_ ev_cleanup *w) EV_THROW;
+# endif
+
+# if EV_EMBED_ENABLE
+/* only supported when loop to be embedded is in fact embeddable */
+EV_API_DECL void ev_embed_start    (EV_P_ ev_embed *w) EV_THROW;
+EV_API_DECL void ev_embed_stop     (EV_P_ ev_embed *w) EV_THROW;
+EV_API_DECL void ev_embed_sweep    (EV_P_ ev_embed *w) EV_THROW;
+# endif
+
+# if EV_ASYNC_ENABLE
+EV_API_DECL void ev_async_start    (EV_P_ ev_async *w) EV_THROW;
+EV_API_DECL void ev_async_stop     (EV_P_ ev_async *w) EV_THROW;
+EV_API_DECL void ev_async_send     (EV_P_ ev_async *w) EV_THROW;
+# endif
+
+#if EV_COMPAT3
+  #define EVLOOP_NONBLOCK EVRUN_NOWAIT
+  #define EVLOOP_ONESHOT  EVRUN_ONCE
+  #define EVUNLOOP_CANCEL EVBREAK_CANCEL
+  #define EVUNLOOP_ONE    EVBREAK_ONE
+  #define EVUNLOOP_ALL    EVBREAK_ALL
+  #if EV_PROTOTYPES
+    EV_INLINE void ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }
+    EV_INLINE void ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }
+    EV_INLINE void ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }
+    EV_INLINE void ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }
+    #if EV_FEATURE_API
+      EV_INLINE unsigned int ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }
+      EV_INLINE unsigned int ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }
+      EV_INLINE void         ev_loop_verify (EV_P) {        ev_verify     (EV_A); }
+    #endif
+  #endif
+#else
+  typedef struct ev_loop ev_loop;
+#endif
+
+#endif
+
+EV_CPP(})
+
+#endif
+
diff --git a/release/src/router/libev-4.22/ev.pod b/release/src/router/libev-4.22/ev.pod
new file mode 100644
index 0000000000..e6473ca702
--- /dev/null
+++ b/release/src/router/libev-4.22/ev.pod
@@ -0,0 +1,5564 @@
+=encoding utf-8
+
+=head1 NAME
+
+libev - a high performance full-featured event loop written in C
+
+=head1 SYNOPSIS
+
+   #include <ev.h>
+
+=head2 EXAMPLE PROGRAM
+
+   // a single header file is required
+   #include <ev.h>
+
+   #include <stdio.h> // for puts
+
+   // every watcher type has its own typedef'd struct
+   // with the name ev_TYPE
+   ev_io stdin_watcher;
+   ev_timer timeout_watcher;
+
+   // all watcher callbacks have a similar signature
+   // this callback is called when data is readable on stdin
+   static void
+   stdin_cb (EV_P_ ev_io *w, int revents)
+   {
+     puts ("stdin ready");
+     // for one-shot events, one must manually stop the watcher
+     // with its corresponding stop function.
+     ev_io_stop (EV_A_ w);
+
+     // this causes all nested ev_run's to stop iterating
+     ev_break (EV_A_ EVBREAK_ALL);
+   }
+
+   // another callback, this time for a time-out
+   static void
+   timeout_cb (EV_P_ ev_timer *w, int revents)
+   {
+     puts ("timeout");
+     // this causes the innermost ev_run to stop iterating
+     ev_break (EV_A_ EVBREAK_ONE);
+   }
+
+   int
+   main (void)
+   {
+     // use the default event loop unless you have special needs
+     struct ev_loop *loop = EV_DEFAULT;
+
+     // initialise an io watcher, then start it
+     // this one will watch for stdin to become readable
+     ev_io_init (&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
+     ev_io_start (loop, &stdin_watcher);
+
+     // initialise a timer watcher, then start it
+     // simple non-repeating 5.5 second timeout
+     ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
+     ev_timer_start (loop, &timeout_watcher);
+
+     // now wait for events to arrive
+     ev_run (loop, 0);
+
+     // break was called, so exit
+     return 0;
+   }
+
+=head1 ABOUT THIS DOCUMENT
+
+This document documents the libev software package.
+
+The newest version of this document is also available as an html-formatted
+web page you might find easier to navigate when reading it for the first
+time: L<http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod>.
+
+While this document tries to be as complete as possible in documenting
+libev, its usage and the rationale behind its design, it is not a tutorial
+on event-based programming, nor will it introduce event-based programming
+with libev.
+
+Familiarity with event based programming techniques in general is assumed
+throughout this document.
+
+=head1 WHAT TO READ WHEN IN A HURRY
+
+This manual tries to be very detailed, but unfortunately, this also makes
+it very long. If you just want to know the basics of libev, I suggest
+reading L</ANATOMY OF A WATCHER>, then the L</EXAMPLE PROGRAM> above and
+look up the missing functions in L</GLOBAL FUNCTIONS> and the C<ev_io> and
+C<ev_timer> sections in L</WATCHER TYPES>.
+
+=head1 ABOUT LIBEV
+
+Libev is an event loop: you register interest in certain events (such as a
+file descriptor being readable or a timeout occurring), and it will manage
+these event sources and provide your program with events.
+
+To do this, it must take more or less complete control over your process
+(or thread) by executing the I<event loop> handler, and will then
+communicate events via a callback mechanism.
+
+You register interest in certain events by registering so-called I<event
+watchers>, which are relatively small C structures you initialise with the
+details of the event, and then hand it over to libev by I<starting> the
+watcher.
+
+=head2 FEATURES
+
+Libev supports C<select>, C<poll>, the Linux-specific C<epoll>, the
+BSD-specific C<kqueue> and the Solaris-specific event port mechanisms
+for file descriptor events (C<ev_io>), the Linux C<inotify> interface
+(for C<ev_stat>), Linux eventfd/signalfd (for faster and cleaner
+inter-thread wakeup (C<ev_async>)/signal handling (C<ev_signal>)) relative
+timers (C<ev_timer>), absolute timers with customised rescheduling
+(C<ev_periodic>), synchronous signals (C<ev_signal>), process status
+change events (C<ev_child>), and event watchers dealing with the event
+loop mechanism itself (C<ev_idle>, C<ev_embed>, C<ev_prepare> and
+C<ev_check> watchers) as well as file watchers (C<ev_stat>) and even
+limited support for fork events (C<ev_fork>).
+
+It also is quite fast (see this
+L<benchmark|http://libev.schmorp.de/bench.html> comparing it to libevent
+for example).
+
+=head2 CONVENTIONS
+
+Libev is very configurable. In this manual the default (and most common)
+configuration will be described, which supports multiple event loops. For
+more info about various configuration options please have a look at
+B<EMBED> section in this manual. If libev was configured without support
+for multiple event loops, then all functions taking an initial argument of
+name C<loop> (which is always of type C<struct ev_loop *>) will not have
+this argument.
+
+=head2 TIME REPRESENTATION
+
+Libev represents time as a single floating point number, representing
+the (fractional) number of seconds since the (POSIX) epoch (in practice
+somewhere near the beginning of 1970, details are complicated, don't
+ask). This type is called C<ev_tstamp>, which is what you should use
+too. It usually aliases to the C<double> type in C. When you need to do
+any calculations on it, you should treat it as some floating point value.
+
+Unlike the name component C<stamp> might indicate, it is also used for
+time differences (e.g. delays) throughout libev.
+
+=head1 ERROR HANDLING
+
+Libev knows three classes of errors: operating system errors, usage errors
+and internal errors (bugs).
+
+When libev catches an operating system error it cannot handle (for example
+a system call indicating a condition libev cannot fix), it calls the callback
+set via C<ev_set_syserr_cb>, which is supposed to fix the problem or
+abort. The default is to print a diagnostic message and to call C<abort
+()>.
+
+When libev detects a usage error such as a negative timer interval, then
+it will print a diagnostic message and abort (via the C<assert> mechanism,
+so C<NDEBUG> will disable this checking): these are programming errors in
+the libev caller and need to be fixed there.
+
+Libev also has a few internal error-checking C<assert>ions, and also has
+extensive consistency checking code. These do not trigger under normal
+circumstances, as they indicate either a bug in libev or worse.
+
+
+=head1 GLOBAL FUNCTIONS
+
+These functions can be called anytime, even before initialising the
+library in any way.
+
+=over 4
+
+=item ev_tstamp ev_time ()
+
+Returns the current time as libev would use it. Please note that the
+C<ev_now> function is usually faster and also often returns the timestamp
+you actually want to know. Also interesting is the combination of
+C<ev_now_update> and C<ev_now>.
+
+=item ev_sleep (ev_tstamp interval)
+
+Sleep for the given interval: The current thread will be blocked
+until either it is interrupted or the given time interval has
+passed (approximately - it might return a bit earlier even if not
+interrupted). Returns immediately if C<< interval <= 0 >>.
+
+Basically this is a sub-second-resolution C<sleep ()>.
+
+The range of the C<interval> is limited - libev only guarantees to work
+with sleep times of up to one day (C<< interval <= 86400 >>).
+
+=item int ev_version_major ()
+
+=item int ev_version_minor ()
+
+You can find out the major and minor ABI version numbers of the library
+you linked against by calling the functions C<ev_version_major> and
+C<ev_version_minor>. If you want, you can compare against the global
+symbols C<EV_VERSION_MAJOR> and C<EV_VERSION_MINOR>, which specify the
+version of the library your program was compiled against.
+
+These version numbers refer to the ABI version of the library, not the
+release version.
+
+Usually, it's a good idea to terminate if the major versions mismatch,
+as this indicates an incompatible change. Minor versions are usually
+compatible to older versions, so a larger minor version alone is usually
+not a problem.
+
+Example: Make sure we haven't accidentally been linked against the wrong
+version (note, however, that this will not detect other ABI mismatches,
+such as LFS or reentrancy).
+
+   assert (("libev version mismatch",
+            ev_version_major () == EV_VERSION_MAJOR
+            && ev_version_minor () >= EV_VERSION_MINOR));
+
+=item unsigned int ev_supported_backends ()
+
+Return the set of all backends (i.e. their corresponding C<EV_BACKEND_*>
+value) compiled into this binary of libev (independent of their
+availability on the system you are running on). See C<ev_default_loop> for
+a description of the set values.
+
+Example: make sure we have the epoll method, because yeah this is cool and
+a must have and can we have a torrent of it please!!!11
+
+   assert (("sorry, no epoll, no sex",
+            ev_supported_backends () & EVBACKEND_EPOLL));
+
+=item unsigned int ev_recommended_backends ()
+
+Return the set of all backends compiled into this binary of libev and
+also recommended for this platform, meaning it will work for most file
+descriptor types. This set is often smaller than the one returned by
+C<ev_supported_backends>, as for example kqueue is broken on most BSDs
+and will not be auto-detected unless you explicitly request it (assuming
+you know what you are doing). This is the set of backends that libev will
+probe for if you specify no backends explicitly.
+
+=item unsigned int ev_embeddable_backends ()
+
+Returns the set of backends that are embeddable in other event loops. This
+value is platform-specific but can include backends not available on the
+current system. To find which embeddable backends might be supported on
+the current system, you would need to look at C<ev_embeddable_backends ()
+& ev_supported_backends ()>, likewise for recommended ones.
+
+See the description of C<ev_embed> watchers for more info.
+
+=item ev_set_allocator (void *(*cb)(void *ptr, long size) throw ())
+
+Sets the allocation function to use (the prototype is similar - the
+semantics are identical to the C<realloc> C89/SuS/POSIX function). It is
+used to allocate and free memory (no surprises here). If it returns zero
+when memory needs to be allocated (C<size != 0>), the library might abort
+or take some potentially destructive action.
+
+Since some systems (at least OpenBSD and Darwin) fail to implement
+correct C<realloc> semantics, libev will use a wrapper around the system
+C<realloc> and C<free> functions by default.
+
+You could override this function in high-availability programs to, say,
+free some memory if it cannot allocate memory, to use a special allocator,
+or even to sleep a while and retry until some memory is available.
+
+Example: Replace the libev allocator with one that waits a bit and then
+retries (example requires a standards-compliant C<realloc>).
+
+   static void *
+   persistent_realloc (void *ptr, size_t size)
+   {
+     for (;;)
+       {
+         void *newptr = realloc (ptr, size);
+
+         if (newptr)
+           return newptr;
+
+         sleep (60);
+       }
+   }
+
+   ...
+   ev_set_allocator (persistent_realloc);
+
+=item ev_set_syserr_cb (void (*cb)(const char *msg) throw ())
+
+Set the callback function to call on a retryable system call error (such
+as failed select, poll, epoll_wait). The message is a printable string
+indicating the system call or subsystem causing the problem. If this
+callback is set, then libev will expect it to remedy the situation, no
+matter what, when it returns. That is, libev will generally retry the
+requested operation, or, if the condition doesn't go away, do bad stuff
+(such as abort).
+
+Example: This is basically the same thing that libev does internally, too.
+
+   static void
+   fatal_error (const char *msg)
+   {
+     perror (msg);
+     abort ();
+   }
+
+   ...
+   ev_set_syserr_cb (fatal_error);
+
+=item ev_feed_signal (int signum)
+
+This function can be used to "simulate" a signal receive. It is completely
+safe to call this function at any time, from any context, including signal
+handlers or random threads.
+
+Its main use is to customise signal handling in your process, especially
+in the presence of threads. For example, you could block signals
+by default in all threads (and specifying C<EVFLAG_NOSIGMASK> when
+creating any loops), and in one thread, use C<sigwait> or any other
+mechanism to wait for signals, then "deliver" them to libev by calling
+C<ev_feed_signal>.
+
+=back
+
+=head1 FUNCTIONS CONTROLLING EVENT LOOPS
+
+An event loop is described by a C<struct ev_loop *> (the C<struct> is
+I<not> optional in this case unless libev 3 compatibility is disabled, as
+libev 3 had an C<ev_loop> function colliding with the struct name).
+
+The library knows two types of such loops, the I<default> loop, which
+supports child process events, and dynamically created event loops which
+do not.
+
+=over 4
+
+=item struct ev_loop *ev_default_loop (unsigned int flags)
+
+This returns the "default" event loop object, which is what you should
+normally use when you just need "the event loop". Event loop objects and
+the C<flags> parameter are described in more detail in the entry for
+C<ev_loop_new>.
+
+If the default loop is already initialised then this function simply
+returns it (and ignores the flags. If that is troubling you, check
+C<ev_backend ()> afterwards). Otherwise it will create it with the given
+flags, which should almost always be C<0>, unless the caller is also the
+one calling C<ev_run> or otherwise qualifies as "the main program".
+
+If you don't know what event loop to use, use the one returned from this
+function (or via the C<EV_DEFAULT> macro).
+
+Note that this function is I<not> thread-safe, so if you want to use it
+from multiple threads, you have to employ some kind of mutex (note also
+that this case is unlikely, as loops cannot be shared easily between
+threads anyway).
+
+The default loop is the only loop that can handle C<ev_child> watchers,
+and to do this, it always registers a handler for C<SIGCHLD>. If this is
+a problem for your application you can either create a dynamic loop with
+C<ev_loop_new> which doesn't do that, or you can simply overwrite the
+C<SIGCHLD> signal handler I<after> calling C<ev_default_init>.
+
+Example: This is the most typical usage.
+
+   if (!ev_default_loop (0))
+     fatal ("could not initialise libev, bad $LIBEV_FLAGS in environment?");
+
+Example: Restrict libev to the select and poll backends, and do not allow
+environment settings to be taken into account:
+
+   ev_default_loop (EVBACKEND_POLL | EVBACKEND_SELECT | EVFLAG_NOENV);
+
+=item struct ev_loop *ev_loop_new (unsigned int flags)
+
+This will create and initialise a new event loop object. If the loop
+could not be initialised, returns false.
+
+This function is thread-safe, and one common way to use libev with
+threads is indeed to create one loop per thread, and using the default
+loop in the "main" or "initial" thread.
+
+The flags argument can be used to specify special behaviour or specific
+backends to use, and is usually specified as C<0> (or C<EVFLAG_AUTO>).
+
+The following flags are supported:
+
+=over 4
+
+=item C<EVFLAG_AUTO>
+
+The default flags value. Use this if you have no clue (it's the right
+thing, believe me).
+
+=item C<EVFLAG_NOENV>
+
+If this flag bit is or'ed into the flag value (or the program runs setuid
+or setgid) then libev will I<not> look at the environment variable
+C<LIBEV_FLAGS>. Otherwise (the default), this environment variable will
+override the flags completely if it is found in the environment. This is
+useful to try out specific backends to test their performance, to work
+around bugs, or to make libev threadsafe (accessing environment variables
+cannot be done in a threadsafe way, but usually it works if no other
+thread modifies them).
+
+=item C<EVFLAG_FORKCHECK>
+
+Instead of calling C<ev_loop_fork> manually after a fork, you can also
+make libev check for a fork in each iteration by enabling this flag.
+
+This works by calling C<getpid ()> on every iteration of the loop,
+and thus this might slow down your event loop if you do a lot of loop
+iterations and little real work, but is usually not noticeable (on my
+GNU/Linux system for example, C<getpid> is actually a simple 5-insn sequence
+without a system call and thus I<very> fast, but my GNU/Linux system also has
+C<pthread_atfork> which is even faster).
+
+The big advantage of this flag is that you can forget about fork (and
+forget about forgetting to tell libev about forking, although you still
+have to ignore C<SIGPIPE>) when you use this flag.
+
+This flag setting cannot be overridden or specified in the C<LIBEV_FLAGS>
+environment variable.
+
+=item C<EVFLAG_NOINOTIFY>
+
+When this flag is specified, then libev will not attempt to use the
+I<inotify> API for its C<ev_stat> watchers. Apart from debugging and
+testing, this flag can be useful to conserve inotify file descriptors, as
+otherwise each loop using C<ev_stat> watchers consumes one inotify handle.
+
+=item C<EVFLAG_SIGNALFD>
+
+When this flag is specified, then libev will attempt to use the
+I<signalfd> API for its C<ev_signal> (and C<ev_child>) watchers. This API
+delivers signals synchronously, which makes it both faster and might make
+it possible to get the queued signal data. It can also simplify signal
+handling with threads, as long as you properly block signals in your
+threads that are not interested in handling them.
+
+Signalfd will not be used by default as this changes your signal mask, and
+there are a lot of shoddy libraries and programs (glib's threadpool for
+example) that can't properly initialise their signal masks.
+
+=item C<EVFLAG_NOSIGMASK>
+
+When this flag is specified, then libev will avoid to modify the signal
+mask. Specifically, this means you have to make sure signals are unblocked
+when you want to receive them.
+
+This behaviour is useful when you want to do your own signal handling, or
+want to handle signals only in specific threads and want to avoid libev
+unblocking the signals.
+
+It's also required by POSIX in a threaded program, as libev calls
+C<sigprocmask>, whose behaviour is officially unspecified.
+
+This flag's behaviour will become the default in future versions of libev.
+
+=item C<EVBACKEND_SELECT>  (value 1, portable select backend)
+
+This is your standard select(2) backend. Not I<completely> standard, as
+libev tries to roll its own fd_set with no limits on the number of fds,
+but if that fails, expect a fairly low limit on the number of fds when
+using this backend. It doesn't scale too well (O(highest_fd)), but its
+usually the fastest backend for a low number of (low-numbered :) fds.
+
+To get good performance out of this backend you need a high amount of
+parallelism (most of the file descriptors should be busy). If you are
+writing a server, you should C<accept ()> in a loop to accept as many
+connections as possible during one iteration. You might also want to have
+a look at C<ev_set_io_collect_interval ()> to increase the amount of
+readiness notifications you get per iteration.
+
+This backend maps C<EV_READ> to the C<readfds> set and C<EV_WRITE> to the
+C<writefds> set (and to work around Microsoft Windows bugs, also onto the
+C<exceptfds> set on that platform).
+
+=item C<EVBACKEND_POLL>    (value 2, poll backend, available everywhere except on windows)
+
+And this is your standard poll(2) backend. It's more complicated
+than select, but handles sparse fds better and has no artificial
+limit on the number of fds you can use (except it will slow down
+considerably with a lot of inactive fds). It scales similarly to select,
+i.e. O(total_fds). See the entry for C<EVBACKEND_SELECT>, above, for
+performance tips.
+
+This backend maps C<EV_READ> to C<POLLIN | POLLERR | POLLHUP>, and
+C<EV_WRITE> to C<POLLOUT | POLLERR | POLLHUP>.
+
+=item C<EVBACKEND_EPOLL>   (value 4, Linux)
+
+Use the linux-specific epoll(7) interface (for both pre- and post-2.6.9
+kernels).
+
+For few fds, this backend is a bit little slower than poll and select, but
+it scales phenomenally better. While poll and select usually scale like
+O(total_fds) where total_fds is the total number of fds (or the highest
+fd), epoll scales either O(1) or O(active_fds).
+
+The epoll mechanism deserves honorable mention as the most misdesigned
+of the more advanced event mechanisms: mere annoyances include silently
+dropping file descriptors, requiring a system call per change per file
+descriptor (and unnecessary guessing of parameters), problems with dup,
+returning before the timeout value, resulting in additional iterations
+(and only giving 5ms accuracy while select on the same platform gives
+0.1ms) and so on. The biggest issue is fork races, however - if a program
+forks then I<both> parent and child process have to recreate the epoll
+set, which can take considerable time (one syscall per file descriptor)
+and is of course hard to detect.
+
+Epoll is also notoriously buggy - embedding epoll fds I<should> work,
+but of course I<doesn't>, and epoll just loves to report events for
+totally I<different> file descriptors (even already closed ones, so
+one cannot even remove them from the set) than registered in the set
+(especially on SMP systems). Libev tries to counter these spurious
+notifications by employing an additional generation counter and comparing
+that against the events to filter out spurious ones, recreating the set
+when required. Epoll also erroneously rounds down timeouts, but gives you
+no way to know when and by how much, so sometimes you have to busy-wait
+because epoll returns immediately despite a nonzero timeout. And last
+not least, it also refuses to work with some file descriptors which work
+perfectly fine with C<select> (files, many character devices...).
+
+Epoll is truly the train wreck among event poll mechanisms, a frankenpoll,
+cobbled together in a hurry, no thought to design or interaction with
+others. Oh, the pain, will it ever stop...
+
+While stopping, setting and starting an I/O watcher in the same iteration
+will result in some caching, there is still a system call per such
+incident (because the same I<file descriptor> could point to a different
+I<file description> now), so its best to avoid that. Also, C<dup ()>'ed
+file descriptors might not work very well if you register events for both
+file descriptors.
+
+Best performance from this backend is achieved by not unregistering all
+watchers for a file descriptor until it has been closed, if possible,
+i.e. keep at least one watcher active per fd at all times. Stopping and
+starting a watcher (without re-setting it) also usually doesn't cause
+extra overhead. A fork can both result in spurious notifications as well
+as in libev having to destroy and recreate the epoll object, which can
+take considerable time and thus should be avoided.
+
+All this means that, in practice, C<EVBACKEND_SELECT> can be as fast or
+faster than epoll for maybe up to a hundred file descriptors, depending on
+the usage. So sad.
+
+While nominally embeddable in other event loops, this feature is broken in
+all kernel versions tested so far.
+
+This backend maps C<EV_READ> and C<EV_WRITE> in the same way as
+C<EVBACKEND_POLL>.
+
+=item C<EVBACKEND_KQUEUE>  (value 8, most BSD clones)
+
+Kqueue deserves special mention, as at the time of this writing, it
+was broken on all BSDs except NetBSD (usually it doesn't work reliably
+with anything but sockets and pipes, except on Darwin, where of course
+it's completely useless). Unlike epoll, however, whose brokenness
+is by design, these kqueue bugs can (and eventually will) be fixed
+without API changes to existing programs. For this reason it's not being
+"auto-detected" unless you explicitly specify it in the flags (i.e. using
+C<EVBACKEND_KQUEUE>) or libev was compiled on a known-to-be-good (-enough)
+system like NetBSD.
+
+You still can embed kqueue into a normal poll or select backend and use it
+only for sockets (after having made sure that sockets work with kqueue on
+the target platform). See C<ev_embed> watchers for more info.
+
+It scales in the same way as the epoll backend, but the interface to the
+kernel is more efficient (which says nothing about its actual speed, of
+course). While stopping, setting and starting an I/O watcher does never
+cause an extra system call as with C<EVBACKEND_EPOLL>, it still adds up to
+two event changes per incident. Support for C<fork ()> is very bad (you
+might have to leak fd's on fork, but it's more sane than epoll) and it
+drops fds silently in similarly hard-to-detect cases.
+
+This backend usually performs well under most conditions.
+
+While nominally embeddable in other event loops, this doesn't work
+everywhere, so you might need to test for this. And since it is broken
+almost everywhere, you should only use it when you have a lot of sockets
+(for which it usually works), by embedding it into another event loop
+(e.g. C<EVBACKEND_SELECT> or C<EVBACKEND_POLL> (but C<poll> is of course
+also broken on OS X)) and, did I mention it, using it only for sockets.
+
+This backend maps C<EV_READ> into an C<EVFILT_READ> kevent with
+C<NOTE_EOF>, and C<EV_WRITE> into an C<EVFILT_WRITE> kevent with
+C<NOTE_EOF>.
+
+=item C<EVBACKEND_DEVPOLL> (value 16, Solaris 8)
+
+This is not implemented yet (and might never be, unless you send me an
+implementation). According to reports, C</dev/poll> only supports sockets
+and is not embeddable, which would limit the usefulness of this backend
+immensely.
+
+=item C<EVBACKEND_PORT>    (value 32, Solaris 10)
+
+This uses the Solaris 10 event port mechanism. As with everything on Solaris,
+it's really slow, but it still scales very well (O(active_fds)).
+
+While this backend scales well, it requires one system call per active
+file descriptor per loop iteration. For small and medium numbers of file
+descriptors a "slow" C<EVBACKEND_SELECT> or C<EVBACKEND_POLL> backend
+might perform better.
+
+On the positive side, this backend actually performed fully to
+specification in all tests and is fully embeddable, which is a rare feat
+among the OS-specific backends (I vastly prefer correctness over speed
+hacks).
+
+On the negative side, the interface is I<bizarre> - so bizarre that
+even sun itself gets it wrong in their code examples: The event polling
+function sometimes returns events to the caller even though an error
+occurred, but with no indication whether it has done so or not (yes, it's
+even documented that way) - deadly for edge-triggered interfaces where you
+absolutely have to know whether an event occurred or not because you have
+to re-arm the watcher.
+
+Fortunately libev seems to be able to work around these idiocies.
+
+This backend maps C<EV_READ> and C<EV_WRITE> in the same way as
+C<EVBACKEND_POLL>.
+
+=item C<EVBACKEND_ALL>
+
+Try all backends (even potentially broken ones that wouldn't be tried
+with C<EVFLAG_AUTO>). Since this is a mask, you can do stuff such as
+C<EVBACKEND_ALL & ~EVBACKEND_KQUEUE>.
+
+It is definitely not recommended to use this flag, use whatever
+C<ev_recommended_backends ()> returns, or simply do not specify a backend
+at all.
+
+=item C<EVBACKEND_MASK>
+
+Not a backend at all, but a mask to select all backend bits from a
+C<flags> value, in case you want to mask out any backends from a flags
+value (e.g. when modifying the C<LIBEV_FLAGS> environment variable).
+
+=back
+
+If one or more of the backend flags are or'ed into the flags value,
+then only these backends will be tried (in the reverse order as listed
+here). If none are specified, all backends in C<ev_recommended_backends
+()> will be tried.
+
+Example: Try to create a event loop that uses epoll and nothing else.
+
+   struct ev_loop *epoller = ev_loop_new (EVBACKEND_EPOLL | EVFLAG_NOENV);
+   if (!epoller)
+     fatal ("no epoll found here, maybe it hides under your chair");
+
+Example: Use whatever libev has to offer, but make sure that kqueue is
+used if available.
+
+   struct ev_loop *loop = ev_loop_new (ev_recommended_backends () | EVBACKEND_KQUEUE);
+
+=item ev_loop_destroy (loop)
+
+Destroys an event loop object (frees all memory and kernel state
+etc.). None of the active event watchers will be stopped in the normal
+sense, so e.g. C<ev_is_active> might still return true. It is your
+responsibility to either stop all watchers cleanly yourself I<before>
+calling this function, or cope with the fact afterwards (which is usually
+the easiest thing, you can just ignore the watchers and/or C<free ()> them
+for example).
+
+Note that certain global state, such as signal state (and installed signal
+handlers), will not be freed by this function, and related watchers (such
+as signal and child watchers) would need to be stopped manually.
+
+This function is normally used on loop objects allocated by
+C<ev_loop_new>, but it can also be used on the default loop returned by
+C<ev_default_loop>, in which case it is not thread-safe.
+
+Note that it is not advisable to call this function on the default loop
+except in the rare occasion where you really need to free its resources.
+If you need dynamically allocated loops it is better to use C<ev_loop_new>
+and C<ev_loop_destroy>.
+
+=item ev_loop_fork (loop)
+
+This function sets a flag that causes subsequent C<ev_run> iterations
+to reinitialise the kernel state for backends that have one. Despite
+the name, you can call it anytime you are allowed to start or stop
+watchers (except inside an C<ev_prepare> callback), but it makes most
+sense after forking, in the child process. You I<must> call it (or use
+C<EVFLAG_FORKCHECK>) in the child before resuming or calling C<ev_run>.
+
+In addition, if you want to reuse a loop (via this function or
+C<EVFLAG_FORKCHECK>), you I<also> have to ignore C<SIGPIPE>.
+
+Again, you I<have> to call it on I<any> loop that you want to re-use after
+a fork, I<even if you do not plan to use the loop in the parent>. This is
+because some kernel interfaces *cough* I<kqueue> *cough* do funny things
+during fork.
+
+On the other hand, you only need to call this function in the child
+process if and only if you want to use the event loop in the child. If
+you just fork+exec or create a new loop in the child, you don't have to
+call it at all (in fact, C<epoll> is so badly broken that it makes a
+difference, but libev will usually detect this case on its own and do a
+costly reset of the backend).
+
+The function itself is quite fast and it's usually not a problem to call
+it just in case after a fork.
+
+Example: Automate calling C<ev_loop_fork> on the default loop when
+using pthreads.
+
+   static void
+   post_fork_child (void)
+   {
+     ev_loop_fork (EV_DEFAULT);
+   }
+
+   ...
+   pthread_atfork (0, 0, post_fork_child);
+
+=item int ev_is_default_loop (loop)
+
+Returns true when the given loop is, in fact, the default loop, and false
+otherwise.
+
+=item unsigned int ev_iteration (loop)
+
+Returns the current iteration count for the event loop, which is identical
+to the number of times libev did poll for new events. It starts at C<0>
+and happily wraps around with enough iterations.
+
+This value can sometimes be useful as a generation counter of sorts (it
+"ticks" the number of loop iterations), as it roughly corresponds with
+C<ev_prepare> and C<ev_check> calls - and is incremented between the
+prepare and check phases.
+
+=item unsigned int ev_depth (loop)
+
+Returns the number of times C<ev_run> was entered minus the number of
+times C<ev_run> was exited normally, in other words, the recursion depth.
+
+Outside C<ev_run>, this number is zero. In a callback, this number is
+C<1>, unless C<ev_run> was invoked recursively (or from another thread),
+in which case it is higher.
+
+Leaving C<ev_run> abnormally (setjmp/longjmp, cancelling the thread,
+throwing an exception etc.), doesn't count as "exit" - consider this
+as a hint to avoid such ungentleman-like behaviour unless it's really
+convenient, in which case it is fully supported.
+
+=item unsigned int ev_backend (loop)
+
+Returns one of the C<EVBACKEND_*> flags indicating the event backend in
+use.
+
+=item ev_tstamp ev_now (loop)
+
+Returns the current "event loop time", which is the time the event loop
+received events and started processing them. This timestamp does not
+change as long as callbacks are being processed, and this is also the base
+time used for relative timers. You can treat it as the timestamp of the
+event occurring (or more correctly, libev finding out about it).
+
+=item ev_now_update (loop)
+
+Establishes the current time by querying the kernel, updating the time
+returned by C<ev_now ()> in the progress. This is a costly operation and
+is usually done automatically within C<ev_run ()>.
+
+This function is rarely useful, but when some event callback runs for a
+very long time without entering the event loop, updating libev's idea of
+the current time is a good idea.
+
+See also L</The special problem of time updates> in the C<ev_timer> section.
+
+=item ev_suspend (loop)
+
+=item ev_resume (loop)
+
+These two functions suspend and resume an event loop, for use when the
+loop is not used for a while and timeouts should not be processed.
+
+A typical use case would be an interactive program such as a game:  When
+the user presses C<^Z> to suspend the game and resumes it an hour later it
+would be best to handle timeouts as if no time had actually passed while
+the program was suspended. This can be achieved by calling C<ev_suspend>
+in your C<SIGTSTP> handler, sending yourself a C<SIGSTOP> and calling
+C<ev_resume> directly afterwards to resume timer processing.
+
+Effectively, all C<ev_timer> watchers will be delayed by the time spend
+between C<ev_suspend> and C<ev_resume>, and all C<ev_periodic> watchers
+will be rescheduled (that is, they will lose any events that would have
+occurred while suspended).
+
+After calling C<ev_suspend> you B<must not> call I<any> function on the
+given loop other than C<ev_resume>, and you B<must not> call C<ev_resume>
+without a previous call to C<ev_suspend>.
+
+Calling C<ev_suspend>/C<ev_resume> has the side effect of updating the
+event loop time (see C<ev_now_update>).
+
+=item bool ev_run (loop, int flags)
+
+Finally, this is it, the event handler. This function usually is called
+after you have initialised all your watchers and you want to start
+handling events. It will ask the operating system for any new events, call
+the watcher callbacks, and then repeat the whole process indefinitely: This
+is why event loops are called I<loops>.
+
+If the flags argument is specified as C<0>, it will keep handling events
+until either no event watchers are active anymore or C<ev_break> was
+called.
+
+The return value is false if there are no more active watchers (which
+usually means "all jobs done" or "deadlock"), and true in all other cases
+(which usually means " you should call C<ev_run> again").
+
+Please note that an explicit C<ev_break> is usually better than
+relying on all watchers to be stopped when deciding when a program has
+finished (especially in interactive programs), but having a program
+that automatically loops as long as it has to and no longer by virtue
+of relying on its watchers stopping correctly, that is truly a thing of
+beauty.
+
+This function is I<mostly> exception-safe - you can break out of a
+C<ev_run> call by calling C<longjmp> in a callback, throwing a C++
+exception and so on. This does not decrement the C<ev_depth> value, nor
+will it clear any outstanding C<EVBREAK_ONE> breaks.
+
+A flags value of C<EVRUN_NOWAIT> will look for new events, will handle
+those events and any already outstanding ones, but will not wait and
+block your process in case there are no events and will return after one
+iteration of the loop. This is sometimes useful to poll and handle new
+events while doing lengthy calculations, to keep the program responsive.
+
+A flags value of C<EVRUN_ONCE> will look for new events (waiting if
+necessary) and will handle those and any already outstanding ones. It
+will block your process until at least one new event arrives (which could
+be an event internal to libev itself, so there is no guarantee that a
+user-registered callback will be called), and will return after one
+iteration of the loop.
+
+This is useful if you are waiting for some external event in conjunction
+with something not expressible using other libev watchers (i.e. "roll your
+own C<ev_run>"). However, a pair of C<ev_prepare>/C<ev_check> watchers is
+usually a better approach for this kind of thing.
+
+Here are the gory details of what C<ev_run> does (this is for your
+understanding, not a guarantee that things will work exactly like this in
+future versions):
+
+   - Increment loop depth.
+   - Reset the ev_break status.
+   - Before the first iteration, call any pending watchers.
+   LOOP:
+   - If EVFLAG_FORKCHECK was used, check for a fork.
+   - If a fork was detected (by any means), queue and call all fork watchers.
+   - Queue and call all prepare watchers.
+   - If ev_break was called, goto FINISH.
+   - If we have been forked, detach and recreate the kernel state
+     as to not disturb the other process.
+   - Update the kernel state with all outstanding changes.
+   - Update the "event loop time" (ev_now ()).
+   - Calculate for how long to sleep or block, if at all
+     (active idle watchers, EVRUN_NOWAIT or not having
+     any active watchers at all will result in not sleeping).
+   - Sleep if the I/O and timer collect interval say so.
+   - Increment loop iteration counter.
+   - Block the process, waiting for any events.
+   - Queue all outstanding I/O (fd) events.
+   - Update the "event loop time" (ev_now ()), and do time jump adjustments.
+   - Queue all expired timers.
+   - Queue all expired periodics.
+   - Queue all idle watchers with priority higher than that of pending events.
+   - Queue all check watchers.
+   - Call all queued watchers in reverse order (i.e. check watchers first).
+     Signals and child watchers are implemented as I/O watchers, and will
+     be handled here by queueing them when their watcher gets executed.
+   - If ev_break has been called, or EVRUN_ONCE or EVRUN_NOWAIT
+     were used, or there are no active watchers, goto FINISH, otherwise
+     continue with step LOOP.
+   FINISH:
+   - Reset the ev_break status iff it was EVBREAK_ONE.
+   - Decrement the loop depth.
+   - Return.
+
+Example: Queue some jobs and then loop until no events are outstanding
+anymore.
+
+   ... queue jobs here, make sure they register event watchers as long
+   ... as they still have work to do (even an idle watcher will do..)
+   ev_run (my_loop, 0);
+   ... jobs done or somebody called break. yeah!
+
+=item ev_break (loop, how)
+
+Can be used to make a call to C<ev_run> return early (but only after it
+has processed all outstanding events). The C<how> argument must be either
+C<EVBREAK_ONE>, which will make the innermost C<ev_run> call return, or
+C<EVBREAK_ALL>, which will make all nested C<ev_run> calls return.
+
+This "break state" will be cleared on the next call to C<ev_run>.
+
+It is safe to call C<ev_break> from outside any C<ev_run> calls, too, in
+which case it will have no effect.
+
+=item ev_ref (loop)
+
+=item ev_unref (loop)
+
+Ref/unref can be used to add or remove a reference count on the event
+loop: Every watcher keeps one reference, and as long as the reference
+count is nonzero, C<ev_run> will not return on its own.
+
+This is useful when you have a watcher that you never intend to
+unregister, but that nevertheless should not keep C<ev_run> from
+returning. In such a case, call C<ev_unref> after starting, and C<ev_ref>
+before stopping it.
+
+As an example, libev itself uses this for its internal signal pipe: It
+is not visible to the libev user and should not keep C<ev_run> from
+exiting if no event watchers registered by it are active. It is also an
+excellent way to do this for generic recurring timers or from within
+third-party libraries. Just remember to I<unref after start> and I<ref
+before stop> (but only if the watcher wasn't active before, or was active
+before, respectively. Note also that libev might stop watchers itself
+(e.g. non-repeating timers) in which case you have to C<ev_ref>
+in the callback).
+
+Example: Create a signal watcher, but keep it from keeping C<ev_run>
+running when nothing else is active.
+
+   ev_signal exitsig;
+   ev_signal_init (&exitsig, sig_cb, SIGINT);
+   ev_signal_start (loop, &exitsig);
+   ev_unref (loop);
+
+Example: For some weird reason, unregister the above signal handler again.
+
+   ev_ref (loop);
+   ev_signal_stop (loop, &exitsig);
+
+=item ev_set_io_collect_interval (loop, ev_tstamp interval)
+
+=item ev_set_timeout_collect_interval (loop, ev_tstamp interval)
+
+These advanced functions influence the time that libev will spend waiting
+for events. Both time intervals are by default C<0>, meaning that libev
+will try to invoke timer/periodic callbacks and I/O callbacks with minimum
+latency.
+
+Setting these to a higher value (the C<interval> I<must> be >= C<0>)
+allows libev to delay invocation of I/O and timer/periodic callbacks
+to increase efficiency of loop iterations (or to increase power-saving
+opportunities).
+
+The idea is that sometimes your program runs just fast enough to handle
+one (or very few) event(s) per loop iteration. While this makes the
+program responsive, it also wastes a lot of CPU time to poll for new
+events, especially with backends like C<select ()> which have a high
+overhead for the actual polling but can deliver many events at once.
+
+By setting a higher I<io collect interval> you allow libev to spend more
+time collecting I/O events, so you can handle more events per iteration,
+at the cost of increasing latency. Timeouts (both C<ev_periodic> and
+C<ev_timer>) will not be affected. Setting this to a non-null value will
+introduce an additional C<ev_sleep ()> call into most loop iterations. The
+sleep time ensures that libev will not poll for I/O events more often then
+once per this interval, on average (as long as the host time resolution is
+good enough).
+
+Likewise, by setting a higher I<timeout collect interval> you allow libev
+to spend more time collecting timeouts, at the expense of increased
+latency/jitter/inexactness (the watcher callback will be called
+later). C<ev_io> watchers will not be affected. Setting this to a non-null
+value will not introduce any overhead in libev.
+
+Many (busy) programs can usually benefit by setting the I/O collect
+interval to a value near C<0.1> or so, which is often enough for
+interactive servers (of course not for games), likewise for timeouts. It
+usually doesn't make much sense to set it to a lower value than C<0.01>,
+as this approaches the timing granularity of most systems. Note that if
+you do transactions with the outside world and you can't increase the
+parallelity, then this setting will limit your transaction rate (if you
+need to poll once per transaction and the I/O collect interval is 0.01,
+then you can't do more than 100 transactions per second).
+
+Setting the I<timeout collect interval> can improve the opportunity for
+saving power, as the program will "bundle" timer callback invocations that
+are "near" in time together, by delaying some, thus reducing the number of
+times the process sleeps and wakes up again. Another useful technique to
+reduce iterations/wake-ups is to use C<ev_periodic> watchers and make sure
+they fire on, say, one-second boundaries only.
+
+Example: we only need 0.1s timeout granularity, and we wish not to poll
+more often than 100 times per second:
+
+   ev_set_timeout_collect_interval (EV_DEFAULT_UC_ 0.1);
+   ev_set_io_collect_interval (EV_DEFAULT_UC_ 0.01);
+
+=item ev_invoke_pending (loop)
+
+This call will simply invoke all pending watchers while resetting their
+pending state. Normally, C<ev_run> does this automatically when required,
+but when overriding the invoke callback this call comes handy. This
+function can be invoked from a watcher - this can be useful for example
+when you want to do some lengthy calculation and want to pass further
+event handling to another thread (you still have to make sure only one
+thread executes within C<ev_invoke_pending> or C<ev_run> of course).
+
+=item int ev_pending_count (loop)
+
+Returns the number of pending watchers - zero indicates that no watchers
+are pending.
+
+=item ev_set_invoke_pending_cb (loop, void (*invoke_pending_cb)(EV_P))
+
+This overrides the invoke pending functionality of the loop: Instead of
+invoking all pending watchers when there are any, C<ev_run> will call
+this callback instead. This is useful, for example, when you want to
+invoke the actual watchers inside another context (another thread etc.).
+
+If you want to reset the callback, use C<ev_invoke_pending> as new
+callback.
+
+=item ev_set_loop_release_cb (loop, void (*release)(EV_P) throw (), void (*acquire)(EV_P) throw ())
+
+Sometimes you want to share the same loop between multiple threads. This
+can be done relatively simply by putting mutex_lock/unlock calls around
+each call to a libev function.
+
+However, C<ev_run> can run an indefinite time, so it is not feasible
+to wait for it to return. One way around this is to wake up the event
+loop via C<ev_break> and C<ev_async_send>, another way is to set these
+I<release> and I<acquire> callbacks on the loop.
+
+When set, then C<release> will be called just before the thread is
+suspended waiting for new events, and C<acquire> is called just
+afterwards.
+
+Ideally, C<release> will just call your mutex_unlock function, and
+C<acquire> will just call the mutex_lock function again.
+
+While event loop modifications are allowed between invocations of
+C<release> and C<acquire> (that's their only purpose after all), no
+modifications done will affect the event loop, i.e. adding watchers will
+have no effect on the set of file descriptors being watched, or the time
+waited. Use an C<ev_async> watcher to wake up C<ev_run> when you want it
+to take note of any changes you made.
+
+In theory, threads executing C<ev_run> will be async-cancel safe between
+invocations of C<release> and C<acquire>.
+
+See also the locking example in the C<THREADS> section later in this
+document.
+
+=item ev_set_userdata (loop, void *data)
+
+=item void *ev_userdata (loop)
+
+Set and retrieve a single C<void *> associated with a loop. When
+C<ev_set_userdata> has never been called, then C<ev_userdata> returns
+C<0>.
+
+These two functions can be used to associate arbitrary data with a loop,
+and are intended solely for the C<invoke_pending_cb>, C<release> and
+C<acquire> callbacks described above, but of course can be (ab-)used for
+any other purpose as well.
+
+=item ev_verify (loop)
+
+This function only does something when C<EV_VERIFY> support has been
+compiled in, which is the default for non-minimal builds. It tries to go
+through all internal structures and checks them for validity. If anything
+is found to be inconsistent, it will print an error message to standard
+error and call C<abort ()>.
+
+This can be used to catch bugs inside libev itself: under normal
+circumstances, this function will never abort as of course libev keeps its
+data structures consistent.
+
+=back
+
+
+=head1 ANATOMY OF A WATCHER
+
+In the following description, uppercase C<TYPE> in names stands for the
+watcher type, e.g. C<ev_TYPE_start> can mean C<ev_timer_start> for timer
+watchers and C<ev_io_start> for I/O watchers.
+
+A watcher is an opaque structure that you allocate and register to record
+your interest in some event. To make a concrete example, imagine you want
+to wait for STDIN to become readable, you would create an C<ev_io> watcher
+for that:
+
+   static void my_cb (struct ev_loop *loop, ev_io *w, int revents)
+   {
+     ev_io_stop (w);
+     ev_break (loop, EVBREAK_ALL);
+   }
+
+   struct ev_loop *loop = ev_default_loop (0);
+
+   ev_io stdin_watcher;
+
+   ev_init (&stdin_watcher, my_cb);
+   ev_io_set (&stdin_watcher, STDIN_FILENO, EV_READ);
+   ev_io_start (loop, &stdin_watcher);
+
+   ev_run (loop, 0);
+
+As you can see, you are responsible for allocating the memory for your
+watcher structures (and it is I<usually> a bad idea to do this on the
+stack).
+
+Each watcher has an associated watcher structure (called C<struct ev_TYPE>
+or simply C<ev_TYPE>, as typedefs are provided for all watcher structs).
+
+Each watcher structure must be initialised by a call to C<ev_init (watcher
+*, callback)>, which expects a callback to be provided. This callback is
+invoked each time the event occurs (or, in the case of I/O watchers, each
+time the event loop detects that the file descriptor given is readable
+and/or writable).
+
+Each watcher type further has its own C<< ev_TYPE_set (watcher *, ...) >>
+macro to configure it, with arguments specific to the watcher type. There
+is also a macro to combine initialisation and setting in one call: C<<
+ev_TYPE_init (watcher *, callback, ...) >>.
+
+To make the watcher actually watch out for events, you have to start it
+with a watcher-specific start function (C<< ev_TYPE_start (loop, watcher
+*) >>), and you can stop watching for events at any time by calling the
+corresponding stop function (C<< ev_TYPE_stop (loop, watcher *) >>.
+
+As long as your watcher is active (has been started but not stopped) you
+must not touch the values stored in it. Most specifically you must never
+reinitialise it or call its C<ev_TYPE_set> macro.
+
+Each and every callback receives the event loop pointer as first, the
+registered watcher structure as second, and a bitset of received events as
+third argument.
+
+The received events usually include a single bit per event type received
+(you can receive multiple events at the same time). The possible bit masks
+are:
+
+=over 4
+
+=item C<EV_READ>
+
+=item C<EV_WRITE>
+
+The file descriptor in the C<ev_io> watcher has become readable and/or
+writable.
+
+=item C<EV_TIMER>
+
+The C<ev_timer> watcher has timed out.
+
+=item C<EV_PERIODIC>
+
+The C<ev_periodic> watcher has timed out.
+
+=item C<EV_SIGNAL>
+
+The signal specified in the C<ev_signal> watcher has been received by a thread.
+
+=item C<EV_CHILD>
+
+The pid specified in the C<ev_child> watcher has received a status change.
+
+=item C<EV_STAT>
+
+The path specified in the C<ev_stat> watcher changed its attributes somehow.
+
+=item C<EV_IDLE>
+
+The C<ev_idle> watcher has determined that you have nothing better to do.
+
+=item C<EV_PREPARE>
+
+=item C<EV_CHECK>
+
+All C<ev_prepare> watchers are invoked just I<before> C<ev_run> starts to
+gather new events, and all C<ev_check> watchers are queued (not invoked)
+just after C<ev_run> has gathered them, but before it queues any callbacks
+for any received events. That means C<ev_prepare> watchers are the last
+watchers invoked before the event loop sleeps or polls for new events, and
+C<ev_check> watchers will be invoked before any other watchers of the same
+or lower priority within an event loop iteration.
+
+Callbacks of both watcher types can start and stop as many watchers as
+they want, and all of them will be taken into account (for example, a
+C<ev_prepare> watcher might start an idle watcher to keep C<ev_run> from
+blocking).
+
+=item C<EV_EMBED>
+
+The embedded event loop specified in the C<ev_embed> watcher needs attention.
+
+=item C<EV_FORK>
+
+The event loop has been resumed in the child process after fork (see
+C<ev_fork>).
+
+=item C<EV_CLEANUP>
+
+The event loop is about to be destroyed (see C<ev_cleanup>).
+
+=item C<EV_ASYNC>
+
+The given async watcher has been asynchronously notified (see C<ev_async>).
+
+=item C<EV_CUSTOM>
+
+Not ever sent (or otherwise used) by libev itself, but can be freely used
+by libev users to signal watchers (e.g. via C<ev_feed_event>).
+
+=item C<EV_ERROR>
+
+An unspecified error has occurred, the watcher has been stopped. This might
+happen because the watcher could not be properly started because libev
+ran out of memory, a file descriptor was found to be closed or any other
+problem. Libev considers these application bugs.
+
+You best act on it by reporting the problem and somehow coping with the
+watcher being stopped. Note that well-written programs should not receive
+an error ever, so when your watcher receives it, this usually indicates a
+bug in your program.
+
+Libev will usually signal a few "dummy" events together with an error, for
+example it might indicate that a fd is readable or writable, and if your
+callbacks is well-written it can just attempt the operation and cope with
+the error from read() or write(). This will not work in multi-threaded
+programs, though, as the fd could already be closed and reused for another
+thing, so beware.
+
+=back
+
+=head2 GENERIC WATCHER FUNCTIONS
+
+=over 4
+
+=item C<ev_init> (ev_TYPE *watcher, callback)
+
+This macro initialises the generic portion of a watcher. The contents
+of the watcher object can be arbitrary (so C<malloc> will do). Only
+the generic parts of the watcher are initialised, you I<need> to call
+the type-specific C<ev_TYPE_set> macro afterwards to initialise the
+type-specific parts. For each type there is also a C<ev_TYPE_init> macro
+which rolls both calls into one.
+
+You can reinitialise a watcher at any time as long as it has been stopped
+(or never started) and there are no pending events outstanding.
+
+The callback is always of type C<void (*)(struct ev_loop *loop, ev_TYPE *watcher,
+int revents)>.
+
+Example: Initialise an C<ev_io> watcher in two steps.
+
+   ev_io w;
+   ev_init (&w, my_cb);
+   ev_io_set (&w, STDIN_FILENO, EV_READ);
+
+=item C<ev_TYPE_set> (ev_TYPE *watcher, [args])
+
+This macro initialises the type-specific parts of a watcher. You need to
+call C<ev_init> at least once before you call this macro, but you can
+call C<ev_TYPE_set> any number of times. You must not, however, call this
+macro on a watcher that is active (it can be pending, however, which is a
+difference to the C<ev_init> macro).
+
+Although some watcher types do not have type-specific arguments
+(e.g. C<ev_prepare>) you still need to call its C<set> macro.
+
+See C<ev_init>, above, for an example.
+
+=item C<ev_TYPE_init> (ev_TYPE *watcher, callback, [args])
+
+This convenience macro rolls both C<ev_init> and C<ev_TYPE_set> macro
+calls into a single call. This is the most convenient method to initialise
+a watcher. The same limitations apply, of course.
+
+Example: Initialise and set an C<ev_io> watcher in one step.
+
+   ev_io_init (&w, my_cb, STDIN_FILENO, EV_READ);
+
+=item C<ev_TYPE_start> (loop, ev_TYPE *watcher)
+
+Starts (activates) the given watcher. Only active watchers will receive
+events. If the watcher is already active nothing will happen.
+
+Example: Start the C<ev_io> watcher that is being abused as example in this
+whole section.
+
+   ev_io_start (EV_DEFAULT_UC, &w);
+
+=item C<ev_TYPE_stop> (loop, ev_TYPE *watcher)
+
+Stops the given watcher if active, and clears the pending status (whether
+the watcher was active or not).
+
+It is possible that stopped watchers are pending - for example,
+non-repeating timers are being stopped when they become pending - but
+calling C<ev_TYPE_stop> ensures that the watcher is neither active nor
+pending. If you want to free or reuse the memory used by the watcher it is
+therefore a good idea to always call its C<ev_TYPE_stop> function.
+
+=item bool ev_is_active (ev_TYPE *watcher)
+
+Returns a true value iff the watcher is active (i.e. it has been started
+and not yet been stopped). As long as a watcher is active you must not modify
+it.
+
+=item bool ev_is_pending (ev_TYPE *watcher)
+
+Returns a true value iff the watcher is pending, (i.e. it has outstanding
+events but its callback has not yet been invoked). As long as a watcher
+is pending (but not active) you must not call an init function on it (but
+C<ev_TYPE_set> is safe), you must not change its priority, and you must
+make sure the watcher is available to libev (e.g. you cannot C<free ()>
+it).
+
+=item callback ev_cb (ev_TYPE *watcher)
+
+Returns the callback currently set on the watcher.
+
+=item ev_set_cb (ev_TYPE *watcher, callback)
+
+Change the callback. You can change the callback at virtually any time
+(modulo threads).
+
+=item ev_set_priority (ev_TYPE *watcher, int priority)
+
+=item int ev_priority (ev_TYPE *watcher)
+
+Set and query the priority of the watcher. The priority is a small
+integer between C<EV_MAXPRI> (default: C<2>) and C<EV_MINPRI>
+(default: C<-2>). Pending watchers with higher priority will be invoked
+before watchers with lower priority, but priority will not keep watchers
+from being executed (except for C<ev_idle> watchers).
+
+If you need to suppress invocation when higher priority events are pending
+you need to look at C<ev_idle> watchers, which provide this functionality.
+
+You I<must not> change the priority of a watcher as long as it is active or
+pending.
+
+Setting a priority outside the range of C<EV_MINPRI> to C<EV_MAXPRI> is
+fine, as long as you do not mind that the priority value you query might
+or might not have been clamped to the valid range.
+
+The default priority used by watchers when no priority has been set is
+always C<0>, which is supposed to not be too high and not be too low :).
+
+See L</WATCHER PRIORITY MODELS>, below, for a more thorough treatment of
+priorities.
+
+=item ev_invoke (loop, ev_TYPE *watcher, int revents)
+
+Invoke the C<watcher> with the given C<loop> and C<revents>. Neither
+C<loop> nor C<revents> need to be valid as long as the watcher callback
+can deal with that fact, as both are simply passed through to the
+callback.
+
+=item int ev_clear_pending (loop, ev_TYPE *watcher)
+
+If the watcher is pending, this function clears its pending status and
+returns its C<revents> bitset (as if its callback was invoked). If the
+watcher isn't pending it does nothing and returns C<0>.
+
+Sometimes it can be useful to "poll" a watcher instead of waiting for its
+callback to be invoked, which can be accomplished with this function.
+
+=item ev_feed_event (loop, ev_TYPE *watcher, int revents)
+
+Feeds the given event set into the event loop, as if the specified event
+had happened for the specified watcher (which must be a pointer to an
+initialised but not necessarily started event watcher). Obviously you must
+not free the watcher as long as it has pending events.
+
+Stopping the watcher, letting libev invoke it, or calling
+C<ev_clear_pending> will clear the pending event, even if the watcher was
+not started in the first place.
+
+See also C<ev_feed_fd_event> and C<ev_feed_signal_event> for related
+functions that do not need a watcher.
+
+=back
+
+See also the L</ASSOCIATING CUSTOM DATA WITH A WATCHER> and L</BUILDING YOUR
+OWN COMPOSITE WATCHERS> idioms.
+
+=head2 WATCHER STATES
+
+There are various watcher states mentioned throughout this manual -
+active, pending and so on. In this section these states and the rules to
+transition between them will be described in more detail - and while these
+rules might look complicated, they usually do "the right thing".
+
+=over 4
+
+=item initialised
+
+Before a watcher can be registered with the event loop it has to be
+initialised. This can be done with a call to C<ev_TYPE_init>, or calls to
+C<ev_init> followed by the watcher-specific C<ev_TYPE_set> function.
+
+In this state it is simply some block of memory that is suitable for
+use in an event loop. It can be moved around, freed, reused etc. at
+will - as long as you either keep the memory contents intact, or call
+C<ev_TYPE_init> again.
+
+=item started/running/active
+
+Once a watcher has been started with a call to C<ev_TYPE_start> it becomes
+property of the event loop, and is actively waiting for events. While in
+this state it cannot be accessed (except in a few documented ways), moved,
+freed or anything else - the only legal thing is to keep a pointer to it,
+and call libev functions on it that are documented to work on active watchers.
+
+=item pending
+
+If a watcher is active and libev determines that an event it is interested
+in has occurred (such as a timer expiring), it will become pending. It will
+stay in this pending state until either it is stopped or its callback is
+about to be invoked, so it is not normally pending inside the watcher
+callback.
+
+The watcher might or might not be active while it is pending (for example,
+an expired non-repeating timer can be pending but no longer active). If it
+is stopped, it can be freely accessed (e.g. by calling C<ev_TYPE_set>),
+but it is still property of the event loop at this time, so cannot be
+moved, freed or reused. And if it is active the rules described in the
+previous item still apply.
+
+It is also possible to feed an event on a watcher that is not active (e.g.
+via C<ev_feed_event>), in which case it becomes pending without being
+active.
+
+=item stopped
+
+A watcher can be stopped implicitly by libev (in which case it might still
+be pending), or explicitly by calling its C<ev_TYPE_stop> function. The
+latter will clear any pending state the watcher might be in, regardless
+of whether it was active or not, so stopping a watcher explicitly before
+freeing it is often a good idea.
+
+While stopped (and not pending) the watcher is essentially in the
+initialised state, that is, it can be reused, moved, modified in any way
+you wish (but when you trash the memory block, you need to C<ev_TYPE_init>
+it again).
+
+=back
+
+=head2 WATCHER PRIORITY MODELS
+
+Many event loops support I<watcher priorities>, which are usually small
+integers that influence the ordering of event callback invocation
+between watchers in some way, all else being equal.
+
+In libev, Watcher priorities can be set using C<ev_set_priority>. See its
+description for the more technical details such as the actual priority
+range.
+
+There are two common ways how these these priorities are being interpreted
+by event loops:
+
+In the more common lock-out model, higher priorities "lock out" invocation
+of lower priority watchers, which means as long as higher priority
+watchers receive events, lower priority watchers are not being invoked.
+
+The less common only-for-ordering model uses priorities solely to order
+callback invocation within a single event loop iteration: Higher priority
+watchers are invoked before lower priority ones, but they all get invoked
+before polling for new events.
+
+Libev uses the second (only-for-ordering) model for all its watchers
+except for idle watchers (which use the lock-out model).
+
+The rationale behind this is that implementing the lock-out model for
+watchers is not well supported by most kernel interfaces, and most event
+libraries will just poll for the same events again and again as long as
+their callbacks have not been executed, which is very inefficient in the
+common case of one high-priority watcher locking out a mass of lower
+priority ones.
+
+Static (ordering) priorities are most useful when you have two or more
+watchers handling the same resource: a typical usage example is having an
+C<ev_io> watcher to receive data, and an associated C<ev_timer> to handle
+timeouts. Under load, data might be received while the program handles
+other jobs, but since timers normally get invoked first, the timeout
+handler will be executed before checking for data. In that case, giving
+the timer a lower priority than the I/O watcher ensures that I/O will be
+handled first even under adverse conditions (which is usually, but not
+always, what you want).
+
+Since idle watchers use the "lock-out" model, meaning that idle watchers
+will only be executed when no same or higher priority watchers have
+received events, they can be used to implement the "lock-out" model when
+required.
+
+For example, to emulate how many other event libraries handle priorities,
+you can associate an C<ev_idle> watcher to each such watcher, and in
+the normal watcher callback, you just start the idle watcher. The real
+processing is done in the idle watcher callback. This causes libev to
+continuously poll and process kernel event data for the watcher, but when
+the lock-out case is known to be rare (which in turn is rare :), this is
+workable.
+
+Usually, however, the lock-out model implemented that way will perform
+miserably under the type of load it was designed to handle. In that case,
+it might be preferable to stop the real watcher before starting the
+idle watcher, so the kernel will not have to process the event in case
+the actual processing will be delayed for considerable time.
+
+Here is an example of an I/O watcher that should run at a strictly lower
+priority than the default, and which should only process data when no
+other events are pending:
+
+   ev_idle idle; // actual processing watcher
+   ev_io io;     // actual event watcher
+
+   static void
+   io_cb (EV_P_ ev_io *w, int revents)
+   {
+     // stop the I/O watcher, we received the event, but
+     // are not yet ready to handle it.
+     ev_io_stop (EV_A_ w);
+
+     // start the idle watcher to handle the actual event.
+     // it will not be executed as long as other watchers
+     // with the default priority are receiving events.
+     ev_idle_start (EV_A_ &idle);
+   }
+
+   static void
+   idle_cb (EV_P_ ev_idle *w, int revents)
+   {
+     // actual processing
+     read (STDIN_FILENO, ...);
+
+     // have to start the I/O watcher again, as
+     // we have handled the event
+     ev_io_start (EV_P_ &io);
+   }
+
+   // initialisation
+   ev_idle_init (&idle, idle_cb);
+   ev_io_init (&io, io_cb, STDIN_FILENO, EV_READ);
+   ev_io_start (EV_DEFAULT_ &io);
+
+In the "real" world, it might also be beneficial to start a timer, so that
+low-priority connections can not be locked out forever under load. This
+enables your program to keep a lower latency for important connections
+during short periods of high load, while not completely locking out less
+important ones.
+
+
+=head1 WATCHER TYPES
+
+This section describes each watcher in detail, but will not repeat
+information given in the last section. Any initialisation/set macros,
+functions and members specific to the watcher type are explained.
+
+Members are additionally marked with either I<[read-only]>, meaning that,
+while the watcher is active, you can look at the member and expect some
+sensible content, but you must not modify it (you can modify it while the
+watcher is stopped to your hearts content), or I<[read-write]>, which
+means you can expect it to have some sensible content while the watcher
+is active, but you can also modify it. Modifying it may not do something
+sensible or take immediate effect (or do anything at all), but libev will
+not crash or malfunction in any way.
+
+
+=head2 C<ev_io> - is this file descriptor readable or writable?
+
+I/O watchers check whether a file descriptor is readable or writable
+in each iteration of the event loop, or, more precisely, when reading
+would not block the process and writing would at least be able to write
+some data. This behaviour is called level-triggering because you keep
+receiving events as long as the condition persists. Remember you can stop
+the watcher if you don't want to act on the event and neither want to
+receive future events.
+
+In general you can register as many read and/or write event watchers per
+fd as you want (as long as you don't confuse yourself). Setting all file
+descriptors to non-blocking mode is also usually a good idea (but not
+required if you know what you are doing).
+
+Another thing you have to watch out for is that it is quite easy to
+receive "spurious" readiness notifications, that is, your callback might
+be called with C<EV_READ> but a subsequent C<read>(2) will actually block
+because there is no data. It is very easy to get into this situation even
+with a relatively standard program structure. Thus it is best to always
+use non-blocking I/O: An extra C<read>(2) returning C<EAGAIN> is far
+preferable to a program hanging until some data arrives.
+
+If you cannot run the fd in non-blocking mode (for example you should
+not play around with an Xlib connection), then you have to separately
+re-test whether a file descriptor is really ready with a known-to-be good
+interface such as poll (fortunately in the case of Xlib, it already does
+this on its own, so its quite safe to use). Some people additionally
+use C<SIGALRM> and an interval timer, just to be sure you won't block
+indefinitely.
+
+But really, best use non-blocking mode.
+
+=head3 The special problem of disappearing file descriptors
+
+Some backends (e.g. kqueue, epoll) need to be told about closing a file
+descriptor (either due to calling C<close> explicitly or any other means,
+such as C<dup2>). The reason is that you register interest in some file
+descriptor, but when it goes away, the operating system will silently drop
+this interest. If another file descriptor with the same number then is
+registered with libev, there is no efficient way to see that this is, in
+fact, a different file descriptor.
+
+To avoid having to explicitly tell libev about such cases, libev follows
+the following policy:  Each time C<ev_io_set> is being called, libev
+will assume that this is potentially a new file descriptor, otherwise
+it is assumed that the file descriptor stays the same. That means that
+you I<have> to call C<ev_io_set> (or C<ev_io_init>) when you change the
+descriptor even if the file descriptor number itself did not change.
+
+This is how one would do it normally anyway, the important point is that
+the libev application should not optimise around libev but should leave
+optimisations to libev.
+
+=head3 The special problem of dup'ed file descriptors
+
+Some backends (e.g. epoll), cannot register events for file descriptors,
+but only events for the underlying file descriptions. That means when you
+have C<dup ()>'ed file descriptors or weirder constellations, and register
+events for them, only one file descriptor might actually receive events.
+
+There is no workaround possible except not registering events
+for potentially C<dup ()>'ed file descriptors, or to resort to
+C<EVBACKEND_SELECT> or C<EVBACKEND_POLL>.
+
+=head3 The special problem of files
+
+Many people try to use C<select> (or libev) on file descriptors
+representing files, and expect it to become ready when their program
+doesn't block on disk accesses (which can take a long time on their own).
+
+However, this cannot ever work in the "expected" way - you get a readiness
+notification as soon as the kernel knows whether and how much data is
+there, and in the case of open files, that's always the case, so you
+always get a readiness notification instantly, and your read (or possibly
+write) will still block on the disk I/O.
+
+Another way to view it is that in the case of sockets, pipes, character
+devices and so on, there is another party (the sender) that delivers data
+on its own, but in the case of files, there is no such thing: the disk
+will not send data on its own, simply because it doesn't know what you
+wish to read - you would first have to request some data.
+
+Since files are typically not-so-well supported by advanced notification
+mechanism, libev tries hard to emulate POSIX behaviour with respect
+to files, even though you should not use it. The reason for this is
+convenience: sometimes you want to watch STDIN or STDOUT, which is
+usually a tty, often a pipe, but also sometimes files or special devices
+(for example, C<epoll> on Linux works with F</dev/random> but not with
+F</dev/urandom>), and even though the file might better be served with
+asynchronous I/O instead of with non-blocking I/O, it is still useful when
+it "just works" instead of freezing.
+
+So avoid file descriptors pointing to files when you know it (e.g. use
+libeio), but use them when it is convenient, e.g. for STDIN/STDOUT, or
+when you rarely read from a file instead of from a socket, and want to
+reuse the same code path.
+
+=head3 The special problem of fork
+
+Some backends (epoll, kqueue) do not support C<fork ()> at all or exhibit
+useless behaviour. Libev fully supports fork, but needs to be told about
+it in the child if you want to continue to use it in the child.
+
+To support fork in your child processes, you have to call C<ev_loop_fork
+()> after a fork in the child, enable C<EVFLAG_FORKCHECK>, or resort to
+C<EVBACKEND_SELECT> or C<EVBACKEND_POLL>.
+
+=head3 The special problem of SIGPIPE
+
+While not really specific to libev, it is easy to forget about C<SIGPIPE>:
+when writing to a pipe whose other end has been closed, your program gets
+sent a SIGPIPE, which, by default, aborts your program. For most programs
+this is sensible behaviour, for daemons, this is usually undesirable.
+
+So when you encounter spurious, unexplained daemon exits, make sure you
+ignore SIGPIPE (and maybe make sure you log the exit status of your daemon
+somewhere, as that would have given you a big clue).
+
+=head3 The special problem of accept()ing when you can't
+
+Many implementations of the POSIX C<accept> function (for example,
+found in post-2004 Linux) have the peculiar behaviour of not removing a
+connection from the pending queue in all error cases.
+
+For example, larger servers often run out of file descriptors (because
+of resource limits), causing C<accept> to fail with C<ENFILE> but not
+rejecting the connection, leading to libev signalling readiness on
+the next iteration again (the connection still exists after all), and
+typically causing the program to loop at 100% CPU usage.
+
+Unfortunately, the set of errors that cause this issue differs between
+operating systems, there is usually little the app can do to remedy the
+situation, and no known thread-safe method of removing the connection to
+cope with overload is known (to me).
+
+One of the easiest ways to handle this situation is to just ignore it
+- when the program encounters an overload, it will just loop until the
+situation is over. While this is a form of busy waiting, no OS offers an
+event-based way to handle this situation, so it's the best one can do.
+
+A better way to handle the situation is to log any errors other than
+C<EAGAIN> and C<EWOULDBLOCK>, making sure not to flood the log with such
+messages, and continue as usual, which at least gives the user an idea of
+what could be wrong ("raise the ulimit!"). For extra points one could stop
+the C<ev_io> watcher on the listening fd "for a while", which reduces CPU
+usage.
+
+If your program is single-threaded, then you could also keep a dummy file
+descriptor for overload situations (e.g. by opening F</dev/null>), and
+when you run into C<ENFILE> or C<EMFILE>, close it, run C<accept>,
+close that fd, and create a new dummy fd. This will gracefully refuse
+clients under typical overload conditions.
+
+The last way to handle it is to simply log the error and C<exit>, as
+is often done with C<malloc> failures, but this results in an easy
+opportunity for a DoS attack.
+
+=head3 Watcher-Specific Functions
+
+=over 4
+
+=item ev_io_init (ev_io *, callback, int fd, int events)
+
+=item ev_io_set (ev_io *, int fd, int events)
+
+Configures an C<ev_io> watcher. The C<fd> is the file descriptor to
+receive events for and C<events> is either C<EV_READ>, C<EV_WRITE> or
+C<EV_READ | EV_WRITE>, to express the desire to receive the given events.
+
+=item int fd [read-only]
+
+The file descriptor being watched.
+
+=item int events [read-only]
+
+The events being watched.
+
+=back
+
+=head3 Examples
+
+Example: Call C<stdin_readable_cb> when STDIN_FILENO has become, well
+readable, but only once. Since it is likely line-buffered, you could
+attempt to read a whole line in the callback.
+
+   static void
+   stdin_readable_cb (struct ev_loop *loop, ev_io *w, int revents)
+   {
+      ev_io_stop (loop, w);
+     .. read from stdin here (or from w->fd) and handle any I/O errors
+   }
+
+   ...
+   struct ev_loop *loop = ev_default_init (0);
+   ev_io stdin_readable;
+   ev_io_init (&stdin_readable, stdin_readable_cb, STDIN_FILENO, EV_READ);
+   ev_io_start (loop, &stdin_readable);
+   ev_run (loop, 0);
+
+
+=head2 C<ev_timer> - relative and optionally repeating timeouts
+
+Timer watchers are simple relative timers that generate an event after a
+given time, and optionally repeating in regular intervals after that.
+
+The timers are based on real time, that is, if you register an event that
+times out after an hour and you reset your system clock to January last
+year, it will still time out after (roughly) one hour. "Roughly" because
+detecting time jumps is hard, and some inaccuracies are unavoidable (the
+monotonic clock option helps a lot here).
+
+The callback is guaranteed to be invoked only I<after> its timeout has
+passed (not I<at>, so on systems with very low-resolution clocks this
+might introduce a small delay, see "the special problem of being too
+early", below). If multiple timers become ready during the same loop
+iteration then the ones with earlier time-out values are invoked before
+ones of the same priority with later time-out values (but this is no
+longer true when a callback calls C<ev_run> recursively).
+
+=head3 Be smart about timeouts
+
+Many real-world problems involve some kind of timeout, usually for error
+recovery. A typical example is an HTTP request - if the other side hangs,
+you want to raise some error after a while.
+
+What follows are some ways to handle this problem, from obvious and
+inefficient to smart and efficient.
+
+In the following, a 60 second activity timeout is assumed - a timeout that
+gets reset to 60 seconds each time there is activity (e.g. each time some
+data or other life sign was received).
+
+=over 4
+
+=item 1. Use a timer and stop, reinitialise and start it on activity.
+
+This is the most obvious, but not the most simple way: In the beginning,
+start the watcher:
+
+   ev_timer_init (timer, callback, 60., 0.);
+   ev_timer_start (loop, timer);
+
+Then, each time there is some activity, C<ev_timer_stop> it, initialise it
+and start it again:
+
+   ev_timer_stop (loop, timer);
+   ev_timer_set (timer, 60., 0.);
+   ev_timer_start (loop, timer);
+
+This is relatively simple to implement, but means that each time there is
+some activity, libev will first have to remove the timer from its internal
+data structure and then add it again. Libev tries to be fast, but it's
+still not a constant-time operation.
+
+=item 2. Use a timer and re-start it with C<ev_timer_again> inactivity.
+
+This is the easiest way, and involves using C<ev_timer_again> instead of
+C<ev_timer_start>.
+
+To implement this, configure an C<ev_timer> with a C<repeat> value
+of C<60> and then call C<ev_timer_again> at start and each time you
+successfully read or write some data. If you go into an idle state where
+you do not expect data to travel on the socket, you can C<ev_timer_stop>
+the timer, and C<ev_timer_again> will automatically restart it if need be.
+
+That means you can ignore both the C<ev_timer_start> function and the
+C<after> argument to C<ev_timer_set>, and only ever use the C<repeat>
+member and C<ev_timer_again>.
+
+At start:
+
+   ev_init (timer, callback);
+   timer->repeat = 60.;
+   ev_timer_again (loop, timer);
+
+Each time there is some activity:
+
+   ev_timer_again (loop, timer);
+
+It is even possible to change the time-out on the fly, regardless of
+whether the watcher is active or not:
+
+   timer->repeat = 30.;
+   ev_timer_again (loop, timer);
+
+This is slightly more efficient then stopping/starting the timer each time
+you want to modify its timeout value, as libev does not have to completely
+remove and re-insert the timer from/into its internal data structure.
+
+It is, however, even simpler than the "obvious" way to do it.
+
+=item 3. Let the timer time out, but then re-arm it as required.
+
+This method is more tricky, but usually most efficient: Most timeouts are
+relatively long compared to the intervals between other activity - in
+our example, within 60 seconds, there are usually many I/O events with
+associated activity resets.
+
+In this case, it would be more efficient to leave the C<ev_timer> alone,
+but remember the time of last activity, and check for a real timeout only
+within the callback:
+
+   ev_tstamp timeout = 60.;
+   ev_tstamp last_activity; // time of last activity
+   ev_timer timer;
+
+   static void
+   callback (EV_P_ ev_timer *w, int revents)
+   {
+     // calculate when the timeout would happen
+     ev_tstamp after = last_activity - ev_now (EV_A) + timeout;
+
+     // if negative, it means we the timeout already occurred
+     if (after < 0.)
+       {
+         // timeout occurred, take action
+       }
+     else
+       {
+         // callback was invoked, but there was some recent 
+         // activity. simply restart the timer to time out
+         // after "after" seconds, which is the earliest time
+         // the timeout can occur.
+         ev_timer_set (w, after, 0.);
+         ev_timer_start (EV_A_ w);
+       }
+   }
+
+To summarise the callback: first calculate in how many seconds the
+timeout will occur (by calculating the absolute time when it would occur,
+C<last_activity + timeout>, and subtracting the current time, C<ev_now
+(EV_A)> from that).
+
+If this value is negative, then we are already past the timeout, i.e. we
+timed out, and need to do whatever is needed in this case.
+
+Otherwise, we now the earliest time at which the timeout would trigger,
+and simply start the timer with this timeout value.
+
+In other words, each time the callback is invoked it will check whether
+the timeout occurred. If not, it will simply reschedule itself to check
+again at the earliest time it could time out. Rinse. Repeat.
+
+This scheme causes more callback invocations (about one every 60 seconds
+minus half the average time between activity), but virtually no calls to
+libev to change the timeout.
+
+To start the machinery, simply initialise the watcher and set
+C<last_activity> to the current time (meaning there was some activity just
+now), then call the callback, which will "do the right thing" and start
+the timer:
+
+   last_activity = ev_now (EV_A);
+   ev_init (&timer, callback);
+   callback (EV_A_ &timer, 0);
+
+When there is some activity, simply store the current time in
+C<last_activity>, no libev calls at all:
+
+   if (activity detected)
+     last_activity = ev_now (EV_A);
+
+When your timeout value changes, then the timeout can be changed by simply
+providing a new value, stopping the timer and calling the callback, which
+will again do the right thing (for example, time out immediately :).
+
+   timeout = new_value;
+   ev_timer_stop (EV_A_ &timer);
+   callback (EV_A_ &timer, 0);
+
+This technique is slightly more complex, but in most cases where the
+time-out is unlikely to be triggered, much more efficient.
+
+=item 4. Wee, just use a double-linked list for your timeouts.
+
+If there is not one request, but many thousands (millions...), all
+employing some kind of timeout with the same timeout value, then one can
+do even better:
+
+When starting the timeout, calculate the timeout value and put the timeout
+at the I<end> of the list.
+
+Then use an C<ev_timer> to fire when the timeout at the I<beginning> of
+the list is expected to fire (for example, using the technique #3).
+
+When there is some activity, remove the timer from the list, recalculate
+the timeout, append it to the end of the list again, and make sure to
+update the C<ev_timer> if it was taken from the beginning of the list.
+
+This way, one can manage an unlimited number of timeouts in O(1) time for
+starting, stopping and updating the timers, at the expense of a major
+complication, and having to use a constant timeout. The constant timeout
+ensures that the list stays sorted.
+
+=back
+
+So which method the best?
+
+Method #2 is a simple no-brain-required solution that is adequate in most
+situations. Method #3 requires a bit more thinking, but handles many cases
+better, and isn't very complicated either. In most case, choosing either
+one is fine, with #3 being better in typical situations.
+
+Method #1 is almost always a bad idea, and buys you nothing. Method #4 is
+rather complicated, but extremely efficient, something that really pays
+off after the first million or so of active timers, i.e. it's usually
+overkill :)
+
+=head3 The special problem of being too early
+
+If you ask a timer to call your callback after three seconds, then
+you expect it to be invoked after three seconds - but of course, this
+cannot be guaranteed to infinite precision. Less obviously, it cannot be
+guaranteed to any precision by libev - imagine somebody suspending the
+process with a STOP signal for a few hours for example.
+
+So, libev tries to invoke your callback as soon as possible I<after> the
+delay has occurred, but cannot guarantee this.
+
+A less obvious failure mode is calling your callback too early: many event
+loops compare timestamps with a "elapsed delay >= requested delay", but
+this can cause your callback to be invoked much earlier than you would
+expect.
+
+To see why, imagine a system with a clock that only offers full second
+resolution (think windows if you can't come up with a broken enough OS
+yourself). If you schedule a one-second timer at the time 500.9, then the
+event loop will schedule your timeout to elapse at a system time of 500
+(500.9 truncated to the resolution) + 1, or 501.
+
+If an event library looks at the timeout 0.1s later, it will see "501 >=
+501" and invoke the callback 0.1s after it was started, even though a
+one-second delay was requested - this is being "too early", despite best
+intentions.
+
+This is the reason why libev will never invoke the callback if the elapsed
+delay equals the requested delay, but only when the elapsed delay is
+larger than the requested delay. In the example above, libev would only invoke
+the callback at system time 502, or 1.1s after the timer was started.
+
+So, while libev cannot guarantee that your callback will be invoked
+exactly when requested, it I<can> and I<does> guarantee that the requested
+delay has actually elapsed, or in other words, it always errs on the "too
+late" side of things.
+
+=head3 The special problem of time updates
+
+Establishing the current time is a costly operation (it usually takes
+at least one system call): EV therefore updates its idea of the current
+time only before and after C<ev_run> collects new events, which causes a
+growing difference between C<ev_now ()> and C<ev_time ()> when handling
+lots of events in one iteration.
+
+The relative timeouts are calculated relative to the C<ev_now ()>
+time. This is usually the right thing as this timestamp refers to the time
+of the event triggering whatever timeout you are modifying/starting. If
+you suspect event processing to be delayed and you I<need> to base the
+timeout on the current time, use something like the following to adjust
+for it:
+
+   ev_timer_set (&timer, after + (ev_time () - ev_now ()), 0.);
+
+If the event loop is suspended for a long time, you can also force an
+update of the time returned by C<ev_now ()> by calling C<ev_now_update
+()>, although that will push the event time of all outstanding events
+further into the future.
+
+=head3 The special problem of unsynchronised clocks
+
+Modern systems have a variety of clocks - libev itself uses the normal
+"wall clock" clock and, if available, the monotonic clock (to avoid time
+jumps).
+
+Neither of these clocks is synchronised with each other or any other clock
+on the system, so C<ev_time ()> might return a considerably different time
+than C<gettimeofday ()> or C<time ()>. On a GNU/Linux system, for example,
+a call to C<gettimeofday> might return a second count that is one higher
+than a directly following call to C<time>.
+
+The moral of this is to only compare libev-related timestamps with
+C<ev_time ()> and C<ev_now ()>, at least if you want better precision than
+a second or so.
+
+One more problem arises due to this lack of synchronisation: if libev uses
+the system monotonic clock and you compare timestamps from C<ev_time>
+or C<ev_now> from when you started your timer and when your callback is
+invoked, you will find that sometimes the callback is a bit "early".
+
+This is because C<ev_timer>s work in real time, not wall clock time, so
+libev makes sure your callback is not invoked before the delay happened,
+I<measured according to the real time>, not the system clock.
+
+If your timeouts are based on a physical timescale (e.g. "time out this
+connection after 100 seconds") then this shouldn't bother you as it is
+exactly the right behaviour.
+
+If you want to compare wall clock/system timestamps to your timers, then
+you need to use C<ev_periodic>s, as these are based on the wall clock
+time, where your comparisons will always generate correct results.
+
+=head3 The special problems of suspended animation
+
+When you leave the server world it is quite customary to hit machines that
+can suspend/hibernate - what happens to the clocks during such a suspend?
+
+Some quick tests made with a Linux 2.6.28 indicate that a suspend freezes
+all processes, while the clocks (C<times>, C<CLOCK_MONOTONIC>) continue
+to run until the system is suspended, but they will not advance while the
+system is suspended. That means, on resume, it will be as if the program
+was frozen for a few seconds, but the suspend time will not be counted
+towards C<ev_timer> when a monotonic clock source is used. The real time
+clock advanced as expected, but if it is used as sole clocksource, then a
+long suspend would be detected as a time jump by libev, and timers would
+be adjusted accordingly.
+
+I would not be surprised to see different behaviour in different between
+operating systems, OS versions or even different hardware.
+
+The other form of suspend (job control, or sending a SIGSTOP) will see a
+time jump in the monotonic clocks and the realtime clock. If the program
+is suspended for a very long time, and monotonic clock sources are in use,
+then you can expect C<ev_timer>s to expire as the full suspension time
+will be counted towards the timers. When no monotonic clock source is in
+use, then libev will again assume a timejump and adjust accordingly.
+
+It might be beneficial for this latter case to call C<ev_suspend>
+and C<ev_resume> in code that handles C<SIGTSTP>, to at least get
+deterministic behaviour in this case (you can do nothing against
+C<SIGSTOP>).
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_timer_init (ev_timer *, callback, ev_tstamp after, ev_tstamp repeat)
+
+=item ev_timer_set (ev_timer *, ev_tstamp after, ev_tstamp repeat)
+
+Configure the timer to trigger after C<after> seconds. If C<repeat>
+is C<0.>, then it will automatically be stopped once the timeout is
+reached. If it is positive, then the timer will automatically be
+configured to trigger again C<repeat> seconds later, again, and again,
+until stopped manually.
+
+The timer itself will do a best-effort at avoiding drift, that is, if
+you configure a timer to trigger every 10 seconds, then it will normally
+trigger at exactly 10 second intervals. If, however, your program cannot
+keep up with the timer (because it takes longer than those 10 seconds to
+do stuff) the timer will not fire more than once per event loop iteration.
+
+=item ev_timer_again (loop, ev_timer *)
+
+This will act as if the timer timed out, and restarts it again if it is
+repeating. It basically works like calling C<ev_timer_stop>, updating the
+timeout to the C<repeat> value and calling C<ev_timer_start>.
+
+The exact semantics are as in the following rules, all of which will be
+applied to the watcher:
+
+=over 4
+
+=item If the timer is pending, the pending status is always cleared.
+
+=item If the timer is started but non-repeating, stop it (as if it timed
+out, without invoking it).
+
+=item If the timer is repeating, make the C<repeat> value the new timeout
+and start the timer, if necessary.
+
+=back
+
+This sounds a bit complicated, see L</Be smart about timeouts>, above, for a
+usage example.
+
+=item ev_tstamp ev_timer_remaining (loop, ev_timer *)
+
+Returns the remaining time until a timer fires. If the timer is active,
+then this time is relative to the current event loop time, otherwise it's
+the timeout value currently configured.
+
+That is, after an C<ev_timer_set (w, 5, 7)>, C<ev_timer_remaining> returns
+C<5>. When the timer is started and one second passes, C<ev_timer_remaining>
+will return C<4>. When the timer expires and is restarted, it will return
+roughly C<7> (likely slightly less as callback invocation takes some time,
+too), and so on.
+
+=item ev_tstamp repeat [read-write]
+
+The current C<repeat> value. Will be used each time the watcher times out
+or C<ev_timer_again> is called, and determines the next timeout (if any),
+which is also when any modifications are taken into account.
+
+=back
+
+=head3 Examples
+
+Example: Create a timer that fires after 60 seconds.
+
+   static void
+   one_minute_cb (struct ev_loop *loop, ev_timer *w, int revents)
+   {
+     .. one minute over, w is actually stopped right here
+   }
+
+   ev_timer mytimer;
+   ev_timer_init (&mytimer, one_minute_cb, 60., 0.);
+   ev_timer_start (loop, &mytimer);
+
+Example: Create a timeout timer that times out after 10 seconds of
+inactivity.
+
+   static void
+   timeout_cb (struct ev_loop *loop, ev_timer *w, int revents)
+   {
+     .. ten seconds without any activity
+   }
+
+   ev_timer mytimer;
+   ev_timer_init (&mytimer, timeout_cb, 0., 10.); /* note, only repeat used */
+   ev_timer_again (&mytimer); /* start timer */
+   ev_run (loop, 0);
+
+   // and in some piece of code that gets executed on any "activity":
+   // reset the timeout to start ticking again at 10 seconds
+   ev_timer_again (&mytimer);
+
+
+=head2 C<ev_periodic> - to cron or not to cron?
+
+Periodic watchers are also timers of a kind, but they are very versatile
+(and unfortunately a bit complex).
+
+Unlike C<ev_timer>, periodic watchers are not based on real time (or
+relative time, the physical time that passes) but on wall clock time
+(absolute time, the thing you can read on your calender or clock). The
+difference is that wall clock time can run faster or slower than real
+time, and time jumps are not uncommon (e.g. when you adjust your
+wrist-watch).
+
+You can tell a periodic watcher to trigger after some specific point
+in time: for example, if you tell a periodic watcher to trigger "in 10
+seconds" (by specifying e.g. C<ev_now () + 10.>, that is, an absolute time
+not a delay) and then reset your system clock to January of the previous
+year, then it will take a year or more to trigger the event (unlike an
+C<ev_timer>, which would still trigger roughly 10 seconds after starting
+it, as it uses a relative timeout).
+
+C<ev_periodic> watchers can also be used to implement vastly more complex
+timers, such as triggering an event on each "midnight, local time", or
+other complicated rules. This cannot be done with C<ev_timer> watchers, as
+those cannot react to time jumps.
+
+As with timers, the callback is guaranteed to be invoked only when the
+point in time where it is supposed to trigger has passed. If multiple
+timers become ready during the same loop iteration then the ones with
+earlier time-out values are invoked before ones with later time-out values
+(but this is no longer true when a callback calls C<ev_run> recursively).
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_periodic_init (ev_periodic *, callback, ev_tstamp offset, ev_tstamp interval, reschedule_cb)
+
+=item ev_periodic_set (ev_periodic *, ev_tstamp offset, ev_tstamp interval, reschedule_cb)
+
+Lots of arguments, let's sort it out... There are basically three modes of
+operation, and we will explain them from simplest to most complex:
+
+=over 4
+
+=item * absolute timer (offset = absolute time, interval = 0, reschedule_cb = 0)
+
+In this configuration the watcher triggers an event after the wall clock
+time C<offset> has passed. It will not repeat and will not adjust when a
+time jump occurs, that is, if it is to be run at January 1st 2011 then it
+will be stopped and invoked when the system clock reaches or surpasses
+this point in time.
+
+=item * repeating interval timer (offset = offset within interval, interval > 0, reschedule_cb = 0)
+
+In this mode the watcher will always be scheduled to time out at the next
+C<offset + N * interval> time (for some integer N, which can also be
+negative) and then repeat, regardless of any time jumps. The C<offset>
+argument is merely an offset into the C<interval> periods.
+
+This can be used to create timers that do not drift with respect to the
+system clock, for example, here is an C<ev_periodic> that triggers each
+hour, on the hour (with respect to UTC):
+
+   ev_periodic_set (&periodic, 0., 3600., 0);
+
+This doesn't mean there will always be 3600 seconds in between triggers,
+but only that the callback will be called when the system time shows a
+full hour (UTC), or more correctly, when the system time is evenly divisible
+by 3600.
+
+Another way to think about it (for the mathematically inclined) is that
+C<ev_periodic> will try to run the callback in this mode at the next possible
+time where C<time = offset (mod interval)>, regardless of any time jumps.
+
+The C<interval> I<MUST> be positive, and for numerical stability, the
+interval value should be higher than C<1/8192> (which is around 100
+microseconds) and C<offset> should be higher than C<0> and should have
+at most a similar magnitude as the current time (say, within a factor of
+ten). Typical values for offset are, in fact, C<0> or something between
+C<0> and C<interval>, which is also the recommended range.
+
+Note also that there is an upper limit to how often a timer can fire (CPU
+speed for example), so if C<interval> is very small then timing stability
+will of course deteriorate. Libev itself tries to be exact to be about one
+millisecond (if the OS supports it and the machine is fast enough).
+
+=item * manual reschedule mode (offset ignored, interval ignored, reschedule_cb = callback)
+
+In this mode the values for C<interval> and C<offset> are both being
+ignored. Instead, each time the periodic watcher gets scheduled, the
+reschedule callback will be called with the watcher as first, and the
+current time as second argument.
+
+NOTE: I<This callback MUST NOT stop or destroy any periodic watcher, ever,
+or make ANY other event loop modifications whatsoever, unless explicitly
+allowed by documentation here>.
+
+If you need to stop it, return C<now + 1e30> (or so, fudge fudge) and stop
+it afterwards (e.g. by starting an C<ev_prepare> watcher, which is the
+only event loop modification you are allowed to do).
+
+The callback prototype is C<ev_tstamp (*reschedule_cb)(ev_periodic
+*w, ev_tstamp now)>, e.g.:
+
+   static ev_tstamp
+   my_rescheduler (ev_periodic *w, ev_tstamp now)
+   {
+     return now + 60.;
+   }
+
+It must return the next time to trigger, based on the passed time value
+(that is, the lowest time value larger than to the second argument). It
+will usually be called just before the callback will be triggered, but
+might be called at other times, too.
+
+NOTE: I<< This callback must always return a time that is higher than or
+equal to the passed C<now> value >>.
+
+This can be used to create very complex timers, such as a timer that
+triggers on "next midnight, local time". To do this, you would calculate the
+next midnight after C<now> and return the timestamp value for this. How
+you do this is, again, up to you (but it is not trivial, which is the main
+reason I omitted it as an example).
+
+=back
+
+=item ev_periodic_again (loop, ev_periodic *)
+
+Simply stops and restarts the periodic watcher again. This is only useful
+when you changed some parameters or the reschedule callback would return
+a different time than the last time it was called (e.g. in a crond like
+program when the crontabs have changed).
+
+=item ev_tstamp ev_periodic_at (ev_periodic *)
+
+When active, returns the absolute time that the watcher is supposed
+to trigger next. This is not the same as the C<offset> argument to
+C<ev_periodic_set>, but indeed works even in interval and manual
+rescheduling modes.
+
+=item ev_tstamp offset [read-write]
+
+When repeating, this contains the offset value, otherwise this is the
+absolute point in time (the C<offset> value passed to C<ev_periodic_set>,
+although libev might modify this value for better numerical stability).
+
+Can be modified any time, but changes only take effect when the periodic
+timer fires or C<ev_periodic_again> is being called.
+
+=item ev_tstamp interval [read-write]
+
+The current interval value. Can be modified any time, but changes only
+take effect when the periodic timer fires or C<ev_periodic_again> is being
+called.
+
+=item ev_tstamp (*reschedule_cb)(ev_periodic *w, ev_tstamp now) [read-write]
+
+The current reschedule callback, or C<0>, if this functionality is
+switched off. Can be changed any time, but changes only take effect when
+the periodic timer fires or C<ev_periodic_again> is being called.
+
+=back
+
+=head3 Examples
+
+Example: Call a callback every hour, or, more precisely, whenever the
+system time is divisible by 3600. The callback invocation times have
+potentially a lot of jitter, but good long-term stability.
+
+   static void
+   clock_cb (struct ev_loop *loop, ev_periodic *w, int revents)
+   {
+     ... its now a full hour (UTC, or TAI or whatever your clock follows)
+   }
+
+   ev_periodic hourly_tick;
+   ev_periodic_init (&hourly_tick, clock_cb, 0., 3600., 0);
+   ev_periodic_start (loop, &hourly_tick);
+
+Example: The same as above, but use a reschedule callback to do it:
+
+   #include <math.h>
+
+   static ev_tstamp
+   my_scheduler_cb (ev_periodic *w, ev_tstamp now)
+   {
+     return now + (3600. - fmod (now, 3600.));
+   }
+
+   ev_periodic_init (&hourly_tick, clock_cb, 0., 0., my_scheduler_cb);
+
+Example: Call a callback every hour, starting now:
+
+   ev_periodic hourly_tick;
+   ev_periodic_init (&hourly_tick, clock_cb,
+                     fmod (ev_now (loop), 3600.), 3600., 0);
+   ev_periodic_start (loop, &hourly_tick);
+
+
+=head2 C<ev_signal> - signal me when a signal gets signalled!
+
+Signal watchers will trigger an event when the process receives a specific
+signal one or more times. Even though signals are very asynchronous, libev
+will try its best to deliver signals synchronously, i.e. as part of the
+normal event processing, like any other event.
+
+If you want signals to be delivered truly asynchronously, just use
+C<sigaction> as you would do without libev and forget about sharing
+the signal. You can even use C<ev_async> from a signal handler to
+synchronously wake up an event loop.
+
+You can configure as many watchers as you like for the same signal, but
+only within the same loop, i.e. you can watch for C<SIGINT> in your
+default loop and for C<SIGIO> in another loop, but you cannot watch for
+C<SIGINT> in both the default loop and another loop at the same time. At
+the moment, C<SIGCHLD> is permanently tied to the default loop.
+
+Only after the first watcher for a signal is started will libev actually
+register something with the kernel. It thus coexists with your own signal
+handlers as long as you don't register any with libev for the same signal.
+
+If possible and supported, libev will install its handlers with
+C<SA_RESTART> (or equivalent) behaviour enabled, so system calls should
+not be unduly interrupted. If you have a problem with system calls getting
+interrupted by signals you can block all signals in an C<ev_check> watcher
+and unblock them in an C<ev_prepare> watcher.
+
+=head3 The special problem of inheritance over fork/execve/pthread_create
+
+Both the signal mask (C<sigprocmask>) and the signal disposition
+(C<sigaction>) are unspecified after starting a signal watcher (and after
+stopping it again), that is, libev might or might not block the signal,
+and might or might not set or restore the installed signal handler (but
+see C<EVFLAG_NOSIGMASK>).
+
+While this does not matter for the signal disposition (libev never
+sets signals to C<SIG_IGN>, so handlers will be reset to C<SIG_DFL> on
+C<execve>), this matters for the signal mask: many programs do not expect
+certain signals to be blocked.
+
+This means that before calling C<exec> (from the child) you should reset
+the signal mask to whatever "default" you expect (all clear is a good
+choice usually).
+
+The simplest way to ensure that the signal mask is reset in the child is
+to install a fork handler with C<pthread_atfork> that resets it. That will
+catch fork calls done by libraries (such as the libc) as well.
+
+In current versions of libev, the signal will not be blocked indefinitely
+unless you use the C<signalfd> API (C<EV_SIGNALFD>). While this reduces
+the window of opportunity for problems, it will not go away, as libev
+I<has> to modify the signal mask, at least temporarily.
+
+So I can't stress this enough: I<If you do not reset your signal mask when
+you expect it to be empty, you have a race condition in your code>. This
+is not a libev-specific thing, this is true for most event libraries.
+
+=head3 The special problem of threads signal handling
+
+POSIX threads has problematic signal handling semantics, specifically,
+a lot of functionality (sigfd, sigwait etc.) only really works if all
+threads in a process block signals, which is hard to achieve.
+
+When you want to use sigwait (or mix libev signal handling with your own
+for the same signals), you can tackle this problem by globally blocking
+all signals before creating any threads (or creating them with a fully set
+sigprocmask) and also specifying the C<EVFLAG_NOSIGMASK> when creating
+loops. Then designate one thread as "signal receiver thread" which handles
+these signals. You can pass on any signals that libev might be interested
+in by calling C<ev_feed_signal>.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_signal_init (ev_signal *, callback, int signum)
+
+=item ev_signal_set (ev_signal *, int signum)
+
+Configures the watcher to trigger on the given signal number (usually one
+of the C<SIGxxx> constants).
+
+=item int signum [read-only]
+
+The signal the watcher watches out for.
+
+=back
+
+=head3 Examples
+
+Example: Try to exit cleanly on SIGINT.
+
+   static void
+   sigint_cb (struct ev_loop *loop, ev_signal *w, int revents)
+   {
+     ev_break (loop, EVBREAK_ALL);
+   }
+
+   ev_signal signal_watcher;
+   ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
+   ev_signal_start (loop, &signal_watcher);
+
+
+=head2 C<ev_child> - watch out for process status changes
+
+Child watchers trigger when your process receives a SIGCHLD in response to
+some child status changes (most typically when a child of yours dies or
+exits). It is permissible to install a child watcher I<after> the child
+has been forked (which implies it might have already exited), as long
+as the event loop isn't entered (or is continued from a watcher), i.e.,
+forking and then immediately registering a watcher for the child is fine,
+but forking and registering a watcher a few event loop iterations later or
+in the next callback invocation is not.
+
+Only the default event loop is capable of handling signals, and therefore
+you can only register child watchers in the default event loop.
+
+Due to some design glitches inside libev, child watchers will always be
+handled at maximum priority (their priority is set to C<EV_MAXPRI> by
+libev)
+
+=head3 Process Interaction
+
+Libev grabs C<SIGCHLD> as soon as the default event loop is
+initialised. This is necessary to guarantee proper behaviour even if the
+first child watcher is started after the child exits. The occurrence
+of C<SIGCHLD> is recorded asynchronously, but child reaping is done
+synchronously as part of the event loop processing. Libev always reaps all
+children, even ones not watched.
+
+=head3 Overriding the Built-In Processing
+
+Libev offers no special support for overriding the built-in child
+processing, but if your application collides with libev's default child
+handler, you can override it easily by installing your own handler for
+C<SIGCHLD> after initialising the default loop, and making sure the
+default loop never gets destroyed. You are encouraged, however, to use an
+event-based approach to child reaping and thus use libev's support for
+that, so other libev users can use C<ev_child> watchers freely.
+
+=head3 Stopping the Child Watcher
+
+Currently, the child watcher never gets stopped, even when the
+child terminates, so normally one needs to stop the watcher in the
+callback. Future versions of libev might stop the watcher automatically
+when a child exit is detected (calling C<ev_child_stop> twice is not a
+problem).
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_child_init (ev_child *, callback, int pid, int trace)
+
+=item ev_child_set (ev_child *, int pid, int trace)
+
+Configures the watcher to wait for status changes of process C<pid> (or
+I<any> process if C<pid> is specified as C<0>). The callback can look
+at the C<rstatus> member of the C<ev_child> watcher structure to see
+the status word (use the macros from C<sys/wait.h> and see your systems
+C<waitpid> documentation). The C<rpid> member contains the pid of the
+process causing the status change. C<trace> must be either C<0> (only
+activate the watcher when the process terminates) or C<1> (additionally
+activate the watcher when the process is stopped or continued).
+
+=item int pid [read-only]
+
+The process id this watcher watches out for, or C<0>, meaning any process id.
+
+=item int rpid [read-write]
+
+The process id that detected a status change.
+
+=item int rstatus [read-write]
+
+The process exit/trace status caused by C<rpid> (see your systems
+C<waitpid> and C<sys/wait.h> documentation for details).
+
+=back
+
+=head3 Examples
+
+Example: C<fork()> a new process and install a child handler to wait for
+its completion.
+
+   ev_child cw;
+
+   static void
+   child_cb (EV_P_ ev_child *w, int revents)
+   {
+     ev_child_stop (EV_A_ w);
+     printf ("process %d exited with status %x\n", w->rpid, w->rstatus);
+   }
+
+   pid_t pid = fork ();
+
+   if (pid < 0)
+     // error
+   else if (pid == 0)
+     {
+       // the forked child executes here
+       exit (1);
+     }
+   else
+     {
+       ev_child_init (&cw, child_cb, pid, 0);
+       ev_child_start (EV_DEFAULT_ &cw);
+     }
+
+
+=head2 C<ev_stat> - did the file attributes just change?
+
+This watches a file system path for attribute changes. That is, it calls
+C<stat> on that path in regular intervals (or when the OS says it changed)
+and sees if it changed compared to the last time, invoking the callback
+if it did. Starting the watcher C<stat>'s the file, so only changes that
+happen after the watcher has been started will be reported.
+
+The path does not need to exist: changing from "path exists" to "path does
+not exist" is a status change like any other. The condition "path does not
+exist" (or more correctly "path cannot be stat'ed") is signified by the
+C<st_nlink> field being zero (which is otherwise always forced to be at
+least one) and all the other fields of the stat buffer having unspecified
+contents.
+
+The path I<must not> end in a slash or contain special components such as
+C<.> or C<..>. The path I<should> be absolute: If it is relative and
+your working directory changes, then the behaviour is undefined.
+
+Since there is no portable change notification interface available, the
+portable implementation simply calls C<stat(2)> regularly on the path
+to see if it changed somehow. You can specify a recommended polling
+interval for this case. If you specify a polling interval of C<0> (highly
+recommended!) then a I<suitable, unspecified default> value will be used
+(which you can expect to be around five seconds, although this might
+change dynamically). Libev will also impose a minimum interval which is
+currently around C<0.1>, but that's usually overkill.
+
+This watcher type is not meant for massive numbers of stat watchers,
+as even with OS-supported change notifications, this can be
+resource-intensive.
+
+At the time of this writing, the only OS-specific interface implemented
+is the Linux inotify interface (implementing kqueue support is left as an
+exercise for the reader. Note, however, that the author sees no way of
+implementing C<ev_stat> semantics with kqueue, except as a hint).
+
+=head3 ABI Issues (Largefile Support)
+
+Libev by default (unless the user overrides this) uses the default
+compilation environment, which means that on systems with large file
+support disabled by default, you get the 32 bit version of the stat
+structure. When using the library from programs that change the ABI to
+use 64 bit file offsets the programs will fail. In that case you have to
+compile libev with the same flags to get binary compatibility. This is
+obviously the case with any flags that change the ABI, but the problem is
+most noticeably displayed with ev_stat and large file support.
+
+The solution for this is to lobby your distribution maker to make large
+file interfaces available by default (as e.g. FreeBSD does) and not
+optional. Libev cannot simply switch on large file support because it has
+to exchange stat structures with application programs compiled using the
+default compilation environment.
+
+=head3 Inotify and Kqueue
+
+When C<inotify (7)> support has been compiled into libev and present at
+runtime, it will be used to speed up change detection where possible. The
+inotify descriptor will be created lazily when the first C<ev_stat>
+watcher is being started.
+
+Inotify presence does not change the semantics of C<ev_stat> watchers
+except that changes might be detected earlier, and in some cases, to avoid
+making regular C<stat> calls. Even in the presence of inotify support
+there are many cases where libev has to resort to regular C<stat> polling,
+but as long as kernel 2.6.25 or newer is used (2.6.24 and older have too
+many bugs), the path exists (i.e. stat succeeds), and the path resides on
+a local filesystem (libev currently assumes only ext2/3, jfs, reiserfs and
+xfs are fully working) libev usually gets away without polling.
+
+There is no support for kqueue, as apparently it cannot be used to
+implement this functionality, due to the requirement of having a file
+descriptor open on the object at all times, and detecting renames, unlinks
+etc. is difficult.
+
+=head3 C<stat ()> is a synchronous operation
+
+Libev doesn't normally do any kind of I/O itself, and so is not blocking
+the process. The exception are C<ev_stat> watchers - those call C<stat
+()>, which is a synchronous operation.
+
+For local paths, this usually doesn't matter: unless the system is very
+busy or the intervals between stat's are large, a stat call will be fast,
+as the path data is usually in memory already (except when starting the
+watcher).
+
+For networked file systems, calling C<stat ()> can block an indefinite
+time due to network issues, and even under good conditions, a stat call
+often takes multiple milliseconds.
+
+Therefore, it is best to avoid using C<ev_stat> watchers on networked
+paths, although this is fully supported by libev.
+
+=head3 The special problem of stat time resolution
+
+The C<stat ()> system call only supports full-second resolution portably,
+and even on systems where the resolution is higher, most file systems
+still only support whole seconds.
+
+That means that, if the time is the only thing that changes, you can
+easily miss updates: on the first update, C<ev_stat> detects a change and
+calls your callback, which does something. When there is another update
+within the same second, C<ev_stat> will be unable to detect unless the
+stat data does change in other ways (e.g. file size).
+
+The solution to this is to delay acting on a change for slightly more
+than a second (or till slightly after the next full second boundary), using
+a roughly one-second-delay C<ev_timer> (e.g. C<ev_timer_set (w, 0., 1.02);
+ev_timer_again (loop, w)>).
+
+The C<.02> offset is added to work around small timing inconsistencies
+of some operating systems (where the second counter of the current time
+might be be delayed. One such system is the Linux kernel, where a call to
+C<gettimeofday> might return a timestamp with a full second later than
+a subsequent C<time> call - if the equivalent of C<time ()> is used to
+update file times then there will be a small window where the kernel uses
+the previous second to update file times but libev might already execute
+the timer callback).
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_stat_init (ev_stat *, callback, const char *path, ev_tstamp interval)
+
+=item ev_stat_set (ev_stat *, const char *path, ev_tstamp interval)
+
+Configures the watcher to wait for status changes of the given
+C<path>. The C<interval> is a hint on how quickly a change is expected to
+be detected and should normally be specified as C<0> to let libev choose
+a suitable value. The memory pointed to by C<path> must point to the same
+path for as long as the watcher is active.
+
+The callback will receive an C<EV_STAT> event when a change was detected,
+relative to the attributes at the time the watcher was started (or the
+last change was detected).
+
+=item ev_stat_stat (loop, ev_stat *)
+
+Updates the stat buffer immediately with new values. If you change the
+watched path in your callback, you could call this function to avoid
+detecting this change (while introducing a race condition if you are not
+the only one changing the path). Can also be useful simply to find out the
+new values.
+
+=item ev_statdata attr [read-only]
+
+The most-recently detected attributes of the file. Although the type is
+C<ev_statdata>, this is usually the (or one of the) C<struct stat> types
+suitable for your system, but you can only rely on the POSIX-standardised
+members to be present. If the C<st_nlink> member is C<0>, then there was
+some error while C<stat>ing the file.
+
+=item ev_statdata prev [read-only]
+
+The previous attributes of the file. The callback gets invoked whenever
+C<prev> != C<attr>, or, more precisely, one or more of these members
+differ: C<st_dev>, C<st_ino>, C<st_mode>, C<st_nlink>, C<st_uid>,
+C<st_gid>, C<st_rdev>, C<st_size>, C<st_atime>, C<st_mtime>, C<st_ctime>.
+
+=item ev_tstamp interval [read-only]
+
+The specified interval.
+
+=item const char *path [read-only]
+
+The file system path that is being watched.
+
+=back
+
+=head3 Examples
+
+Example: Watch C</etc/passwd> for attribute changes.
+
+   static void
+   passwd_cb (struct ev_loop *loop, ev_stat *w, int revents)
+   {
+     /* /etc/passwd changed in some way */
+     if (w->attr.st_nlink)
+       {
+         printf ("passwd current size  %ld\n", (long)w->attr.st_size);
+         printf ("passwd current atime %ld\n", (long)w->attr.st_mtime);
+         printf ("passwd current mtime %ld\n", (long)w->attr.st_mtime);
+       }
+     else
+       /* you shalt not abuse printf for puts */
+       puts ("wow, /etc/passwd is not there, expect problems. "
+             "if this is windows, they already arrived\n");
+   }
+
+   ...
+   ev_stat passwd;
+
+   ev_stat_init (&passwd, passwd_cb, "/etc/passwd", 0.);
+   ev_stat_start (loop, &passwd);
+
+Example: Like above, but additionally use a one-second delay so we do not
+miss updates (however, frequent updates will delay processing, too, so
+one might do the work both on C<ev_stat> callback invocation I<and> on
+C<ev_timer> callback invocation).
+
+   static ev_stat passwd;
+   static ev_timer timer;
+
+   static void
+   timer_cb (EV_P_ ev_timer *w, int revents)
+   {
+     ev_timer_stop (EV_A_ w);
+
+     /* now it's one second after the most recent passwd change */
+   }
+
+   static void
+   stat_cb (EV_P_ ev_stat *w, int revents)
+   {
+     /* reset the one-second timer */
+     ev_timer_again (EV_A_ &timer);
+   }
+
+   ...
+   ev_stat_init (&passwd, stat_cb, "/etc/passwd", 0.);
+   ev_stat_start (loop, &passwd);
+   ev_timer_init (&timer, timer_cb, 0., 1.02);
+
+
+=head2 C<ev_idle> - when you've got nothing better to do...
+
+Idle watchers trigger events when no other events of the same or higher
+priority are pending (prepare, check and other idle watchers do not count
+as receiving "events").
+
+That is, as long as your process is busy handling sockets or timeouts
+(or even signals, imagine) of the same or higher priority it will not be
+triggered. But when your process is idle (or only lower-priority watchers
+are pending), the idle watchers are being called once per event loop
+iteration - until stopped, that is, or your process receives more events
+and becomes busy again with higher priority stuff.
+
+The most noteworthy effect is that as long as any idle watchers are
+active, the process will not block when waiting for new events.
+
+Apart from keeping your process non-blocking (which is a useful
+effect on its own sometimes), idle watchers are a good place to do
+"pseudo-background processing", or delay processing stuff to after the
+event loop has handled all outstanding events.
+
+=head3 Abusing an C<ev_idle> watcher for its side-effect
+
+As long as there is at least one active idle watcher, libev will never
+sleep unnecessarily. Or in other words, it will loop as fast as possible.
+For this to work, the idle watcher doesn't need to be invoked at all - the
+lowest priority will do.
+
+This mode of operation can be useful together with an C<ev_check> watcher,
+to do something on each event loop iteration - for example to balance load
+between different connections.
+
+See L</Abusing an ev_check watcher for its side-effect> for a longer
+example.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_idle_init (ev_idle *, callback)
+
+Initialises and configures the idle watcher - it has no parameters of any
+kind. There is a C<ev_idle_set> macro, but using it is utterly pointless,
+believe me.
+
+=back
+
+=head3 Examples
+
+Example: Dynamically allocate an C<ev_idle> watcher, start it, and in the
+callback, free it. Also, use no error checking, as usual.
+
+   static void
+   idle_cb (struct ev_loop *loop, ev_idle *w, int revents)
+   {
+     // stop the watcher
+     ev_idle_stop (loop, w);
+
+     // now we can free it
+     free (w);
+
+     // now do something you wanted to do when the program has
+     // no longer anything immediate to do.
+   }
+
+   ev_idle *idle_watcher = malloc (sizeof (ev_idle));
+   ev_idle_init (idle_watcher, idle_cb);
+   ev_idle_start (loop, idle_watcher);
+
+
+=head2 C<ev_prepare> and C<ev_check> - customise your event loop!
+
+Prepare and check watchers are often (but not always) used in pairs:
+prepare watchers get invoked before the process blocks and check watchers
+afterwards.
+
+You I<must not> call C<ev_run> (or similar functions that enter the
+current event loop) or C<ev_loop_fork> from either C<ev_prepare> or
+C<ev_check> watchers. Other loops than the current one are fine,
+however. The rationale behind this is that you do not need to check
+for recursion in those watchers, i.e. the sequence will always be
+C<ev_prepare>, blocking, C<ev_check> so if you have one watcher of each
+kind they will always be called in pairs bracketing the blocking call.
+
+Their main purpose is to integrate other event mechanisms into libev and
+their use is somewhat advanced. They could be used, for example, to track
+variable changes, implement your own watchers, integrate net-snmp or a
+coroutine library and lots more. They are also occasionally useful if
+you cache some data and want to flush it before blocking (for example,
+in X programs you might want to do an C<XFlush ()> in an C<ev_prepare>
+watcher).
+
+This is done by examining in each prepare call which file descriptors
+need to be watched by the other library, registering C<ev_io> watchers
+for them and starting an C<ev_timer> watcher for any timeouts (many
+libraries provide exactly this functionality). Then, in the check watcher,
+you check for any events that occurred (by checking the pending status
+of all watchers and stopping them) and call back into the library. The
+I/O and timer callbacks will never actually be called (but must be valid
+nevertheless, because you never know, you know?).
+
+As another example, the Perl Coro module uses these hooks to integrate
+coroutines into libev programs, by yielding to other active coroutines
+during each prepare and only letting the process block if no coroutines
+are ready to run (it's actually more complicated: it only runs coroutines
+with priority higher than or equal to the event loop and one coroutine
+of lower priority, but only once, using idle watchers to keep the event
+loop from blocking if lower-priority coroutines are active, thus mapping
+low-priority coroutines to idle/background tasks).
+
+When used for this purpose, it is recommended to give C<ev_check> watchers
+highest (C<EV_MAXPRI>) priority, to ensure that they are being run before
+any other watchers after the poll (this doesn't matter for C<ev_prepare>
+watchers).
+
+Also, C<ev_check> watchers (and C<ev_prepare> watchers, too) should not
+activate ("feed") events into libev. While libev fully supports this, they
+might get executed before other C<ev_check> watchers did their job. As
+C<ev_check> watchers are often used to embed other (non-libev) event
+loops those other event loops might be in an unusable state until their
+C<ev_check> watcher ran (always remind yourself to coexist peacefully with
+others).
+
+=head3 Abusing an C<ev_check> watcher for its side-effect
+
+C<ev_check> (and less often also C<ev_prepare>) watchers can also be
+useful because they are called once per event loop iteration. For
+example, if you want to handle a large number of connections fairly, you
+normally only do a bit of work for each active connection, and if there
+is more work to do, you wait for the next event loop iteration, so other
+connections have a chance of making progress.
+
+Using an C<ev_check> watcher is almost enough: it will be called on the
+next event loop iteration. However, that isn't as soon as possible -
+without external events, your C<ev_check> watcher will not be invoked.
+
+This is where C<ev_idle> watchers come in handy - all you need is a
+single global idle watcher that is active as long as you have one active
+C<ev_check> watcher. The C<ev_idle> watcher makes sure the event loop
+will not sleep, and the C<ev_check> watcher makes sure a callback gets
+invoked. Neither watcher alone can do that.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_prepare_init (ev_prepare *, callback)
+
+=item ev_check_init (ev_check *, callback)
+
+Initialises and configures the prepare or check watcher - they have no
+parameters of any kind. There are C<ev_prepare_set> and C<ev_check_set>
+macros, but using them is utterly, utterly, utterly and completely
+pointless.
+
+=back
+
+=head3 Examples
+
+There are a number of principal ways to embed other event loops or modules
+into libev. Here are some ideas on how to include libadns into libev
+(there is a Perl module named C<EV::ADNS> that does this, which you could
+use as a working example. Another Perl module named C<EV::Glib> embeds a
+Glib main context into libev, and finally, C<Glib::EV> embeds EV into the
+Glib event loop).
+
+Method 1: Add IO watchers and a timeout watcher in a prepare handler,
+and in a check watcher, destroy them and call into libadns. What follows
+is pseudo-code only of course. This requires you to either use a low
+priority for the check watcher or use C<ev_clear_pending> explicitly, as
+the callbacks for the IO/timeout watchers might not have been called yet.
+
+   static ev_io iow [nfd];
+   static ev_timer tw;
+
+   static void
+   io_cb (struct ev_loop *loop, ev_io *w, int revents)
+   {
+   }
+
+   // create io watchers for each fd and a timer before blocking
+   static void
+   adns_prepare_cb (struct ev_loop *loop, ev_prepare *w, int revents)
+   {
+     int timeout = 3600000;
+     struct pollfd fds [nfd];
+     // actual code will need to loop here and realloc etc.
+     adns_beforepoll (ads, fds, &nfd, &timeout, timeval_from (ev_time ()));
+
+     /* the callback is illegal, but won't be called as we stop during check */
+     ev_timer_init (&tw, 0, timeout * 1e-3, 0.);
+     ev_timer_start (loop, &tw);
+
+     // create one ev_io per pollfd
+     for (int i = 0; i < nfd; ++i)
+       {
+         ev_io_init (iow + i, io_cb, fds [i].fd,
+           ((fds [i].events & POLLIN ? EV_READ : 0)
+            | (fds [i].events & POLLOUT ? EV_WRITE : 0)));
+
+         fds [i].revents = 0;
+         ev_io_start (loop, iow + i);
+       }
+   }
+
+   // stop all watchers after blocking
+   static void
+   adns_check_cb (struct ev_loop *loop, ev_check *w, int revents)
+   {
+     ev_timer_stop (loop, &tw);
+
+     for (int i = 0; i < nfd; ++i)
+       {
+         // set the relevant poll flags
+         // could also call adns_processreadable etc. here
+         struct pollfd *fd = fds + i;
+         int revents = ev_clear_pending (iow + i);
+         if (revents & EV_READ ) fd->revents |= fd->events & POLLIN;
+         if (revents & EV_WRITE) fd->revents |= fd->events & POLLOUT;
+
+         // now stop the watcher
+         ev_io_stop (loop, iow + i);
+       }
+
+     adns_afterpoll (adns, fds, nfd, timeval_from (ev_now (loop));
+   }
+
+Method 2: This would be just like method 1, but you run C<adns_afterpoll>
+in the prepare watcher and would dispose of the check watcher.
+
+Method 3: If the module to be embedded supports explicit event
+notification (libadns does), you can also make use of the actual watcher
+callbacks, and only destroy/create the watchers in the prepare watcher.
+
+   static void
+   timer_cb (EV_P_ ev_timer *w, int revents)
+   {
+     adns_state ads = (adns_state)w->data;
+     update_now (EV_A);
+
+     adns_processtimeouts (ads, &tv_now);
+   }
+
+   static void
+   io_cb (EV_P_ ev_io *w, int revents)
+   {
+     adns_state ads = (adns_state)w->data;
+     update_now (EV_A);
+
+     if (revents & EV_READ ) adns_processreadable  (ads, w->fd, &tv_now);
+     if (revents & EV_WRITE) adns_processwriteable (ads, w->fd, &tv_now);
+   }
+
+   // do not ever call adns_afterpoll
+
+Method 4: Do not use a prepare or check watcher because the module you
+want to embed is not flexible enough to support it. Instead, you can
+override their poll function. The drawback with this solution is that the
+main loop is now no longer controllable by EV. The C<Glib::EV> module uses
+this approach, effectively embedding EV as a client into the horrible
+libglib event loop.
+
+   static gint
+   event_poll_func (GPollFD *fds, guint nfds, gint timeout)
+   {
+     int got_events = 0;
+
+     for (n = 0; n < nfds; ++n)
+       // create/start io watcher that sets the relevant bits in fds[n] and increment got_events
+
+     if (timeout >= 0)
+       // create/start timer
+
+     // poll
+     ev_run (EV_A_ 0);
+
+     // stop timer again
+     if (timeout >= 0)
+       ev_timer_stop (EV_A_ &to);
+
+     // stop io watchers again - their callbacks should have set
+     for (n = 0; n < nfds; ++n)
+       ev_io_stop (EV_A_ iow [n]);
+
+     return got_events;
+   }
+
+
+=head2 C<ev_embed> - when one backend isn't enough...
+
+This is a rather advanced watcher type that lets you embed one event loop
+into another (currently only C<ev_io> events are supported in the embedded
+loop, other types of watchers might be handled in a delayed or incorrect
+fashion and must not be used).
+
+There are primarily two reasons you would want that: work around bugs and
+prioritise I/O.
+
+As an example for a bug workaround, the kqueue backend might only support
+sockets on some platform, so it is unusable as generic backend, but you
+still want to make use of it because you have many sockets and it scales
+so nicely. In this case, you would create a kqueue-based loop and embed
+it into your default loop (which might use e.g. poll). Overall operation
+will be a bit slower because first libev has to call C<poll> and then
+C<kevent>, but at least you can use both mechanisms for what they are
+best: C<kqueue> for scalable sockets and C<poll> if you want it to work :)
+
+As for prioritising I/O: under rare circumstances you have the case where
+some fds have to be watched and handled very quickly (with low latency),
+and even priorities and idle watchers might have too much overhead. In
+this case you would put all the high priority stuff in one loop and all
+the rest in a second one, and embed the second one in the first.
+
+As long as the watcher is active, the callback will be invoked every
+time there might be events pending in the embedded loop. The callback
+must then call C<ev_embed_sweep (mainloop, watcher)> to make a single
+sweep and invoke their callbacks (the callback doesn't need to invoke the
+C<ev_embed_sweep> function directly, it could also start an idle watcher
+to give the embedded loop strictly lower priority for example).
+
+You can also set the callback to C<0>, in which case the embed watcher
+will automatically execute the embedded loop sweep whenever necessary.
+
+Fork detection will be handled transparently while the C<ev_embed> watcher
+is active, i.e., the embedded loop will automatically be forked when the
+embedding loop forks. In other cases, the user is responsible for calling
+C<ev_loop_fork> on the embedded loop.
+
+Unfortunately, not all backends are embeddable: only the ones returned by
+C<ev_embeddable_backends> are, which, unfortunately, does not include any
+portable one.
+
+So when you want to use this feature you will always have to be prepared
+that you cannot get an embeddable loop. The recommended way to get around
+this is to have a separate variables for your embeddable loop, try to
+create it, and if that fails, use the normal loop for everything.
+
+=head3 C<ev_embed> and fork
+
+While the C<ev_embed> watcher is running, forks in the embedding loop will
+automatically be applied to the embedded loop as well, so no special
+fork handling is required in that case. When the watcher is not running,
+however, it is still the task of the libev user to call C<ev_loop_fork ()>
+as applicable.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_embed_init (ev_embed *, callback, struct ev_loop *embedded_loop)
+
+=item ev_embed_set (ev_embed *, struct ev_loop *embedded_loop)
+
+Configures the watcher to embed the given loop, which must be
+embeddable. If the callback is C<0>, then C<ev_embed_sweep> will be
+invoked automatically, otherwise it is the responsibility of the callback
+to invoke it (it will continue to be called until the sweep has been done,
+if you do not want that, you need to temporarily stop the embed watcher).
+
+=item ev_embed_sweep (loop, ev_embed *)
+
+Make a single, non-blocking sweep over the embedded loop. This works
+similarly to C<ev_run (embedded_loop, EVRUN_NOWAIT)>, but in the most
+appropriate way for embedded loops.
+
+=item struct ev_loop *other [read-only]
+
+The embedded event loop.
+
+=back
+
+=head3 Examples
+
+Example: Try to get an embeddable event loop and embed it into the default
+event loop. If that is not possible, use the default loop. The default
+loop is stored in C<loop_hi>, while the embeddable loop is stored in
+C<loop_lo> (which is C<loop_hi> in the case no embeddable loop can be
+used).
+
+   struct ev_loop *loop_hi = ev_default_init (0);
+   struct ev_loop *loop_lo = 0;
+   ev_embed embed;
+
+   // see if there is a chance of getting one that works
+   // (remember that a flags value of 0 means autodetection)
+   loop_lo = ev_embeddable_backends () & ev_recommended_backends ()
+     ? ev_loop_new (ev_embeddable_backends () & ev_recommended_backends ())
+     : 0;
+
+   // if we got one, then embed it, otherwise default to loop_hi
+   if (loop_lo)
+     {
+       ev_embed_init (&embed, 0, loop_lo);
+       ev_embed_start (loop_hi, &embed);
+     }
+   else
+     loop_lo = loop_hi;
+
+Example: Check if kqueue is available but not recommended and create
+a kqueue backend for use with sockets (which usually work with any
+kqueue implementation). Store the kqueue/socket-only event loop in
+C<loop_socket>. (One might optionally use C<EVFLAG_NOENV>, too).
+
+   struct ev_loop *loop = ev_default_init (0);
+   struct ev_loop *loop_socket = 0;
+   ev_embed embed;
+
+   if (ev_supported_backends () & ~ev_recommended_backends () & EVBACKEND_KQUEUE)
+     if ((loop_socket = ev_loop_new (EVBACKEND_KQUEUE))
+       {
+         ev_embed_init (&embed, 0, loop_socket);
+         ev_embed_start (loop, &embed);
+       }
+
+   if (!loop_socket)
+     loop_socket = loop;
+
+   // now use loop_socket for all sockets, and loop for everything else
+
+
+=head2 C<ev_fork> - the audacity to resume the event loop after a fork
+
+Fork watchers are called when a C<fork ()> was detected (usually because
+whoever is a good citizen cared to tell libev about it by calling
+C<ev_loop_fork>). The invocation is done before the event loop blocks next
+and before C<ev_check> watchers are being called, and only in the child
+after the fork. If whoever good citizen calling C<ev_default_fork> cheats
+and calls it in the wrong process, the fork handlers will be invoked, too,
+of course.
+
+=head3 The special problem of life after fork - how is it possible?
+
+Most uses of C<fork ()> consist of forking, then some simple calls to set
+up/change the process environment, followed by a call to C<exec()>. This
+sequence should be handled by libev without any problems.
+
+This changes when the application actually wants to do event handling
+in the child, or both parent in child, in effect "continuing" after the
+fork.
+
+The default mode of operation (for libev, with application help to detect
+forks) is to duplicate all the state in the child, as would be expected
+when I<either> the parent I<or> the child process continues.
+
+When both processes want to continue using libev, then this is usually the
+wrong result. In that case, usually one process (typically the parent) is
+supposed to continue with all watchers in place as before, while the other
+process typically wants to start fresh, i.e. without any active watchers.
+
+The cleanest and most efficient way to achieve that with libev is to
+simply create a new event loop, which of course will be "empty", and
+use that for new watchers. This has the advantage of not touching more
+memory than necessary, and thus avoiding the copy-on-write, and the
+disadvantage of having to use multiple event loops (which do not support
+signal watchers).
+
+When this is not possible, or you want to use the default loop for
+other reasons, then in the process that wants to start "fresh", call
+C<ev_loop_destroy (EV_DEFAULT)> followed by C<ev_default_loop (...)>.
+Destroying the default loop will "orphan" (not stop) all registered
+watchers, so you have to be careful not to execute code that modifies
+those watchers. Note also that in that case, you have to re-register any
+signal watchers.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_fork_init (ev_fork *, callback)
+
+Initialises and configures the fork watcher - it has no parameters of any
+kind. There is a C<ev_fork_set> macro, but using it is utterly pointless,
+really.
+
+=back
+
+
+=head2 C<ev_cleanup> - even the best things end
+
+Cleanup watchers are called just before the event loop is being destroyed
+by a call to C<ev_loop_destroy>.
+
+While there is no guarantee that the event loop gets destroyed, cleanup
+watchers provide a convenient method to install cleanup hooks for your
+program, worker threads and so on - you just to make sure to destroy the
+loop when you want them to be invoked.
+
+Cleanup watchers are invoked in the same way as any other watcher. Unlike
+all other watchers, they do not keep a reference to the event loop (which
+makes a lot of sense if you think about it). Like all other watchers, you
+can call libev functions in the callback, except C<ev_cleanup_start>.
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_cleanup_init (ev_cleanup *, callback)
+
+Initialises and configures the cleanup watcher - it has no parameters of
+any kind. There is a C<ev_cleanup_set> macro, but using it is utterly
+pointless, I assure you.
+
+=back
+
+Example: Register an atexit handler to destroy the default loop, so any
+cleanup functions are called.
+
+   static void
+   program_exits (void)
+   {
+     ev_loop_destroy (EV_DEFAULT_UC);
+   }
+
+   ...
+   atexit (program_exits);
+
+
+=head2 C<ev_async> - how to wake up an event loop
+
+In general, you cannot use an C<ev_loop> from multiple threads or other
+asynchronous sources such as signal handlers (as opposed to multiple event
+loops - those are of course safe to use in different threads).
+
+Sometimes, however, you need to wake up an event loop you do not control,
+for example because it belongs to another thread. This is what C<ev_async>
+watchers do: as long as the C<ev_async> watcher is active, you can signal
+it by calling C<ev_async_send>, which is thread- and signal safe.
+
+This functionality is very similar to C<ev_signal> watchers, as signals,
+too, are asynchronous in nature, and signals, too, will be compressed
+(i.e. the number of callback invocations may be less than the number of
+C<ev_async_send> calls). In fact, you could use signal watchers as a kind
+of "global async watchers" by using a watcher on an otherwise unused
+signal, and C<ev_feed_signal> to signal this watcher from another thread,
+even without knowing which loop owns the signal.
+
+=head3 Queueing
+
+C<ev_async> does not support queueing of data in any way. The reason
+is that the author does not know of a simple (or any) algorithm for a
+multiple-writer-single-reader queue that works in all cases and doesn't
+need elaborate support such as pthreads or unportable memory access
+semantics.
+
+That means that if you want to queue data, you have to provide your own
+queue. But at least I can tell you how to implement locking around your
+queue:
+
+=over 4
+
+=item queueing from a signal handler context
+
+To implement race-free queueing, you simply add to the queue in the signal
+handler but you block the signal handler in the watcher callback. Here is
+an example that does that for some fictitious SIGUSR1 handler:
+
+   static ev_async mysig;
+
+   static void
+   sigusr1_handler (void)
+   {
+     sometype data;
+
+     // no locking etc.
+     queue_put (data);
+     ev_async_send (EV_DEFAULT_ &mysig);
+   }
+
+   static void
+   mysig_cb (EV_P_ ev_async *w, int revents)
+   {
+     sometype data;
+     sigset_t block, prev;
+
+     sigemptyset (&block);
+     sigaddset (&block, SIGUSR1);
+     sigprocmask (SIG_BLOCK, &block, &prev);
+
+     while (queue_get (&data))
+       process (data);
+
+     if (sigismember (&prev, SIGUSR1)
+       sigprocmask (SIG_UNBLOCK, &block, 0);
+   }
+
+(Note: pthreads in theory requires you to use C<pthread_setmask>
+instead of C<sigprocmask> when you use threads, but libev doesn't do it
+either...).
+
+=item queueing from a thread context
+
+The strategy for threads is different, as you cannot (easily) block
+threads but you can easily preempt them, so to queue safely you need to
+employ a traditional mutex lock, such as in this pthread example:
+
+   static ev_async mysig;
+   static pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;
+
+   static void
+   otherthread (void)
+   {
+     // only need to lock the actual queueing operation
+     pthread_mutex_lock (&mymutex);
+     queue_put (data);
+     pthread_mutex_unlock (&mymutex);
+
+     ev_async_send (EV_DEFAULT_ &mysig);
+   }
+
+   static void
+   mysig_cb (EV_P_ ev_async *w, int revents)
+   {
+     pthread_mutex_lock (&mymutex);
+
+     while (queue_get (&data))
+       process (data);
+
+     pthread_mutex_unlock (&mymutex);
+   }
+
+=back
+
+
+=head3 Watcher-Specific Functions and Data Members
+
+=over 4
+
+=item ev_async_init (ev_async *, callback)
+
+Initialises and configures the async watcher - it has no parameters of any
+kind. There is a C<ev_async_set> macro, but using it is utterly pointless,
+trust me.
+
+=item ev_async_send (loop, ev_async *)
+
+Sends/signals/activates the given C<ev_async> watcher, that is, feeds
+an C<EV_ASYNC> event on the watcher into the event loop, and instantly
+returns.
+
+Unlike C<ev_feed_event>, this call is safe to do from other threads,
+signal or similar contexts (see the discussion of C<EV_ATOMIC_T> in the
+embedding section below on what exactly this means).
+
+Note that, as with other watchers in libev, multiple events might get
+compressed into a single callback invocation (another way to look at
+this is that C<ev_async> watchers are level-triggered: they are set on
+C<ev_async_send>, reset when the event loop detects that).
+
+This call incurs the overhead of at most one extra system call per event
+loop iteration, if the event loop is blocked, and no syscall at all if
+the event loop (or your program) is processing events. That means that
+repeated calls are basically free (there is no need to avoid calls for
+performance reasons) and that the overhead becomes smaller (typically
+zero) under load.
+
+=item bool = ev_async_pending (ev_async *)
+
+Returns a non-zero value when C<ev_async_send> has been called on the
+watcher but the event has not yet been processed (or even noted) by the
+event loop.
+
+C<ev_async_send> sets a flag in the watcher and wakes up the loop. When
+the loop iterates next and checks for the watcher to have become active,
+it will reset the flag again. C<ev_async_pending> can be used to very
+quickly check whether invoking the loop might be a good idea.
+
+Not that this does I<not> check whether the watcher itself is pending,
+only whether it has been requested to make this watcher pending: there
+is a time window between the event loop checking and resetting the async
+notification, and the callback being invoked.
+
+=back
+
+
+=head1 OTHER FUNCTIONS
+
+There are some other functions of possible interest. Described. Here. Now.
+
+=over 4
+
+=item ev_once (loop, int fd, int events, ev_tstamp timeout, callback)
+
+This function combines a simple timer and an I/O watcher, calls your
+callback on whichever event happens first and automatically stops both
+watchers. This is useful if you want to wait for a single event on an fd
+or timeout without having to allocate/configure/start/stop/free one or
+more watchers yourself.
+
+If C<fd> is less than 0, then no I/O watcher will be started and the
+C<events> argument is being ignored. Otherwise, an C<ev_io> watcher for
+the given C<fd> and C<events> set will be created and started.
+
+If C<timeout> is less than 0, then no timeout watcher will be
+started. Otherwise an C<ev_timer> watcher with after = C<timeout> (and
+repeat = 0) will be started. C<0> is a valid timeout.
+
+The callback has the type C<void (*cb)(int revents, void *arg)> and is
+passed an C<revents> set like normal event callbacks (a combination of
+C<EV_ERROR>, C<EV_READ>, C<EV_WRITE> or C<EV_TIMER>) and the C<arg>
+value passed to C<ev_once>. Note that it is possible to receive I<both>
+a timeout and an io event at the same time - you probably should give io
+events precedence.
+
+Example: wait up to ten seconds for data to appear on STDIN_FILENO.
+
+   static void stdin_ready (int revents, void *arg)
+   {
+     if (revents & EV_READ)
+       /* stdin might have data for us, joy! */;
+     else if (revents & EV_TIMER)
+       /* doh, nothing entered */;
+   }
+
+   ev_once (STDIN_FILENO, EV_READ, 10., stdin_ready, 0);
+
+=item ev_feed_fd_event (loop, int fd, int revents)
+
+Feed an event on the given fd, as if a file descriptor backend detected
+the given events.
+
+=item ev_feed_signal_event (loop, int signum)
+
+Feed an event as if the given signal occurred. See also C<ev_feed_signal>,
+which is async-safe.
+
+=back
+
+
+=head1 COMMON OR USEFUL IDIOMS (OR BOTH)
+
+This section explains some common idioms that are not immediately
+obvious. Note that examples are sprinkled over the whole manual, and this
+section only contains stuff that wouldn't fit anywhere else.
+
+=head2 ASSOCIATING CUSTOM DATA WITH A WATCHER
+
+Each watcher has, by default, a C<void *data> member that you can read
+or modify at any time: libev will completely ignore it. This can be used
+to associate arbitrary data with your watcher. If you need more data and
+don't want to allocate memory separately and store a pointer to it in that
+data member, you can also "subclass" the watcher type and provide your own
+data:
+
+   struct my_io
+   {
+     ev_io io;
+     int otherfd;
+     void *somedata;
+     struct whatever *mostinteresting;
+   };
+
+   ...
+   struct my_io w;
+   ev_io_init (&w.io, my_cb, fd, EV_READ);
+
+And since your callback will be called with a pointer to the watcher, you
+can cast it back to your own type:
+
+   static void my_cb (struct ev_loop *loop, ev_io *w_, int revents)
+   {
+     struct my_io *w = (struct my_io *)w_;
+     ...
+   }
+
+More interesting and less C-conformant ways of casting your callback
+function type instead have been omitted.
+
+=head2 BUILDING YOUR OWN COMPOSITE WATCHERS
+
+Another common scenario is to use some data structure with multiple
+embedded watchers, in effect creating your own watcher that combines
+multiple libev event sources into one "super-watcher":
+
+   struct my_biggy
+   {
+     int some_data;
+     ev_timer t1;
+     ev_timer t2;
+   }
+
+In this case getting the pointer to C<my_biggy> is a bit more
+complicated: Either you store the address of your C<my_biggy> struct in
+the C<data> member of the watcher (for woozies or C++ coders), or you need
+to use some pointer arithmetic using C<offsetof> inside your watchers (for
+real programmers):
+
+   #include <stddef.h>
+
+   static void
+   t1_cb (EV_P_ ev_timer *w, int revents)
+   {
+     struct my_biggy big = (struct my_biggy *)
+       (((char *)w) - offsetof (struct my_biggy, t1));
+   }
+
+   static void
+   t2_cb (EV_P_ ev_timer *w, int revents)
+   {
+     struct my_biggy big = (struct my_biggy *)
+       (((char *)w) - offsetof (struct my_biggy, t2));
+   }
+
+=head2 AVOIDING FINISHING BEFORE RETURNING
+
+Often you have structures like this in event-based programs:
+
+  callback ()
+  {
+    free (request);
+  }
+
+  request = start_new_request (..., callback);
+
+The intent is to start some "lengthy" operation. The C<request> could be
+used to cancel the operation, or do other things with it.
+
+It's not uncommon to have code paths in C<start_new_request> that
+immediately invoke the callback, for example, to report errors. Or you add
+some caching layer that finds that it can skip the lengthy aspects of the
+operation and simply invoke the callback with the result.
+
+The problem here is that this will happen I<before> C<start_new_request>
+has returned, so C<request> is not set.
+
+Even if you pass the request by some safer means to the callback, you
+might want to do something to the request after starting it, such as
+canceling it, which probably isn't working so well when the callback has
+already been invoked.
+
+A common way around all these issues is to make sure that
+C<start_new_request> I<always> returns before the callback is invoked. If
+C<start_new_request> immediately knows the result, it can artificially
+delay invoking the callback by using a C<prepare> or C<idle> watcher for
+example, or more sneakily, by reusing an existing (stopped) watcher and
+pushing it into the pending queue:
+
+   ev_set_cb (watcher, callback);
+   ev_feed_event (EV_A_ watcher, 0);
+
+This way, C<start_new_request> can safely return before the callback is
+invoked, while not delaying callback invocation too much.
+
+=head2 MODEL/NESTED EVENT LOOP INVOCATIONS AND EXIT CONDITIONS
+
+Often (especially in GUI toolkits) there are places where you have
+I<modal> interaction, which is most easily implemented by recursively
+invoking C<ev_run>.
+
+This brings the problem of exiting - a callback might want to finish the
+main C<ev_run> call, but not the nested one (e.g. user clicked "Quit", but
+a modal "Are you sure?" dialog is still waiting), or just the nested one
+and not the main one (e.g. user clocked "Ok" in a modal dialog), or some
+other combination: In these cases, a simple C<ev_break> will not work.
+
+The solution is to maintain "break this loop" variable for each C<ev_run>
+invocation, and use a loop around C<ev_run> until the condition is
+triggered, using C<EVRUN_ONCE>:
+
+   // main loop
+   int exit_main_loop = 0;
+
+   while (!exit_main_loop)
+     ev_run (EV_DEFAULT_ EVRUN_ONCE);
+
+   // in a modal watcher
+   int exit_nested_loop = 0;
+
+   while (!exit_nested_loop)
+     ev_run (EV_A_ EVRUN_ONCE);
+
+To exit from any of these loops, just set the corresponding exit variable:
+
+   // exit modal loop
+   exit_nested_loop = 1;
+
+   // exit main program, after modal loop is finished
+   exit_main_loop = 1;
+
+   // exit both
+   exit_main_loop = exit_nested_loop = 1;
+
+=head2 THREAD LOCKING EXAMPLE
+
+Here is a fictitious example of how to run an event loop in a different
+thread from where callbacks are being invoked and watchers are
+created/added/removed.
+
+For a real-world example, see the C<EV::Loop::Async> perl module,
+which uses exactly this technique (which is suited for many high-level
+languages).
+
+The example uses a pthread mutex to protect the loop data, a condition
+variable to wait for callback invocations, an async watcher to notify the
+event loop thread and an unspecified mechanism to wake up the main thread.
+
+First, you need to associate some data with the event loop:
+
+   typedef struct {
+     mutex_t lock; /* global loop lock */
+     ev_async async_w;
+     thread_t tid;
+     cond_t invoke_cv;
+   } userdata;
+
+   void prepare_loop (EV_P)
+   {
+      // for simplicity, we use a static userdata struct.
+      static userdata u;
+
+      ev_async_init (&u->async_w, async_cb);
+      ev_async_start (EV_A_ &u->async_w);
+
+      pthread_mutex_init (&u->lock, 0);
+      pthread_cond_init (&u->invoke_cv, 0);
+
+      // now associate this with the loop
+      ev_set_userdata (EV_A_ u);
+      ev_set_invoke_pending_cb (EV_A_ l_invoke);
+      ev_set_loop_release_cb (EV_A_ l_release, l_acquire);
+
+      // then create the thread running ev_run
+      pthread_create (&u->tid, 0, l_run, EV_A);
+   }
+
+The callback for the C<ev_async> watcher does nothing: the watcher is used
+solely to wake up the event loop so it takes notice of any new watchers
+that might have been added:
+
+   static void
+   async_cb (EV_P_ ev_async *w, int revents)
+   {
+      // just used for the side effects
+   }
+
+The C<l_release> and C<l_acquire> callbacks simply unlock/lock the mutex
+protecting the loop data, respectively.
+
+   static void
+   l_release (EV_P)
+   {
+     userdata *u = ev_userdata (EV_A);
+     pthread_mutex_unlock (&u->lock);
+   }
+
+   static void
+   l_acquire (EV_P)
+   {
+     userdata *u = ev_userdata (EV_A);
+     pthread_mutex_lock (&u->lock);
+   }
+
+The event loop thread first acquires the mutex, and then jumps straight
+into C<ev_run>:
+
+   void *
+   l_run (void *thr_arg)
+   {
+     struct ev_loop *loop = (struct ev_loop *)thr_arg;
+
+     l_acquire (EV_A);
+     pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, 0);
+     ev_run (EV_A_ 0);
+     l_release (EV_A);
+
+     return 0;
+   }
+
+Instead of invoking all pending watchers, the C<l_invoke> callback will
+signal the main thread via some unspecified mechanism (signals? pipe
+writes? C<Async::Interrupt>?) and then waits until all pending watchers
+have been called (in a while loop because a) spurious wakeups are possible
+and b) skipping inter-thread-communication when there are no pending
+watchers is very beneficial):
+
+   static void
+   l_invoke (EV_P)
+   {
+     userdata *u = ev_userdata (EV_A);
+
+     while (ev_pending_count (EV_A))
+       {
+         wake_up_other_thread_in_some_magic_or_not_so_magic_way ();
+         pthread_cond_wait (&u->invoke_cv, &u->lock);
+       }
+   }
+
+Now, whenever the main thread gets told to invoke pending watchers, it
+will grab the lock, call C<ev_invoke_pending> and then signal the loop
+thread to continue:
+
+   static void
+   real_invoke_pending (EV_P)
+   {
+     userdata *u = ev_userdata (EV_A);
+
+     pthread_mutex_lock (&u->lock);
+     ev_invoke_pending (EV_A);
+     pthread_cond_signal (&u->invoke_cv);
+     pthread_mutex_unlock (&u->lock);
+   }
+
+Whenever you want to start/stop a watcher or do other modifications to an
+event loop, you will now have to lock:
+
+   ev_timer timeout_watcher;
+   userdata *u = ev_userdata (EV_A);
+
+   ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
+
+   pthread_mutex_lock (&u->lock);
+   ev_timer_start (EV_A_ &timeout_watcher);
+   ev_async_send (EV_A_ &u->async_w);
+   pthread_mutex_unlock (&u->lock);
+
+Note that sending the C<ev_async> watcher is required because otherwise
+an event loop currently blocking in the kernel will have no knowledge
+about the newly added timer. By waking up the loop it will pick up any new
+watchers in the next event loop iteration.
+
+=head2 THREADS, COROUTINES, CONTINUATIONS, QUEUES... INSTEAD OF CALLBACKS
+
+While the overhead of a callback that e.g. schedules a thread is small, it
+is still an overhead. If you embed libev, and your main usage is with some
+kind of threads or coroutines, you might want to customise libev so that
+doesn't need callbacks anymore.
+
+Imagine you have coroutines that you can switch to using a function
+C<switch_to (coro)>, that libev runs in a coroutine called C<libev_coro>
+and that due to some magic, the currently active coroutine is stored in a
+global called C<current_coro>. Then you can build your own "wait for libev
+event" primitive by changing C<EV_CB_DECLARE> and C<EV_CB_INVOKE> (note
+the differing C<;> conventions):
+
+   #define EV_CB_DECLARE(type)   struct my_coro *cb;
+   #define EV_CB_INVOKE(watcher) switch_to ((watcher)->cb)
+
+That means instead of having a C callback function, you store the
+coroutine to switch to in each watcher, and instead of having libev call
+your callback, you instead have it switch to that coroutine.
+
+A coroutine might now wait for an event with a function called
+C<wait_for_event>. (the watcher needs to be started, as always, but it doesn't
+matter when, or whether the watcher is active or not when this function is
+called):
+
+   void
+   wait_for_event (ev_watcher *w)
+   {
+     ev_set_cb (w, current_coro);
+     switch_to (libev_coro);
+   }
+
+That basically suspends the coroutine inside C<wait_for_event> and
+continues the libev coroutine, which, when appropriate, switches back to
+this or any other coroutine.
+
+You can do similar tricks if you have, say, threads with an event queue -
+instead of storing a coroutine, you store the queue object and instead of
+switching to a coroutine, you push the watcher onto the queue and notify
+any waiters.
+
+To embed libev, see L</EMBEDDING>, but in short, it's easiest to create two
+files, F<my_ev.h> and F<my_ev.c> that include the respective libev files:
+
+   // my_ev.h
+   #define EV_CB_DECLARE(type)   struct my_coro *cb;
+   #define EV_CB_INVOKE(watcher) switch_to ((watcher)->cb)
+   #include "../libev/ev.h"
+
+   // my_ev.c
+   #define EV_H "my_ev.h"
+   #include "../libev/ev.c"
+
+And then use F<my_ev.h> when you would normally use F<ev.h>, and compile
+F<my_ev.c> into your project. When properly specifying include paths, you
+can even use F<ev.h> as header file name directly.
+
+
+=head1 LIBEVENT EMULATION
+
+Libev offers a compatibility emulation layer for libevent. It cannot
+emulate the internals of libevent, so here are some usage hints:
+
+=over 4
+
+=item * Only the libevent-1.4.1-beta API is being emulated.
+
+This was the newest libevent version available when libev was implemented,
+and is still mostly unchanged in 2010.
+
+=item * Use it by including <event.h>, as usual.
+
+=item * The following members are fully supported: ev_base, ev_callback,
+ev_arg, ev_fd, ev_res, ev_events.
+
+=item * Avoid using ev_flags and the EVLIST_*-macros, while it is
+maintained by libev, it does not work exactly the same way as in libevent (consider
+it a private API).
+
+=item * Priorities are not currently supported. Initialising priorities
+will fail and all watchers will have the same priority, even though there
+is an ev_pri field.
+
+=item * In libevent, the last base created gets the signals, in libev, the
+base that registered the signal gets the signals.
+
+=item * Other members are not supported.
+
+=item * The libev emulation is I<not> ABI compatible to libevent, you need
+to use the libev header file and library.
+
+=back
+
+=head1 C++ SUPPORT
+
+=head2 C API
+
+The normal C API should work fine when used from C++: both ev.h and the
+libev sources can be compiled as C++. Therefore, code that uses the C API
+will work fine.
+
+Proper exception specifications might have to be added to callbacks passed
+to libev: exceptions may be thrown only from watcher callbacks, all
+other callbacks (allocator, syserr, loop acquire/release and periodic
+reschedule callbacks) must not throw exceptions, and might need a C<throw
+()> specification. If you have code that needs to be compiled as both C
+and C++ you can use the C<EV_THROW> macro for this:
+
+   static void
+   fatal_error (const char *msg) EV_THROW
+   {
+     perror (msg);
+     abort ();
+   }
+
+   ...
+   ev_set_syserr_cb (fatal_error);
+
+The only API functions that can currently throw exceptions are C<ev_run>,
+C<ev_invoke>, C<ev_invoke_pending> and C<ev_loop_destroy> (the latter
+because it runs cleanup watchers).
+
+Throwing exceptions in watcher callbacks is only supported if libev itself
+is compiled with a C++ compiler or your C and C++ environments allow
+throwing exceptions through C libraries (most do).
+
+=head2 C++ API
+
+Libev comes with some simplistic wrapper classes for C++ that mainly allow
+you to use some convenience methods to start/stop watchers and also change
+the callback model to a model using method callbacks on objects.
+
+To use it,
+
+   #include <ev++.h>
+
+This automatically includes F<ev.h> and puts all of its definitions (many
+of them macros) into the global namespace. All C++ specific things are
+put into the C<ev> namespace. It should support all the same embedding
+options as F<ev.h>, most notably C<EV_MULTIPLICITY>.
+
+Care has been taken to keep the overhead low. The only data member the C++
+classes add (compared to plain C-style watchers) is the event loop pointer
+that the watcher is associated with (or no additional members at all if
+you disable C<EV_MULTIPLICITY> when embedding libev).
+
+Currently, functions, static and non-static member functions and classes
+with C<operator ()> can be used as callbacks. Other types should be easy
+to add as long as they only need one additional pointer for context. If
+you need support for other types of functors please contact the author
+(preferably after implementing it).
+
+For all this to work, your C++ compiler either has to use the same calling
+conventions as your C compiler (for static member functions), or you have
+to embed libev and compile libev itself as C++.
+
+Here is a list of things available in the C<ev> namespace:
+
+=over 4
+
+=item C<ev::READ>, C<ev::WRITE> etc.
+
+These are just enum values with the same values as the C<EV_READ> etc.
+macros from F<ev.h>.
+
+=item C<ev::tstamp>, C<ev::now>
+
+Aliases to the same types/functions as with the C<ev_> prefix.
+
+=item C<ev::io>, C<ev::timer>, C<ev::periodic>, C<ev::idle>, C<ev::sig> etc.
+
+For each C<ev_TYPE> watcher in F<ev.h> there is a corresponding class of
+the same name in the C<ev> namespace, with the exception of C<ev_signal>
+which is called C<ev::sig> to avoid clashes with the C<signal> macro
+defined by many implementations.
+
+All of those classes have these methods:
+
+=over 4
+
+=item ev::TYPE::TYPE ()
+
+=item ev::TYPE::TYPE (loop)
+
+=item ev::TYPE::~TYPE
+
+The constructor (optionally) takes an event loop to associate the watcher
+with. If it is omitted, it will use C<EV_DEFAULT>.
+
+The constructor calls C<ev_init> for you, which means you have to call the
+C<set> method before starting it.
+
+It will not set a callback, however: You have to call the templated C<set>
+method to set a callback before you can start the watcher.
+
+(The reason why you have to use a method is a limitation in C++ which does
+not allow explicit template arguments for constructors).
+
+The destructor automatically stops the watcher if it is active.
+
+=item w->set<class, &class::method> (object *)
+
+This method sets the callback method to call. The method has to have a
+signature of C<void (*)(ev_TYPE &, int)>, it receives the watcher as
+first argument and the C<revents> as second. The object must be given as
+parameter and is stored in the C<data> member of the watcher.
+
+This method synthesizes efficient thunking code to call your method from
+the C callback that libev requires. If your compiler can inline your
+callback (i.e. it is visible to it at the place of the C<set> call and
+your compiler is good :), then the method will be fully inlined into the
+thunking function, making it as fast as a direct C callback.
+
+Example: simple class declaration and watcher initialisation
+
+   struct myclass
+   {
+     void io_cb (ev::io &w, int revents) { }
+   }
+
+   myclass obj;
+   ev::io iow;
+   iow.set <myclass, &myclass::io_cb> (&obj);
+
+=item w->set (object *)
+
+This is a variation of a method callback - leaving out the method to call
+will default the method to C<operator ()>, which makes it possible to use
+functor objects without having to manually specify the C<operator ()> all
+the time. Incidentally, you can then also leave out the template argument
+list.
+
+The C<operator ()> method prototype must be C<void operator ()(watcher &w,
+int revents)>.
+
+See the method-C<set> above for more details.
+
+Example: use a functor object as callback.
+
+   struct myfunctor
+   {
+     void operator() (ev::io &w, int revents)
+     {
+       ...
+     }
+   }
+
+   myfunctor f;
+
+   ev::io w;
+   w.set (&f);
+
+=item w->set<function> (void *data = 0)
+
+Also sets a callback, but uses a static method or plain function as
+callback. The optional C<data> argument will be stored in the watcher's
+C<data> member and is free for you to use.
+
+The prototype of the C<function> must be C<void (*)(ev::TYPE &w, int)>.
+
+See the method-C<set> above for more details.
+
+Example: Use a plain function as callback.
+
+   static void io_cb (ev::io &w, int revents) { }
+   iow.set <io_cb> ();
+
+=item w->set (loop)
+
+Associates a different C<struct ev_loop> with this watcher. You can only
+do this when the watcher is inactive (and not pending either).
+
+=item w->set ([arguments])
+
+Basically the same as C<ev_TYPE_set> (except for C<ev::embed> watchers>),
+with the same arguments. Either this method or a suitable start method
+must be called at least once. Unlike the C counterpart, an active watcher
+gets automatically stopped and restarted when reconfiguring it with this
+method.
+
+For C<ev::embed> watchers this method is called C<set_embed>, to avoid
+clashing with the C<set (loop)> method.
+
+=item w->start ()
+
+Starts the watcher. Note that there is no C<loop> argument, as the
+constructor already stores the event loop.
+
+=item w->start ([arguments])
+
+Instead of calling C<set> and C<start> methods separately, it is often
+convenient to wrap them in one call. Uses the same type of arguments as
+the configure C<set> method of the watcher.
+
+=item w->stop ()
+
+Stops the watcher if it is active. Again, no C<loop> argument.
+
+=item w->again () (C<ev::timer>, C<ev::periodic> only)
+
+For C<ev::timer> and C<ev::periodic>, this invokes the corresponding
+C<ev_TYPE_again> function.
+
+=item w->sweep () (C<ev::embed> only)
+
+Invokes C<ev_embed_sweep>.
+
+=item w->update () (C<ev::stat> only)
+
+Invokes C<ev_stat_stat>.
+
+=back
+
+=back
+
+Example: Define a class with two I/O and idle watchers, start the I/O
+watchers in the constructor.
+
+   class myclass
+   {
+     ev::io   io  ; void io_cb   (ev::io   &w, int revents);
+     ev::io   io2 ; void io2_cb  (ev::io   &w, int revents);
+     ev::idle idle; void idle_cb (ev::idle &w, int revents);
+
+     myclass (int fd)
+     {
+       io  .set <myclass, &myclass::io_cb  > (this);
+       io2 .set <myclass, &myclass::io2_cb > (this);
+       idle.set <myclass, &myclass::idle_cb> (this);
+
+       io.set (fd, ev::WRITE); // configure the watcher
+       io.start ();            // start it whenever convenient
+
+       io2.start (fd, ev::READ); // set + start in one call
+     }
+   };
+
+
+=head1 OTHER LANGUAGE BINDINGS
+
+Libev does not offer other language bindings itself, but bindings for a
+number of languages exist in the form of third-party packages. If you know
+any interesting language binding in addition to the ones listed here, drop
+me a note.
+
+=over 4
+
+=item Perl
+
+The EV module implements the full libev API and is actually used to test
+libev. EV is developed together with libev. Apart from the EV core module,
+there are additional modules that implement libev-compatible interfaces
+to C<libadns> (C<EV::ADNS>, but C<AnyEvent::DNS> is preferred nowadays),
+C<Net::SNMP> (C<Net::SNMP::EV>) and the C<libglib> event core (C<Glib::EV>
+and C<EV::Glib>).
+
+It can be found and installed via CPAN, its homepage is at
+L<http://software.schmorp.de/pkg/EV>.
+
+=item Python
+
+Python bindings can be found at L<http://code.google.com/p/pyev/>. It
+seems to be quite complete and well-documented.
+
+=item Ruby
+
+Tony Arcieri has written a ruby extension that offers access to a subset
+of the libev API and adds file handle abstractions, asynchronous DNS and
+more on top of it. It can be found via gem servers. Its homepage is at
+L<http://rev.rubyforge.org/>.
+
+Roger Pack reports that using the link order C<-lws2_32 -lmsvcrt-ruby-190>
+makes rev work even on mingw.
+
+=item Haskell
+
+A haskell binding to libev is available at
+L<http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hlibev>.
+
+=item D
+
+Leandro Lucarella has written a D language binding (F<ev.d>) for libev, to
+be found at L<http://www.llucax.com.ar/proj/ev.d/index.html>.
+
+=item Ocaml
+
+Erkki Seppala has written Ocaml bindings for libev, to be found at
+L<http://modeemi.cs.tut.fi/~flux/software/ocaml-ev/>.
+
+=item Lua
+
+Brian Maher has written a partial interface to libev for lua (at the
+time of this writing, only C<ev_io> and C<ev_timer>), to be found at
+L<http://github.com/brimworks/lua-ev>.
+
+=item Javascript
+
+Node.js (L<http://nodejs.org>) uses libev as the underlying event library.
+
+=item Others
+
+There are others, and I stopped counting.
+
+=back
+
+
+=head1 MACRO MAGIC
+
+Libev can be compiled with a variety of options, the most fundamental
+of which is C<EV_MULTIPLICITY>. This option determines whether (most)
+functions and callbacks have an initial C<struct ev_loop *> argument.
+
+To make it easier to write programs that cope with either variant, the
+following macros are defined:
+
+=over 4
+
+=item C<EV_A>, C<EV_A_>
+
+This provides the loop I<argument> for functions, if one is required ("ev
+loop argument"). The C<EV_A> form is used when this is the sole argument,
+C<EV_A_> is used when other arguments are following. Example:
+
+   ev_unref (EV_A);
+   ev_timer_add (EV_A_ watcher);
+   ev_run (EV_A_ 0);
+
+It assumes the variable C<loop> of type C<struct ev_loop *> is in scope,
+which is often provided by the following macro.
+
+=item C<EV_P>, C<EV_P_>
+
+This provides the loop I<parameter> for functions, if one is required ("ev
+loop parameter"). The C<EV_P> form is used when this is the sole parameter,
+C<EV_P_> is used when other parameters are following. Example:
+
+   // this is how ev_unref is being declared
+   static void ev_unref (EV_P);
+
+   // this is how you can declare your typical callback
+   static void cb (EV_P_ ev_timer *w, int revents)
+
+It declares a parameter C<loop> of type C<struct ev_loop *>, quite
+suitable for use with C<EV_A>.
+
+=item C<EV_DEFAULT>, C<EV_DEFAULT_>
+
+Similar to the other two macros, this gives you the value of the default
+loop, if multiple loops are supported ("ev loop default"). The default loop
+will be initialised if it isn't already initialised.
+
+For non-multiplicity builds, these macros do nothing, so you always have
+to initialise the loop somewhere.
+
+=item C<EV_DEFAULT_UC>, C<EV_DEFAULT_UC_>
+
+Usage identical to C<EV_DEFAULT> and C<EV_DEFAULT_>, but requires that the
+default loop has been initialised (C<UC> == unchecked). Their behaviour
+is undefined when the default loop has not been initialised by a previous
+execution of C<EV_DEFAULT>, C<EV_DEFAULT_> or C<ev_default_init (...)>.
+
+It is often prudent to use C<EV_DEFAULT> when initialising the first
+watcher in a function but use C<EV_DEFAULT_UC> afterwards.
+
+=back
+
+Example: Declare and initialise a check watcher, utilising the above
+macros so it will work regardless of whether multiple loops are supported
+or not.
+
+   static void
+   check_cb (EV_P_ ev_timer *w, int revents)
+   {
+     ev_check_stop (EV_A_ w);
+   }
+
+   ev_check check;
+   ev_check_init (&check, check_cb);
+   ev_check_start (EV_DEFAULT_ &check);
+   ev_run (EV_DEFAULT_ 0);
+
+=head1 EMBEDDING
+
+Libev can (and often is) directly embedded into host
+applications. Examples of applications that embed it include the Deliantra
+Game Server, the EV perl module, the GNU Virtual Private Ethernet (gvpe)
+and rxvt-unicode.
+
+The goal is to enable you to just copy the necessary files into your
+source directory without having to change even a single line in them, so
+you can easily upgrade by simply copying (or having a checked-out copy of
+libev somewhere in your source tree).
+
+=head2 FILESETS
+
+Depending on what features you need you need to include one or more sets of files
+in your application.
+
+=head3 CORE EVENT LOOP
+
+To include only the libev core (all the C<ev_*> functions), with manual
+configuration (no autoconf):
+
+   #define EV_STANDALONE 1
+   #include "ev.c"
+
+This will automatically include F<ev.h>, too, and should be done in a
+single C source file only to provide the function implementations. To use
+it, do the same for F<ev.h> in all files wishing to use this API (best
+done by writing a wrapper around F<ev.h> that you can include instead and
+where you can put other configuration options):
+
+   #define EV_STANDALONE 1
+   #include "ev.h"
+
+Both header files and implementation files can be compiled with a C++
+compiler (at least, that's a stated goal, and breakage will be treated
+as a bug).
+
+You need the following files in your source tree, or in a directory
+in your include path (e.g. in libev/ when using -Ilibev):
+
+   ev.h
+   ev.c
+   ev_vars.h
+   ev_wrap.h
+
+   ev_win32.c      required on win32 platforms only
+
+   ev_select.c     only when select backend is enabled (which is enabled by default)
+   ev_poll.c       only when poll backend is enabled (disabled by default)
+   ev_epoll.c      only when the epoll backend is enabled (disabled by default)
+   ev_kqueue.c     only when the kqueue backend is enabled (disabled by default)
+   ev_port.c       only when the solaris port backend is enabled (disabled by default)
+
+F<ev.c> includes the backend files directly when enabled, so you only need
+to compile this single file.
+
+=head3 LIBEVENT COMPATIBILITY API
+
+To include the libevent compatibility API, also include:
+
+   #include "event.c"
+
+in the file including F<ev.c>, and:
+
+   #include "event.h"
+
+in the files that want to use the libevent API. This also includes F<ev.h>.
+
+You need the following additional files for this:
+
+   event.h
+   event.c
+
+=head3 AUTOCONF SUPPORT
+
+Instead of using C<EV_STANDALONE=1> and providing your configuration in
+whatever way you want, you can also C<m4_include([libev.m4])> in your
+F<configure.ac> and leave C<EV_STANDALONE> undefined. F<ev.c> will then
+include F<config.h> and configure itself accordingly.
+
+For this of course you need the m4 file:
+
+   libev.m4
+
+=head2 PREPROCESSOR SYMBOLS/MACROS
+
+Libev can be configured via a variety of preprocessor symbols you have to
+define before including (or compiling) any of its files. The default in
+the absence of autoconf is documented for every option.
+
+Symbols marked with "(h)" do not change the ABI, and can have different
+values when compiling libev vs. including F<ev.h>, so it is permissible
+to redefine them before including F<ev.h> without breaking compatibility
+to a compiled library. All other symbols change the ABI, which means all
+users of libev and the libev code itself must be compiled with compatible
+settings.
+
+=over 4
+
+=item EV_COMPAT3 (h)
+
+Backwards compatibility is a major concern for libev. This is why this
+release of libev comes with wrappers for the functions and symbols that
+have been renamed between libev version 3 and 4.
+
+You can disable these wrappers (to test compatibility with future
+versions) by defining C<EV_COMPAT3> to C<0> when compiling your
+sources. This has the additional advantage that you can drop the C<struct>
+from C<struct ev_loop> declarations, as libev will provide an C<ev_loop>
+typedef in that case.
+
+In some future version, the default for C<EV_COMPAT3> will become C<0>,
+and in some even more future version the compatibility code will be
+removed completely.
+
+=item EV_STANDALONE (h)
+
+Must always be C<1> if you do not use autoconf configuration, which
+keeps libev from including F<config.h>, and it also defines dummy
+implementations for some libevent functions (such as logging, which is not
+supported). It will also not define any of the structs usually found in
+F<event.h> that are not directly supported by the libev core alone.
+
+In standalone mode, libev will still try to automatically deduce the
+configuration, but has to be more conservative.
+
+=item EV_USE_FLOOR
+
+If defined to be C<1>, libev will use the C<floor ()> function for its
+periodic reschedule calculations, otherwise libev will fall back on a
+portable (slower) implementation. If you enable this, you usually have to
+link against libm or something equivalent. Enabling this when the C<floor>
+function is not available will fail, so the safe default is to not enable
+this.
+
+=item EV_USE_MONOTONIC
+
+If defined to be C<1>, libev will try to detect the availability of the
+monotonic clock option at both compile time and runtime. Otherwise no
+use of the monotonic clock option will be attempted. If you enable this,
+you usually have to link against librt or something similar. Enabling it
+when the functionality isn't available is safe, though, although you have
+to make sure you link against any libraries where the C<clock_gettime>
+function is hiding in (often F<-lrt>). See also C<EV_USE_CLOCK_SYSCALL>.
+
+=item EV_USE_REALTIME
+
+If defined to be C<1>, libev will try to detect the availability of the
+real-time clock option at compile time (and assume its availability
+at runtime if successful). Otherwise no use of the real-time clock
+option will be attempted. This effectively replaces C<gettimeofday>
+by C<clock_get (CLOCK_REALTIME, ...)> and will not normally affect
+correctness. See the note about libraries in the description of
+C<EV_USE_MONOTONIC>, though. Defaults to the opposite value of
+C<EV_USE_CLOCK_SYSCALL>.
+
+=item EV_USE_CLOCK_SYSCALL
+
+If defined to be C<1>, libev will try to use a direct syscall instead
+of calling the system-provided C<clock_gettime> function. This option
+exists because on GNU/Linux, C<clock_gettime> is in C<librt>, but C<librt>
+unconditionally pulls in C<libpthread>, slowing down single-threaded
+programs needlessly. Using a direct syscall is slightly slower (in
+theory), because no optimised vdso implementation can be used, but avoids
+the pthread dependency. Defaults to C<1> on GNU/Linux with glibc 2.x or
+higher, as it simplifies linking (no need for C<-lrt>).
+
+=item EV_USE_NANOSLEEP
+
+If defined to be C<1>, libev will assume that C<nanosleep ()> is available
+and will use it for delays. Otherwise it will use C<select ()>.
+
+=item EV_USE_EVENTFD
+
+If defined to be C<1>, then libev will assume that C<eventfd ()> is
+available and will probe for kernel support at runtime. This will improve
+C<ev_signal> and C<ev_async> performance and reduce resource consumption.
+If undefined, it will be enabled if the headers indicate GNU/Linux + Glibc
+2.7 or newer, otherwise disabled.
+
+=item EV_USE_SELECT
+
+If undefined or defined to be C<1>, libev will compile in support for the
+C<select>(2) backend. No attempt at auto-detection will be done: if no
+other method takes over, select will be it. Otherwise the select backend
+will not be compiled in.
+
+=item EV_SELECT_USE_FD_SET
+
+If defined to C<1>, then the select backend will use the system C<fd_set>
+structure. This is useful if libev doesn't compile due to a missing
+C<NFDBITS> or C<fd_mask> definition or it mis-guesses the bitset layout
+on exotic systems. This usually limits the range of file descriptors to
+some low limit such as 1024 or might have other limitations (winsocket
+only allows 64 sockets). The C<FD_SETSIZE> macro, set before compilation,
+configures the maximum size of the C<fd_set>.
+
+=item EV_SELECT_IS_WINSOCKET
+
+When defined to C<1>, the select backend will assume that
+select/socket/connect etc. don't understand file descriptors but
+wants osf handles on win32 (this is the case when the select to
+be used is the winsock select). This means that it will call
+C<_get_osfhandle> on the fd to convert it to an OS handle. Otherwise,
+it is assumed that all these functions actually work on fds, even
+on win32. Should not be defined on non-win32 platforms.
+
+=item EV_FD_TO_WIN32_HANDLE(fd)
+
+If C<EV_SELECT_IS_WINSOCKET> is enabled, then libev needs a way to map
+file descriptors to socket handles. When not defining this symbol (the
+default), then libev will call C<_get_osfhandle>, which is usually
+correct. In some cases, programs use their own file descriptor management,
+in which case they can provide this function to map fds to socket handles.
+
+=item EV_WIN32_HANDLE_TO_FD(handle)
+
+If C<EV_SELECT_IS_WINSOCKET> then libev maps handles to file descriptors
+using the standard C<_open_osfhandle> function. For programs implementing
+their own fd to handle mapping, overwriting this function makes it easier
+to do so. This can be done by defining this macro to an appropriate value.
+
+=item EV_WIN32_CLOSE_FD(fd)
+
+If programs implement their own fd to handle mapping on win32, then this
+macro can be used to override the C<close> function, useful to unregister
+file descriptors again. Note that the replacement function has to close
+the underlying OS handle.
+
+=item EV_USE_WSASOCKET
+
+If defined to be C<1>, libev will use C<WSASocket> to create its internal
+communication socket, which works better in some environments. Otherwise,
+the normal C<socket> function will be used, which works better in other
+environments.
+
+=item EV_USE_POLL
+
+If defined to be C<1>, libev will compile in support for the C<poll>(2)
+backend. Otherwise it will be enabled on non-win32 platforms. It
+takes precedence over select.
+
+=item EV_USE_EPOLL
+
+If defined to be C<1>, libev will compile in support for the Linux
+C<epoll>(7) backend. Its availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for GNU/Linux systems. If undefined, it will be enabled if the
+headers indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
+
+=item EV_USE_KQUEUE
+
+If defined to be C<1>, libev will compile in support for the BSD style
+C<kqueue>(2) backend. Its actual availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for BSD and BSD-like systems, although on most BSDs kqueue only
+supports some types of fds correctly (the only platform we found that
+supports ptys for example was NetBSD), so kqueue might be compiled in, but
+not be used unless explicitly requested. The best way to use it is to find
+out whether kqueue supports your type of fd properly and use an embedded
+kqueue loop.
+
+=item EV_USE_PORT
+
+If defined to be C<1>, libev will compile in support for the Solaris
+10 port style backend. Its availability will be detected at runtime,
+otherwise another method will be used as fallback. This is the preferred
+backend for Solaris 10 systems.
+
+=item EV_USE_DEVPOLL
+
+Reserved for future expansion, works like the USE symbols above.
+
+=item EV_USE_INOTIFY
+
+If defined to be C<1>, libev will compile in support for the Linux inotify
+interface to speed up C<ev_stat> watchers. Its actual availability will
+be detected at runtime. If undefined, it will be enabled if the headers
+indicate GNU/Linux + Glibc 2.4 or newer, otherwise disabled.
+
+=item EV_NO_SMP
+
+If defined to be C<1>, libev will assume that memory is always coherent
+between threads, that is, threads can be used, but threads never run on
+different cpus (or different cpu cores). This reduces dependencies
+and makes libev faster.
+
+=item EV_NO_THREADS
+
+If defined to be C<1>, libev will assume that it will never be called from
+different threads (that includes signal handlers), which is a stronger
+assumption than C<EV_NO_SMP>, above. This reduces dependencies and makes
+libev faster.
+
+=item EV_ATOMIC_T
+
+Libev requires an integer type (suitable for storing C<0> or C<1>) whose
+access is atomic with respect to other threads or signal contexts. No
+such type is easily found in the C language, so you can provide your own
+type that you know is safe for your purposes. It is used both for signal
+handler "locking" as well as for signal and thread safety in C<ev_async>
+watchers.
+
+In the absence of this define, libev will use C<sig_atomic_t volatile>
+(from F<signal.h>), which is usually good enough on most platforms.
+
+=item EV_H (h)
+
+The name of the F<ev.h> header file used to include it. The default if
+undefined is C<"ev.h"> in F<event.h>, F<ev.c> and F<ev++.h>. This can be
+used to virtually rename the F<ev.h> header file in case of conflicts.
+
+=item EV_CONFIG_H (h)
+
+If C<EV_STANDALONE> isn't C<1>, this variable can be used to override
+F<ev.c>'s idea of where to find the F<config.h> file, similarly to
+C<EV_H>, above.
+
+=item EV_EVENT_H (h)
+
+Similarly to C<EV_H>, this macro can be used to override F<event.c>'s idea
+of how the F<event.h> header can be found, the default is C<"event.h">.
+
+=item EV_PROTOTYPES (h)
+
+If defined to be C<0>, then F<ev.h> will not define any function
+prototypes, but still define all the structs and other symbols. This is
+occasionally useful if you want to provide your own wrapper functions
+around libev functions.
+
+=item EV_MULTIPLICITY
+
+If undefined or defined to C<1>, then all event-loop-specific functions
+will have the C<struct ev_loop *> as first argument, and you can create
+additional independent event loops. Otherwise there will be no support
+for multiple event loops and there is no first event loop pointer
+argument. Instead, all functions act on the single default loop.
+
+Note that C<EV_DEFAULT> and C<EV_DEFAULT_> will no longer provide a
+default loop when multiplicity is switched off - you always have to
+initialise the loop manually in this case.
+
+=item EV_MINPRI
+
+=item EV_MAXPRI
+
+The range of allowed priorities. C<EV_MINPRI> must be smaller or equal to
+C<EV_MAXPRI>, but otherwise there are no non-obvious limitations. You can
+provide for more priorities by overriding those symbols (usually defined
+to be C<-2> and C<2>, respectively).
+
+When doing priority-based operations, libev usually has to linearly search
+all the priorities, so having many of them (hundreds) uses a lot of space
+and time, so using the defaults of five priorities (-2 .. +2) is usually
+fine.
+
+If your embedding application does not need any priorities, defining these
+both to C<0> will save some memory and CPU.
+
+=item EV_PERIODIC_ENABLE, EV_IDLE_ENABLE, EV_EMBED_ENABLE, EV_STAT_ENABLE,
+EV_PREPARE_ENABLE, EV_CHECK_ENABLE, EV_FORK_ENABLE, EV_SIGNAL_ENABLE,
+EV_ASYNC_ENABLE, EV_CHILD_ENABLE.
+
+If undefined or defined to be C<1> (and the platform supports it), then
+the respective watcher type is supported. If defined to be C<0>, then it
+is not. Disabling watcher types mainly saves code size.
+
+=item EV_FEATURES
+
+If you need to shave off some kilobytes of code at the expense of some
+speed (but with the full API), you can define this symbol to request
+certain subsets of functionality. The default is to enable all features
+that can be enabled on the platform.
+
+A typical way to use this symbol is to define it to C<0> (or to a bitset
+with some broad features you want) and then selectively re-enable
+additional parts you want, for example if you want everything minimal,
+but multiple event loop support, async and child watchers and the poll
+backend, use this:
+
+   #define EV_FEATURES 0
+   #define EV_MULTIPLICITY 1
+   #define EV_USE_POLL 1
+   #define EV_CHILD_ENABLE 1
+   #define EV_ASYNC_ENABLE 1
+
+The actual value is a bitset, it can be a combination of the following
+values (by default, all of these are enabled):
+
+=over 4
+
+=item C<1> - faster/larger code
+
+Use larger code to speed up some operations.
+
+Currently this is used to override some inlining decisions (enlarging the
+code size by roughly 30% on amd64).
+
+When optimising for size, use of compiler flags such as C<-Os> with
+gcc is recommended, as well as C<-DNDEBUG>, as libev contains a number of
+assertions.
+
+The default is off when C<__OPTIMIZE_SIZE__> is defined by your compiler
+(e.g. gcc with C<-Os>).
+
+=item C<2> - faster/larger data structures
+
+Replaces the small 2-heap for timer management by a faster 4-heap, larger
+hash table sizes and so on. This will usually further increase code size
+and can additionally have an effect on the size of data structures at
+runtime.
+
+The default is off when C<__OPTIMIZE_SIZE__> is defined by your compiler
+(e.g. gcc with C<-Os>).
+
+=item C<4> - full API configuration
+
+This enables priorities (sets C<EV_MAXPRI>=2 and C<EV_MINPRI>=-2), and
+enables multiplicity (C<EV_MULTIPLICITY>=1).
+
+=item C<8> - full API
+
+This enables a lot of the "lesser used" API functions. See C<ev.h> for
+details on which parts of the API are still available without this
+feature, and do not complain if this subset changes over time.
+
+=item C<16> - enable all optional watcher types
+
+Enables all optional watcher types.  If you want to selectively enable
+only some watcher types other than I/O and timers (e.g. prepare,
+embed, async, child...) you can enable them manually by defining
+C<EV_watchertype_ENABLE> to C<1> instead.
+
+=item C<32> - enable all backends
+
+This enables all backends - without this feature, you need to enable at
+least one backend manually (C<EV_USE_SELECT> is a good choice).
+
+=item C<64> - enable OS-specific "helper" APIs
+
+Enable inotify, eventfd, signalfd and similar OS-specific helper APIs by
+default.
+
+=back
+
+Compiling with C<gcc -Os -DEV_STANDALONE -DEV_USE_EPOLL=1 -DEV_FEATURES=0>
+reduces the compiled size of libev from 24.7Kb code/2.8Kb data to 6.5Kb
+code/0.3Kb data on my GNU/Linux amd64 system, while still giving you I/O
+watchers, timers and monotonic clock support.
+
+With an intelligent-enough linker (gcc+binutils are intelligent enough
+when you use C<-Wl,--gc-sections -ffunction-sections>) functions unused by
+your program might be left out as well - a binary starting a timer and an
+I/O watcher then might come out at only 5Kb.
+
+=item EV_API_STATIC
+
+If this symbol is defined (by default it is not), then all identifiers
+will have static linkage. This means that libev will not export any
+identifiers, and you cannot link against libev anymore. This can be useful
+when you embed libev, only want to use libev functions in a single file,
+and do not want its identifiers to be visible.
+
+To use this, define C<EV_API_STATIC> and include F<ev.c> in the file that
+wants to use libev.
+
+This option only works when libev is compiled with a C compiler, as C++
+doesn't support the required declaration syntax.
+
+=item EV_AVOID_STDIO
+
+If this is set to C<1> at compiletime, then libev will avoid using stdio
+functions (printf, scanf, perror etc.). This will increase the code size
+somewhat, but if your program doesn't otherwise depend on stdio and your
+libc allows it, this avoids linking in the stdio library which is quite
+big.
+
+Note that error messages might become less precise when this option is
+enabled.
+
+=item EV_NSIG
+
+The highest supported signal number, +1 (or, the number of
+signals): Normally, libev tries to deduce the maximum number of signals
+automatically, but sometimes this fails, in which case it can be
+specified. Also, using a lower number than detected (C<32> should be
+good for about any system in existence) can save some memory, as libev
+statically allocates some 12-24 bytes per signal number.
+
+=item EV_PID_HASHSIZE
+
+C<ev_child> watchers use a small hash table to distribute workload by
+pid. The default size is C<16> (or C<1> with C<EV_FEATURES> disabled),
+usually more than enough. If you need to manage thousands of children you
+might want to increase this value (I<must> be a power of two).
+
+=item EV_INOTIFY_HASHSIZE
+
+C<ev_stat> watchers use a small hash table to distribute workload by
+inotify watch id. The default size is C<16> (or C<1> with C<EV_FEATURES>
+disabled), usually more than enough. If you need to manage thousands of
+C<ev_stat> watchers you might want to increase this value (I<must> be a
+power of two).
+
+=item EV_USE_4HEAP
+
+Heaps are not very cache-efficient. To improve the cache-efficiency of the
+timer and periodics heaps, libev uses a 4-heap when this symbol is defined
+to C<1>. The 4-heap uses more complicated (longer) code but has noticeably
+faster performance with many (thousands) of watchers.
+
+The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
+will be C<0>.
+
+=item EV_HEAP_CACHE_AT
+
+Heaps are not very cache-efficient. To improve the cache-efficiency of the
+timer and periodics heaps, libev can cache the timestamp (I<at>) within
+the heap structure (selected by defining C<EV_HEAP_CACHE_AT> to C<1>),
+which uses 8-12 bytes more per watcher and a few hundred bytes more code,
+but avoids random read accesses on heap changes. This improves performance
+noticeably with many (hundreds) of watchers.
+
+The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
+will be C<0>.
+
+=item EV_VERIFY
+
+Controls how much internal verification (see C<ev_verify ()>) will
+be done: If set to C<0>, no internal verification code will be compiled
+in. If set to C<1>, then verification code will be compiled in, but not
+called. If set to C<2>, then the internal verification code will be
+called once per loop, which can slow down libev. If set to C<3>, then the
+verification code will be called very frequently, which will slow down
+libev considerably.
+
+The default is C<1>, unless C<EV_FEATURES> overrides it, in which case it
+will be C<0>.
+
+=item EV_COMMON
+
+By default, all watchers have a C<void *data> member. By redefining
+this macro to something else you can include more and other types of
+members. You have to define it each time you include one of the files,
+though, and it must be identical each time.
+
+For example, the perl EV module uses something like this:
+
+   #define EV_COMMON                       \
+     SV *self; /* contains this struct */  \
+     SV *cb_sv, *fh /* note no trailing ";" */
+
+=item EV_CB_DECLARE (type)
+
+=item EV_CB_INVOKE (watcher, revents)
+
+=item ev_set_cb (ev, cb)
+
+Can be used to change the callback member declaration in each watcher,
+and the way callbacks are invoked and set. Must expand to a struct member
+definition and a statement, respectively. See the F<ev.h> header file for
+their default definitions. One possible use for overriding these is to
+avoid the C<struct ev_loop *> as first argument in all cases, or to use
+method calls instead of plain function calls in C++.
+
+=back
+
+=head2 EXPORTED API SYMBOLS
+
+If you need to re-export the API (e.g. via a DLL) and you need a list of
+exported symbols, you can use the provided F<Symbol.*> files which list
+all public symbols, one per line:
+
+   Symbols.ev      for libev proper
+   Symbols.event   for the libevent emulation
+
+This can also be used to rename all public symbols to avoid clashes with
+multiple versions of libev linked together (which is obviously bad in
+itself, but sometimes it is inconvenient to avoid this).
+
+A sed command like this will create wrapper C<#define>'s that you need to
+include before including F<ev.h>:
+
+   <Symbols.ev sed -e "s/.*/#define & myprefix_&/" >wrap.h
+
+This would create a file F<wrap.h> which essentially looks like this:
+
+   #define ev_backend     myprefix_ev_backend
+   #define ev_check_start myprefix_ev_check_start
+   #define ev_check_stop  myprefix_ev_check_stop
+   ...
+
+=head2 EXAMPLES
+
+For a real-world example of a program the includes libev
+verbatim, you can have a look at the EV perl module
+(L<http://software.schmorp.de/pkg/EV.html>). It has the libev files in
+the F<libev/> subdirectory and includes them in the F<EV/EVAPI.h> (public
+interface) and F<EV.xs> (implementation) files. Only the F<EV.xs> file
+will be compiled. It is pretty complex because it provides its own header
+file.
+
+The usage in rxvt-unicode is simpler. It has a F<ev_cpp.h> header file
+that everybody includes and which overrides some configure choices:
+
+   #define EV_FEATURES 8
+   #define EV_USE_SELECT 1
+   #define EV_PREPARE_ENABLE 1
+   #define EV_IDLE_ENABLE 1
+   #define EV_SIGNAL_ENABLE 1
+   #define EV_CHILD_ENABLE 1
+   #define EV_USE_STDEXCEPT 0
+   #define EV_CONFIG_H <config.h>
+
+   #include "ev++.h"
+
+And a F<ev_cpp.C> implementation file that contains libev proper and is compiled:
+
+   #include "ev_cpp.h"
+   #include "ev.c"
+
+=head1 INTERACTION WITH OTHER PROGRAMS, LIBRARIES OR THE ENVIRONMENT
+
+=head2 THREADS AND COROUTINES
+
+=head3 THREADS
+
+All libev functions are reentrant and thread-safe unless explicitly
+documented otherwise, but libev implements no locking itself. This means
+that you can use as many loops as you want in parallel, as long as there
+are no concurrent calls into any libev function with the same loop
+parameter (C<ev_default_*> calls have an implicit default loop parameter,
+of course): libev guarantees that different event loops share no data
+structures that need any locking.
+
+Or to put it differently: calls with different loop parameters can be done
+concurrently from multiple threads, calls with the same loop parameter
+must be done serially (but can be done from different threads, as long as
+only one thread ever is inside a call at any point in time, e.g. by using
+a mutex per loop).
+
+Specifically to support threads (and signal handlers), libev implements
+so-called C<ev_async> watchers, which allow some limited form of
+concurrency on the same event loop, namely waking it up "from the
+outside".
+
+If you want to know which design (one loop, locking, or multiple loops
+without or something else still) is best for your problem, then I cannot
+help you, but here is some generic advice:
+
+=over 4
+
+=item * most applications have a main thread: use the default libev loop
+in that thread, or create a separate thread running only the default loop.
+
+This helps integrating other libraries or software modules that use libev
+themselves and don't care/know about threading.
+
+=item * one loop per thread is usually a good model.
+
+Doing this is almost never wrong, sometimes a better-performance model
+exists, but it is always a good start.
+
+=item * other models exist, such as the leader/follower pattern, where one
+loop is handed through multiple threads in a kind of round-robin fashion.
+
+Choosing a model is hard - look around, learn, know that usually you can do
+better than you currently do :-)
+
+=item * often you need to talk to some other thread which blocks in the
+event loop.
+
+C<ev_async> watchers can be used to wake them up from other threads safely
+(or from signal contexts...).
+
+An example use would be to communicate signals or other events that only
+work in the default loop by registering the signal watcher with the
+default loop and triggering an C<ev_async> watcher from the default loop
+watcher callback into the event loop interested in the signal.
+
+=back
+
+See also L</THREAD LOCKING EXAMPLE>.
+
+=head3 COROUTINES
+
+Libev is very accommodating to coroutines ("cooperative threads"):
+libev fully supports nesting calls to its functions from different
+coroutines (e.g. you can call C<ev_run> on the same loop from two
+different coroutines, and switch freely between both coroutines running
+the loop, as long as you don't confuse yourself). The only exception is
+that you must not do this from C<ev_periodic> reschedule callbacks.
+
+Care has been taken to ensure that libev does not keep local state inside
+C<ev_run>, and other calls do not usually allow for coroutine switches as
+they do not call any callbacks.
+
+=head2 COMPILER WARNINGS
+
+Depending on your compiler and compiler settings, you might get no or a
+lot of warnings when compiling libev code. Some people are apparently
+scared by this.
+
+However, these are unavoidable for many reasons. For one, each compiler
+has different warnings, and each user has different tastes regarding
+warning options. "Warn-free" code therefore cannot be a goal except when
+targeting a specific compiler and compiler-version.
+
+Another reason is that some compiler warnings require elaborate
+workarounds, or other changes to the code that make it less clear and less
+maintainable.
+
+And of course, some compiler warnings are just plain stupid, or simply
+wrong (because they don't actually warn about the condition their message
+seems to warn about). For example, certain older gcc versions had some
+warnings that resulted in an extreme number of false positives. These have
+been fixed, but some people still insist on making code warn-free with
+such buggy versions.
+
+While libev is written to generate as few warnings as possible,
+"warn-free" code is not a goal, and it is recommended not to build libev
+with any compiler warnings enabled unless you are prepared to cope with
+them (e.g. by ignoring them). Remember that warnings are just that:
+warnings, not errors, or proof of bugs.
+
+
+=head2 VALGRIND
+
+Valgrind has a special section here because it is a popular tool that is
+highly useful. Unfortunately, valgrind reports are very hard to interpret.
+
+If you think you found a bug (memory leak, uninitialised data access etc.)
+in libev, then check twice: If valgrind reports something like:
+
+   ==2274==    definitely lost: 0 bytes in 0 blocks.
+   ==2274==      possibly lost: 0 bytes in 0 blocks.
+   ==2274==    still reachable: 256 bytes in 1 blocks.
+
+Then there is no memory leak, just as memory accounted to global variables
+is not a memleak - the memory is still being referenced, and didn't leak.
+
+Similarly, under some circumstances, valgrind might report kernel bugs
+as if it were a bug in libev (e.g. in realloc or in the poll backend,
+although an acceptable workaround has been found here), or it might be
+confused.
+
+Keep in mind that valgrind is a very good tool, but only a tool. Don't
+make it into some kind of religion.
+
+If you are unsure about something, feel free to contact the mailing list
+with the full valgrind report and an explanation on why you think this
+is a bug in libev (best check the archives, too :). However, don't be
+annoyed when you get a brisk "this is no bug" answer and take the chance
+of learning how to interpret valgrind properly.
+
+If you need, for some reason, empty reports from valgrind for your project
+I suggest using suppression lists.
+
+
+=head1 PORTABILITY NOTES
+
+=head2 GNU/LINUX 32 BIT LIMITATIONS
+
+GNU/Linux is the only common platform that supports 64 bit file/large file
+interfaces but I<disables> them by default.
+
+That means that libev compiled in the default environment doesn't support
+files larger than 2GiB or so, which mainly affects C<ev_stat> watchers.
+
+Unfortunately, many programs try to work around this GNU/Linux issue
+by enabling the large file API, which makes them incompatible with the
+standard libev compiled for their system.
+
+Likewise, libev cannot enable the large file API itself as this would
+suddenly make it incompatible to the default compile time environment,
+i.e. all programs not using special compile switches.
+
+=head2 OS/X AND DARWIN BUGS
+
+The whole thing is a bug if you ask me - basically any system interface
+you touch is broken, whether it is locales, poll, kqueue or even the
+OpenGL drivers.
+
+=head3 C<kqueue> is buggy
+
+The kqueue syscall is broken in all known versions - most versions support
+only sockets, many support pipes.
+
+Libev tries to work around this by not using C<kqueue> by default on this
+rotten platform, but of course you can still ask for it when creating a
+loop - embedding a socket-only kqueue loop into a select-based one is
+probably going to work well.
+
+=head3 C<poll> is buggy
+
+Instead of fixing C<kqueue>, Apple replaced their (working) C<poll>
+implementation by something calling C<kqueue> internally around the 10.5.6
+release, so now C<kqueue> I<and> C<poll> are broken.
+
+Libev tries to work around this by not using C<poll> by default on
+this rotten platform, but of course you can still ask for it when creating
+a loop.
+
+=head3 C<select> is buggy
+
+All that's left is C<select>, and of course Apple found a way to fuck this
+one up as well: On OS/X, C<select> actively limits the number of file
+descriptors you can pass in to 1024 - your program suddenly crashes when
+you use more.
+
+There is an undocumented "workaround" for this - defining
+C<_DARWIN_UNLIMITED_SELECT>, which libev tries to use, so select I<should>
+work on OS/X.
+
+=head2 SOLARIS PROBLEMS AND WORKAROUNDS
+
+=head3 C<errno> reentrancy
+
+The default compile environment on Solaris is unfortunately so
+thread-unsafe that you can't even use components/libraries compiled
+without C<-D_REENTRANT> in a threaded program, which, of course, isn't
+defined by default. A valid, if stupid, implementation choice.
+
+If you want to use libev in threaded environments you have to make sure
+it's compiled with C<_REENTRANT> defined.
+
+=head3 Event port backend
+
+The scalable event interface for Solaris is called "event
+ports". Unfortunately, this mechanism is very buggy in all major
+releases. If you run into high CPU usage, your program freezes or you get
+a large number of spurious wakeups, make sure you have all the relevant
+and latest kernel patches applied. No, I don't know which ones, but there
+are multiple ones to apply, and afterwards, event ports actually work
+great.
+
+If you can't get it to work, you can try running the program by setting
+the environment variable C<LIBEV_FLAGS=3> to only allow C<poll> and
+C<select> backends.
+
+=head2 AIX POLL BUG
+
+AIX unfortunately has a broken C<poll.h> header. Libev works around
+this by trying to avoid the poll backend altogether (i.e. it's not even
+compiled in), which normally isn't a big problem as C<select> works fine
+with large bitsets on AIX, and AIX is dead anyway.
+
+=head2 WIN32 PLATFORM LIMITATIONS AND WORKAROUNDS
+
+=head3 General issues
+
+Win32 doesn't support any of the standards (e.g. POSIX) that libev
+requires, and its I/O model is fundamentally incompatible with the POSIX
+model. Libev still offers limited functionality on this platform in
+the form of the C<EVBACKEND_SELECT> backend, and only supports socket
+descriptors. This only applies when using Win32 natively, not when using
+e.g. cygwin. Actually, it only applies to the microsofts own compilers,
+as every compiler comes with a slightly differently broken/incompatible
+environment.
+
+Lifting these limitations would basically require the full
+re-implementation of the I/O system. If you are into this kind of thing,
+then note that glib does exactly that for you in a very portable way (note
+also that glib is the slowest event library known to man).
+
+There is no supported compilation method available on windows except
+embedding it into other applications.
+
+Sensible signal handling is officially unsupported by Microsoft - libev
+tries its best, but under most conditions, signals will simply not work.
+
+Not a libev limitation but worth mentioning: windows apparently doesn't
+accept large writes: instead of resulting in a partial write, windows will
+either accept everything or return C<ENOBUFS> if the buffer is too large,
+so make sure you only write small amounts into your sockets (less than a
+megabyte seems safe, but this apparently depends on the amount of memory
+available).
+
+Due to the many, low, and arbitrary limits on the win32 platform and
+the abysmal performance of winsockets, using a large number of sockets
+is not recommended (and not reasonable). If your program needs to use
+more than a hundred or so sockets, then likely it needs to use a totally
+different implementation for windows, as libev offers the POSIX readiness
+notification model, which cannot be implemented efficiently on windows
+(due to Microsoft monopoly games).
+
+A typical way to use libev under windows is to embed it (see the embedding
+section for details) and use the following F<evwrap.h> header file instead
+of F<ev.h>:
+
+   #define EV_STANDALONE              /* keeps ev from requiring config.h */
+   #define EV_SELECT_IS_WINSOCKET 1   /* configure libev for windows select */
+
+   #include "ev.h"
+
+And compile the following F<evwrap.c> file into your project (make sure
+you do I<not> compile the F<ev.c> or any other embedded source files!):
+
+   #include "evwrap.h"
+   #include "ev.c"
+
+=head3 The winsocket C<select> function
+
+The winsocket C<select> function doesn't follow POSIX in that it
+requires socket I<handles> and not socket I<file descriptors> (it is
+also extremely buggy). This makes select very inefficient, and also
+requires a mapping from file descriptors to socket handles (the Microsoft
+C runtime provides the function C<_open_osfhandle> for this). See the
+discussion of the C<EV_SELECT_USE_FD_SET>, C<EV_SELECT_IS_WINSOCKET> and
+C<EV_FD_TO_WIN32_HANDLE> preprocessor symbols for more info.
+
+The configuration for a "naked" win32 using the Microsoft runtime
+libraries and raw winsocket select is:
+
+   #define EV_USE_SELECT 1
+   #define EV_SELECT_IS_WINSOCKET 1   /* forces EV_SELECT_USE_FD_SET, too */
+
+Note that winsockets handling of fd sets is O(n), so you can easily get a
+complexity in the O(n²) range when using win32.
+
+=head3 Limited number of file descriptors
+
+Windows has numerous arbitrary (and low) limits on things.
+
+Early versions of winsocket's select only supported waiting for a maximum
+of C<64> handles (probably owning to the fact that all windows kernels
+can only wait for C<64> things at the same time internally; Microsoft
+recommends spawning a chain of threads and wait for 63 handles and the
+previous thread in each. Sounds great!).
+
+Newer versions support more handles, but you need to define C<FD_SETSIZE>
+to some high number (e.g. C<2048>) before compiling the winsocket select
+call (which might be in libev or elsewhere, for example, perl and many
+other interpreters do their own select emulation on windows).
+
+Another limit is the number of file descriptors in the Microsoft runtime
+libraries, which by default is C<64> (there must be a hidden I<64>
+fetish or something like this inside Microsoft). You can increase this
+by calling C<_setmaxstdio>, which can increase this limit to C<2048>
+(another arbitrary limit), but is broken in many versions of the Microsoft
+runtime libraries. This might get you to about C<512> or C<2048> sockets
+(depending on windows version and/or the phase of the moon). To get more,
+you need to wrap all I/O functions and provide your own fd management, but
+the cost of calling select (O(n²)) will likely make this unworkable.
+
+=head2 PORTABILITY REQUIREMENTS
+
+In addition to a working ISO-C implementation and of course the
+backend-specific APIs, libev relies on a few additional extensions:
+
+=over 4
+
+=item C<void (*)(ev_watcher_type *, int revents)> must have compatible
+calling conventions regardless of C<ev_watcher_type *>.
+
+Libev assumes not only that all watcher pointers have the same internal
+structure (guaranteed by POSIX but not by ISO C for example), but it also
+assumes that the same (machine) code can be used to call any watcher
+callback: The watcher callbacks have different type signatures, but libev
+calls them using an C<ev_watcher *> internally.
+
+=item pointer accesses must be thread-atomic
+
+Accessing a pointer value must be atomic, it must both be readable and
+writable in one piece - this is the case on all current architectures.
+
+=item C<sig_atomic_t volatile> must be thread-atomic as well
+
+The type C<sig_atomic_t volatile> (or whatever is defined as
+C<EV_ATOMIC_T>) must be atomic with respect to accesses from different
+threads. This is not part of the specification for C<sig_atomic_t>, but is
+believed to be sufficiently portable.
+
+=item C<sigprocmask> must work in a threaded environment
+
+Libev uses C<sigprocmask> to temporarily block signals. This is not
+allowed in a threaded program (C<pthread_sigmask> has to be used). Typical
+pthread implementations will either allow C<sigprocmask> in the "main
+thread" or will block signals process-wide, both behaviours would
+be compatible with libev. Interaction between C<sigprocmask> and
+C<pthread_sigmask> could complicate things, however.
+
+The most portable way to handle signals is to block signals in all threads
+except the initial one, and run the signal handling loop in the initial
+thread as well.
+
+=item C<long> must be large enough for common memory allocation sizes
+
+To improve portability and simplify its API, libev uses C<long> internally
+instead of C<size_t> when allocating its data structures. On non-POSIX
+systems (Microsoft...) this might be unexpectedly low, but is still at
+least 31 bits everywhere, which is enough for hundreds of millions of
+watchers.
+
+=item C<double> must hold a time value in seconds with enough accuracy
+
+The type C<double> is used to represent timestamps. It is required to
+have at least 51 bits of mantissa (and 9 bits of exponent), which is
+good enough for at least into the year 4000 with millisecond accuracy
+(the design goal for libev). This requirement is overfulfilled by
+implementations using IEEE 754, which is basically all existing ones.
+
+With IEEE 754 doubles, you get microsecond accuracy until at least the
+year 2255 (and millisecond accuracy till the year 287396 - by then, libev
+is either obsolete or somebody patched it to use C<long double> or
+something like that, just kidding).
+
+=back
+
+If you know of other additional requirements drop me a note.
+
+
+=head1 ALGORITHMIC COMPLEXITIES
+
+In this section the complexities of (many of) the algorithms used inside
+libev will be documented. For complexity discussions about backends see
+the documentation for C<ev_default_init>.
+
+All of the following are about amortised time: If an array needs to be
+extended, libev needs to realloc and move the whole array, but this
+happens asymptotically rarer with higher number of elements, so O(1) might
+mean that libev does a lengthy realloc operation in rare cases, but on
+average it is much faster and asymptotically approaches constant time.
+
+=over 4
+
+=item Starting and stopping timer/periodic watchers: O(log skipped_other_timers)
+
+This means that, when you have a watcher that triggers in one hour and
+there are 100 watchers that would trigger before that, then inserting will
+have to skip roughly seven (C<ld 100>) of these watchers.
+
+=item Changing timer/periodic watchers (by autorepeat or calling again): O(log skipped_other_timers)
+
+That means that changing a timer costs less than removing/adding them,
+as only the relative motion in the event queue has to be paid for.
+
+=item Starting io/check/prepare/idle/signal/child/fork/async watchers: O(1)
+
+These just add the watcher into an array or at the head of a list.
+
+=item Stopping check/prepare/idle/fork/async watchers: O(1)
+
+=item Stopping an io/signal/child watcher: O(number_of_watchers_for_this_(fd/signal/pid % EV_PID_HASHSIZE))
+
+These watchers are stored in lists, so they need to be walked to find the
+correct watcher to remove. The lists are usually short (you don't usually
+have many watchers waiting for the same fd or signal: one is typical, two
+is rare).
+
+=item Finding the next timer in each loop iteration: O(1)
+
+By virtue of using a binary or 4-heap, the next timer is always found at a
+fixed position in the storage array.
+
+=item Each change on a file descriptor per loop iteration: O(number_of_watchers_for_this_fd)
+
+A change means an I/O watcher gets started or stopped, which requires
+libev to recalculate its status (and possibly tell the kernel, depending
+on backend and whether C<ev_io_set> was used).
+
+=item Activating one watcher (putting it into the pending state): O(1)
+
+=item Priority handling: O(number_of_priorities)
+
+Priorities are implemented by allocating some space for each
+priority. When doing priority-based operations, libev usually has to
+linearly search all the priorities, but starting/stopping and activating
+watchers becomes O(1) with respect to priority handling.
+
+=item Sending an ev_async: O(1)
+
+=item Processing ev_async_send: O(number_of_async_watchers)
+
+=item Processing signals: O(max_signal_number)
+
+Sending involves a system call I<iff> there were no other C<ev_async_send>
+calls in the current loop iteration and the loop is currently
+blocked. Checking for async and signal events involves iterating over all
+running async watchers or all signal numbers.
+
+=back
+
+
+=head1 PORTING FROM LIBEV 3.X TO 4.X
+
+The major version 4 introduced some incompatible changes to the API.
+
+At the moment, the C<ev.h> header file provides compatibility definitions
+for all changes, so most programs should still compile. The compatibility
+layer might be removed in later versions of libev, so better update to the
+new API early than late.
+
+=over 4
+
+=item C<EV_COMPAT3> backwards compatibility mechanism
+
+The backward compatibility mechanism can be controlled by
+C<EV_COMPAT3>. See L</"PREPROCESSOR SYMBOLS/MACROS"> in the L</EMBEDDING>
+section.
+
+=item C<ev_default_destroy> and C<ev_default_fork> have been removed
+
+These calls can be replaced easily by their C<ev_loop_xxx> counterparts:
+
+   ev_loop_destroy (EV_DEFAULT_UC);
+   ev_loop_fork (EV_DEFAULT);
+
+=item function/symbol renames
+
+A number of functions and symbols have been renamed:
+
+  ev_loop         => ev_run
+  EVLOOP_NONBLOCK => EVRUN_NOWAIT
+  EVLOOP_ONESHOT  => EVRUN_ONCE
+
+  ev_unloop       => ev_break
+  EVUNLOOP_CANCEL => EVBREAK_CANCEL
+  EVUNLOOP_ONE    => EVBREAK_ONE
+  EVUNLOOP_ALL    => EVBREAK_ALL
+
+  EV_TIMEOUT      => EV_TIMER
+
+  ev_loop_count   => ev_iteration
+  ev_loop_depth   => ev_depth
+  ev_loop_verify  => ev_verify
+
+Most functions working on C<struct ev_loop> objects don't have an
+C<ev_loop_> prefix, so it was removed; C<ev_loop>, C<ev_unloop> and
+associated constants have been renamed to not collide with the C<struct
+ev_loop> anymore and C<EV_TIMER> now follows the same naming scheme
+as all other watcher types. Note that C<ev_loop_fork> is still called
+C<ev_loop_fork> because it would otherwise clash with the C<ev_fork>
+typedef.
+
+=item C<EV_MINIMAL> mechanism replaced by C<EV_FEATURES>
+
+The preprocessor symbol C<EV_MINIMAL> has been replaced by a different
+mechanism, C<EV_FEATURES>. Programs using C<EV_MINIMAL> usually compile
+and work, but the library code will of course be larger.
+
+=back
+
+
+=head1 GLOSSARY
+
+=over 4
+
+=item active
+
+A watcher is active as long as it has been started and not yet stopped.
+See L</WATCHER STATES> for details.
+
+=item application
+
+In this document, an application is whatever is using libev.
+
+=item backend
+
+The part of the code dealing with the operating system interfaces.
+
+=item callback
+
+The address of a function that is called when some event has been
+detected. Callbacks are being passed the event loop, the watcher that
+received the event, and the actual event bitset.
+
+=item callback/watcher invocation
+
+The act of calling the callback associated with a watcher.
+
+=item event
+
+A change of state of some external event, such as data now being available
+for reading on a file descriptor, time having passed or simply not having
+any other events happening anymore.
+
+In libev, events are represented as single bits (such as C<EV_READ> or
+C<EV_TIMER>).
+
+=item event library
+
+A software package implementing an event model and loop.
+
+=item event loop
+
+An entity that handles and processes external events and converts them
+into callback invocations.
+
+=item event model
+
+The model used to describe how an event loop handles and processes
+watchers and events.
+
+=item pending
+
+A watcher is pending as soon as the corresponding event has been
+detected. See L</WATCHER STATES> for details.
+
+=item real time
+
+The physical time that is observed. It is apparently strictly monotonic :)
+
+=item wall-clock time
+
+The time and date as shown on clocks. Unlike real time, it can actually
+be wrong and jump forwards and backwards, e.g. when you adjust your
+clock.
+
+=item watcher
+
+A data structure that describes interest in certain events. Watchers need
+to be started (attached to an event loop) before they can receive events.
+
+=back
+
+=head1 AUTHOR
+
+Marc Lehmann <libev@schmorp.de>, with repeated corrections by Mikael
+Magnusson and Emanuele Giaquinta, and minor corrections by many others.
+
diff --git a/release/src/router/libev-4.22/ev_epoll.c b/release/src/router/libev-4.22/ev_epoll.c
new file mode 100644
index 0000000000..a1f04f6a49
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_epoll.c
@@ -0,0 +1,282 @@
+/*
+ * libev epoll fd activity backend
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+/*
+ * general notes about epoll:
+ *
+ * a) epoll silently removes fds from the fd set. as nothing tells us
+ *    that an fd has been removed otherwise, we have to continually
+ *    "rearm" fds that we suspect *might* have changed (same
+ *    problem with kqueue, but much less costly there).
+ * b) the fact that ADD != MOD creates a lot of extra syscalls due to a)
+ *    and seems not to have any advantage.
+ * c) the inability to handle fork or file descriptors (think dup)
+ *    limits the applicability over poll, so this is not a generic
+ *    poll replacement.
+ * d) epoll doesn't work the same as select with many file descriptors
+ *    (such as files). while not critical, no other advanced interface
+ *    seems to share this (rather non-unixy) limitation.
+ * e) epoll claims to be embeddable, but in practise you never get
+ *    a ready event for the epoll fd (broken: <=2.6.26, working: >=2.6.32).
+ * f) epoll_ctl returning EPERM means the fd is always ready.
+ *
+ * lots of "weird code" and complication handling in this file is due
+ * to these design problems with epoll, as we try very hard to avoid
+ * epoll_ctl syscalls for common usage patterns and handle the breakage
+ * ensuing from receiving events for closed and otherwise long gone
+ * file descriptors.
+ */
+
+#include <sys/epoll.h>
+
+#define EV_EMASK_EPERM 0x80
+
+static void
+epoll_modify (EV_P_ int fd, int oev, int nev)
+{
+  struct epoll_event ev;
+  unsigned char oldmask;
+
+  /*
+   * we handle EPOLL_CTL_DEL by ignoring it here
+   * on the assumption that the fd is gone anyways
+   * if that is wrong, we have to handle the spurious
+   * event in epoll_poll.
+   * if the fd is added again, we try to ADD it, and, if that
+   * fails, we assume it still has the same eventmask.
+   */
+  if (!nev)
+    return;
+
+  oldmask = anfds [fd].emask;
+  anfds [fd].emask = nev;
+
+  /* store the generation counter in the upper 32 bits, the fd in the lower 32 bits */
+  ev.data.u64 = (uint64_t)(uint32_t)fd
+              | ((uint64_t)(uint32_t)++anfds [fd].egen << 32);
+  ev.events   = (nev & EV_READ  ? EPOLLIN  : 0)
+              | (nev & EV_WRITE ? EPOLLOUT : 0);
+
+  if (expect_true (!epoll_ctl (backend_fd, oev && oldmask != nev ? EPOLL_CTL_MOD : EPOLL_CTL_ADD, fd, &ev)))
+    return;
+
+  if (expect_true (errno == ENOENT))
+    {
+      /* if ENOENT then the fd went away, so try to do the right thing */
+      if (!nev)
+        goto dec_egen;
+
+      if (!epoll_ctl (backend_fd, EPOLL_CTL_ADD, fd, &ev))
+        return;
+    }
+  else if (expect_true (errno == EEXIST))
+    {
+      /* EEXIST means we ignored a previous DEL, but the fd is still active */
+      /* if the kernel mask is the same as the new mask, we assume it hasn't changed */
+      if (oldmask == nev)
+        goto dec_egen;
+
+      if (!epoll_ctl (backend_fd, EPOLL_CTL_MOD, fd, &ev))
+        return;
+    }
+  else if (expect_true (errno == EPERM))
+    {
+      /* EPERM means the fd is always ready, but epoll is too snobbish */
+      /* to handle it, unlike select or poll. */
+      anfds [fd].emask = EV_EMASK_EPERM;
+
+      /* add fd to epoll_eperms, if not already inside */
+      if (!(oldmask & EV_EMASK_EPERM))
+        {
+          array_needsize (int, epoll_eperms, epoll_epermmax, epoll_epermcnt + 1, EMPTY2);
+          epoll_eperms [epoll_epermcnt++] = fd;
+        }
+
+      return;
+    }
+
+  fd_kill (EV_A_ fd);
+
+dec_egen:
+  /* we didn't successfully call epoll_ctl, so decrement the generation counter again */
+  --anfds [fd].egen;
+}
+
+static void
+epoll_poll (EV_P_ ev_tstamp timeout)
+{
+  int i;
+  int eventcnt;
+
+  if (expect_false (epoll_epermcnt))
+    timeout = 0.;
+
+  /* epoll wait times cannot be larger than (LONG_MAX - 999UL) / HZ msecs, which is below */
+  /* the default libev max wait time, however. */
+  EV_RELEASE_CB;
+  eventcnt = epoll_wait (backend_fd, epoll_events, epoll_eventmax, timeout * 1e3);
+  EV_ACQUIRE_CB;
+
+  if (expect_false (eventcnt < 0))
+    {
+      if (errno != EINTR)
+        ev_syserr ("(libev) epoll_wait");
+
+      return;
+    }
+
+  for (i = 0; i < eventcnt; ++i)
+    {
+      struct epoll_event *ev = epoll_events + i;
+
+      int fd = (uint32_t)ev->data.u64; /* mask out the lower 32 bits */
+      int want = anfds [fd].events;
+      int got  = (ev->events & (EPOLLOUT | EPOLLERR | EPOLLHUP) ? EV_WRITE : 0)
+               | (ev->events & (EPOLLIN  | EPOLLERR | EPOLLHUP) ? EV_READ  : 0);
+
+      /*
+       * check for spurious notification.
+       * this only finds spurious notifications on egen updates
+       * other spurious notifications will be found by epoll_ctl, below
+       * we assume that fd is always in range, as we never shrink the anfds array
+       */
+      if (expect_false ((uint32_t)anfds [fd].egen != (uint32_t)(ev->data.u64 >> 32)))
+        {
+          /* recreate kernel state */
+          postfork |= 2;
+          continue;
+        }
+
+      if (expect_false (got & ~want))
+        {
+          anfds [fd].emask = want;
+
+          /*
+           * we received an event but are not interested in it, try mod or del
+           * this often happens because we optimistically do not unregister fds
+           * when we are no longer interested in them, but also when we get spurious
+           * notifications for fds from another process. this is partially handled
+           * above with the gencounter check (== our fd is not the event fd), and
+           * partially here, when epoll_ctl returns an error (== a child has the fd
+           * but we closed it).
+           */
+          ev->events = (want & EV_READ  ? EPOLLIN  : 0)
+                     | (want & EV_WRITE ? EPOLLOUT : 0);
+
+          /* pre-2.6.9 kernels require a non-null pointer with EPOLL_CTL_DEL, */
+          /* which is fortunately easy to do for us. */
+          if (epoll_ctl (backend_fd, want ? EPOLL_CTL_MOD : EPOLL_CTL_DEL, fd, ev))
+            {
+              postfork |= 2; /* an error occurred, recreate kernel state */
+              continue;
+            }
+        }
+
+      fd_event (EV_A_ fd, got);
+    }
+
+  /* if the receive array was full, increase its size */
+  if (expect_false (eventcnt == epoll_eventmax))
+    {
+      ev_free (epoll_events);
+      epoll_eventmax = array_nextsize (sizeof (struct epoll_event), epoll_eventmax, epoll_eventmax + 1);
+      epoll_events = (struct epoll_event *)ev_malloc (sizeof (struct epoll_event) * epoll_eventmax);
+    }
+
+  /* now synthesize events for all fds where epoll fails, while select works... */
+  for (i = epoll_epermcnt; i--; )
+    {
+      int fd = epoll_eperms [i];
+      unsigned char events = anfds [fd].events & (EV_READ | EV_WRITE);
+
+      if (anfds [fd].emask & EV_EMASK_EPERM && events)
+        fd_event (EV_A_ fd, events);
+      else
+        {
+          epoll_eperms [i] = epoll_eperms [--epoll_epermcnt];
+          anfds [fd].emask = 0;
+        }
+    }
+}
+
+int inline_size
+epoll_init (EV_P_ int flags)
+{
+#ifdef EPOLL_CLOEXEC
+  backend_fd = epoll_create1 (EPOLL_CLOEXEC);
+
+  if (backend_fd < 0 && (errno == EINVAL || errno == ENOSYS))
+#endif
+    backend_fd = epoll_create (256);
+
+  if (backend_fd < 0)
+    return 0;
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
+
+  backend_mintime = 1e-3; /* epoll does sometimes return early, this is just to avoid the worst */
+  backend_modify  = epoll_modify;
+  backend_poll    = epoll_poll;
+
+  epoll_eventmax = 64; /* initial number of events receivable per poll */
+  epoll_events = (struct epoll_event *)ev_malloc (sizeof (struct epoll_event) * epoll_eventmax);
+
+  return EVBACKEND_EPOLL;
+}
+
+void inline_size
+epoll_destroy (EV_P)
+{
+  ev_free (epoll_events);
+  array_free (epoll_eperm, EMPTY);
+}
+
+void inline_size
+epoll_fork (EV_P)
+{
+  close (backend_fd);
+
+  while ((backend_fd = epoll_create (256)) < 0)
+    ev_syserr ("(libev) epoll_create");
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
+
+  fd_rearm_all (EV_A);
+}
+
diff --git a/release/src/router/libev-4.22/ev_kqueue.c b/release/src/router/libev-4.22/ev_kqueue.c
new file mode 100644
index 0000000000..27def23d43
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_kqueue.c
@@ -0,0 +1,214 @@
+/*
+ * libev kqueue backend
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/event.h>
+#include <string.h>
+#include <errno.h>
+
+void inline_speed
+kqueue_change (EV_P_ int fd, int filter, int flags, int fflags)
+{
+  ++kqueue_changecnt;
+  array_needsize (struct kevent, kqueue_changes, kqueue_changemax, kqueue_changecnt, EMPTY2);
+
+  EV_SET (&kqueue_changes [kqueue_changecnt - 1], fd, filter, flags, fflags, 0, 0);
+}
+
+/* OS X at least needs this */
+#ifndef EV_ENABLE
+# define EV_ENABLE 0
+#endif
+#ifndef NOTE_EOF
+# define NOTE_EOF 0
+#endif
+
+static void
+kqueue_modify (EV_P_ int fd, int oev, int nev)
+{
+  if (oev != nev)
+    {
+      if (oev & EV_READ)
+        kqueue_change (EV_A_ fd, EVFILT_READ , EV_DELETE, 0);
+
+      if (oev & EV_WRITE)
+        kqueue_change (EV_A_ fd, EVFILT_WRITE, EV_DELETE, 0);
+    }
+
+  /* to detect close/reopen reliably, we have to re-add */
+  /* event requests even when oev == nev */
+
+  if (nev & EV_READ)
+    kqueue_change (EV_A_ fd, EVFILT_READ , EV_ADD | EV_ENABLE, NOTE_EOF);
+
+  if (nev & EV_WRITE)
+    kqueue_change (EV_A_ fd, EVFILT_WRITE, EV_ADD | EV_ENABLE, NOTE_EOF);
+}
+
+static void
+kqueue_poll (EV_P_ ev_tstamp timeout)
+{
+  int res, i;
+  struct timespec ts;
+
+  /* need to resize so there is enough space for errors */
+  if (kqueue_changecnt > kqueue_eventmax)
+    {
+      ev_free (kqueue_events);
+      kqueue_eventmax = array_nextsize (sizeof (struct kevent), kqueue_eventmax, kqueue_changecnt);
+      kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);
+    }
+
+  EV_RELEASE_CB;
+  EV_TS_SET (ts, timeout);
+  res = kevent (backend_fd, kqueue_changes, kqueue_changecnt, kqueue_events, kqueue_eventmax, &ts);
+  EV_ACQUIRE_CB;
+  kqueue_changecnt = 0;
+
+  if (expect_false (res < 0))
+    {
+      if (errno != EINTR)
+        ev_syserr ("(libev) kevent");
+
+      return;
+    }
+
+  for (i = 0; i < res; ++i)
+    {
+      int fd = kqueue_events [i].ident;
+
+      if (expect_false (kqueue_events [i].flags & EV_ERROR))
+        {
+          int err = kqueue_events [i].data;
+
+          /* we are only interested in errors for fds that we are interested in :) */
+          if (anfds [fd].events)
+            {
+              if (err == ENOENT) /* resubmit changes on ENOENT */
+                kqueue_modify (EV_A_ fd, 0, anfds [fd].events);
+              else if (err == EBADF) /* on EBADF, we re-check the fd */
+                {
+                  if (fd_valid (fd))
+                    kqueue_modify (EV_A_ fd, 0, anfds [fd].events);
+                  else
+                    fd_kill (EV_A_ fd);
+                }
+              else /* on all other errors, we error out on the fd */
+                fd_kill (EV_A_ fd);
+            }
+        }
+      else
+        fd_event (
+          EV_A_
+          fd,
+          kqueue_events [i].filter == EVFILT_READ ? EV_READ
+          : kqueue_events [i].filter == EVFILT_WRITE ? EV_WRITE
+          : 0
+        );
+    }
+
+  if (expect_false (res == kqueue_eventmax))
+    {
+      ev_free (kqueue_events);
+      kqueue_eventmax = array_nextsize (sizeof (struct kevent), kqueue_eventmax, kqueue_eventmax + 1);
+      kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);
+    }
+}
+
+int inline_size
+kqueue_init (EV_P_ int flags)
+{
+  /* initialize the kernel queue */
+  kqueue_fd_pid = getpid ();
+  if ((backend_fd = kqueue ()) < 0)
+    return 0;
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC); /* not sure if necessary, hopefully doesn't hurt */
+
+  backend_mintime = 1e-9; /* apparently, they did the right thing in freebsd */
+  backend_modify  = kqueue_modify;
+  backend_poll    = kqueue_poll;
+
+  kqueue_eventmax = 64; /* initial number of events receivable per poll */
+  kqueue_events = (struct kevent *)ev_malloc (sizeof (struct kevent) * kqueue_eventmax);
+
+  kqueue_changes   = 0;
+  kqueue_changemax = 0;
+  kqueue_changecnt = 0;
+
+  return EVBACKEND_KQUEUE;
+}
+
+void inline_size
+kqueue_destroy (EV_P)
+{
+  ev_free (kqueue_events);
+  ev_free (kqueue_changes);
+}
+
+void inline_size
+kqueue_fork (EV_P)
+{
+  /* some BSD kernels don't just destroy the kqueue itself,
+   * but also close the fd, which isn't documented, and
+   * impossible to support properly.
+   * we remember the pid of the kqueue call and only close
+   * the fd if the pid is still the same.
+   * this leaks fds on sane kernels, but BSD interfaces are
+   * notoriously buggy and rarely get fixed.
+   */
+  pid_t newpid = getpid ();
+
+  if (newpid == kqueue_fd_pid)
+    close (backend_fd);
+
+  kqueue_fd_pid = newpid;
+  while ((backend_fd = kqueue ()) < 0)
+    ev_syserr ("(libev) kqueue");
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
+
+  /* re-register interest in fds */
+  fd_rearm_all (EV_A);
+}
+
+/* sys/event.h defines EV_ERROR */
+#undef EV_ERROR
+
diff --git a/release/src/router/libev-4.22/ev_poll.c b/release/src/router/libev-4.22/ev_poll.c
new file mode 100644
index 0000000000..48323516dd
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_poll.c
@@ -0,0 +1,148 @@
+/*
+ * libev poll fd activity backend
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#include <poll.h>
+
+void inline_size
+pollidx_init (int *base, int count)
+{
+  /* consider using memset (.., -1, ...), which is practically guaranteed
+   * to work on all systems implementing poll */
+  while (count--)
+    *base++ = -1;
+}
+
+static void
+poll_modify (EV_P_ int fd, int oev, int nev)
+{
+  int idx;
+
+  if (oev == nev)
+    return;
+
+  array_needsize (int, pollidxs, pollidxmax, fd + 1, pollidx_init);
+
+  idx = pollidxs [fd];
+
+  if (idx < 0) /* need to allocate a new pollfd */
+    {
+      pollidxs [fd] = idx = pollcnt++;
+      array_needsize (struct pollfd, polls, pollmax, pollcnt, EMPTY2);
+      polls [idx].fd = fd;
+    }
+
+  assert (polls [idx].fd == fd);
+
+  if (nev)
+    polls [idx].events =
+        (nev & EV_READ ? POLLIN : 0)
+        | (nev & EV_WRITE ? POLLOUT : 0);
+  else /* remove pollfd */
+    {
+      pollidxs [fd] = -1;
+
+      if (expect_true (idx < --pollcnt))
+        {
+          polls [idx] = polls [pollcnt];
+          pollidxs [polls [idx].fd] = idx;
+        }
+    }
+}
+
+static void
+poll_poll (EV_P_ ev_tstamp timeout)
+{
+  struct pollfd *p;
+  int res;
+  
+  EV_RELEASE_CB;
+  res = poll (polls, pollcnt, timeout * 1e3);
+  EV_ACQUIRE_CB;
+
+  if (expect_false (res < 0))
+    {
+      if (errno == EBADF)
+        fd_ebadf (EV_A);
+      else if (errno == ENOMEM && !syserr_cb)
+        fd_enomem (EV_A);
+      else if (errno != EINTR)
+        ev_syserr ("(libev) poll");
+    }
+  else
+    for (p = polls; res; ++p)
+      {
+        assert (("libev: poll() returned illegal result, broken BSD kernel?", p < polls + pollcnt));
+
+        if (expect_false (p->revents)) /* this expect is debatable */
+          {
+            --res;
+
+            if (expect_false (p->revents & POLLNVAL))
+              fd_kill (EV_A_ p->fd);
+            else
+              fd_event (
+                EV_A_
+                p->fd,
+                (p->revents & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)
+                | (p->revents & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)
+              );
+          }
+      }
+}
+
+int inline_size
+poll_init (EV_P_ int flags)
+{
+  backend_mintime = 1e-3;
+  backend_modify  = poll_modify;
+  backend_poll    = poll_poll;
+
+  pollidxs = 0; pollidxmax = 0;
+  polls    = 0; pollmax    = 0; pollcnt = 0;
+
+  return EVBACKEND_POLL;
+}
+
+void inline_size
+poll_destroy (EV_P)
+{
+  ev_free (pollidxs);
+  ev_free (polls);
+}
+
diff --git a/release/src/router/libev-4.22/ev_port.c b/release/src/router/libev-4.22/ev_port.c
new file mode 100644
index 0000000000..9368501cd5
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_port.c
@@ -0,0 +1,185 @@
+/*
+ * libev solaris event port backend
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+/* useful reading:
+ *
+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6268715 (random results)
+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6455223 (just totally broken)
+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6873782 (manpage ETIME)
+ * http://bugs.opensolaris.org/view_bug.do?bug_id=6874410 (implementation ETIME)
+ * http://www.mail-archive.com/networking-discuss@opensolaris.org/msg11898.html ETIME vs. nget
+ * http://src.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/lib/libc/port/gen/event_port.c (libc)
+ * http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/usr/src/uts/common/fs/portfs/port.c#1325 (kernel)
+ */
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <poll.h>
+#include <port.h>
+#include <string.h>
+#include <errno.h>
+
+void inline_speed
+port_associate_and_check (EV_P_ int fd, int ev)
+{
+  if (0 >
+      port_associate (
+         backend_fd, PORT_SOURCE_FD, fd,
+         (ev & EV_READ ? POLLIN : 0)
+         | (ev & EV_WRITE ? POLLOUT : 0),
+         0
+      )
+  )
+    {
+      if (errno == EBADFD)
+        fd_kill (EV_A_ fd);
+      else
+        ev_syserr ("(libev) port_associate");
+    }
+}
+
+static void
+port_modify (EV_P_ int fd, int oev, int nev)
+{
+  /* we need to reassociate no matter what, as closes are
+   * once more silently being discarded.
+   */
+  if (!nev)
+    {
+      if (oev)
+        port_dissociate (backend_fd, PORT_SOURCE_FD, fd);
+    }
+  else
+    port_associate_and_check (EV_A_ fd, nev);
+}
+
+static void
+port_poll (EV_P_ ev_tstamp timeout)
+{
+  int res, i;
+  struct timespec ts;
+  uint_t nget = 1;
+
+  /* we initialise this to something we will skip in the loop, as */
+  /* port_getn can return with nget unchanged, but no indication */
+  /* whether it was the original value or has been updated :/ */
+  port_events [0].portev_source = 0;
+
+  EV_RELEASE_CB;
+  EV_TS_SET (ts, timeout);
+  res = port_getn (backend_fd, port_events, port_eventmax, &nget, &ts);
+  EV_ACQUIRE_CB;
+
+  /* port_getn may or may not set nget on error */
+  /* so we rely on port_events [0].portev_source not being updated */
+  if (res == -1 && errno != ETIME && errno != EINTR)
+    ev_syserr ("(libev) port_getn (see http://bugs.opensolaris.org/view_bug.do?bug_id=6268715, try LIBEV_FLAGS=3 env variable)");
+
+  for (i = 0; i < nget; ++i)
+    {
+      if (port_events [i].portev_source == PORT_SOURCE_FD)
+        {
+          int fd = port_events [i].portev_object;
+
+          fd_event (
+            EV_A_
+            fd,
+            (port_events [i].portev_events & (POLLOUT | POLLERR | POLLHUP) ? EV_WRITE : 0)
+            | (port_events [i].portev_events & (POLLIN | POLLERR | POLLHUP) ? EV_READ : 0)
+          );
+
+          fd_change (EV_A_ fd, EV__IOFDSET);
+        }
+    }
+
+  if (expect_false (nget == port_eventmax))
+    {
+      ev_free (port_events);
+      port_eventmax = array_nextsize (sizeof (port_event_t), port_eventmax, port_eventmax + 1);
+      port_events = (port_event_t *)ev_malloc (sizeof (port_event_t) * port_eventmax);
+    }
+}
+
+int inline_size
+port_init (EV_P_ int flags)
+{
+  /* Initialize the kernel queue */
+  if ((backend_fd = port_create ()) < 0)
+    return 0;
+
+  assert (("libev: PORT_SOURCE_FD must not be zero", PORT_SOURCE_FD));
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC); /* not sure if necessary, hopefully doesn't hurt */
+
+  /* if my reading of the opensolaris kernel sources are correct, then
+   * opensolaris does something very stupid: it checks if the time has already
+   * elapsed and doesn't round up if that is the case,m otherwise it DOES round
+   * up. Since we can't know what the case is, we need to guess by using a
+   * "large enough" timeout. Normally, 1e-9 would be correct.
+   */
+  backend_mintime = 1e-3; /* needed to compensate for port_getn returning early */
+  backend_modify  = port_modify;
+  backend_poll    = port_poll;
+
+  port_eventmax = 64; /* initial number of events receivable per poll */
+  port_events = (port_event_t *)ev_malloc (sizeof (port_event_t) * port_eventmax);
+
+  return EVBACKEND_PORT;
+}
+
+void inline_size
+port_destroy (EV_P)
+{
+  ev_free (port_events);
+}
+
+void inline_size
+port_fork (EV_P)
+{
+  close (backend_fd);
+
+  while ((backend_fd = port_create ()) < 0)
+    ev_syserr ("(libev) port");
+
+  fcntl (backend_fd, F_SETFD, FD_CLOEXEC);
+
+  /* re-register interest in fds */
+  fd_rearm_all (EV_A);
+}
+
diff --git a/release/src/router/libev-4.22/ev_select.c b/release/src/router/libev-4.22/ev_select.c
new file mode 100644
index 0000000000..f38d6ca3e0
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_select.c
@@ -0,0 +1,314 @@
+/*
+ * libev select fd activity backend
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef _WIN32
+/* for unix systems */
+# include <inttypes.h>
+# ifndef __hpux
+/* for REAL unix systems */
+#  include <sys/select.h>
+# endif
+#endif
+
+#ifndef EV_SELECT_USE_FD_SET
+# ifdef NFDBITS
+#  define EV_SELECT_USE_FD_SET 0
+# else
+#  define EV_SELECT_USE_FD_SET 1
+# endif
+#endif
+
+#if EV_SELECT_IS_WINSOCKET
+# undef EV_SELECT_USE_FD_SET
+# define EV_SELECT_USE_FD_SET 1
+# undef NFDBITS
+# define NFDBITS 0
+#endif
+
+#if !EV_SELECT_USE_FD_SET
+# define NFDBYTES (NFDBITS / 8)
+#endif
+
+#include <string.h>
+
+static void
+select_modify (EV_P_ int fd, int oev, int nev)
+{
+  if (oev == nev)
+    return;
+
+  {
+#if EV_SELECT_USE_FD_SET
+
+    #if EV_SELECT_IS_WINSOCKET
+    SOCKET handle = anfds [fd].handle;
+    #else
+    int handle = fd;
+    #endif
+
+    assert (("libev: fd >= FD_SETSIZE passed to fd_set-based select backend", fd < FD_SETSIZE));
+
+    /* FD_SET is broken on windows (it adds the fd to a set twice or more,
+     * which eventually leads to overflows). Need to call it only on changes.
+     */
+    #if EV_SELECT_IS_WINSOCKET
+    if ((oev ^ nev) & EV_READ)
+    #endif
+      if (nev & EV_READ)
+        FD_SET (handle, (fd_set *)vec_ri);
+      else
+        FD_CLR (handle, (fd_set *)vec_ri);
+
+    #if EV_SELECT_IS_WINSOCKET
+    if ((oev ^ nev) & EV_WRITE)
+    #endif
+      if (nev & EV_WRITE)
+        FD_SET (handle, (fd_set *)vec_wi);
+      else
+        FD_CLR (handle, (fd_set *)vec_wi);
+
+#else
+
+    int     word = fd / NFDBITS;
+    fd_mask mask = 1UL << (fd % NFDBITS);
+
+    if (expect_false (vec_max <= word))
+      {
+        int new_max = word + 1;
+
+        vec_ri = ev_realloc (vec_ri, new_max * NFDBYTES);
+        vec_ro = ev_realloc (vec_ro, new_max * NFDBYTES); /* could free/malloc */
+        vec_wi = ev_realloc (vec_wi, new_max * NFDBYTES);
+        vec_wo = ev_realloc (vec_wo, new_max * NFDBYTES); /* could free/malloc */
+        #ifdef _WIN32
+        vec_eo = ev_realloc (vec_eo, new_max * NFDBYTES); /* could free/malloc */
+        #endif
+
+        for (; vec_max < new_max; ++vec_max)
+          ((fd_mask *)vec_ri) [vec_max] =
+          ((fd_mask *)vec_wi) [vec_max] = 0;
+      }
+
+    ((fd_mask *)vec_ri) [word] |= mask;
+    if (!(nev & EV_READ))
+      ((fd_mask *)vec_ri) [word] &= ~mask;
+
+    ((fd_mask *)vec_wi) [word] |= mask;
+    if (!(nev & EV_WRITE))
+      ((fd_mask *)vec_wi) [word] &= ~mask;
+#endif
+  }
+}
+
+static void
+select_poll (EV_P_ ev_tstamp timeout)
+{
+  struct timeval tv;
+  int res;
+  int fd_setsize;
+
+  EV_RELEASE_CB;
+  EV_TV_SET (tv, timeout);
+
+#if EV_SELECT_USE_FD_SET
+  fd_setsize = sizeof (fd_set);
+#else
+  fd_setsize = vec_max * NFDBYTES;
+#endif
+
+  memcpy (vec_ro, vec_ri, fd_setsize);
+  memcpy (vec_wo, vec_wi, fd_setsize);
+
+#ifdef _WIN32
+  /* pass in the write set as except set.
+   * the idea behind this is to work around a windows bug that causes
+   * errors to be reported as an exception and not by setting
+   * the writable bit. this is so uncontrollably lame.
+   */
+  memcpy (vec_eo, vec_wi, fd_setsize);
+  res = select (vec_max * NFDBITS, (fd_set *)vec_ro, (fd_set *)vec_wo, (fd_set *)vec_eo, &tv);
+#elif EV_SELECT_USE_FD_SET
+  fd_setsize = anfdmax < FD_SETSIZE ? anfdmax : FD_SETSIZE;
+  res = select (fd_setsize, (fd_set *)vec_ro, (fd_set *)vec_wo, 0, &tv);
+#else
+  res = select (vec_max * NFDBITS, (fd_set *)vec_ro, (fd_set *)vec_wo, 0, &tv);
+#endif
+  EV_ACQUIRE_CB;
+
+  if (expect_false (res < 0))
+    {
+      #if EV_SELECT_IS_WINSOCKET
+      errno = WSAGetLastError ();
+      #endif
+      #ifdef WSABASEERR
+      /* on windows, select returns incompatible error codes, fix this */
+      if (errno >= WSABASEERR && errno < WSABASEERR + 1000)
+        if (errno == WSAENOTSOCK)
+          errno = EBADF;
+        else
+          errno -= WSABASEERR;
+      #endif
+
+      #ifdef _WIN32
+      /* select on windows erroneously returns EINVAL when no fd sets have been
+       * provided (this is documented). what microsoft doesn't tell you that this bug
+       * exists even when the fd sets _are_ provided, so we have to check for this bug
+       * here and emulate by sleeping manually.
+       * we also get EINVAL when the timeout is invalid, but we ignore this case here
+       * and assume that EINVAL always means: you have to wait manually.
+       */
+      if (errno == EINVAL)
+        {
+          if (timeout)
+            {
+              unsigned long ms = timeout * 1e3;
+              Sleep (ms ? ms : 1);
+            }
+
+          return;
+        }
+      #endif
+
+      if (errno == EBADF)
+        fd_ebadf (EV_A);
+      else if (errno == ENOMEM && !syserr_cb)
+        fd_enomem (EV_A);
+      else if (errno != EINTR)
+        ev_syserr ("(libev) select");
+
+      return;
+    }
+
+#if EV_SELECT_USE_FD_SET
+
+  {
+    int fd;
+
+    for (fd = 0; fd < anfdmax; ++fd)
+      if (anfds [fd].events)
+        {
+          int events = 0;
+          #if EV_SELECT_IS_WINSOCKET
+          SOCKET handle = anfds [fd].handle;
+          #else
+          int handle = fd;
+          #endif
+
+          if (FD_ISSET (handle, (fd_set *)vec_ro)) events |= EV_READ;
+          if (FD_ISSET (handle, (fd_set *)vec_wo)) events |= EV_WRITE;
+          #ifdef _WIN32
+          if (FD_ISSET (handle, (fd_set *)vec_eo)) events |= EV_WRITE;
+          #endif
+
+          if (expect_true (events))
+            fd_event (EV_A_ fd, events);
+        }
+  }
+
+#else
+
+  {
+    int word, bit;
+    for (word = vec_max; word--; )
+      {
+        fd_mask word_r = ((fd_mask *)vec_ro) [word];
+        fd_mask word_w = ((fd_mask *)vec_wo) [word];
+        #ifdef _WIN32
+        word_w |= ((fd_mask *)vec_eo) [word];
+        #endif
+
+        if (word_r || word_w)
+          for (bit = NFDBITS; bit--; )
+            {
+              fd_mask mask = 1UL << bit;
+              int events = 0;
+
+              events |= word_r & mask ? EV_READ  : 0;
+              events |= word_w & mask ? EV_WRITE : 0;
+
+              if (expect_true (events))
+                fd_event (EV_A_ word * NFDBITS + bit, events);
+            }
+      }
+  }
+
+#endif
+}
+
+int inline_size
+select_init (EV_P_ int flags)
+{
+  backend_mintime = 1e-6;
+  backend_modify  = select_modify;
+  backend_poll    = select_poll;
+
+#if EV_SELECT_USE_FD_SET
+  vec_ri  = ev_malloc (sizeof (fd_set)); FD_ZERO ((fd_set *)vec_ri);
+  vec_ro  = ev_malloc (sizeof (fd_set));
+  vec_wi  = ev_malloc (sizeof (fd_set)); FD_ZERO ((fd_set *)vec_wi);
+  vec_wo  = ev_malloc (sizeof (fd_set));
+  #ifdef _WIN32
+  vec_eo  = ev_malloc (sizeof (fd_set));
+  #endif
+#else
+  vec_max = 0;
+  vec_ri  = 0;
+  vec_ro  = 0;
+  vec_wi  = 0;
+  vec_wo  = 0;
+  #ifdef _WIN32
+  vec_eo  = 0;
+  #endif
+#endif
+
+  return EVBACKEND_SELECT;
+}
+
+void inline_size
+select_destroy (EV_P)
+{
+  ev_free (vec_ri);
+  ev_free (vec_ro);
+  ev_free (vec_wi);
+  ev_free (vec_wo);
+  #ifdef _WIN32
+  ev_free (vec_eo);
+  #endif
+}
+
diff --git a/release/src/router/libev-4.22/ev_vars.h b/release/src/router/libev-4.22/ev_vars.h
new file mode 100644
index 0000000000..04d4db16f5
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_vars.h
@@ -0,0 +1,204 @@
+/*
+ * loop member variable declarations
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2013 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#define VARx(type,name) VAR(name, type name)
+
+VARx(ev_tstamp, now_floor) /* last time we refreshed rt_time */
+VARx(ev_tstamp, mn_now)    /* monotonic clock "now" */
+VARx(ev_tstamp, rtmn_diff) /* difference realtime - monotonic time */
+
+/* for reverse feeding of events */
+VARx(W *, rfeeds)
+VARx(int, rfeedmax)
+VARx(int, rfeedcnt)
+
+VAR (pendings, ANPENDING *pendings [NUMPRI])
+VAR (pendingmax, int pendingmax [NUMPRI])
+VAR (pendingcnt, int pendingcnt [NUMPRI])
+VARx(int, pendingpri) /* highest priority currently pending */
+VARx(ev_prepare, pending_w) /* dummy pending watcher */
+
+VARx(ev_tstamp, io_blocktime)
+VARx(ev_tstamp, timeout_blocktime)
+
+VARx(int, backend)
+VARx(int, activecnt) /* total number of active events ("refcount") */
+VARx(EV_ATOMIC_T, loop_done)  /* signal by ev_break */
+
+VARx(int, backend_fd)
+VARx(ev_tstamp, backend_mintime) /* assumed typical timer resolution */
+VAR (backend_modify, void (*backend_modify)(EV_P_ int fd, int oev, int nev))
+VAR (backend_poll  , void (*backend_poll)(EV_P_ ev_tstamp timeout))
+
+VARx(ANFD *, anfds)
+VARx(int, anfdmax)
+
+VAR (evpipe, int evpipe [2])
+VARx(ev_io, pipe_w)
+VARx(EV_ATOMIC_T, pipe_write_wanted)
+VARx(EV_ATOMIC_T, pipe_write_skipped)
+
+#if !defined(_WIN32) || EV_GENWRAP
+VARx(pid_t, curpid)
+#endif
+
+VARx(char, postfork)  /* true if we need to recreate kernel state after fork */
+
+#if EV_USE_SELECT || EV_GENWRAP
+VARx(void *, vec_ri)
+VARx(void *, vec_ro)
+VARx(void *, vec_wi)
+VARx(void *, vec_wo)
+#if defined(_WIN32) || EV_GENWRAP
+VARx(void *, vec_eo)
+#endif
+VARx(int, vec_max)
+#endif
+
+#if EV_USE_POLL || EV_GENWRAP
+VARx(struct pollfd *, polls)
+VARx(int, pollmax)
+VARx(int, pollcnt)
+VARx(int *, pollidxs) /* maps fds into structure indices */
+VARx(int, pollidxmax)
+#endif
+
+#if EV_USE_EPOLL || EV_GENWRAP
+VARx(struct epoll_event *, epoll_events)
+VARx(int, epoll_eventmax)
+VARx(int *, epoll_eperms)
+VARx(int, epoll_epermcnt)
+VARx(int, epoll_epermmax)
+#endif
+
+#if EV_USE_KQUEUE || EV_GENWRAP
+VARx(pid_t, kqueue_fd_pid)
+VARx(struct kevent *, kqueue_changes)
+VARx(int, kqueue_changemax)
+VARx(int, kqueue_changecnt)
+VARx(struct kevent *, kqueue_events)
+VARx(int, kqueue_eventmax)
+#endif
+
+#if EV_USE_PORT || EV_GENWRAP
+VARx(struct port_event *, port_events)
+VARx(int, port_eventmax)
+#endif
+
+#if EV_USE_IOCP || EV_GENWRAP
+VARx(HANDLE, iocp)
+#endif
+
+VARx(int *, fdchanges)
+VARx(int, fdchangemax)
+VARx(int, fdchangecnt)
+
+VARx(ANHE *, timers)
+VARx(int, timermax)
+VARx(int, timercnt)
+
+#if EV_PERIODIC_ENABLE || EV_GENWRAP
+VARx(ANHE *, periodics)
+VARx(int, periodicmax)
+VARx(int, periodiccnt)
+#endif
+
+#if EV_IDLE_ENABLE || EV_GENWRAP
+VAR (idles, ev_idle **idles [NUMPRI])
+VAR (idlemax, int idlemax [NUMPRI])
+VAR (idlecnt, int idlecnt [NUMPRI])
+#endif
+VARx(int, idleall) /* total number */
+
+VARx(struct ev_prepare **, prepares)
+VARx(int, preparemax)
+VARx(int, preparecnt)
+
+VARx(struct ev_check **, checks)
+VARx(int, checkmax)
+VARx(int, checkcnt)
+
+#if EV_FORK_ENABLE || EV_GENWRAP
+VARx(struct ev_fork **, forks)
+VARx(int, forkmax)
+VARx(int, forkcnt)
+#endif
+
+#if EV_CLEANUP_ENABLE || EV_GENWRAP
+VARx(struct ev_cleanup **, cleanups)
+VARx(int, cleanupmax)
+VARx(int, cleanupcnt)
+#endif
+
+#if EV_ASYNC_ENABLE || EV_GENWRAP
+VARx(EV_ATOMIC_T, async_pending)
+VARx(struct ev_async **, asyncs)
+VARx(int, asyncmax)
+VARx(int, asynccnt)
+#endif
+
+#if EV_USE_INOTIFY || EV_GENWRAP
+VARx(int, fs_fd)
+VARx(ev_io, fs_w)
+VARx(char, fs_2625) /* whether we are running in linux 2.6.25 or newer */
+VAR (fs_hash, ANFS fs_hash [EV_INOTIFY_HASHSIZE])
+#endif
+
+VARx(EV_ATOMIC_T, sig_pending)
+#if EV_USE_SIGNALFD || EV_GENWRAP
+VARx(int, sigfd)
+VARx(ev_io, sigfd_w)
+VARx(sigset_t, sigfd_set)
+#endif
+
+VARx(unsigned int, origflags) /* original loop flags */
+
+#if EV_FEATURE_API || EV_GENWRAP
+VARx(unsigned int, loop_count) /* total number of loop iterations/blocks */
+VARx(unsigned int, loop_depth) /* #ev_run enters - #ev_run leaves */
+
+VARx(void *, userdata)
+/* C++ doesn't support the ev_loop_callback typedef here. stinks. */
+VAR (release_cb, void (*release_cb)(EV_P) EV_THROW)
+VAR (acquire_cb, void (*acquire_cb)(EV_P) EV_THROW)
+VAR (invoke_cb , ev_loop_callback invoke_cb)
+#endif
+
+#undef VARx
+
diff --git a/release/src/router/libev-4.22/ev_win32.c b/release/src/router/libev-4.22/ev_win32.c
new file mode 100644
index 0000000000..fd671356a4
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_win32.c
@@ -0,0 +1,162 @@
+/*
+ * libev win32 compatibility cruft (_not_ a backend)
+ *
+ * Copyright (c) 2007,2008,2009 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifdef _WIN32
+
+/* note: the comment below could not be substantiated, but what would I care */
+/* MSDN says this is required to handle SIGFPE */
+/* my wild guess would be that using something floating-pointy is required */
+/* for the crt to do something about it */
+volatile double SIGFPE_REQ = 0.0f;
+
+static SOCKET
+ev_tcp_socket (void)
+{
+#if EV_USE_WSASOCKET
+  return WSASocket (AF_INET, SOCK_STREAM, 0, 0, 0, 0);
+#else
+  return socket (AF_INET, SOCK_STREAM, 0);
+#endif
+}
+
+/* oh, the humanity! */
+static int
+ev_pipe (int filedes [2])
+{
+  struct sockaddr_in addr = { 0 };
+  int addr_size = sizeof (addr);
+  struct sockaddr_in adr2;
+  int adr2_size = sizeof (adr2);
+  SOCKET listener;
+  SOCKET sock [2] = { -1, -1 };
+
+  if ((listener = ev_tcp_socket ()) == INVALID_SOCKET)
+    return -1;
+
+  addr.sin_family = AF_INET;
+  addr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
+  addr.sin_port = 0;
+
+  if (bind (listener, (struct sockaddr *)&addr, addr_size))
+    goto fail;
+
+  if (getsockname (listener, (struct sockaddr *)&addr, &addr_size))
+    goto fail;
+
+  if (listen (listener, 1))
+    goto fail;
+
+  if ((sock [0] = ev_tcp_socket ()) == INVALID_SOCKET)
+    goto fail;
+
+  if (connect (sock [0], (struct sockaddr *)&addr, addr_size))
+    goto fail;
+
+  /* TODO: returns INVALID_SOCKET on winsock accept, not < 0. fix it */
+  /* when convenient, probably by just removing error checking altogether? */
+  if ((sock [1] = accept (listener, 0, 0)) < 0)
+    goto fail;
+
+  /* windows vista returns fantasy port numbers for sockets:
+   * example for two interconnected tcp sockets:
+   *
+   * (Socket::unpack_sockaddr_in getsockname $sock0)[0] == 53364
+   * (Socket::unpack_sockaddr_in getpeername $sock0)[0] == 53363
+   * (Socket::unpack_sockaddr_in getsockname $sock1)[0] == 53363
+   * (Socket::unpack_sockaddr_in getpeername $sock1)[0] == 53365
+   *
+   * wow! tridirectional sockets!
+   *
+   * this way of checking ports seems to work:
+   */
+  if (getpeername (sock [0], (struct sockaddr *)&addr, &addr_size))
+    goto fail;
+
+  if (getsockname (sock [1], (struct sockaddr *)&adr2, &adr2_size))
+    goto fail;
+
+  errno = WSAEINVAL;
+  if (addr_size != adr2_size
+      || addr.sin_addr.s_addr != adr2.sin_addr.s_addr /* just to be sure, I mean, it's windows */
+      || addr.sin_port        != adr2.sin_port)
+    goto fail;
+
+  closesocket (listener);
+
+#if EV_SELECT_IS_WINSOCKET
+  filedes [0] = EV_WIN32_HANDLE_TO_FD (sock [0]);
+  filedes [1] = EV_WIN32_HANDLE_TO_FD (sock [1]);
+#else
+  /* when select isn't winsocket, we also expect socket, connect, accept etc.
+   * to work on fds */
+  filedes [0] = sock [0];
+  filedes [1] = sock [1];
+#endif
+
+  return 0;
+
+fail:
+  closesocket (listener);
+
+  if (sock [0] != INVALID_SOCKET) closesocket (sock [0]);
+  if (sock [1] != INVALID_SOCKET) closesocket (sock [1]);
+
+  return -1;
+}
+
+#undef pipe
+#define pipe(filedes) ev_pipe (filedes)
+
+#define EV_HAVE_EV_TIME 1
+ev_tstamp
+ev_time (void)
+{
+  FILETIME ft;
+  ULARGE_INTEGER ui;
+
+  GetSystemTimeAsFileTime (&ft);
+  ui.u.LowPart  = ft.dwLowDateTime;
+  ui.u.HighPart = ft.dwHighDateTime;
+
+  /* msvc cannot convert ulonglong to double... yes, it is that sucky */
+  return (LONGLONG)(ui.QuadPart - 116444736000000000) * 1e-7;
+}
+
+#endif
+
diff --git a/release/src/router/libev-4.22/ev_wrap.h b/release/src/router/libev-4.22/ev_wrap.h
new file mode 100644
index 0000000000..ad989ea7d5
--- /dev/null
+++ b/release/src/router/libev-4.22/ev_wrap.h
@@ -0,0 +1,200 @@
+/* DO NOT EDIT, automatically generated by update_ev_wrap */
+#ifndef EV_WRAP_H
+#define EV_WRAP_H
+#define acquire_cb ((loop)->acquire_cb)
+#define activecnt ((loop)->activecnt)
+#define anfdmax ((loop)->anfdmax)
+#define anfds ((loop)->anfds)
+#define async_pending ((loop)->async_pending)
+#define asynccnt ((loop)->asynccnt)
+#define asyncmax ((loop)->asyncmax)
+#define asyncs ((loop)->asyncs)
+#define backend ((loop)->backend)
+#define backend_fd ((loop)->backend_fd)
+#define backend_mintime ((loop)->backend_mintime)
+#define backend_modify ((loop)->backend_modify)
+#define backend_poll ((loop)->backend_poll)
+#define checkcnt ((loop)->checkcnt)
+#define checkmax ((loop)->checkmax)
+#define checks ((loop)->checks)
+#define cleanupcnt ((loop)->cleanupcnt)
+#define cleanupmax ((loop)->cleanupmax)
+#define cleanups ((loop)->cleanups)
+#define curpid ((loop)->curpid)
+#define epoll_epermcnt ((loop)->epoll_epermcnt)
+#define epoll_epermmax ((loop)->epoll_epermmax)
+#define epoll_eperms ((loop)->epoll_eperms)
+#define epoll_eventmax ((loop)->epoll_eventmax)
+#define epoll_events ((loop)->epoll_events)
+#define evpipe ((loop)->evpipe)
+#define fdchangecnt ((loop)->fdchangecnt)
+#define fdchangemax ((loop)->fdchangemax)
+#define fdchanges ((loop)->fdchanges)
+#define forkcnt ((loop)->forkcnt)
+#define forkmax ((loop)->forkmax)
+#define forks ((loop)->forks)
+#define fs_2625 ((loop)->fs_2625)
+#define fs_fd ((loop)->fs_fd)
+#define fs_hash ((loop)->fs_hash)
+#define fs_w ((loop)->fs_w)
+#define idleall ((loop)->idleall)
+#define idlecnt ((loop)->idlecnt)
+#define idlemax ((loop)->idlemax)
+#define idles ((loop)->idles)
+#define invoke_cb ((loop)->invoke_cb)
+#define io_blocktime ((loop)->io_blocktime)
+#define iocp ((loop)->iocp)
+#define kqueue_changecnt ((loop)->kqueue_changecnt)
+#define kqueue_changemax ((loop)->kqueue_changemax)
+#define kqueue_changes ((loop)->kqueue_changes)
+#define kqueue_eventmax ((loop)->kqueue_eventmax)
+#define kqueue_events ((loop)->kqueue_events)
+#define kqueue_fd_pid ((loop)->kqueue_fd_pid)
+#define loop_count ((loop)->loop_count)
+#define loop_depth ((loop)->loop_depth)
+#define loop_done ((loop)->loop_done)
+#define mn_now ((loop)->mn_now)
+#define now_floor ((loop)->now_floor)
+#define origflags ((loop)->origflags)
+#define pending_w ((loop)->pending_w)
+#define pendingcnt ((loop)->pendingcnt)
+#define pendingmax ((loop)->pendingmax)
+#define pendingpri ((loop)->pendingpri)
+#define pendings ((loop)->pendings)
+#define periodiccnt ((loop)->periodiccnt)
+#define periodicmax ((loop)->periodicmax)
+#define periodics ((loop)->periodics)
+#define pipe_w ((loop)->pipe_w)
+#define pipe_write_skipped ((loop)->pipe_write_skipped)
+#define pipe_write_wanted ((loop)->pipe_write_wanted)
+#define pollcnt ((loop)->pollcnt)
+#define pollidxmax ((loop)->pollidxmax)
+#define pollidxs ((loop)->pollidxs)
+#define pollmax ((loop)->pollmax)
+#define polls ((loop)->polls)
+#define port_eventmax ((loop)->port_eventmax)
+#define port_events ((loop)->port_events)
+#define postfork ((loop)->postfork)
+#define preparecnt ((loop)->preparecnt)
+#define preparemax ((loop)->preparemax)
+#define prepares ((loop)->prepares)
+#define release_cb ((loop)->release_cb)
+#define rfeedcnt ((loop)->rfeedcnt)
+#define rfeedmax ((loop)->rfeedmax)
+#define rfeeds ((loop)->rfeeds)
+#define rtmn_diff ((loop)->rtmn_diff)
+#define sig_pending ((loop)->sig_pending)
+#define sigfd ((loop)->sigfd)
+#define sigfd_set ((loop)->sigfd_set)
+#define sigfd_w ((loop)->sigfd_w)
+#define timeout_blocktime ((loop)->timeout_blocktime)
+#define timercnt ((loop)->timercnt)
+#define timermax ((loop)->timermax)
+#define timers ((loop)->timers)
+#define userdata ((loop)->userdata)
+#define vec_eo ((loop)->vec_eo)
+#define vec_max ((loop)->vec_max)
+#define vec_ri ((loop)->vec_ri)
+#define vec_ro ((loop)->vec_ro)
+#define vec_wi ((loop)->vec_wi)
+#define vec_wo ((loop)->vec_wo)
+#else
+#undef EV_WRAP_H
+#undef acquire_cb
+#undef activecnt
+#undef anfdmax
+#undef anfds
+#undef async_pending
+#undef asynccnt
+#undef asyncmax
+#undef asyncs
+#undef backend
+#undef backend_fd
+#undef backend_mintime
+#undef backend_modify
+#undef backend_poll
+#undef checkcnt
+#undef checkmax
+#undef checks
+#undef cleanupcnt
+#undef cleanupmax
+#undef cleanups
+#undef curpid
+#undef epoll_epermcnt
+#undef epoll_epermmax
+#undef epoll_eperms
+#undef epoll_eventmax
+#undef epoll_events
+#undef evpipe
+#undef fdchangecnt
+#undef fdchangemax
+#undef fdchanges
+#undef forkcnt
+#undef forkmax
+#undef forks
+#undef fs_2625
+#undef fs_fd
+#undef fs_hash
+#undef fs_w
+#undef idleall
+#undef idlecnt
+#undef idlemax
+#undef idles
+#undef invoke_cb
+#undef io_blocktime
+#undef iocp
+#undef kqueue_changecnt
+#undef kqueue_changemax
+#undef kqueue_changes
+#undef kqueue_eventmax
+#undef kqueue_events
+#undef kqueue_fd_pid
+#undef loop_count
+#undef loop_depth
+#undef loop_done
+#undef mn_now
+#undef now_floor
+#undef origflags
+#undef pending_w
+#undef pendingcnt
+#undef pendingmax
+#undef pendingpri
+#undef pendings
+#undef periodiccnt
+#undef periodicmax
+#undef periodics
+#undef pipe_w
+#undef pipe_write_skipped
+#undef pipe_write_wanted
+#undef pollcnt
+#undef pollidxmax
+#undef pollidxs
+#undef pollmax
+#undef polls
+#undef port_eventmax
+#undef port_events
+#undef postfork
+#undef preparecnt
+#undef preparemax
+#undef prepares
+#undef release_cb
+#undef rfeedcnt
+#undef rfeedmax
+#undef rfeeds
+#undef rtmn_diff
+#undef sig_pending
+#undef sigfd
+#undef sigfd_set
+#undef sigfd_w
+#undef timeout_blocktime
+#undef timercnt
+#undef timermax
+#undef timers
+#undef userdata
+#undef vec_eo
+#undef vec_max
+#undef vec_ri
+#undef vec_ro
+#undef vec_wi
+#undef vec_wo
+#endif
diff --git a/release/src/router/libev-4.22/event.c b/release/src/router/libev-4.22/event.c
new file mode 100644
index 0000000000..5586cd3538
--- /dev/null
+++ b/release/src/router/libev-4.22/event.c
@@ -0,0 +1,425 @@
+/*
+ * libevent compatibility layer
+ *
+ * Copyright (c) 2007,2008,2009,2010,2012 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#ifdef EV_EVENT_H
+# include EV_EVENT_H
+#else
+# include "event.h"
+#endif
+
+#if EV_MULTIPLICITY
+# define dLOOPev struct ev_loop *loop = (struct ev_loop *)ev->ev_base
+# define dLOOPbase struct ev_loop *loop = (struct ev_loop *)base
+#else
+# define dLOOPev
+# define dLOOPbase
+#endif
+
+/* never accessed, will always be cast from/to ev_loop */
+struct event_base
+{
+  int dummy;
+};
+
+static struct event_base *ev_x_cur;
+
+static ev_tstamp
+ev_tv_get (struct timeval *tv)
+{
+  if (tv)
+    {
+      ev_tstamp after = tv->tv_sec + tv->tv_usec * 1e-6;
+      return after ? after : 1e-6;
+    }
+  else
+    return -1.;
+}
+
+#define EVENT_STRINGIFY(s) # s
+#define EVENT_VERSION(a,b) EVENT_STRINGIFY (a) "." EVENT_STRINGIFY (b)
+
+const char *
+event_get_version (void)
+{
+  /* returns ABI, not API or library, version */
+  return EVENT_VERSION (EV_VERSION_MAJOR, EV_VERSION_MINOR);
+}
+
+const char *
+event_get_method (void)
+{
+  return "libev";
+}
+
+void *event_init (void)
+{
+#if EV_MULTIPLICITY
+  if (ev_x_cur)
+    ev_x_cur = (struct event_base *)ev_loop_new (EVFLAG_AUTO);
+  else
+    ev_x_cur = (struct event_base *)ev_default_loop (EVFLAG_AUTO);
+#else
+  assert (("libev: multiple event bases not supported when not compiled with EV_MULTIPLICITY", !ev_x_cur));
+
+  ev_x_cur = (struct event_base *)(long)ev_default_loop (EVFLAG_AUTO);
+#endif
+
+  return ev_x_cur;
+}
+
+const char *
+event_base_get_method (const struct event_base *base)
+{
+  return "libev";
+}
+
+struct event_base *
+event_base_new (void)
+{
+#if EV_MULTIPLICITY
+  return (struct event_base *)ev_loop_new (EVFLAG_AUTO);
+#else
+  assert (("libev: multiple event bases not supported when not compiled with EV_MULTIPLICITY"));
+  return NULL;
+#endif
+}
+
+void event_base_free (struct event_base *base)
+{
+  dLOOPbase;
+
+#if EV_MULTIPLICITY
+  if (!ev_is_default_loop (loop))
+    ev_loop_destroy (loop);
+#endif
+}
+
+int event_dispatch (void)
+{
+  return event_base_dispatch (ev_x_cur);
+}
+
+#ifdef EV_STANDALONE
+void event_set_log_callback (event_log_cb cb)
+{
+  /* nop */
+}
+#endif
+
+int event_loop (int flags)
+{
+  return event_base_loop (ev_x_cur, flags);
+}
+
+int event_loopexit (struct timeval *tv)
+{
+  return event_base_loopexit (ev_x_cur, tv);
+}
+
+event_callback_fn event_get_callback
+(const struct event *ev)
+{
+  return ev->ev_callback;
+}
+
+static void
+ev_x_cb (struct event *ev, int revents)
+{
+  revents &= EV_READ | EV_WRITE | EV_TIMER | EV_SIGNAL;
+
+  ev->ev_res = revents;
+  ev->ev_callback (ev->ev_fd, (short)revents, ev->ev_arg);
+}
+
+static void
+ev_x_cb_sig (EV_P_ struct ev_signal *w, int revents)
+{
+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, iosig.sig));
+
+  if (revents & EV_ERROR)
+    event_del (ev);
+
+  ev_x_cb (ev, revents);
+}
+
+static void
+ev_x_cb_io (EV_P_ struct ev_io *w, int revents)
+{
+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, iosig.io));
+
+  if ((revents & EV_ERROR) || !(ev->ev_events & EV_PERSIST))
+    event_del (ev);
+
+  ev_x_cb (ev, revents);
+}
+
+static void
+ev_x_cb_to (EV_P_ struct ev_timer *w, int revents)
+{
+  struct event *ev = (struct event *)(((char *)w) - offsetof (struct event, to));
+
+  event_del (ev);
+
+  ev_x_cb (ev, revents);
+}
+
+void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg)
+{
+  if (events & EV_SIGNAL)
+    ev_init (&ev->iosig.sig, ev_x_cb_sig);
+  else
+    ev_init (&ev->iosig.io, ev_x_cb_io);
+
+  ev_init (&ev->to, ev_x_cb_to);
+
+  ev->ev_base     = ev_x_cur; /* not threadsafe, but it's how libevent works */
+  ev->ev_fd       = fd;
+  ev->ev_events   = events;
+  ev->ev_pri      = 0;
+  ev->ev_callback = cb;
+  ev->ev_arg      = arg;
+  ev->ev_res      = 0;
+  ev->ev_flags    = EVLIST_INIT;
+}
+
+int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
+{
+  return event_base_once (ev_x_cur, fd, events, cb, arg, tv);
+}
+
+int event_add (struct event *ev, struct timeval *tv)
+{
+  dLOOPev;
+
+  if (ev->ev_events & EV_SIGNAL)
+    {
+      if (!ev_is_active (&ev->iosig.sig))
+        {
+          ev_signal_set (&ev->iosig.sig, ev->ev_fd);
+          ev_signal_start (EV_A_ &ev->iosig.sig);
+
+          ev->ev_flags |= EVLIST_SIGNAL;
+        }
+    }
+  else if (ev->ev_events & (EV_READ | EV_WRITE))
+    {
+      if (!ev_is_active (&ev->iosig.io))
+        {
+          ev_io_set (&ev->iosig.io, ev->ev_fd, ev->ev_events & (EV_READ | EV_WRITE));
+          ev_io_start (EV_A_ &ev->iosig.io);
+
+          ev->ev_flags |= EVLIST_INSERTED;
+        }
+    }
+
+  if (tv)
+    {
+      ev->to.repeat = ev_tv_get (tv);
+      ev_timer_again (EV_A_ &ev->to);
+      ev->ev_flags |= EVLIST_TIMEOUT;
+    }
+  else
+    {
+      ev_timer_stop (EV_A_ &ev->to);
+      ev->ev_flags &= ~EVLIST_TIMEOUT;
+    }
+
+  ev->ev_flags |= EVLIST_ACTIVE;
+
+  return 0;
+}
+
+int event_del (struct event *ev)
+{
+  dLOOPev;
+
+  if (ev->ev_events & EV_SIGNAL)
+    ev_signal_stop (EV_A_ &ev->iosig.sig);
+  else if (ev->ev_events & (EV_READ | EV_WRITE))
+    ev_io_stop (EV_A_ &ev->iosig.io);
+
+  if (ev_is_active (&ev->to))
+    ev_timer_stop (EV_A_ &ev->to);
+
+  ev->ev_flags = EVLIST_INIT;
+
+  return 0;
+}
+
+void event_active (struct event *ev, int res, short ncalls)
+{
+  dLOOPev;
+
+  if (res & EV_TIMEOUT)
+    ev_feed_event (EV_A_ &ev->to, res & EV_TIMEOUT);
+
+  if (res & EV_SIGNAL)
+    ev_feed_event (EV_A_ &ev->iosig.sig, res & EV_SIGNAL);
+
+  if (res & (EV_READ | EV_WRITE))
+    ev_feed_event (EV_A_ &ev->iosig.io, res & (EV_READ | EV_WRITE));
+}
+
+int event_pending (struct event *ev, short events, struct timeval *tv)
+{
+  short revents = 0;
+  dLOOPev;
+
+  if (ev->ev_events & EV_SIGNAL)
+    {
+      /* sig */
+      if (ev_is_active (&ev->iosig.sig) || ev_is_pending (&ev->iosig.sig))
+        revents |= EV_SIGNAL;
+    }
+  else if (ev->ev_events & (EV_READ | EV_WRITE))
+    {
+      /* io */
+      if (ev_is_active (&ev->iosig.io) || ev_is_pending (&ev->iosig.io))
+        revents |= ev->ev_events & (EV_READ | EV_WRITE);
+    }
+
+  if (ev->ev_events & EV_TIMEOUT || ev_is_active (&ev->to) || ev_is_pending (&ev->to))
+    {
+      revents |= EV_TIMEOUT;
+
+      if (tv)
+        {
+          ev_tstamp at = ev_now (EV_A);
+
+          tv->tv_sec  = (long)at;
+          tv->tv_usec = (long)((at - (ev_tstamp)tv->tv_sec) * 1e6);
+        }
+    }
+
+  return events & revents;
+}
+
+int event_priority_init (int npri)
+{
+  return event_base_priority_init (ev_x_cur, npri);
+}
+
+int event_priority_set (struct event *ev, int pri)
+{
+  ev->ev_pri = pri;
+
+  return 0;
+}
+
+int event_base_set (struct event_base *base, struct event *ev)
+{
+  ev->ev_base = base;
+
+  return 0;
+}
+
+int event_base_loop (struct event_base *base, int flags)
+{
+  dLOOPbase;
+
+  return !ev_run (EV_A_ flags);
+}
+
+int event_base_dispatch (struct event_base *base)
+{
+  return event_base_loop (base, 0);
+}
+
+static void
+ev_x_loopexit_cb (int revents, void *base)
+{
+  dLOOPbase;
+
+  ev_break (EV_A_ EVBREAK_ONE);
+}
+
+int event_base_loopexit (struct event_base *base, struct timeval *tv)
+{
+  ev_tstamp after = ev_tv_get (tv);
+  dLOOPbase;
+
+  ev_once (EV_A_ -1, 0, after >= 0. ? after : 0., ev_x_loopexit_cb, (void *)base);
+
+  return 0;
+}
+
+struct ev_x_once
+{
+  int fd;
+  void (*cb)(int, short, void *);
+  void *arg;
+};
+
+static void
+ev_x_once_cb (int revents, void *arg)
+{
+  struct ev_x_once *once = (struct ev_x_once *)arg;
+
+  once->cb (once->fd, (short)revents, once->arg);
+  free (once);
+}
+
+int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv)
+{
+  struct ev_x_once *once = (struct ev_x_once *)malloc (sizeof (struct ev_x_once));
+  dLOOPbase;
+
+  if (!once)
+    return -1;
+
+  once->fd  = fd;
+  once->cb  = cb;
+  once->arg = arg;
+
+  ev_once (EV_A_ fd, events & (EV_READ | EV_WRITE), ev_tv_get (tv), ev_x_once_cb, (void *)once);
+
+  return 0;
+}
+
+int event_base_priority_init (struct event_base *base, int npri)
+{
+  /*dLOOPbase;*/
+
+  return 0;
+}
+
diff --git a/release/src/router/libev-4.22/event.h b/release/src/router/libev-4.22/event.h
new file mode 100644
index 0000000000..aa81928f35
--- /dev/null
+++ b/release/src/router/libev-4.22/event.h
@@ -0,0 +1,177 @@
+/*
+ * libevent compatibility header, only core events supported
+ *
+ * Copyright (c) 2007,2008,2010,2012 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef EVENT_H_
+#define EVENT_H_
+
+#ifdef EV_H
+# include EV_H
+#else
+# include "ev.h"
+#endif
+
+#ifndef EVLOOP_NONBLOCK
+# define EVLOOP_NONBLOCK EVRUN_NOWAIT
+#endif
+#ifndef EVLOOP_ONESHOT
+# define EVLOOP_ONESHOT EVRUN_ONCE
+#endif
+#ifndef EV_TIMEOUT
+# define EV_TIMEOUT EV_TIMER
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* we need sys/time.h for struct timeval only */
+#if !defined (WIN32) || defined (__MINGW32__)
+# include <time.h> /* mingw seems to need this, for whatever reason */
+# include <sys/time.h>
+#endif
+
+struct event_base;
+
+#define EVLIST_TIMEOUT  0x01
+#define EVLIST_INSERTED 0x02
+#define EVLIST_SIGNAL   0x04
+#define EVLIST_ACTIVE   0x08
+#define EVLIST_INTERNAL 0x10
+#define EVLIST_INIT     0x80
+
+typedef void (*event_callback_fn)(int, short, void *);
+
+struct event
+{
+  /* libev watchers we map onto */
+  union {
+    struct ev_io io;
+    struct ev_signal sig;
+  } iosig;
+  struct ev_timer to;
+
+  /* compatibility slots */
+  struct event_base *ev_base;
+  event_callback_fn ev_callback;
+  void *ev_arg;
+  int ev_fd;
+  int ev_pri;
+  int ev_res;
+  int ev_flags;
+  short ev_events;
+};
+
+event_callback_fn event_get_callback (const struct event *ev);
+
+#define EV_READ                    EV_READ
+#define EV_WRITE                   EV_WRITE
+#define EV_PERSIST                 0x10
+#define EV_ET                      0x20 /* nop */
+
+#define EVENT_SIGNAL(ev)           ((int) (ev)->ev_fd)
+#define EVENT_FD(ev)               ((int) (ev)->ev_fd)
+
+#define event_initialized(ev)      ((ev)->ev_flags & EVLIST_INIT)
+
+#define evtimer_add(ev,tv)         event_add (ev, tv)
+#define evtimer_set(ev,cb,data)    event_set (ev, -1, 0, cb, data)
+#define evtimer_del(ev)            event_del (ev)
+#define evtimer_pending(ev,tv)     event_pending (ev, EV_TIMEOUT, tv)
+#define evtimer_initialized(ev)    event_initialized (ev)
+
+#define timeout_add(ev,tv)         evtimer_add (ev, tv)
+#define timeout_set(ev,cb,data)    evtimer_set (ev, cb, data)
+#define timeout_del(ev)            evtimer_del (ev)
+#define timeout_pending(ev,tv)     evtimer_pending (ev, tv)
+#define timeout_initialized(ev)    evtimer_initialized (ev)
+
+#define signal_add(ev,tv)          event_add (ev, tv)
+#define signal_set(ev,sig,cb,data) event_set (ev, sig, EV_SIGNAL | EV_PERSIST, cb, data)
+#define signal_del(ev)             event_del (ev)
+#define signal_pending(ev,tv)      event_pending (ev, EV_SIGNAL, tv)
+#define signal_initialized(ev)     event_initialized (ev)
+
+const char *event_get_version (void);
+const char *event_get_method (void);
+
+void *event_init (void);
+void event_base_free (struct event_base *base);
+
+#define EVLOOP_ONCE      EVLOOP_ONESHOT
+int event_loop (int);
+int event_loopexit (struct timeval *tv);
+int event_dispatch (void);
+
+#define _EVENT_LOG_DEBUG 0
+#define _EVENT_LOG_MSG   1
+#define _EVENT_LOG_WARN  2
+#define _EVENT_LOG_ERR   3
+typedef void (*event_log_cb)(int severity, const char *msg);
+void event_set_log_callback(event_log_cb cb);
+
+void event_set (struct event *ev, int fd, short events, void (*cb)(int, short, void *), void *arg);
+int event_once (int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);
+
+int event_add (struct event *ev, struct timeval *tv);
+int event_del (struct event *ev);
+void event_active (struct event *ev, int res, short ncalls); /* ncalls is being ignored */
+
+int event_pending (struct event *ev, short, struct timeval *tv);
+
+int event_priority_init (int npri);
+int event_priority_set (struct event *ev, int pri);
+
+struct event_base *event_base_new (void);
+const char *event_base_get_method (const struct event_base *);
+int event_base_set (struct event_base *base, struct event *ev);
+int event_base_loop (struct event_base *base, int);
+int event_base_loopexit (struct event_base *base, struct timeval *tv);
+int event_base_dispatch (struct event_base *base);
+int event_base_once (struct event_base *base, int fd, short events, void (*cb)(int, short, void *), void *arg, struct timeval *tv);
+int event_base_priority_init (struct event_base *base, int fd);
+
+/* next line is different in the libevent+libev version */
+/*libevent-include*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff --git a/release/src/router/libev-4.22/install-sh b/release/src/router/libev-4.22/install-sh
new file mode 100755
index 0000000000..377bb8687f
--- /dev/null
+++ b/release/src/router/libev-4.22/install-sh
@@ -0,0 +1,527 @@
+#!/bin/sh
+# install - install a program, script, or datafile
+
+scriptversion=2011-11-20.07; # UTC
+
+# This originates from X11R5 (mit/util/scripts/install.sh), which was
+# later released in X11R6 (xc/config/util/install.sh) with the
+# following copyright and license.
+#
+# Copyright (C) 1994 X Consortium
+#
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to
+# deal in the Software without restriction, including without limitation the
+# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+# sell copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
+# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+#
+# Except as contained in this notice, the name of the X Consortium shall not
+# be used in advertising or otherwise to promote the sale, use or other deal-
+# ings in this Software without prior written authorization from the X Consor-
+# tium.
+#
+#
+# FSF changes to this file are in the public domain.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# 'make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.
+
+nl='
+'
+IFS=" ""	$nl"
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit=${DOITPROG-}
+if test -z "$doit"; then
+  doit_exec=exec
+else
+  doit_exec=$doit
+fi
+
+# Put in absolute file names if you don't have them in your path;
+# or use environment vars.
+
+chgrpprog=${CHGRPPROG-chgrp}
+chmodprog=${CHMODPROG-chmod}
+chownprog=${CHOWNPROG-chown}
+cmpprog=${CMPPROG-cmp}
+cpprog=${CPPROG-cp}
+mkdirprog=${MKDIRPROG-mkdir}
+mvprog=${MVPROG-mv}
+rmprog=${RMPROG-rm}
+stripprog=${STRIPPROG-strip}
+
+posix_glob='?'
+initialize_posix_glob='
+  test "$posix_glob" != "?" || {
+    if (set -f) 2>/dev/null; then
+      posix_glob=
+    else
+      posix_glob=:
+    fi
+  }
+'
+
+posix_mkdir=
+
+# Desired mode of installed file.
+mode=0755
+
+chgrpcmd=
+chmodcmd=$chmodprog
+chowncmd=
+mvcmd=$mvprog
+rmcmd="$rmprog -f"
+stripcmd=
+
+src=
+dst=
+dir_arg=
+dst_arg=
+
+copy_on_change=false
+no_target_directory=
+
+usage="\
+Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+   or: $0 [OPTION]... SRCFILES... DIRECTORY
+   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
+   or: $0 [OPTION]... -d DIRECTORIES...
+
+In the 1st form, copy SRCFILE to DSTFILE.
+In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
+In the 4th, create DIRECTORIES.
+
+Options:
+     --help     display this help and exit.
+     --version  display version info and exit.
+
+  -c            (ignored)
+  -C            install only if different (preserve the last data modification time)
+  -d            create directories instead of installing files.
+  -g GROUP      $chgrpprog installed files to GROUP.
+  -m MODE       $chmodprog installed files to MODE.
+  -o USER       $chownprog installed files to USER.
+  -s            $stripprog installed files.
+  -t DIRECTORY  install into DIRECTORY.
+  -T            report an error if DSTFILE is a directory.
+
+Environment variables override the default commands:
+  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
+  RMPROG STRIPPROG
+"
+
+while test $# -ne 0; do
+  case $1 in
+    -c) ;;
+
+    -C) copy_on_change=true;;
+
+    -d) dir_arg=true;;
+
+    -g) chgrpcmd="$chgrpprog $2"
+	shift;;
+
+    --help) echo "$usage"; exit $?;;
+
+    -m) mode=$2
+	case $mode in
+	  *' '* | *'	'* | *'
+'*	  | *'*'* | *'?'* | *'['*)
+	    echo "$0: invalid mode: $mode" >&2
+	    exit 1;;
+	esac
+	shift;;
+
+    -o) chowncmd="$chownprog $2"
+	shift;;
+
+    -s) stripcmd=$stripprog;;
+
+    -t) dst_arg=$2
+	# Protect names problematic for 'test' and other utilities.
+	case $dst_arg in
+	  -* | [=\(\)!]) dst_arg=./$dst_arg;;
+	esac
+	shift;;
+
+    -T) no_target_directory=true;;
+
+    --version) echo "$0 $scriptversion"; exit $?;;
+
+    --)	shift
+	break;;
+
+    -*)	echo "$0: invalid option: $1" >&2
+	exit 1;;
+
+    *)  break;;
+  esac
+  shift
+done
+
+if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+  # When -d is used, all remaining arguments are directories to create.
+  # When -t is used, the destination is already specified.
+  # Otherwise, the last argument is the destination.  Remove it from $@.
+  for arg
+  do
+    if test -n "$dst_arg"; then
+      # $@ is not empty: it contains at least $arg.
+      set fnord "$@" "$dst_arg"
+      shift # fnord
+    fi
+    shift # arg
+    dst_arg=$arg
+    # Protect names problematic for 'test' and other utilities.
+    case $dst_arg in
+      -* | [=\(\)!]) dst_arg=./$dst_arg;;
+    esac
+  done
+fi
+
+if test $# -eq 0; then
+  if test -z "$dir_arg"; then
+    echo "$0: no input file specified." >&2
+    exit 1
+  fi
+  # It's OK to call 'install-sh -d' without argument.
+  # This can happen when creating conditional directories.
+  exit 0
+fi
+
+if test -z "$dir_arg"; then
+  do_exit='(exit $ret); exit $ret'
+  trap "ret=129; $do_exit" 1
+  trap "ret=130; $do_exit" 2
+  trap "ret=141; $do_exit" 13
+  trap "ret=143; $do_exit" 15
+
+  # Set umask so as not to create temps with too-generous modes.
+  # However, 'strip' requires both read and write access to temps.
+  case $mode in
+    # Optimize common cases.
+    *644) cp_umask=133;;
+    *755) cp_umask=22;;
+
+    *[0-7])
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw='% 200'
+      fi
+      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
+    *)
+      if test -z "$stripcmd"; then
+	u_plus_rw=
+      else
+	u_plus_rw=,u+rw
+      fi
+      cp_umask=$mode$u_plus_rw;;
+  esac
+fi
+
+for src
+do
+  # Protect names problematic for 'test' and other utilities.
+  case $src in
+    -* | [=\(\)!]) src=./$src;;
+  esac
+
+  if test -n "$dir_arg"; then
+    dst=$src
+    dstdir=$dst
+    test -d "$dstdir"
+    dstdir_status=$?
+  else
+
+    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
+    # might cause directories to be created, which would be especially bad
+    # if $src (and thus $dsttmp) contains '*'.
+    if test ! -f "$src" && test ! -d "$src"; then
+      echo "$0: $src does not exist." >&2
+      exit 1
+    fi
+
+    if test -z "$dst_arg"; then
+      echo "$0: no destination specified." >&2
+      exit 1
+    fi
+    dst=$dst_arg
+
+    # If destination is a directory, append the input filename; won't work
+    # if double slashes aren't ignored.
+    if test -d "$dst"; then
+      if test -n "$no_target_directory"; then
+	echo "$0: $dst_arg: Is a directory" >&2
+	exit 1
+      fi
+      dstdir=$dst
+      dst=$dstdir/`basename "$src"`
+      dstdir_status=0
+    else
+      # Prefer dirname, but fall back on a substitute if dirname fails.
+      dstdir=`
+	(dirname "$dst") 2>/dev/null ||
+	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	     X"$dst" : 'X\(//\)[^/]' \| \
+	     X"$dst" : 'X\(//\)$' \| \
+	     X"$dst" : 'X\(/\)' \| . 2>/dev/null ||
+	echo X"$dst" |
+	    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)[^/].*/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\/\)$/{
+		   s//\1/
+		   q
+		 }
+		 /^X\(\/\).*/{
+		   s//\1/
+		   q
+		 }
+		 s/.*/./; q'
+      `
+
+      test -d "$dstdir"
+      dstdir_status=$?
+    fi
+  fi
+
+  obsolete_mkdir_used=false
+
+  if test $dstdir_status != 0; then
+    case $posix_mkdir in
+      '')
+	# Create intermediate dirs using mode 755 as modified by the umask.
+	# This is like FreeBSD 'install' as of 1997-10-28.
+	umask=`umask`
+	case $stripcmd.$umask in
+	  # Optimize common cases.
+	  *[2367][2367]) mkdir_umask=$umask;;
+	  .*0[02][02] | .[02][02] | .[02]) mkdir_umask=22;;
+
+	  *[0-7])
+	    mkdir_umask=`expr $umask + 22 \
+	      - $umask % 100 % 40 + $umask % 20 \
+	      - $umask % 10 % 4 + $umask % 2
+	    `;;
+	  *) mkdir_umask=$umask,go-w;;
+	esac
+
+	# With -d, create the new directory with the user-specified mode.
+	# Otherwise, rely on $mkdir_umask.
+	if test -n "$dir_arg"; then
+	  mkdir_mode=-m$mode
+	else
+	  mkdir_mode=
+	fi
+
+	posix_mkdir=false
+	case $umask in
+	  *[123567][0-7][0-7])
+	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
+	    # is incompatible with FreeBSD 'install' when (umask & 300) != 0.
+	    ;;
+	  *)
+	    tmpdir=${TMPDIR-/tmp}/ins$RANDOM-$$
+	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
+
+	    if (umask $mkdir_umask &&
+		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
+	    then
+	      if test -z "$dir_arg" || {
+		   # Check for POSIX incompatibilities with -m.
+		   # HP-UX 11.23 and IRIX 6.5 mkdir -m -p sets group- or
+		   # other-writable bit of parent directory when it shouldn't.
+		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
+		   ls_ld_tmpdir=`ls -ld "$tmpdir"`
+		   case $ls_ld_tmpdir in
+		     d????-?r-*) different_mode=700;;
+		     d????-?--*) different_mode=755;;
+		     *) false;;
+		   esac &&
+		   $mkdirprog -m$different_mode -p -- "$tmpdir" && {
+		     ls_ld_tmpdir_1=`ls -ld "$tmpdir"`
+		     test "$ls_ld_tmpdir" = "$ls_ld_tmpdir_1"
+		   }
+		 }
+	      then posix_mkdir=:
+	      fi
+	      rmdir "$tmpdir/d" "$tmpdir"
+	    else
+	      # Remove any dirs left behind by ancient mkdir implementations.
+	      rmdir ./$mkdir_mode ./-p ./-- 2>/dev/null
+	    fi
+	    trap '' 0;;
+	esac;;
+    esac
+
+    if
+      $posix_mkdir && (
+	umask $mkdir_umask &&
+	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
+      )
+    then :
+    else
+
+      # The umask is ridiculous, or mkdir does not conform to POSIX,
+      # or it failed possibly due to a race condition.  Create the
+      # directory the slow way, step by step, checking for races as we go.
+
+      case $dstdir in
+	/*) prefix='/';;
+	[-=\(\)!]*) prefix='./';;
+	*)  prefix='';;
+      esac
+
+      eval "$initialize_posix_glob"
+
+      oIFS=$IFS
+      IFS=/
+      $posix_glob set -f
+      set fnord $dstdir
+      shift
+      $posix_glob set +f
+      IFS=$oIFS
+
+      prefixes=
+
+      for d
+      do
+	test X"$d" = X && continue
+
+	prefix=$prefix$d
+	if test -d "$prefix"; then
+	  prefixes=
+	else
+	  if $posix_mkdir; then
+	    (umask=$mkdir_umask &&
+	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
+	    # Don't fail if two instances are running concurrently.
+	    test -d "$prefix" || exit 1
+	  else
+	    case $prefix in
+	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
+	      *) qprefix=$prefix;;
+	    esac
+	    prefixes="$prefixes '$qprefix'"
+	  fi
+	fi
+	prefix=$prefix/
+      done
+
+      if test -n "$prefixes"; then
+	# Don't fail if two instances are running concurrently.
+	(umask $mkdir_umask &&
+	 eval "\$doit_exec \$mkdirprog $prefixes") ||
+	  test -d "$dstdir" || exit 1
+	obsolete_mkdir_used=true
+      fi
+    fi
+  fi
+
+  if test -n "$dir_arg"; then
+    { test -z "$chowncmd" || $doit $chowncmd "$dst"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } &&
+    { test "$obsolete_mkdir_used$chowncmd$chgrpcmd" = false ||
+      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
+  else
+
+    # Make a couple of temp file names in the proper directory.
+    dsttmp=$dstdir/_inst.$$_
+    rmtmp=$dstdir/_rm.$$_
+
+    # Trap to clean up those temp files at exit.
+    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
+
+    # Copy the file name to the temp name.
+    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
+
+    # and set any options; do chmod last to preserve setuid bits.
+    #
+    # If any of these fail, we abort the whole thing.  If we want to
+    # ignore errors from any of these, just make sure not to ignore
+    # errors from the above "$doit $cpprog $src $dsttmp" command.
+    #
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
+    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
+    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
+    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # If -C, don't bother to copy if it wouldn't change the file.
+    if $copy_on_change &&
+       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
+       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
+
+       eval "$initialize_posix_glob" &&
+       $posix_glob set -f &&
+       set X $old && old=:$2:$4:$5:$6 &&
+       set X $new && new=:$2:$4:$5:$6 &&
+       $posix_glob set +f &&
+
+       test "$old" = "$new" &&
+       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
+    then
+      rm -f "$dsttmp"
+    else
+      # Rename the file to the real destination.
+      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
+
+      # The rename failed, perhaps because mv can't rename something else
+      # to itself, or perhaps because mv is so ancient that it does not
+      # support -f.
+      {
+	# Now remove or move aside any old file at destination location.
+	# We try this two ways since rm can't unlink itself on some
+	# systems and the destination file might be busy for other
+	# reasons.  In this case, the final cleanup might fail but the new
+	# file should still install successfully.
+	{
+	  test ! -f "$dst" ||
+	  $doit $rmcmd -f "$dst" 2>/dev/null ||
+	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
+	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
+	  } ||
+	  { echo "$0: cannot unlink or rename $dst" >&2
+	    (exit 1); exit 1
+	  }
+	} &&
+
+	# Now rename the file to the real destination.
+	$doit $mvcmd "$dsttmp" "$dst"
+      }
+    fi || exit 1
+
+    trap '' 0
+  fi
+done
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/release/src/router/libev-4.22/libev.m4 b/release/src/router/libev-4.22/libev.m4
new file mode 100644
index 0000000000..439fbde2c8
--- /dev/null
+++ b/release/src/router/libev-4.22/libev.m4
@@ -0,0 +1,42 @@
+dnl this file is part of libev, do not make local modifications
+dnl http://software.schmorp.de/pkg/libev
+
+dnl libev support
+AC_CHECK_HEADERS(sys/inotify.h sys/epoll.h sys/event.h port.h poll.h sys/select.h sys/eventfd.h sys/signalfd.h)
+ 
+AC_CHECK_FUNCS(inotify_init epoll_ctl kqueue port_create poll select eventfd signalfd)
+ 
+AC_CHECK_FUNCS(clock_gettime, [], [
+   dnl on linux, try syscall wrapper first
+   if test $(uname) = Linux; then
+      AC_MSG_CHECKING(for clock_gettime syscall)
+      AC_LINK_IFELSE([AC_LANG_PROGRAM(
+                      [#include <unistd.h>
+                       #include <sys/syscall.h>
+                       #include <time.h>],
+                      [struct timespec ts; int status = syscall (SYS_clock_gettime, CLOCK_REALTIME, &ts)])],
+                     [ac_have_clock_syscall=1
+                      AC_DEFINE(HAVE_CLOCK_SYSCALL, 1, Define to 1 to use the syscall interface for clock_gettime)
+                      AC_MSG_RESULT(yes)],
+                     [AC_MSG_RESULT(no)])
+   fi
+   if test -z "$LIBEV_M4_AVOID_LIBRT" && test -z "$ac_have_clock_syscall"; then
+      AC_CHECK_LIB(rt, clock_gettime)
+      unset ac_cv_func_clock_gettime
+      AC_CHECK_FUNCS(clock_gettime)
+   fi
+])
+
+AC_CHECK_FUNCS(nanosleep, [], [
+   if test -z "$LIBEV_M4_AVOID_LIBRT"; then
+      AC_CHECK_LIB(rt, nanosleep)
+      unset ac_cv_func_nanosleep
+      AC_CHECK_FUNCS(nanosleep)
+   fi
+])
+
+if test -z "$LIBEV_M4_AVOID_LIBM"; then
+   LIBM=m
+fi
+AC_SEARCH_LIBS(floor, $LIBM, [AC_DEFINE(HAVE_FLOOR, 1, Define to 1 if the floor function is available)])
+
diff --git a/release/src/router/libev-4.22/ltmain.sh b/release/src/router/libev-4.22/ltmain.sh
new file mode 100644
index 0000000000..bffda54187
--- /dev/null
+++ b/release/src/router/libev-4.22/ltmain.sh
@@ -0,0 +1,9661 @@
+
+# libtool (GNU libtool) 2.4.2
+# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,
+# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+# This is free software; see the source for copying conditions.  There is NO
+# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+# GNU Libtool is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# As a special exception to the GNU General Public License,
+# if you distribute this file as part of a program or library that
+# is built using GNU Libtool, you may include this file under the
+# same distribution terms that you use for the rest of that program.
+#
+# GNU Libtool is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Libtool; see the file COPYING.  If not, a copy
+# can be downloaded from http://www.gnu.org/licenses/gpl.html,
+# or obtained by writing to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+# Usage: $progname [OPTION]... [MODE-ARG]...
+#
+# Provide generalized library-building support services.
+#
+#       --config             show all configuration variables
+#       --debug              enable verbose shell tracing
+#   -n, --dry-run            display commands without modifying any files
+#       --features           display basic configuration information and exit
+#       --mode=MODE          use operation mode MODE
+#       --preserve-dup-deps  don't remove duplicate dependency libraries
+#       --quiet, --silent    don't print informational messages
+#       --no-quiet, --no-silent
+#                            print informational messages (default)
+#       --no-warn            don't display warning messages
+#       --tag=TAG            use configuration variables from tag TAG
+#   -v, --verbose            print more informational messages than default
+#       --no-verbose         don't print the extra informational messages
+#       --version            print version information
+#   -h, --help, --help-all   print short, long, or detailed help message
+#
+# MODE must be one of the following:
+#
+#         clean              remove files from the build directory
+#         compile            compile a source file into a libtool object
+#         execute            automatically set library path, then run a program
+#         finish             complete the installation of libtool libraries
+#         install            install libraries or executables
+#         link               create a library or an executable
+#         uninstall          remove libraries from an installed directory
+#
+# MODE-ARGS vary depending on the MODE.  When passed as first option,
+# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.
+# Try `$progname --help --mode=MODE' for a more detailed description of MODE.
+#
+# When reporting a bug, please describe a test case to reproduce it and
+# include the following information:
+#
+#         host-triplet:	$host
+#         shell:		$SHELL
+#         compiler:		$LTCC
+#         compiler flags:		$LTCFLAGS
+#         linker:		$LD (gnu? $with_gnu_ld)
+#         $progname:	(GNU libtool) 2.4.2 Debian-2.4.2-1.11
+#         automake:	$automake_version
+#         autoconf:	$autoconf_version
+#
+# Report bugs to <bug-libtool@gnu.org>.
+# GNU libtool home page: <http://www.gnu.org/software/libtool/>.
+# General help using GNU software: <http://www.gnu.org/gethelp/>.
+
+PROGRAM=libtool
+PACKAGE=libtool
+VERSION="2.4.2 Debian-2.4.2-1.11"
+TIMESTAMP=""
+package_revision=1.3337
+
+# Be Bourne compatible
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+$1
+_LTECHO_EOF'
+}
+
+# NLS nuisances: We save the old values to restore during execute mode.
+lt_user_locale=
+lt_safe_locale=
+for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+do
+  eval "if test \"\${$lt_var+set}\" = set; then
+          save_$lt_var=\$$lt_var
+          $lt_var=C
+	  export $lt_var
+	  lt_user_locale=\"$lt_var=\\\$save_\$lt_var; \$lt_user_locale\"
+	  lt_safe_locale=\"$lt_var=C; \$lt_safe_locale\"
+	fi"
+done
+LC_ALL=C
+LANGUAGE=C
+export LANGUAGE LC_ALL
+
+$lt_unset CDPATH
+
+
+# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh
+# is ksh but when the shell is invoked as "sh" and the current value of
+# the _XPG environment variable is not equal to 1 (one), the special
+# positional parameter $0, within a function call, is the name of the
+# function.
+progpath="$0"
+
+
+
+: ${CP="cp -f"}
+test "${ECHO+set}" = set || ECHO=${as_echo-'printf %s\n'}
+: ${MAKE="make"}
+: ${MKDIR="mkdir"}
+: ${MV="mv -f"}
+: ${RM="rm -f"}
+: ${SHELL="${CONFIG_SHELL-/bin/sh}"}
+: ${Xsed="$SED -e 1s/^X//"}
+
+# Global variables:
+EXIT_SUCCESS=0
+EXIT_FAILURE=1
+EXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.
+EXIT_SKIP=77	  # $? = 77 is used to indicate a skipped test to automake.
+
+exit_status=$EXIT_SUCCESS
+
+# Make sure IFS has a sensible default
+lt_nl='
+'
+IFS=" 	$lt_nl"
+
+dirname="s,/[^/]*$,,"
+basename="s,^.*/,,"
+
+# func_dirname file append nondir_replacement
+# Compute the dirname of FILE.  If nonempty, add APPEND to the result,
+# otherwise set result to NONDIR_REPLACEMENT.
+func_dirname ()
+{
+    func_dirname_result=`$ECHO "${1}" | $SED "$dirname"`
+    if test "X$func_dirname_result" = "X${1}"; then
+      func_dirname_result="${3}"
+    else
+      func_dirname_result="$func_dirname_result${2}"
+    fi
+} # func_dirname may be replaced by extended shell implementation
+
+
+# func_basename file
+func_basename ()
+{
+    func_basename_result=`$ECHO "${1}" | $SED "$basename"`
+} # func_basename may be replaced by extended shell implementation
+
+
+# func_dirname_and_basename file append nondir_replacement
+# perform func_basename and func_dirname in a single function
+# call:
+#   dirname:  Compute the dirname of FILE.  If nonempty,
+#             add APPEND to the result, otherwise set result
+#             to NONDIR_REPLACEMENT.
+#             value returned in "$func_dirname_result"
+#   basename: Compute filename of FILE.
+#             value retuned in "$func_basename_result"
+# Implementation must be kept synchronized with func_dirname
+# and func_basename. For efficiency, we do not delegate to
+# those functions but instead duplicate the functionality here.
+func_dirname_and_basename ()
+{
+    # Extract subdirectory from the argument.
+    func_dirname_result=`$ECHO "${1}" | $SED -e "$dirname"`
+    if test "X$func_dirname_result" = "X${1}"; then
+      func_dirname_result="${3}"
+    else
+      func_dirname_result="$func_dirname_result${2}"
+    fi
+    func_basename_result=`$ECHO "${1}" | $SED -e "$basename"`
+} # func_dirname_and_basename may be replaced by extended shell implementation
+
+
+# func_stripname prefix suffix name
+# strip PREFIX and SUFFIX off of NAME.
+# PREFIX and SUFFIX must not contain globbing or regex special
+# characters, hashes, percent signs, but SUFFIX may contain a leading
+# dot (in which case that matches only a dot).
+# func_strip_suffix prefix name
+func_stripname ()
+{
+    case ${2} in
+      .*) func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%\\\\${2}\$%%"`;;
+      *)  func_stripname_result=`$ECHO "${3}" | $SED "s%^${1}%%; s%${2}\$%%"`;;
+    esac
+} # func_stripname may be replaced by extended shell implementation
+
+
+# These SED scripts presuppose an absolute path with a trailing slash.
+pathcar='s,^/\([^/]*\).*$,\1,'
+pathcdr='s,^/[^/]*,,'
+removedotparts=':dotsl
+		s@/\./@/@g
+		t dotsl
+		s,/\.$,/,'
+collapseslashes='s@/\{1,\}@/@g'
+finalslash='s,/*$,/,'
+
+# func_normal_abspath PATH
+# Remove doubled-up and trailing slashes, "." path components,
+# and cancel out any ".." path components in PATH after making
+# it an absolute path.
+#             value returned in "$func_normal_abspath_result"
+func_normal_abspath ()
+{
+  # Start from root dir and reassemble the path.
+  func_normal_abspath_result=
+  func_normal_abspath_tpath=$1
+  func_normal_abspath_altnamespace=
+  case $func_normal_abspath_tpath in
+    "")
+      # Empty path, that just means $cwd.
+      func_stripname '' '/' "`pwd`"
+      func_normal_abspath_result=$func_stripname_result
+      return
+    ;;
+    # The next three entries are used to spot a run of precisely
+    # two leading slashes without using negated character classes;
+    # we take advantage of case's first-match behaviour.
+    ///*)
+      # Unusual form of absolute path, do nothing.
+    ;;
+    //*)
+      # Not necessarily an ordinary path; POSIX reserves leading '//'
+      # and for example Cygwin uses it to access remote file shares
+      # over CIFS/SMB, so we conserve a leading double slash if found.
+      func_normal_abspath_altnamespace=/
+    ;;
+    /*)
+      # Absolute path, do nothing.
+    ;;
+    *)
+      # Relative path, prepend $cwd.
+      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath
+    ;;
+  esac
+  # Cancel out all the simple stuff to save iterations.  We also want
+  # the path to end with a slash for ease of parsing, so make sure
+  # there is one (and only one) here.
+  func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
+        -e "$removedotparts" -e "$collapseslashes" -e "$finalslash"`
+  while :; do
+    # Processed it all yet?
+    if test "$func_normal_abspath_tpath" = / ; then
+      # If we ascended to the root using ".." the result may be empty now.
+      if test -z "$func_normal_abspath_result" ; then
+        func_normal_abspath_result=/
+      fi
+      break
+    fi
+    func_normal_abspath_tcomponent=`$ECHO "$func_normal_abspath_tpath" | $SED \
+        -e "$pathcar"`
+    func_normal_abspath_tpath=`$ECHO "$func_normal_abspath_tpath" | $SED \
+        -e "$pathcdr"`
+    # Figure out what to do with it
+    case $func_normal_abspath_tcomponent in
+      "")
+        # Trailing empty path component, ignore it.
+      ;;
+      ..)
+        # Parent dir; strip last assembled component from result.
+        func_dirname "$func_normal_abspath_result"
+        func_normal_abspath_result=$func_dirname_result
+      ;;
+      *)
+        # Actual path component, append it.
+        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent
+      ;;
+    esac
+  done
+  # Restore leading double-slash if one was found on entry.
+  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result
+}
+
+# func_relative_path SRCDIR DSTDIR
+# generates a relative path from SRCDIR to DSTDIR, with a trailing
+# slash if non-empty, suitable for immediately appending a filename
+# without needing to append a separator.
+#             value returned in "$func_relative_path_result"
+func_relative_path ()
+{
+  func_relative_path_result=
+  func_normal_abspath "$1"
+  func_relative_path_tlibdir=$func_normal_abspath_result
+  func_normal_abspath "$2"
+  func_relative_path_tbindir=$func_normal_abspath_result
+
+  # Ascend the tree starting from libdir
+  while :; do
+    # check if we have found a prefix of bindir
+    case $func_relative_path_tbindir in
+      $func_relative_path_tlibdir)
+        # found an exact match
+        func_relative_path_tcancelled=
+        break
+        ;;
+      $func_relative_path_tlibdir*)
+        # found a matching prefix
+        func_stripname "$func_relative_path_tlibdir" '' "$func_relative_path_tbindir"
+        func_relative_path_tcancelled=$func_stripname_result
+        if test -z "$func_relative_path_result"; then
+          func_relative_path_result=.
+        fi
+        break
+        ;;
+      *)
+        func_dirname $func_relative_path_tlibdir
+        func_relative_path_tlibdir=${func_dirname_result}
+        if test "x$func_relative_path_tlibdir" = x ; then
+          # Have to descend all the way to the root!
+          func_relative_path_result=../$func_relative_path_result
+          func_relative_path_tcancelled=$func_relative_path_tbindir
+          break
+        fi
+        func_relative_path_result=../$func_relative_path_result
+        ;;
+    esac
+  done
+
+  # Now calculate path; take care to avoid doubling-up slashes.
+  func_stripname '' '/' "$func_relative_path_result"
+  func_relative_path_result=$func_stripname_result
+  func_stripname '/' '/' "$func_relative_path_tcancelled"
+  if test "x$func_stripname_result" != x ; then
+    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}
+  fi
+
+  # Normalisation. If bindir is libdir, return empty string,
+  # else relative path ending with a slash; either way, target
+  # file name can be directly appended.
+  if test ! -z "$func_relative_path_result"; then
+    func_stripname './' '' "$func_relative_path_result/"
+    func_relative_path_result=$func_stripname_result
+  fi
+}
+
+# The name of this program:
+func_dirname_and_basename "$progpath"
+progname=$func_basename_result
+
+# Make sure we have an absolute path for reexecution:
+case $progpath in
+  [\\/]*|[A-Za-z]:\\*) ;;
+  *[\\/]*)
+     progdir=$func_dirname_result
+     progdir=`cd "$progdir" && pwd`
+     progpath="$progdir/$progname"
+     ;;
+  *)
+     save_IFS="$IFS"
+     IFS=${PATH_SEPARATOR-:}
+     for progdir in $PATH; do
+       IFS="$save_IFS"
+       test -x "$progdir/$progname" && break
+     done
+     IFS="$save_IFS"
+     test -n "$progdir" || progdir=`pwd`
+     progpath="$progdir/$progname"
+     ;;
+esac
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+Xsed="${SED}"' -e 1s/^X//'
+sed_quote_subst='s/\([`"$\\]\)/\\\1/g'
+
+# Same as above, but do not quote variable references.
+double_quote_subst='s/\(["`\\]\)/\\\1/g'
+
+# Sed substitution that turns a string into a regex matching for the
+# string literally.
+sed_make_literal_regex='s,[].[^$\\*\/],\\&,g'
+
+# Sed substitution that converts a w32 file name or path
+# which contains forward slashes, into one that contains
+# (escaped) backslashes.  A very naive implementation.
+lt_sed_naive_backslashify='s|\\\\*|\\|g;s|/|\\|g;s|\\|\\\\|g'
+
+# Re-`\' parameter expansions in output of double_quote_subst that were
+# `\'-ed in input to the same.  If an odd number of `\' preceded a '$'
+# in input to double_quote_subst, that '$' was protected from expansion.
+# Since each input `\' is now two `\'s, look for any number of runs of
+# four `\'s followed by two `\'s and then a '$'.  `\' that '$'.
+bs='\\'
+bs2='\\\\'
+bs4='\\\\\\\\'
+dollar='\$'
+sed_double_backslash="\
+  s/$bs4/&\\
+/g
+  s/^$bs2$dollar/$bs&/
+  s/\\([^$bs]\\)$bs2$dollar/\\1$bs2$bs$dollar/g
+  s/\n//g"
+
+# Standard options:
+opt_dry_run=false
+opt_help=false
+opt_quiet=false
+opt_verbose=false
+opt_warning=:
+
+# func_echo arg...
+# Echo program name prefixed message, along with the current mode
+# name if it has been set yet.
+func_echo ()
+{
+    $ECHO "$progname: ${opt_mode+$opt_mode: }$*"
+}
+
+# func_verbose arg...
+# Echo program name prefixed message in verbose mode only.
+func_verbose ()
+{
+    $opt_verbose && func_echo ${1+"$@"}
+
+    # A bug in bash halts the script if the last line of a function
+    # fails when set -e is in force, so we need another command to
+    # work around that:
+    :
+}
+
+# func_echo_all arg...
+# Invoke $ECHO with all args, space-separated.
+func_echo_all ()
+{
+    $ECHO "$*"
+}
+
+# func_error arg...
+# Echo program name prefixed message to standard error.
+func_error ()
+{
+    $ECHO "$progname: ${opt_mode+$opt_mode: }"${1+"$@"} 1>&2
+}
+
+# func_warning arg...
+# Echo program name prefixed warning message to standard error.
+func_warning ()
+{
+    $opt_warning && $ECHO "$progname: ${opt_mode+$opt_mode: }warning: "${1+"$@"} 1>&2
+
+    # bash bug again:
+    :
+}
+
+# func_fatal_error arg...
+# Echo program name prefixed message to standard error, and exit.
+func_fatal_error ()
+{
+    func_error ${1+"$@"}
+    exit $EXIT_FAILURE
+}
+
+# func_fatal_help arg...
+# Echo program name prefixed message to standard error, followed by
+# a help hint, and exit.
+func_fatal_help ()
+{
+    func_error ${1+"$@"}
+    func_fatal_error "$help"
+}
+help="Try \`$progname --help' for more information."  ## default
+
+
+# func_grep expression filename
+# Check whether EXPRESSION matches any line of FILENAME, without output.
+func_grep ()
+{
+    $GREP "$1" "$2" >/dev/null 2>&1
+}
+
+
+# func_mkdir_p directory-path
+# Make sure the entire path to DIRECTORY-PATH is available.
+func_mkdir_p ()
+{
+    my_directory_path="$1"
+    my_dir_list=
+
+    if test -n "$my_directory_path" && test "$opt_dry_run" != ":"; then
+
+      # Protect directory names starting with `-'
+      case $my_directory_path in
+        -*) my_directory_path="./$my_directory_path" ;;
+      esac
+
+      # While some portion of DIR does not yet exist...
+      while test ! -d "$my_directory_path"; do
+        # ...make a list in topmost first order.  Use a colon delimited
+	# list incase some portion of path contains whitespace.
+        my_dir_list="$my_directory_path:$my_dir_list"
+
+        # If the last portion added has no slash in it, the list is done
+        case $my_directory_path in */*) ;; *) break ;; esac
+
+        # ...otherwise throw away the child directory and loop
+        my_directory_path=`$ECHO "$my_directory_path" | $SED -e "$dirname"`
+      done
+      my_dir_list=`$ECHO "$my_dir_list" | $SED 's,:*$,,'`
+
+      save_mkdir_p_IFS="$IFS"; IFS=':'
+      for my_dir in $my_dir_list; do
+	IFS="$save_mkdir_p_IFS"
+        # mkdir can fail with a `File exist' error if two processes
+        # try to create one of the directories concurrently.  Don't
+        # stop in that case!
+        $MKDIR "$my_dir" 2>/dev/null || :
+      done
+      IFS="$save_mkdir_p_IFS"
+
+      # Bail out if we (or some other process) failed to create a directory.
+      test -d "$my_directory_path" || \
+        func_fatal_error "Failed to create \`$1'"
+    fi
+}
+
+
+# func_mktempdir [string]
+# Make a temporary directory that won't clash with other running
+# libtool processes, and avoids race conditions if possible.  If
+# given, STRING is the basename for that directory.
+func_mktempdir ()
+{
+    my_template="${TMPDIR-/tmp}/${1-$progname}"
+
+    if test "$opt_dry_run" = ":"; then
+      # Return a directory name, but don't create it in dry-run mode
+      my_tmpdir="${my_template}-$$"
+    else
+
+      # If mktemp works, use that first and foremost
+      my_tmpdir=`mktemp -d "${my_template}-XXXXXXXX" 2>/dev/null`
+
+      if test ! -d "$my_tmpdir"; then
+        # Failing that, at least try and use $RANDOM to avoid a race
+        my_tmpdir="${my_template}-${RANDOM-0}$$"
+
+        save_mktempdir_umask=`umask`
+        umask 0077
+        $MKDIR "$my_tmpdir"
+        umask $save_mktempdir_umask
+      fi
+
+      # If we're not in dry-run mode, bomb out on failure
+      test -d "$my_tmpdir" || \
+        func_fatal_error "cannot create temporary directory \`$my_tmpdir'"
+    fi
+
+    $ECHO "$my_tmpdir"
+}
+
+
+# func_quote_for_eval arg
+# Aesthetically quote ARG to be evaled later.
+# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT
+# is double-quoted, suitable for a subsequent eval, whereas
+# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters
+# which are still active within double quotes backslashified.
+func_quote_for_eval ()
+{
+    case $1 in
+      *[\\\`\"\$]*)
+	func_quote_for_eval_unquoted_result=`$ECHO "$1" | $SED "$sed_quote_subst"` ;;
+      *)
+        func_quote_for_eval_unquoted_result="$1" ;;
+    esac
+
+    case $func_quote_for_eval_unquoted_result in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting, command substitution and and variable
+      # expansion for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        func_quote_for_eval_result="\"$func_quote_for_eval_unquoted_result\""
+        ;;
+      *)
+        func_quote_for_eval_result="$func_quote_for_eval_unquoted_result"
+    esac
+}
+
+
+# func_quote_for_expand arg
+# Aesthetically quote ARG to be evaled later; same as above,
+# but do not quote variable references.
+func_quote_for_expand ()
+{
+    case $1 in
+      *[\\\`\"]*)
+	my_arg=`$ECHO "$1" | $SED \
+	    -e "$double_quote_subst" -e "$sed_double_backslash"` ;;
+      *)
+        my_arg="$1" ;;
+    esac
+
+    case $my_arg in
+      # Double-quote args containing shell metacharacters to delay
+      # word splitting and command substitution for a subsequent eval.
+      # Many Bourne shells cannot handle close brackets correctly
+      # in scan sets, so we specify it separately.
+      *[\[\~\#\^\&\*\(\)\{\}\|\;\<\>\?\'\ \	]*|*]*|"")
+        my_arg="\"$my_arg\""
+        ;;
+    esac
+
+    func_quote_for_expand_result="$my_arg"
+}
+
+
+# func_show_eval cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.
+func_show_eval ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$my_cmd"
+      my_status=$?
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+
+# func_show_eval_locale cmd [fail_exp]
+# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is
+# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP
+# is given, then evaluate it.  Use the saved locale for evaluation.
+func_show_eval_locale ()
+{
+    my_cmd="$1"
+    my_fail_exp="${2-:}"
+
+    ${opt_silent-false} || {
+      func_quote_for_expand "$my_cmd"
+      eval "func_echo $func_quote_for_expand_result"
+    }
+
+    if ${opt_dry_run-false}; then :; else
+      eval "$lt_user_locale
+	    $my_cmd"
+      my_status=$?
+      eval "$lt_safe_locale"
+      if test "$my_status" -eq 0; then :; else
+	eval "(exit $my_status); $my_fail_exp"
+      fi
+    fi
+}
+
+# func_tr_sh
+# Turn $1 into a string suitable for a shell variable name.
+# Result is stored in $func_tr_sh_result.  All characters
+# not in the set a-zA-Z0-9_ are replaced with '_'. Further,
+# if $1 begins with a digit, a '_' is prepended as well.
+func_tr_sh ()
+{
+  case $1 in
+  [0-9]* | *[!a-zA-Z0-9_]*)
+    func_tr_sh_result=`$ECHO "$1" | $SED 's/^\([0-9]\)/_\1/; s/[^a-zA-Z0-9_]/_/g'`
+    ;;
+  * )
+    func_tr_sh_result=$1
+    ;;
+  esac
+}
+
+
+# func_version
+# Echo version message to standard output and exit.
+func_version ()
+{
+    $opt_debug
+
+    $SED -n '/(C)/!b go
+	:more
+	/\./!{
+	  N
+	  s/\n# / /
+	  b more
+	}
+	:go
+	/^# '$PROGRAM' (GNU /,/# warranty; / {
+        s/^# //
+	s/^# *$//
+        s/\((C)\)[ 0-9,-]*\( [1-9][0-9]*\)/\1\2/
+        p
+     }' < "$progpath"
+     exit $?
+}
+
+# func_usage
+# Echo short help message to standard output and exit.
+func_usage ()
+{
+    $opt_debug
+
+    $SED -n '/^# Usage:/,/^#  *.*--help/ {
+        s/^# //
+	s/^# *$//
+	s/\$progname/'$progname'/
+	p
+    }' < "$progpath"
+    echo
+    $ECHO "run \`$progname --help | more' for full usage"
+    exit $?
+}
+
+# func_help [NOEXIT]
+# Echo long help message to standard output and exit,
+# unless 'noexit' is passed as argument.
+func_help ()
+{
+    $opt_debug
+
+    $SED -n '/^# Usage:/,/# Report bugs to/ {
+	:print
+        s/^# //
+	s/^# *$//
+	s*\$progname*'$progname'*
+	s*\$host*'"$host"'*
+	s*\$SHELL*'"$SHELL"'*
+	s*\$LTCC*'"$LTCC"'*
+	s*\$LTCFLAGS*'"$LTCFLAGS"'*
+	s*\$LD*'"$LD"'*
+	s/\$with_gnu_ld/'"$with_gnu_ld"'/
+	s/\$automake_version/'"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`"'/
+	s/\$autoconf_version/'"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`"'/
+	p
+	d
+     }
+     /^# .* home page:/b print
+     /^# General help using/b print
+     ' < "$progpath"
+    ret=$?
+    if test -z "$1"; then
+      exit $ret
+    fi
+}
+
+# func_missing_arg argname
+# Echo program name prefixed message to standard error and set global
+# exit_cmd.
+func_missing_arg ()
+{
+    $opt_debug
+
+    func_error "missing argument for $1."
+    exit_cmd=exit
+}
+
+
+# func_split_short_opt shortopt
+# Set func_split_short_opt_name and func_split_short_opt_arg shell
+# variables after splitting SHORTOPT after the 2nd character.
+func_split_short_opt ()
+{
+    my_sed_short_opt='1s/^\(..\).*$/\1/;q'
+    my_sed_short_rest='1s/^..\(.*\)$/\1/;q'
+
+    func_split_short_opt_name=`$ECHO "$1" | $SED "$my_sed_short_opt"`
+    func_split_short_opt_arg=`$ECHO "$1" | $SED "$my_sed_short_rest"`
+} # func_split_short_opt may be replaced by extended shell implementation
+
+
+# func_split_long_opt longopt
+# Set func_split_long_opt_name and func_split_long_opt_arg shell
+# variables after splitting LONGOPT at the `=' sign.
+func_split_long_opt ()
+{
+    my_sed_long_opt='1s/^\(--[^=]*\)=.*/\1/;q'
+    my_sed_long_arg='1s/^--[^=]*=//'
+
+    func_split_long_opt_name=`$ECHO "$1" | $SED "$my_sed_long_opt"`
+    func_split_long_opt_arg=`$ECHO "$1" | $SED "$my_sed_long_arg"`
+} # func_split_long_opt may be replaced by extended shell implementation
+
+exit_cmd=:
+
+
+
+
+
+magic="%%%MAGIC variable%%%"
+magic_exe="%%%MAGIC EXE variable%%%"
+
+# Global variables.
+nonopt=
+preserve_args=
+lo2o="s/\\.lo\$/.${objext}/"
+o2lo="s/\\.${objext}\$/.lo/"
+extracted_archives=
+extracted_serial=0
+
+# If this variable is set in any of the actions, the command in it
+# will be execed at the end.  This prevents here-documents from being
+# left over by shells.
+exec_cmd=
+
+# func_append var value
+# Append VALUE to the end of shell variable VAR.
+func_append ()
+{
+    eval "${1}=\$${1}\${2}"
+} # func_append may be replaced by extended shell implementation
+
+# func_append_quoted var value
+# Quote VALUE and append to the end of shell variable VAR, separated
+# by a space.
+func_append_quoted ()
+{
+    func_quote_for_eval "${2}"
+    eval "${1}=\$${1}\\ \$func_quote_for_eval_result"
+} # func_append_quoted may be replaced by extended shell implementation
+
+
+# func_arith arithmetic-term...
+func_arith ()
+{
+    func_arith_result=`expr "${@}"`
+} # func_arith may be replaced by extended shell implementation
+
+
+# func_len string
+# STRING may not start with a hyphen.
+func_len ()
+{
+    func_len_result=`expr "${1}" : ".*" 2>/dev/null || echo $max_cmd_len`
+} # func_len may be replaced by extended shell implementation
+
+
+# func_lo2o object
+func_lo2o ()
+{
+    func_lo2o_result=`$ECHO "${1}" | $SED "$lo2o"`
+} # func_lo2o may be replaced by extended shell implementation
+
+
+# func_xform libobj-or-source
+func_xform ()
+{
+    func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
+} # func_xform may be replaced by extended shell implementation
+
+
+# func_fatal_configuration arg...
+# Echo program name prefixed message to standard error, followed by
+# a configuration failure hint, and exit.
+func_fatal_configuration ()
+{
+    func_error ${1+"$@"}
+    func_error "See the $PACKAGE documentation for more information."
+    func_fatal_error "Fatal configuration error."
+}
+
+
+# func_config
+# Display the configuration for all the tags in this script.
+func_config ()
+{
+    re_begincf='^# ### BEGIN LIBTOOL'
+    re_endcf='^# ### END LIBTOOL'
+
+    # Default configuration.
+    $SED "1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\$d" < "$progpath"
+
+    # Now print the configurations for the tags.
+    for tagname in $taglist; do
+      $SED -n "/$re_begincf TAG CONFIG: $tagname\$/,/$re_endcf TAG CONFIG: $tagname\$/p" < "$progpath"
+    done
+
+    exit $?
+}
+
+# func_features
+# Display the features supported by this script.
+func_features ()
+{
+    echo "host: $host"
+    if test "$build_libtool_libs" = yes; then
+      echo "enable shared libraries"
+    else
+      echo "disable shared libraries"
+    fi
+    if test "$build_old_libs" = yes; then
+      echo "enable static libraries"
+    else
+      echo "disable static libraries"
+    fi
+
+    exit $?
+}
+
+# func_enable_tag tagname
+# Verify that TAGNAME is valid, and either flag an error and exit, or
+# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist
+# variable here.
+func_enable_tag ()
+{
+  # Global variable:
+  tagname="$1"
+
+  re_begincf="^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\$"
+  re_endcf="^# ### END LIBTOOL TAG CONFIG: $tagname\$"
+  sed_extractcf="/$re_begincf/,/$re_endcf/p"
+
+  # Validate tagname.
+  case $tagname in
+    *[!-_A-Za-z0-9,/]*)
+      func_fatal_error "invalid tag name: $tagname"
+      ;;
+  esac
+
+  # Don't test for the "default" C tag, as we know it's
+  # there but not specially marked.
+  case $tagname in
+    CC) ;;
+    *)
+      if $GREP "$re_begincf" "$progpath" >/dev/null 2>&1; then
+	taglist="$taglist $tagname"
+
+	# Evaluate the configuration.  Be careful to quote the path
+	# and the sed script, to avoid splitting on whitespace, but
+	# also don't use non-portable quotes within backquotes within
+	# quotes we have to do it in 2 steps:
+	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
+	eval "$extractedcf"
+      else
+	func_error "ignoring unknown tag $tagname"
+      fi
+      ;;
+  esac
+}
+
+# func_check_version_match
+# Ensure that we are using m4 macros, and libtool script from the same
+# release of libtool.
+func_check_version_match ()
+{
+  if test "$package_revision" != "$macro_revision"; then
+    if test "$VERSION" != "$macro_version"; then
+      if test -z "$macro_version"; then
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from an older release.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      else
+        cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the
+$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.
+$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION
+$progname: and run autoconf again.
+_LT_EOF
+      fi
+    else
+      cat >&2 <<_LT_EOF
+$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,
+$progname: but the definition of this LT_INIT comes from revision $macro_revision.
+$progname: You should recreate aclocal.m4 with macros from revision $package_revision
+$progname: of $PACKAGE $VERSION and run autoconf again.
+_LT_EOF
+    fi
+
+    exit $EXIT_MISMATCH
+  fi
+}
+
+
+# Shorthand for --mode=foo, only valid as the first argument
+case $1 in
+clean|clea|cle|cl)
+  shift; set dummy --mode clean ${1+"$@"}; shift
+  ;;
+compile|compil|compi|comp|com|co|c)
+  shift; set dummy --mode compile ${1+"$@"}; shift
+  ;;
+execute|execut|execu|exec|exe|ex|e)
+  shift; set dummy --mode execute ${1+"$@"}; shift
+  ;;
+finish|finis|fini|fin|fi|f)
+  shift; set dummy --mode finish ${1+"$@"}; shift
+  ;;
+install|instal|insta|inst|ins|in|i)
+  shift; set dummy --mode install ${1+"$@"}; shift
+  ;;
+link|lin|li|l)
+  shift; set dummy --mode link ${1+"$@"}; shift
+  ;;
+uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)
+  shift; set dummy --mode uninstall ${1+"$@"}; shift
+  ;;
+esac
+
+
+
+# Option defaults:
+opt_debug=:
+opt_dry_run=false
+opt_config=false
+opt_preserve_dup_deps=false
+opt_features=false
+opt_finish=false
+opt_help=false
+opt_help_all=false
+opt_silent=:
+opt_warning=:
+opt_verbose=:
+opt_silent=false
+opt_verbose=false
+
+
+# Parse options once, thoroughly.  This comes as soon as possible in the
+# script to make things like `--version' happen as quickly as we can.
+{
+  # this just eases exit handling
+  while test $# -gt 0; do
+    opt="$1"
+    shift
+    case $opt in
+      --debug|-x)	opt_debug='set -x'
+			func_echo "enabling shell trace mode"
+			$opt_debug
+			;;
+      --dry-run|--dryrun|-n)
+			opt_dry_run=:
+			;;
+      --config)
+			opt_config=:
+func_config
+			;;
+      --dlopen|-dlopen)
+			optarg="$1"
+			opt_dlopen="${opt_dlopen+$opt_dlopen
+}$optarg"
+			shift
+			;;
+      --preserve-dup-deps)
+			opt_preserve_dup_deps=:
+			;;
+      --features)
+			opt_features=:
+func_features
+			;;
+      --finish)
+			opt_finish=:
+set dummy --mode finish ${1+"$@"}; shift
+			;;
+      --help)
+			opt_help=:
+			;;
+      --help-all)
+			opt_help_all=:
+opt_help=': help-all'
+			;;
+      --mode)
+			test $# = 0 && func_missing_arg $opt && break
+			optarg="$1"
+			opt_mode="$optarg"
+case $optarg in
+  # Valid mode arguments:
+  clean|compile|execute|finish|install|link|relink|uninstall) ;;
+
+  # Catch anything else as an error
+  *) func_error "invalid argument for $opt"
+     exit_cmd=exit
+     break
+     ;;
+esac
+			shift
+			;;
+      --no-silent|--no-quiet)
+			opt_silent=false
+func_append preserve_args " $opt"
+			;;
+      --no-warning|--no-warn)
+			opt_warning=false
+func_append preserve_args " $opt"
+			;;
+      --no-verbose)
+			opt_verbose=false
+func_append preserve_args " $opt"
+			;;
+      --silent|--quiet)
+			opt_silent=:
+func_append preserve_args " $opt"
+        opt_verbose=false
+			;;
+      --verbose|-v)
+			opt_verbose=:
+func_append preserve_args " $opt"
+opt_silent=false
+			;;
+      --tag)
+			test $# = 0 && func_missing_arg $opt && break
+			optarg="$1"
+			opt_tag="$optarg"
+func_append preserve_args " $opt $optarg"
+func_enable_tag "$optarg"
+			shift
+			;;
+
+      -\?|-h)		func_usage				;;
+      --help)		func_help				;;
+      --version)	func_version				;;
+
+      # Separate optargs to long options:
+      --*=*)
+			func_split_long_opt "$opt"
+			set dummy "$func_split_long_opt_name" "$func_split_long_opt_arg" ${1+"$@"}
+			shift
+			;;
+
+      # Separate non-argument short options:
+      -\?*|-h*|-n*|-v*)
+			func_split_short_opt "$opt"
+			set dummy "$func_split_short_opt_name" "-$func_split_short_opt_arg" ${1+"$@"}
+			shift
+			;;
+
+      --)		break					;;
+      -*)		func_fatal_help "unrecognized option \`$opt'" ;;
+      *)		set dummy "$opt" ${1+"$@"};	shift; break  ;;
+    esac
+  done
+
+  # Validate options:
+
+  # save first non-option argument
+  if test "$#" -gt 0; then
+    nonopt="$opt"
+    shift
+  fi
+
+  # preserve --debug
+  test "$opt_debug" = : || func_append preserve_args " --debug"
+
+  case $host in
+    *cygwin* | *mingw* | *pw32* | *cegcc*)
+      # don't eliminate duplications in $postdeps and $predeps
+      opt_duplicate_compiler_generated_deps=:
+      ;;
+    *)
+      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps
+      ;;
+  esac
+
+  $opt_help || {
+    # Sanity checks first:
+    func_check_version_match
+
+    if test "$build_libtool_libs" != yes && test "$build_old_libs" != yes; then
+      func_fatal_configuration "not configured to build any kind of library"
+    fi
+
+    # Darwin sucks
+    eval std_shrext=\"$shrext_cmds\"
+
+    # Only execute mode is allowed to have -dlopen flags.
+    if test -n "$opt_dlopen" && test "$opt_mode" != execute; then
+      func_error "unrecognized option \`-dlopen'"
+      $ECHO "$help" 1>&2
+      exit $EXIT_FAILURE
+    fi
+
+    # Change the help message to a mode-specific one.
+    generic_help="$help"
+    help="Try \`$progname --help --mode=$opt_mode' for more information."
+  }
+
+
+  # Bail if the options were screwed
+  $exit_cmd $EXIT_FAILURE
+}
+
+
+
+
+## ----------- ##
+##    Main.    ##
+## ----------- ##
+
+# func_lalib_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_lalib_p ()
+{
+    test -f "$1" &&
+      $SED -e 4q "$1" 2>/dev/null \
+        | $GREP "^# Generated by .*$PACKAGE" > /dev/null 2>&1
+}
+
+# func_lalib_unsafe_p file
+# True iff FILE is a libtool `.la' library or `.lo' object file.
+# This function implements the same check as func_lalib_p without
+# resorting to external programs.  To this end, it redirects stdin and
+# closes it afterwards, without saving the original file descriptor.
+# As a safety measure, use it only where a negative result would be
+# fatal anyway.  Works if `file' does not exist.
+func_lalib_unsafe_p ()
+{
+    lalib_p=no
+    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
+	for lalib_p_l in 1 2 3 4
+	do
+	    read lalib_p_line
+	    case "$lalib_p_line" in
+		\#\ Generated\ by\ *$PACKAGE* ) lalib_p=yes; break;;
+	    esac
+	done
+	exec 0<&5 5<&-
+    fi
+    test "$lalib_p" = yes
+}
+
+# func_ltwrapper_script_p file
+# True iff FILE is a libtool wrapper script
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_script_p ()
+{
+    func_lalib_p "$1"
+}
+
+# func_ltwrapper_executable_p file
+# True iff FILE is a libtool wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_executable_p ()
+{
+    func_ltwrapper_exec_suffix=
+    case $1 in
+    *.exe) ;;
+    *) func_ltwrapper_exec_suffix=.exe ;;
+    esac
+    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
+}
+
+# func_ltwrapper_scriptname file
+# Assumes file is an ltwrapper_executable
+# uses $file to determine the appropriate filename for a
+# temporary ltwrapper_script.
+func_ltwrapper_scriptname ()
+{
+    func_dirname_and_basename "$1" "" "."
+    func_stripname '' '.exe' "$func_basename_result"
+    func_ltwrapper_scriptname_result="$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper"
+}
+
+# func_ltwrapper_p file
+# True iff FILE is a libtool wrapper script or wrapper executable
+# This function is only a basic sanity check; it will hardly flush out
+# determined imposters.
+func_ltwrapper_p ()
+{
+    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
+}
+
+
+# func_execute_cmds commands fail_cmd
+# Execute tilde-delimited COMMANDS.
+# If FAIL_CMD is given, eval that upon failure.
+# FAIL_CMD may read-access the current command in variable CMD!
+func_execute_cmds ()
+{
+    $opt_debug
+    save_ifs=$IFS; IFS='~'
+    for cmd in $1; do
+      IFS=$save_ifs
+      eval cmd=\"$cmd\"
+      func_show_eval "$cmd" "${2-:}"
+    done
+    IFS=$save_ifs
+}
+
+
+# func_source file
+# Source FILE, adding directory component if necessary.
+# Note that it is not necessary on cygwin/mingw to append a dot to
+# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
+# behavior happens only for exec(3), not for open(2)!  Also, sourcing
+# `FILE.' does not work on cygwin managed mounts.
+func_source ()
+{
+    $opt_debug
+    case $1 in
+    */* | *\\*)	. "$1" ;;
+    *)		. "./$1" ;;
+    esac
+}
+
+
+# func_resolve_sysroot PATH
+# Replace a leading = in PATH with a sysroot.  Store the result into
+# func_resolve_sysroot_result
+func_resolve_sysroot ()
+{
+  func_resolve_sysroot_result=$1
+  case $func_resolve_sysroot_result in
+  =*)
+    func_stripname '=' '' "$func_resolve_sysroot_result"
+    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result
+    ;;
+  esac
+}
+
+# func_replace_sysroot PATH
+# If PATH begins with the sysroot, replace it with = and
+# store the result into func_replace_sysroot_result.
+func_replace_sysroot ()
+{
+  case "$lt_sysroot:$1" in
+  ?*:"$lt_sysroot"*)
+    func_stripname "$lt_sysroot" '' "$1"
+    func_replace_sysroot_result="=$func_stripname_result"
+    ;;
+  *)
+    # Including no sysroot.
+    func_replace_sysroot_result=$1
+    ;;
+  esac
+}
+
+# func_infer_tag arg
+# Infer tagged configuration to use if any are available and
+# if one wasn't chosen via the "--tag" command line option.
+# Only attempt this if the compiler in the base compile
+# command doesn't match the default compiler.
+# arg is usually of the form 'gcc ...'
+func_infer_tag ()
+{
+    $opt_debug
+    if test -n "$available_tags" && test -z "$tagname"; then
+      CC_quoted=
+      for arg in $CC; do
+	func_append_quoted CC_quoted "$arg"
+      done
+      CC_expanded=`func_echo_all $CC`
+      CC_quoted_expanded=`func_echo_all $CC_quoted`
+      case $@ in
+      # Blanks in the command may have been stripped by the calling shell,
+      # but not from the CC environment variable when configure was run.
+      " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
+      " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*) ;;
+      # Blanks at the start of $base_compile will cause this to fail
+      # if we don't check for them as well.
+      *)
+	for z in $available_tags; do
+	  if $GREP "^# ### BEGIN LIBTOOL TAG CONFIG: $z$" < "$progpath" > /dev/null; then
+	    # Evaluate the configuration.
+	    eval "`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`"
+	    CC_quoted=
+	    for arg in $CC; do
+	      # Double-quote args containing other shell metacharacters.
+	      func_append_quoted CC_quoted "$arg"
+	    done
+	    CC_expanded=`func_echo_all $CC`
+	    CC_quoted_expanded=`func_echo_all $CC_quoted`
+	    case "$@ " in
+	    " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
+	    " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*)
+	      # The compiler in the base compile command matches
+	      # the one in the tagged configuration.
+	      # Assume this is the tagged configuration we want.
+	      tagname=$z
+	      break
+	      ;;
+	    esac
+	  fi
+	done
+	# If $tagname still isn't set, then no tagged configuration
+	# was found and let the user know that the "--tag" command
+	# line option must be used.
+	if test -z "$tagname"; then
+	  func_echo "unable to infer tagged configuration"
+	  func_fatal_error "specify a tag with \`--tag'"
+#	else
+#	  func_verbose "using $tagname tagged configuration"
+	fi
+	;;
+      esac
+    fi
+}
+
+
+
+# func_write_libtool_object output_name pic_name nonpic_name
+# Create a libtool object file (analogous to a ".la" file),
+# but don't create it if we're doing a dry run.
+func_write_libtool_object ()
+{
+    write_libobj=${1}
+    if test "$build_libtool_libs" = yes; then
+      write_lobj=\'${2}\'
+    else
+      write_lobj=none
+    fi
+
+    if test "$build_old_libs" = yes; then
+      write_oldobj=\'${3}\'
+    else
+      write_oldobj=none
+    fi
+
+    $opt_dry_run || {
+      cat >${write_libobj}T <<EOF
+# $write_libobj - a libtool object file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# Name of the PIC object.
+pic_object=$write_lobj
+
+# Name of the non-PIC object
+non_pic_object=$write_oldobj
+
+EOF
+      $MV "${write_libobj}T" "${write_libobj}"
+    }
+}
+
+
+##################################################
+# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #
+##################################################
+
+# func_convert_core_file_wine_to_w32 ARG
+# Helper function used by file name conversion functions when $build is *nix,
+# and $host is mingw, cygwin, or some other w32 environment. Relies on a
+# correctly configured wine environment available, with the winepath program
+# in $build's $PATH.
+#
+# ARG is the $build file name to be converted to w32 format.
+# Result is available in $func_convert_core_file_wine_to_w32_result, and will
+# be empty on error (or when ARG is empty)
+func_convert_core_file_wine_to_w32 ()
+{
+  $opt_debug
+  func_convert_core_file_wine_to_w32_result="$1"
+  if test -n "$1"; then
+    # Unfortunately, winepath does not exit with a non-zero error code, so we
+    # are forced to check the contents of stdout. On the other hand, if the
+    # command is not found, the shell will set an exit code of 127 and print
+    # *an error message* to stdout. So we must check for both error code of
+    # zero AND non-empty stdout, which explains the odd construction:
+    func_convert_core_file_wine_to_w32_tmp=`winepath -w "$1" 2>/dev/null`
+    if test "$?" -eq 0 && test -n "${func_convert_core_file_wine_to_w32_tmp}"; then
+      func_convert_core_file_wine_to_w32_result=`$ECHO "$func_convert_core_file_wine_to_w32_tmp" |
+        $SED -e "$lt_sed_naive_backslashify"`
+    else
+      func_convert_core_file_wine_to_w32_result=
+    fi
+  fi
+}
+# end: func_convert_core_file_wine_to_w32
+
+
+# func_convert_core_path_wine_to_w32 ARG
+# Helper function used by path conversion functions when $build is *nix, and
+# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly
+# configured wine environment available, with the winepath program in $build's
+# $PATH. Assumes ARG has no leading or trailing path separator characters.
+#
+# ARG is path to be converted from $build format to win32.
+# Result is available in $func_convert_core_path_wine_to_w32_result.
+# Unconvertible file (directory) names in ARG are skipped; if no directory names
+# are convertible, then the result may be empty.
+func_convert_core_path_wine_to_w32 ()
+{
+  $opt_debug
+  # unfortunately, winepath doesn't convert paths, only file names
+  func_convert_core_path_wine_to_w32_result=""
+  if test -n "$1"; then
+    oldIFS=$IFS
+    IFS=:
+    for func_convert_core_path_wine_to_w32_f in $1; do
+      IFS=$oldIFS
+      func_convert_core_file_wine_to_w32 "$func_convert_core_path_wine_to_w32_f"
+      if test -n "$func_convert_core_file_wine_to_w32_result" ; then
+        if test -z "$func_convert_core_path_wine_to_w32_result"; then
+          func_convert_core_path_wine_to_w32_result="$func_convert_core_file_wine_to_w32_result"
+        else
+          func_append func_convert_core_path_wine_to_w32_result ";$func_convert_core_file_wine_to_w32_result"
+        fi
+      fi
+    done
+    IFS=$oldIFS
+  fi
+}
+# end: func_convert_core_path_wine_to_w32
+
+
+# func_cygpath ARGS...
+# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when
+# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)
+# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or
+# (2), returns the Cygwin file name or path in func_cygpath_result (input
+# file name or path is assumed to be in w32 format, as previously converted
+# from $build's *nix or MSYS format). In case (3), returns the w32 file name
+# or path in func_cygpath_result (input file name or path is assumed to be in
+# Cygwin format). Returns an empty string on error.
+#
+# ARGS are passed to cygpath, with the last one being the file name or path to
+# be converted.
+#
+# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH
+# environment variable; do not put it in $PATH.
+func_cygpath ()
+{
+  $opt_debug
+  if test -n "$LT_CYGPATH" && test -f "$LT_CYGPATH"; then
+    func_cygpath_result=`$LT_CYGPATH "$@" 2>/dev/null`
+    if test "$?" -ne 0; then
+      # on failure, ensure result is empty
+      func_cygpath_result=
+    fi
+  else
+    func_cygpath_result=
+    func_error "LT_CYGPATH is empty or specifies non-existent file: \`$LT_CYGPATH'"
+  fi
+}
+#end: func_cygpath
+
+
+# func_convert_core_msys_to_w32 ARG
+# Convert file name or path ARG from MSYS format to w32 format.  Return
+# result in func_convert_core_msys_to_w32_result.
+func_convert_core_msys_to_w32 ()
+{
+  $opt_debug
+  # awkward: cmd appends spaces to result
+  func_convert_core_msys_to_w32_result=`( cmd //c echo "$1" ) 2>/dev/null |
+    $SED -e 's/[ ]*$//' -e "$lt_sed_naive_backslashify"`
+}
+#end: func_convert_core_msys_to_w32
+
+
+# func_convert_file_check ARG1 ARG2
+# Verify that ARG1 (a file name in $build format) was converted to $host
+# format in ARG2. Otherwise, emit an error message, but continue (resetting
+# func_to_host_file_result to ARG1).
+func_convert_file_check ()
+{
+  $opt_debug
+  if test -z "$2" && test -n "$1" ; then
+    func_error "Could not determine host file name corresponding to"
+    func_error "  \`$1'"
+    func_error "Continuing, but uninstalled executables may not work."
+    # Fallback:
+    func_to_host_file_result="$1"
+  fi
+}
+# end func_convert_file_check
+
+
+# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH
+# Verify that FROM_PATH (a path in $build format) was converted to $host
+# format in TO_PATH. Otherwise, emit an error message, but continue, resetting
+# func_to_host_file_result to a simplistic fallback value (see below).
+func_convert_path_check ()
+{
+  $opt_debug
+  if test -z "$4" && test -n "$3"; then
+    func_error "Could not determine the host path corresponding to"
+    func_error "  \`$3'"
+    func_error "Continuing, but uninstalled executables may not work."
+    # Fallback.  This is a deliberately simplistic "conversion" and
+    # should not be "improved".  See libtool.info.
+    if test "x$1" != "x$2"; then
+      lt_replace_pathsep_chars="s|$1|$2|g"
+      func_to_host_path_result=`echo "$3" |
+        $SED -e "$lt_replace_pathsep_chars"`
+    else
+      func_to_host_path_result="$3"
+    fi
+  fi
+}
+# end func_convert_path_check
+
+
+# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG
+# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT
+# and appending REPL if ORIG matches BACKPAT.
+func_convert_path_front_back_pathsep ()
+{
+  $opt_debug
+  case $4 in
+  $1 ) func_to_host_path_result="$3$func_to_host_path_result"
+    ;;
+  esac
+  case $4 in
+  $2 ) func_append func_to_host_path_result "$3"
+    ;;
+  esac
+}
+# end func_convert_path_front_back_pathsep
+
+
+##################################################
+# $build to $host FILE NAME CONVERSION FUNCTIONS #
+##################################################
+# invoked via `$to_host_file_cmd ARG'
+#
+# In each case, ARG is the path to be converted from $build to $host format.
+# Result will be available in $func_to_host_file_result.
+
+
+# func_to_host_file ARG
+# Converts the file name ARG from $build format to $host format. Return result
+# in func_to_host_file_result.
+func_to_host_file ()
+{
+  $opt_debug
+  $to_host_file_cmd "$1"
+}
+# end func_to_host_file
+
+
+# func_to_tool_file ARG LAZY
+# converts the file name ARG from $build format to toolchain format. Return
+# result in func_to_tool_file_result.  If the conversion in use is listed
+# in (the comma separated) LAZY, no conversion takes place.
+func_to_tool_file ()
+{
+  $opt_debug
+  case ,$2, in
+    *,"$to_tool_file_cmd",*)
+      func_to_tool_file_result=$1
+      ;;
+    *)
+      $to_tool_file_cmd "$1"
+      func_to_tool_file_result=$func_to_host_file_result
+      ;;
+  esac
+}
+# end func_to_tool_file
+
+
+# func_convert_file_noop ARG
+# Copy ARG to func_to_host_file_result.
+func_convert_file_noop ()
+{
+  func_to_host_file_result="$1"
+}
+# end func_convert_file_noop
+
+
+# func_convert_file_msys_to_w32 ARG
+# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic
+# conversion to w32 is not available inside the cwrapper.  Returns result in
+# func_to_host_file_result.
+func_convert_file_msys_to_w32 ()
+{
+  $opt_debug
+  func_to_host_file_result="$1"
+  if test -n "$1"; then
+    func_convert_core_msys_to_w32 "$1"
+    func_to_host_file_result="$func_convert_core_msys_to_w32_result"
+  fi
+  func_convert_file_check "$1" "$func_to_host_file_result"
+}
+# end func_convert_file_msys_to_w32
+
+
+# func_convert_file_cygwin_to_w32 ARG
+# Convert file name ARG from Cygwin to w32 format.  Returns result in
+# func_to_host_file_result.
+func_convert_file_cygwin_to_w32 ()
+{
+  $opt_debug
+  func_to_host_file_result="$1"
+  if test -n "$1"; then
+    # because $build is cygwin, we call "the" cygpath in $PATH; no need to use
+    # LT_CYGPATH in this case.
+    func_to_host_file_result=`cygpath -m "$1"`
+  fi
+  func_convert_file_check "$1" "$func_to_host_file_result"
+}
+# end func_convert_file_cygwin_to_w32
+
+
+# func_convert_file_nix_to_w32 ARG
+# Convert file name ARG from *nix to w32 format.  Requires a wine environment
+# and a working winepath. Returns result in func_to_host_file_result.
+func_convert_file_nix_to_w32 ()
+{
+  $opt_debug
+  func_to_host_file_result="$1"
+  if test -n "$1"; then
+    func_convert_core_file_wine_to_w32 "$1"
+    func_to_host_file_result="$func_convert_core_file_wine_to_w32_result"
+  fi
+  func_convert_file_check "$1" "$func_to_host_file_result"
+}
+# end func_convert_file_nix_to_w32
+
+
+# func_convert_file_msys_to_cygwin ARG
+# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.
+# Returns result in func_to_host_file_result.
+func_convert_file_msys_to_cygwin ()
+{
+  $opt_debug
+  func_to_host_file_result="$1"
+  if test -n "$1"; then
+    func_convert_core_msys_to_w32 "$1"
+    func_cygpath -u "$func_convert_core_msys_to_w32_result"
+    func_to_host_file_result="$func_cygpath_result"
+  fi
+  func_convert_file_check "$1" "$func_to_host_file_result"
+}
+# end func_convert_file_msys_to_cygwin
+
+
+# func_convert_file_nix_to_cygwin ARG
+# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed
+# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result
+# in func_to_host_file_result.
+func_convert_file_nix_to_cygwin ()
+{
+  $opt_debug
+  func_to_host_file_result="$1"
+  if test -n "$1"; then
+    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.
+    func_convert_core_file_wine_to_w32 "$1"
+    func_cygpath -u "$func_convert_core_file_wine_to_w32_result"
+    func_to_host_file_result="$func_cygpath_result"
+  fi
+  func_convert_file_check "$1" "$func_to_host_file_result"
+}
+# end func_convert_file_nix_to_cygwin
+
+
+#############################################
+# $build to $host PATH CONVERSION FUNCTIONS #
+#############################################
+# invoked via `$to_host_path_cmd ARG'
+#
+# In each case, ARG is the path to be converted from $build to $host format.
+# The result will be available in $func_to_host_path_result.
+#
+# Path separators are also converted from $build format to $host format.  If
+# ARG begins or ends with a path separator character, it is preserved (but
+# converted to $host format) on output.
+#
+# All path conversion functions are named using the following convention:
+#   file name conversion function    : func_convert_file_X_to_Y ()
+#   path conversion function         : func_convert_path_X_to_Y ()
+# where, for any given $build/$host combination the 'X_to_Y' value is the
+# same.  If conversion functions are added for new $build/$host combinations,
+# the two new functions must follow this pattern, or func_init_to_host_path_cmd
+# will break.
+
+
+# func_init_to_host_path_cmd
+# Ensures that function "pointer" variable $to_host_path_cmd is set to the
+# appropriate value, based on the value of $to_host_file_cmd.
+to_host_path_cmd=
+func_init_to_host_path_cmd ()
+{
+  $opt_debug
+  if test -z "$to_host_path_cmd"; then
+    func_stripname 'func_convert_file_' '' "$to_host_file_cmd"
+    to_host_path_cmd="func_convert_path_${func_stripname_result}"
+  fi
+}
+
+
+# func_to_host_path ARG
+# Converts the path ARG from $build format to $host format. Return result
+# in func_to_host_path_result.
+func_to_host_path ()
+{
+  $opt_debug
+  func_init_to_host_path_cmd
+  $to_host_path_cmd "$1"
+}
+# end func_to_host_path
+
+
+# func_convert_path_noop ARG
+# Copy ARG to func_to_host_path_result.
+func_convert_path_noop ()
+{
+  func_to_host_path_result="$1"
+}
+# end func_convert_path_noop
+
+
+# func_convert_path_msys_to_w32 ARG
+# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic
+# conversion to w32 is not available inside the cwrapper.  Returns result in
+# func_to_host_path_result.
+func_convert_path_msys_to_w32 ()
+{
+  $opt_debug
+  func_to_host_path_result="$1"
+  if test -n "$1"; then
+    # Remove leading and trailing path separator characters from ARG.  MSYS
+    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';
+    # and winepath ignores them completely.
+    func_stripname : : "$1"
+    func_to_host_path_tmp1=$func_stripname_result
+    func_convert_core_msys_to_w32 "$func_to_host_path_tmp1"
+    func_to_host_path_result="$func_convert_core_msys_to_w32_result"
+    func_convert_path_check : ";" \
+      "$func_to_host_path_tmp1" "$func_to_host_path_result"
+    func_convert_path_front_back_pathsep ":*" "*:" ";" "$1"
+  fi
+}
+# end func_convert_path_msys_to_w32
+
+
+# func_convert_path_cygwin_to_w32 ARG
+# Convert path ARG from Cygwin to w32 format.  Returns result in
+# func_to_host_file_result.
+func_convert_path_cygwin_to_w32 ()
+{
+  $opt_debug
+  func_to_host_path_result="$1"
+  if test -n "$1"; then
+    # See func_convert_path_msys_to_w32:
+    func_stripname : : "$1"
+    func_to_host_path_tmp1=$func_stripname_result
+    func_to_host_path_result=`cygpath -m -p "$func_to_host_path_tmp1"`
+    func_convert_path_check : ";" \
+      "$func_to_host_path_tmp1" "$func_to_host_path_result"
+    func_convert_path_front_back_pathsep ":*" "*:" ";" "$1"
+  fi
+}
+# end func_convert_path_cygwin_to_w32
+
+
+# func_convert_path_nix_to_w32 ARG
+# Convert path ARG from *nix to w32 format.  Requires a wine environment and
+# a working winepath.  Returns result in func_to_host_file_result.
+func_convert_path_nix_to_w32 ()
+{
+  $opt_debug
+  func_to_host_path_result="$1"
+  if test -n "$1"; then
+    # See func_convert_path_msys_to_w32:
+    func_stripname : : "$1"
+    func_to_host_path_tmp1=$func_stripname_result
+    func_convert_core_path_wine_to_w32 "$func_to_host_path_tmp1"
+    func_to_host_path_result="$func_convert_core_path_wine_to_w32_result"
+    func_convert_path_check : ";" \
+      "$func_to_host_path_tmp1" "$func_to_host_path_result"
+    func_convert_path_front_back_pathsep ":*" "*:" ";" "$1"
+  fi
+}
+# end func_convert_path_nix_to_w32
+
+
+# func_convert_path_msys_to_cygwin ARG
+# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.
+# Returns result in func_to_host_file_result.
+func_convert_path_msys_to_cygwin ()
+{
+  $opt_debug
+  func_to_host_path_result="$1"
+  if test -n "$1"; then
+    # See func_convert_path_msys_to_w32:
+    func_stripname : : "$1"
+    func_to_host_path_tmp1=$func_stripname_result
+    func_convert_core_msys_to_w32 "$func_to_host_path_tmp1"
+    func_cygpath -u -p "$func_convert_core_msys_to_w32_result"
+    func_to_host_path_result="$func_cygpath_result"
+    func_convert_path_check : : \
+      "$func_to_host_path_tmp1" "$func_to_host_path_result"
+    func_convert_path_front_back_pathsep ":*" "*:" : "$1"
+  fi
+}
+# end func_convert_path_msys_to_cygwin
+
+
+# func_convert_path_nix_to_cygwin ARG
+# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a
+# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in
+# func_to_host_file_result.
+func_convert_path_nix_to_cygwin ()
+{
+  $opt_debug
+  func_to_host_path_result="$1"
+  if test -n "$1"; then
+    # Remove leading and trailing path separator characters from
+    # ARG. msys behavior is inconsistent here, cygpath turns them
+    # into '.;' and ';.', and winepath ignores them completely.
+    func_stripname : : "$1"
+    func_to_host_path_tmp1=$func_stripname_result
+    func_convert_core_path_wine_to_w32 "$func_to_host_path_tmp1"
+    func_cygpath -u -p "$func_convert_core_path_wine_to_w32_result"
+    func_to_host_path_result="$func_cygpath_result"
+    func_convert_path_check : : \
+      "$func_to_host_path_tmp1" "$func_to_host_path_result"
+    func_convert_path_front_back_pathsep ":*" "*:" : "$1"
+  fi
+}
+# end func_convert_path_nix_to_cygwin
+
+
+# func_mode_compile arg...
+func_mode_compile ()
+{
+    $opt_debug
+    # Get the compilation command and the source file.
+    base_compile=
+    srcfile="$nonopt"  #  always keep a non-empty value in "srcfile"
+    suppress_opt=yes
+    suppress_output=
+    arg_mode=normal
+    libobj=
+    later=
+    pie_flag=
+
+    for arg
+    do
+      case $arg_mode in
+      arg  )
+	# do not "continue".  Instead, add this to base_compile
+	lastarg="$arg"
+	arg_mode=normal
+	;;
+
+      target )
+	libobj="$arg"
+	arg_mode=normal
+	continue
+	;;
+
+      normal )
+	# Accept any command-line options.
+	case $arg in
+	-o)
+	  test -n "$libobj" && \
+	    func_fatal_error "you cannot specify \`-o' more than once"
+	  arg_mode=target
+	  continue
+	  ;;
+
+	-pie | -fpie | -fPIE)
+          func_append pie_flag " $arg"
+	  continue
+	  ;;
+
+	-shared | -static | -prefer-pic | -prefer-non-pic)
+	  func_append later " $arg"
+	  continue
+	  ;;
+
+	-no-suppress)
+	  suppress_opt=no
+	  continue
+	  ;;
+
+	-Xcompiler)
+	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
+	  continue      #  The current "srcfile" will either be retained or
+	  ;;            #  replaced later.  I would guess that would be a bug.
+
+	-Wc,*)
+	  func_stripname '-Wc,' '' "$arg"
+	  args=$func_stripname_result
+	  lastarg=
+	  save_ifs="$IFS"; IFS=','
+	  for arg in $args; do
+	    IFS="$save_ifs"
+	    func_append_quoted lastarg "$arg"
+	  done
+	  IFS="$save_ifs"
+	  func_stripname ' ' '' "$lastarg"
+	  lastarg=$func_stripname_result
+
+	  # Add the arguments to base_compile.
+	  func_append base_compile " $lastarg"
+	  continue
+	  ;;
+
+	*)
+	  # Accept the current argument as the source file.
+	  # The previous "srcfile" becomes the current argument.
+	  #
+	  lastarg="$srcfile"
+	  srcfile="$arg"
+	  ;;
+	esac  #  case $arg
+	;;
+      esac    #  case $arg_mode
+
+      # Aesthetically quote the previous argument.
+      func_append_quoted base_compile "$lastarg"
+    done # for arg
+
+    case $arg_mode in
+    arg)
+      func_fatal_error "you must specify an argument for -Xcompile"
+      ;;
+    target)
+      func_fatal_error "you must specify a target with \`-o'"
+      ;;
+    *)
+      # Get the name of the library object.
+      test -z "$libobj" && {
+	func_basename "$srcfile"
+	libobj="$func_basename_result"
+      }
+      ;;
+    esac
+
+    # Recognize several different file suffixes.
+    # If the user specifies -o file.o, it is replaced with file.lo
+    case $libobj in
+    *.[cCFSifmso] | \
+    *.ada | *.adb | *.ads | *.asm | \
+    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
+    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)
+      func_xform "$libobj"
+      libobj=$func_xform_result
+      ;;
+    esac
+
+    case $libobj in
+    *.lo) func_lo2o "$libobj"; obj=$func_lo2o_result ;;
+    *)
+      func_fatal_error "cannot determine name of library object from \`$libobj'"
+      ;;
+    esac
+
+    func_infer_tag $base_compile
+
+    for arg in $later; do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	continue
+	;;
+
+      -static)
+	build_libtool_libs=no
+	build_old_libs=yes
+	continue
+	;;
+
+      -prefer-pic)
+	pic_mode=yes
+	continue
+	;;
+
+      -prefer-non-pic)
+	pic_mode=no
+	continue
+	;;
+      esac
+    done
+
+    func_quote_for_eval "$libobj"
+    test "X$libobj" != "X$func_quote_for_eval_result" \
+      && $ECHO "X$libobj" | $GREP '[]~#^*{};<>?"'"'"'	 &()|`$[]' \
+      && func_warning "libobj name \`$libobj' may not contain shell special characters."
+    func_dirname_and_basename "$obj" "/" ""
+    objname="$func_basename_result"
+    xdir="$func_dirname_result"
+    lobj=${xdir}$objdir/$objname
+
+    test -z "$base_compile" && \
+      func_fatal_help "you must specify a compilation command"
+
+    # Delete any leftover library objects.
+    if test "$build_old_libs" = yes; then
+      removelist="$obj $lobj $libobj ${libobj}T"
+    else
+      removelist="$lobj $libobj ${libobj}T"
+    fi
+
+    # On Cygwin there's no "real" PIC flag so we must build both object types
+    case $host_os in
+    cygwin* | mingw* | pw32* | os2* | cegcc*)
+      pic_mode=default
+      ;;
+    esac
+    if test "$pic_mode" = no && test "$deplibs_check_method" != pass_all; then
+      # non-PIC code in shared libraries is not supported
+      pic_mode=default
+    fi
+
+    # Calculate the filename of the output object if compiler does
+    # not support -o with -c
+    if test "$compiler_c_o" = no; then
+      output_obj=`$ECHO "$srcfile" | $SED 's%^.*/%%; s%\.[^.]*$%%'`.${objext}
+      lockfile="$output_obj.lock"
+    else
+      output_obj=
+      need_locks=no
+      lockfile=
+    fi
+
+    # Lock this critical section if it is needed
+    # We use this script file to make the link, it avoids creating a new file
+    if test "$need_locks" = yes; then
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    elif test "$need_locks" = warn; then
+      if test -f "$lockfile"; then
+	$ECHO "\
+*** ERROR, $lockfile exists and contains:
+`cat $lockfile 2>/dev/null`
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+      func_append removelist " $output_obj"
+      $ECHO "$srcfile" > "$lockfile"
+    fi
+
+    $opt_dry_run || $RM $removelist
+    func_append removelist " $lockfile"
+    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
+
+    func_to_tool_file "$srcfile" func_convert_file_msys_to_w32
+    srcfile=$func_to_tool_file_result
+    func_quote_for_eval "$srcfile"
+    qsrcfile=$func_quote_for_eval_result
+
+    # Only build a PIC object if we are building libtool libraries.
+    if test "$build_libtool_libs" = yes; then
+      # Without this assignment, base_compile gets emptied.
+      fbsd_hideous_sh_bug=$base_compile
+
+      if test "$pic_mode" != no; then
+	command="$base_compile $qsrcfile $pic_flag"
+      else
+	# Don't build PIC code
+	command="$base_compile $qsrcfile"
+      fi
+
+      func_mkdir_p "$xdir$objdir"
+
+      if test -z "$output_obj"; then
+	# Place PIC objects in $objdir
+	func_append command " -o $lobj"
+      fi
+
+      func_show_eval_locale "$command"	\
+          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed, then go on to compile the next one
+      if test -n "$output_obj" && test "X$output_obj" != "X$lobj"; then
+	func_show_eval '$MV "$output_obj" "$lobj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+
+      # Allow error messages only from the first compilation.
+      if test "$suppress_opt" = yes; then
+	suppress_output=' >/dev/null 2>&1'
+      fi
+    fi
+
+    # Only build a position-dependent object if we build old libraries.
+    if test "$build_old_libs" = yes; then
+      if test "$pic_mode" != yes; then
+	# Don't build PIC code
+	command="$base_compile $qsrcfile$pie_flag"
+      else
+	command="$base_compile $qsrcfile $pic_flag"
+      fi
+      if test "$compiler_c_o" = yes; then
+	func_append command " -o $obj"
+      fi
+
+      # Suppress compiler output if we already did a PIC compilation.
+      func_append command "$suppress_output"
+      func_show_eval_locale "$command" \
+        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
+
+      if test "$need_locks" = warn &&
+	 test "X`cat $lockfile 2>/dev/null`" != "X$srcfile"; then
+	$ECHO "\
+*** ERROR, $lockfile contains:
+`cat $lockfile 2>/dev/null`
+
+but it should contain:
+$srcfile
+
+This indicates that another process is trying to use the same
+temporary object file, and libtool could not work around it because
+your compiler does not support \`-c' and \`-o' together.  If you
+repeat this compilation, it may succeed, by chance, but you had better
+avoid parallel builds (make -j) in this platform, or get a better
+compiler."
+
+	$opt_dry_run || $RM $removelist
+	exit $EXIT_FAILURE
+      fi
+
+      # Just move the object if needed
+      if test -n "$output_obj" && test "X$output_obj" != "X$obj"; then
+	func_show_eval '$MV "$output_obj" "$obj"' \
+	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
+      fi
+    fi
+
+    $opt_dry_run || {
+      func_write_libtool_object "$libobj" "$objdir/$objname" "$objname"
+
+      # Unlock the critical section if it was locked
+      if test "$need_locks" != no; then
+	removelist=$lockfile
+        $RM "$lockfile"
+      fi
+    }
+
+    exit $EXIT_SUCCESS
+}
+
+$opt_help || {
+  test "$opt_mode" = compile && func_mode_compile ${1+"$@"}
+}
+
+func_mode_help ()
+{
+    # We need to display help for each of the modes.
+    case $opt_mode in
+      "")
+        # Generic help is extracted from the usage comments
+        # at the start of this file.
+        func_help
+        ;;
+
+      clean)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...
+
+Remove files from the build directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, object or program, all the files associated
+with it are deleted. Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      compile)
+      $ECHO \
+"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE
+
+Compile a source file into a libtool library object.
+
+This mode accepts the following additional options:
+
+  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE
+  -no-suppress      do not suppress compiler output for multiple passes
+  -prefer-pic       try to build PIC objects only
+  -prefer-non-pic   try to build non-PIC objects only
+  -shared           do not build a \`.o' file suitable for static linking
+  -static           only build a \`.o' file suitable for static linking
+  -Wc,FLAG          pass FLAG directly to the compiler
+
+COMPILE-COMMAND is a command to be used in creating a \`standard' object file
+from the given SOURCEFILE.
+
+The output file name is determined by removing the directory component from
+SOURCEFILE, then substituting the C source code suffix \`.c' with the
+library object suffix, \`.lo'."
+        ;;
+
+      execute)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
+
+Automatically set library path, then run a program.
+
+This mode accepts the following additional options:
+
+  -dlopen FILE      add the directory containing FILE to the library path
+
+This mode sets the library path environment variable according to \`-dlopen'
+flags.
+
+If any of the ARGS are libtool executable wrappers, then they are translated
+into their corresponding uninstalled binary, and any of their required library
+directories are added to the library path.
+
+Then, COMMAND is executed, with ARGS as arguments."
+        ;;
+
+      finish)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...
+
+Complete the installation of libtool libraries.
+
+Each LIBDIR is a directory that contains libtool libraries.
+
+The commands that this mode executes may require superuser privileges.  Use
+the \`--dry-run' option if you just want to see what would be executed."
+        ;;
+
+      install)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...
+
+Install executables or libraries.
+
+INSTALL-COMMAND is the installation command.  The first component should be
+either the \`install' or \`cp' program.
+
+The following components of INSTALL-COMMAND are treated specially:
+
+  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
+
+The rest of the components are interpreted as arguments to that command (only
+BSD-compatible install options are recognized)."
+        ;;
+
+      link)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...
+
+Link object files or libraries together to form another library, or to
+create an executable program.
+
+LINK-COMMAND is a command using the C compiler that you would use to create
+a program from several object files.
+
+The following components of LINK-COMMAND are treated specially:
+
+  -all-static       do not do any dynamic linking at all
+  -avoid-version    do not add a version suffix if possible
+  -bindir BINDIR    specify path to binaries directory (for systems where
+                    libraries must be found in the PATH setting at runtime)
+  -dlopen FILE      \`-dlpreopen' FILE if it cannot be dlopened at runtime
+  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols
+  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
+  -export-symbols SYMFILE
+                    try to export only the symbols listed in SYMFILE
+  -export-symbols-regex REGEX
+                    try to export only the symbols matching REGEX
+  -LLIBDIR          search LIBDIR for required installed libraries
+  -lNAME            OUTPUT-FILE requires the installed library libNAME
+  -module           build a library that can dlopened
+  -no-fast-install  disable the fast-install mode
+  -no-install       link a not-installable executable
+  -no-undefined     declare that a library does not refer to external symbols
+  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects
+  -objectlist FILE  Use a list of object files found in FILE to specify objects
+  -precious-files-regex REGEX
+                    don't remove output files matching REGEX
+  -release RELEASE  specify package release information
+  -rpath LIBDIR     the created library will eventually be installed in LIBDIR
+  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries
+  -shared           only do dynamic linking of libtool libraries
+  -shrext SUFFIX    override the standard shared library file extension
+  -static           do not do any dynamic linking of uninstalled libtool libraries
+  -static-libtool-libs
+                    do not do any dynamic linking of libtool libraries
+  -version-info CURRENT[:REVISION[:AGE]]
+                    specify library version info [each variable defaults to 0]
+  -weak LIBNAME     declare that the target provides the LIBNAME interface
+  -Wc,FLAG
+  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler
+  -Wl,FLAG
+  -Xlinker FLAG     pass linker-specific FLAG directly to the linker
+  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)
+
+All other options (arguments beginning with \`-') are ignored.
+
+Every other argument is treated as a filename.  Files ending in \`.la' are
+treated as uninstalled libtool libraries, other files are standard or library
+object files.
+
+If the OUTPUT-FILE ends in \`.la', then a libtool library is created,
+only library objects (\`.lo' files) may be specified, and \`-rpath' is
+required, except when creating a convenience library.
+
+If OUTPUT-FILE ends in \`.a' or \`.lib', then a standard library is created
+using \`ar' and \`ranlib', or on Windows using \`lib'.
+
+If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
+is created, otherwise an executable program is created."
+        ;;
+
+      uninstall)
+        $ECHO \
+"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...
+
+Remove libraries from an installation directory.
+
+RM is the name of the program to use to delete files associated with each FILE
+(typically \`/bin/rm').  RM-OPTIONS are options (such as \`-f') to be passed
+to RM.
+
+If FILE is a libtool library, all the files associated with it are deleted.
+Otherwise, only FILE itself is deleted using RM."
+        ;;
+
+      *)
+        func_fatal_help "invalid operation mode \`$opt_mode'"
+        ;;
+    esac
+
+    echo
+    $ECHO "Try \`$progname --help' for more information about other modes."
+}
+
+# Now that we've collected a possible --mode arg, show help if necessary
+if $opt_help; then
+  if test "$opt_help" = :; then
+    func_mode_help
+  else
+    {
+      func_help noexit
+      for opt_mode in compile link execute install finish uninstall clean; do
+	func_mode_help
+      done
+    } | sed -n '1p; 2,$s/^Usage:/  or: /p'
+    {
+      func_help noexit
+      for opt_mode in compile link execute install finish uninstall clean; do
+	echo
+	func_mode_help
+      done
+    } |
+    sed '1d
+      /^When reporting/,/^Report/{
+	H
+	d
+      }
+      $x
+      /information about other modes/d
+      /more detailed .*MODE/d
+      s/^Usage:.*--mode=\([^ ]*\) .*/Description of \1 mode:/'
+  fi
+  exit $?
+fi
+
+
+# func_mode_execute arg...
+func_mode_execute ()
+{
+    $opt_debug
+    # The first argument is the command name.
+    cmd="$nonopt"
+    test -z "$cmd" && \
+      func_fatal_help "you must specify a COMMAND"
+
+    # Handle -dlopen flags immediately.
+    for file in $opt_dlopen; do
+      test -f "$file" \
+	|| func_fatal_help "\`$file' is not a file"
+
+      dir=
+      case $file in
+      *.la)
+	func_resolve_sysroot "$file"
+	file=$func_resolve_sysroot_result
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$lib' is not a valid libtool archive"
+
+	# Read the libtool library.
+	dlname=
+	library_names=
+	func_source "$file"
+
+	# Skip this library if it cannot be dlopened.
+	if test -z "$dlname"; then
+	  # Warn if it was a shared library.
+	  test -n "$library_names" && \
+	    func_warning "\`$file' was not linked with \`-export-dynamic'"
+	  continue
+	fi
+
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+
+	if test -f "$dir/$objdir/$dlname"; then
+	  func_append dir "/$objdir"
+	else
+	  if test ! -f "$dir/$dlname"; then
+	    func_fatal_error "cannot find \`$dlname' in \`$dir' or \`$dir/$objdir'"
+	  fi
+	fi
+	;;
+
+      *.lo)
+	# Just add the directory containing the .lo file.
+	func_dirname "$file" "" "."
+	dir="$func_dirname_result"
+	;;
+
+      *)
+	func_warning "\`-dlopen' is ignored for non-libtool libraries and objects"
+	continue
+	;;
+      esac
+
+      # Get the absolute pathname.
+      absdir=`cd "$dir" && pwd`
+      test -n "$absdir" && dir="$absdir"
+
+      # Now add the directory to shlibpath_var.
+      if eval "test -z \"\$$shlibpath_var\""; then
+	eval "$shlibpath_var=\"\$dir\""
+      else
+	eval "$shlibpath_var=\"\$dir:\$$shlibpath_var\""
+      fi
+    done
+
+    # This variable tells wrapper scripts just to set shlibpath_var
+    # rather than running their programs.
+    libtool_execute_magic="$magic"
+
+    # Check if any of the arguments is a wrapper script.
+    args=
+    for file
+    do
+      case $file in
+      -* | *.la | *.lo ) ;;
+      *)
+	# Do a test to see if this is really a libtool program.
+	if func_ltwrapper_script_p "$file"; then
+	  func_source "$file"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	elif func_ltwrapper_executable_p "$file"; then
+	  func_ltwrapper_scriptname "$file"
+	  func_source "$func_ltwrapper_scriptname_result"
+	  # Transform arg to wrapped name.
+	  file="$progdir/$program"
+	fi
+	;;
+      esac
+      # Quote arguments (to preserve shell metacharacters).
+      func_append_quoted args "$file"
+    done
+
+    if test "X$opt_dry_run" = Xfalse; then
+      if test -n "$shlibpath_var"; then
+	# Export the shlibpath_var.
+	eval "export $shlibpath_var"
+      fi
+
+      # Restore saved environment variables
+      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES
+      do
+	eval "if test \"\${save_$lt_var+set}\" = set; then
+                $lt_var=\$save_$lt_var; export $lt_var
+	      else
+		$lt_unset $lt_var
+	      fi"
+      done
+
+      # Now prepare to actually exec the command.
+      exec_cmd="\$cmd$args"
+    else
+      # Display what would be done.
+      if test -n "$shlibpath_var"; then
+	eval "\$ECHO \"\$shlibpath_var=\$$shlibpath_var\""
+	echo "export $shlibpath_var"
+      fi
+      $ECHO "$cmd$args"
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$opt_mode" = execute && func_mode_execute ${1+"$@"}
+
+
+# func_mode_finish arg...
+func_mode_finish ()
+{
+    $opt_debug
+    libs=
+    libdirs=
+    admincmds=
+
+    for opt in "$nonopt" ${1+"$@"}
+    do
+      if test -d "$opt"; then
+	func_append libdirs " $opt"
+
+      elif test -f "$opt"; then
+	if func_lalib_unsafe_p "$opt"; then
+	  func_append libs " $opt"
+	else
+	  func_warning "\`$opt' is not a valid libtool archive"
+	fi
+
+      else
+	func_fatal_error "invalid argument \`$opt'"
+      fi
+    done
+
+    if test -n "$libs"; then
+      if test -n "$lt_sysroot"; then
+        sysroot_regex=`$ECHO "$lt_sysroot" | $SED "$sed_make_literal_regex"`
+        sysroot_cmd="s/\([ ']\)$sysroot_regex/\1/g;"
+      else
+        sysroot_cmd=
+      fi
+
+      # Remove sysroot references
+      if $opt_dry_run; then
+        for lib in $libs; do
+          echo "removing references to $lt_sysroot and \`=' prefixes from $lib"
+        done
+      else
+        tmpdir=`func_mktempdir`
+        for lib in $libs; do
+	  sed -e "${sysroot_cmd} s/\([ ']-[LR]\)=/\1/g; s/\([ ']\)=/\1/g" $lib \
+	    > $tmpdir/tmp-la
+	  mv -f $tmpdir/tmp-la $lib
+	done
+        ${RM}r "$tmpdir"
+      fi
+    fi
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      for libdir in $libdirs; do
+	if test -n "$finish_cmds"; then
+	  # Do each command in the finish commands.
+	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
+'"$cmd"'"'
+	fi
+	if test -n "$finish_eval"; then
+	  # Do the single finish_eval.
+	  eval cmds=\"$finish_eval\"
+	  $opt_dry_run || eval "$cmds" || func_append admincmds "
+       $cmds"
+	fi
+      done
+    fi
+
+    # Exit here if they wanted silent mode.
+    $opt_silent && exit $EXIT_SUCCESS
+
+    if test -n "$finish_cmds$finish_eval" && test -n "$libdirs"; then
+      echo "----------------------------------------------------------------------"
+      echo "Libraries have been installed in:"
+      for libdir in $libdirs; do
+	$ECHO "   $libdir"
+      done
+      echo
+      echo "If you ever happen to want to link against installed libraries"
+      echo "in a given directory, LIBDIR, you must either use libtool, and"
+      echo "specify the full pathname of the library, or use the \`-LLIBDIR'"
+      echo "flag during linking and do at least one of the following:"
+      if test -n "$shlibpath_var"; then
+	echo "   - add LIBDIR to the \`$shlibpath_var' environment variable"
+	echo "     during execution"
+      fi
+      if test -n "$runpath_var"; then
+	echo "   - add LIBDIR to the \`$runpath_var' environment variable"
+	echo "     during linking"
+      fi
+      if test -n "$hardcode_libdir_flag_spec"; then
+	libdir=LIBDIR
+	eval flag=\"$hardcode_libdir_flag_spec\"
+
+	$ECHO "   - use the \`$flag' linker flag"
+      fi
+      if test -n "$admincmds"; then
+	$ECHO "   - have your system administrator run these commands:$admincmds"
+      fi
+      if test -f /etc/ld.so.conf; then
+	echo "   - have your system administrator add LIBDIR to \`/etc/ld.so.conf'"
+      fi
+      echo
+
+      echo "See any operating system documentation about shared libraries for"
+      case $host in
+	solaris2.[6789]|solaris2.1[0-9])
+	  echo "more information, such as the ld(1), crle(1) and ld.so(8) manual"
+	  echo "pages."
+	  ;;
+	*)
+	  echo "more information, such as the ld(1) and ld.so(8) manual pages."
+	  ;;
+      esac
+      echo "----------------------------------------------------------------------"
+    fi
+    exit $EXIT_SUCCESS
+}
+
+test "$opt_mode" = finish && func_mode_finish ${1+"$@"}
+
+
+# func_mode_install arg...
+func_mode_install ()
+{
+    $opt_debug
+    # There may be an optional sh(1) argument at the beginning of
+    # install_prog (especially on Windows NT).
+    if test "$nonopt" = "$SHELL" || test "$nonopt" = /bin/sh ||
+       # Allow the use of GNU shtool's install command.
+       case $nonopt in *shtool*) :;; *) false;; esac; then
+      # Aesthetically quote it.
+      func_quote_for_eval "$nonopt"
+      install_prog="$func_quote_for_eval_result "
+      arg=$1
+      shift
+    else
+      install_prog=
+      arg=$nonopt
+    fi
+
+    # The real first argument should be the name of the installation program.
+    # Aesthetically quote it.
+    func_quote_for_eval "$arg"
+    func_append install_prog "$func_quote_for_eval_result"
+    install_shared_prog=$install_prog
+    case " $install_prog " in
+      *[\\\ /]cp\ *) install_cp=: ;;
+      *) install_cp=false ;;
+    esac
+
+    # We need to accept at least all the BSD install flags.
+    dest=
+    files=
+    opts=
+    prev=
+    install_type=
+    isdir=no
+    stripme=
+    no_mode=:
+    for arg
+    do
+      arg2=
+      if test -n "$dest"; then
+	func_append files " $dest"
+	dest=$arg
+	continue
+      fi
+
+      case $arg in
+      -d) isdir=yes ;;
+      -f)
+	if $install_cp; then :; else
+	  prev=$arg
+	fi
+	;;
+      -g | -m | -o)
+	prev=$arg
+	;;
+      -s)
+	stripme=" -s"
+	continue
+	;;
+      -*)
+	;;
+      *)
+	# If the previous option needed an argument, then skip it.
+	if test -n "$prev"; then
+	  if test "x$prev" = x-m && test -n "$install_override_mode"; then
+	    arg2=$install_override_mode
+	    no_mode=false
+	  fi
+	  prev=
+	else
+	  dest=$arg
+	  continue
+	fi
+	;;
+      esac
+
+      # Aesthetically quote the argument.
+      func_quote_for_eval "$arg"
+      func_append install_prog " $func_quote_for_eval_result"
+      if test -n "$arg2"; then
+	func_quote_for_eval "$arg2"
+      fi
+      func_append install_shared_prog " $func_quote_for_eval_result"
+    done
+
+    test -z "$install_prog" && \
+      func_fatal_help "you must specify an install program"
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prev' option requires an argument"
+
+    if test -n "$install_override_mode" && $no_mode; then
+      if $install_cp; then :; else
+	func_quote_for_eval "$install_override_mode"
+	func_append install_shared_prog " -m $func_quote_for_eval_result"
+      fi
+    fi
+
+    if test -z "$files"; then
+      if test -z "$dest"; then
+	func_fatal_help "no file or destination specified"
+      else
+	func_fatal_help "you must specify a destination"
+      fi
+    fi
+
+    # Strip any trailing slash from the destination.
+    func_stripname '' '/' "$dest"
+    dest=$func_stripname_result
+
+    # Check to see that the destination is a directory.
+    test -d "$dest" && isdir=yes
+    if test "$isdir" = yes; then
+      destdir="$dest"
+      destname=
+    else
+      func_dirname_and_basename "$dest" "" "."
+      destdir="$func_dirname_result"
+      destname="$func_basename_result"
+
+      # Not a directory, so check to see that there is only one file specified.
+      set dummy $files; shift
+      test "$#" -gt 1 && \
+	func_fatal_help "\`$dest' is not a directory"
+    fi
+    case $destdir in
+    [\\/]* | [A-Za-z]:[\\/]*) ;;
+    *)
+      for file in $files; do
+	case $file in
+	*.lo) ;;
+	*)
+	  func_fatal_help "\`$destdir' must be an absolute directory name"
+	  ;;
+	esac
+      done
+      ;;
+    esac
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    staticlibs=
+    future_libdirs=
+    current_libdirs=
+    for file in $files; do
+
+      # Do each installation.
+      case $file in
+      *.$libext)
+	# Do the static libraries later.
+	func_append staticlibs " $file"
+	;;
+
+      *.la)
+	func_resolve_sysroot "$file"
+	file=$func_resolve_sysroot_result
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$file" \
+	  || func_fatal_help "\`$file' is not a valid libtool archive"
+
+	library_names=
+	old_library=
+	relink_command=
+	func_source "$file"
+
+	# Add the libdir to current_libdirs if it is the destination.
+	if test "X$destdir" = "X$libdir"; then
+	  case "$current_libdirs " in
+	  *" $libdir "*) ;;
+	  *) func_append current_libdirs " $libdir" ;;
+	  esac
+	else
+	  # Note the libdir as a future libdir.
+	  case "$future_libdirs " in
+	  *" $libdir "*) ;;
+	  *) func_append future_libdirs " $libdir" ;;
+	  esac
+	fi
+
+	func_dirname "$file" "/" ""
+	dir="$func_dirname_result"
+	func_append dir "$objdir"
+
+	if test -n "$relink_command"; then
+	  # Determine the prefix the user has applied to our future dir.
+	  inst_prefix_dir=`$ECHO "$destdir" | $SED -e "s%$libdir\$%%"`
+
+	  # Don't allow the user to place us outside of our expected
+	  # location b/c this prevents finding dependent libraries that
+	  # are installed to the same prefix.
+	  # At present, this check doesn't affect windows .dll's that
+	  # are installed into $libdir/../bin (currently, that works fine)
+	  # but it's something to keep an eye on.
+	  test "$inst_prefix_dir" = "$destdir" && \
+	    func_fatal_error "error: cannot install \`$file' to a directory not ending in $libdir"
+
+	  if test -n "$inst_prefix_dir"; then
+	    # Stick the inst_prefix_dir data into the link command.
+	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
+	  else
+	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%%"`
+	  fi
+
+	  func_warning "relinking \`$file'"
+	  func_show_eval "$relink_command" \
+	    'func_fatal_error "error: relink \`$file'\'' with the above command before installing it"'
+	fi
+
+	# See the names of the shared library.
+	set dummy $library_names; shift
+	if test -n "$1"; then
+	  realname="$1"
+	  shift
+
+	  srcname="$realname"
+	  test -n "$relink_command" && srcname="$realname"T
+
+	  # Install the shared library and build the symlinks.
+	  func_show_eval "$install_shared_prog $dir/$srcname $destdir/$realname" \
+	      'exit $?'
+	  tstripme="$stripme"
+	  case $host_os in
+	  cygwin* | mingw* | pw32* | cegcc*)
+	    case $realname in
+	    *.dll.a)
+	      tstripme=""
+	      ;;
+	    esac
+	    ;;
+	  esac
+	  if test -n "$tstripme" && test -n "$striplib"; then
+	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
+	  fi
+
+	  if test "$#" -gt 0; then
+	    # Delete the old symlinks, and create new ones.
+	    # Try `ln -sf' first, because the `ln' binary might depend on
+	    # the symlink we replace!  Solaris /bin/ln does not understand -f,
+	    # so we also need to try rm && ln -s.
+	    for linkname
+	    do
+	      test "$linkname" != "$realname" \
+		&& func_show_eval "(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })"
+	    done
+	  fi
+
+	  # Do each command in the postinstall commands.
+	  lib="$destdir/$realname"
+	  func_execute_cmds "$postinstall_cmds" 'exit $?'
+	fi
+
+	# Install the pseudo-library for information purposes.
+	func_basename "$file"
+	name="$func_basename_result"
+	instname="$dir/$name"i
+	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
+
+	# Maybe install the static library, too.
+	test -n "$old_library" && func_append staticlibs " $dir/$old_library"
+	;;
+
+      *.lo)
+	# Install (i.e. copy) a libtool object.
+
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# Deduce the name of the destination old-style object file.
+	case $destfile in
+	*.lo)
+	  func_lo2o "$destfile"
+	  staticdest=$func_lo2o_result
+	  ;;
+	*.$objext)
+	  staticdest="$destfile"
+	  destfile=
+	  ;;
+	*)
+	  func_fatal_help "cannot copy a libtool object to \`$destfile'"
+	  ;;
+	esac
+
+	# Install the libtool object if requested.
+	test -n "$destfile" && \
+	  func_show_eval "$install_prog $file $destfile" 'exit $?'
+
+	# Install the old object if enabled.
+	if test "$build_old_libs" = yes; then
+	  # Deduce the name of the old-style object file.
+	  func_lo2o "$file"
+	  staticobj=$func_lo2o_result
+	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
+	fi
+	exit $EXIT_SUCCESS
+	;;
+
+      *)
+	# Figure out destination file name, if it wasn't already specified.
+	if test -n "$destname"; then
+	  destfile="$destdir/$destname"
+	else
+	  func_basename "$file"
+	  destfile="$func_basename_result"
+	  destfile="$destdir/$destfile"
+	fi
+
+	# If the file is missing, and there is a .exe on the end, strip it
+	# because it is most likely a libtool script we actually want to
+	# install
+	stripped_ext=""
+	case $file in
+	  *.exe)
+	    if test ! -f "$file"; then
+	      func_stripname '' '.exe' "$file"
+	      file=$func_stripname_result
+	      stripped_ext=".exe"
+	    fi
+	    ;;
+	esac
+
+	# Do a test to see if this is really a libtool program.
+	case $host in
+	*cygwin* | *mingw*)
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      wrapper=$func_ltwrapper_scriptname_result
+	    else
+	      func_stripname '' '.exe' "$file"
+	      wrapper=$func_stripname_result
+	    fi
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if func_ltwrapper_script_p "$wrapper"; then
+	  notinst_deplibs=
+	  relink_command=
+
+	  func_source "$wrapper"
+
+	  # Check the variables that should have been set.
+	  test -z "$generated_by_libtool_version" && \
+	    func_fatal_error "invalid libtool wrapper script \`$wrapper'"
+
+	  finalize=yes
+	  for lib in $notinst_deplibs; do
+	    # Check to see that each library is installed.
+	    libdir=
+	    if test -f "$lib"; then
+	      func_source "$lib"
+	    fi
+	    libfile="$libdir/"`$ECHO "$lib" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test
+	    if test -n "$libdir" && test ! -f "$libfile"; then
+	      func_warning "\`$lib' has not been installed in \`$libdir'"
+	      finalize=no
+	    fi
+	  done
+
+	  relink_command=
+	  func_source "$wrapper"
+
+	  outputname=
+	  if test "$fast_install" = no && test -n "$relink_command"; then
+	    $opt_dry_run || {
+	      if test "$finalize" = yes; then
+	        tmpdir=`func_mktempdir`
+		func_basename "$file$stripped_ext"
+		file="$func_basename_result"
+	        outputname="$tmpdir/$file"
+	        # Replace the output file specification.
+	        relink_command=`$ECHO "$relink_command" | $SED 's%@OUTPUT@%'"$outputname"'%g'`
+
+	        $opt_silent || {
+	          func_quote_for_expand "$relink_command"
+		  eval "func_echo $func_quote_for_expand_result"
+	        }
+	        if eval "$relink_command"; then :
+	          else
+		  func_error "error: relink \`$file' with the above command before installing it"
+		  $opt_dry_run || ${RM}r "$tmpdir"
+		  continue
+	        fi
+	        file="$outputname"
+	      else
+	        func_warning "cannot relink \`$file'"
+	      fi
+	    }
+	  else
+	    # Install the binary that we compiled earlier.
+	    file=`$ECHO "$file$stripped_ext" | $SED "s%\([^/]*\)$%$objdir/\1%"`
+	  fi
+	fi
+
+	# remove .exe since cygwin /usr/bin/install will append another
+	# one anyway
+	case $install_prog,$host in
+	*/usr/bin/install*,*cygwin*)
+	  case $file:$destfile in
+	  *.exe:*.exe)
+	    # this is ok
+	    ;;
+	  *.exe:*)
+	    destfile=$destfile.exe
+	    ;;
+	  *:*.exe)
+	    func_stripname '' '.exe' "$destfile"
+	    destfile=$func_stripname_result
+	    ;;
+	  esac
+	  ;;
+	esac
+	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
+	$opt_dry_run || if test -n "$outputname"; then
+	  ${RM}r "$tmpdir"
+	fi
+	;;
+      esac
+    done
+
+    for file in $staticlibs; do
+      func_basename "$file"
+      name="$func_basename_result"
+
+      # Set up the ranlib parameters.
+      oldlib="$destdir/$name"
+      func_to_tool_file "$oldlib" func_convert_file_msys_to_w32
+      tool_oldlib=$func_to_tool_file_result
+
+      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
+
+      if test -n "$stripme" && test -n "$old_striplib"; then
+	func_show_eval "$old_striplib $tool_oldlib" 'exit $?'
+      fi
+
+      # Do each command in the postinstall commands.
+      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
+    done
+
+    test -n "$future_libdirs" && \
+      func_warning "remember to run \`$progname --finish$future_libdirs'"
+
+    if test -n "$current_libdirs"; then
+      # Maybe just do a dry run.
+      $opt_dry_run && current_libdirs=" -n$current_libdirs"
+      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
+    else
+      exit $EXIT_SUCCESS
+    fi
+}
+
+test "$opt_mode" = install && func_mode_install ${1+"$@"}
+
+
+# func_generate_dlsyms outputname originator pic_p
+# Extract symbols from dlprefiles and create ${outputname}S.o with
+# a dlpreopen symbol table.
+func_generate_dlsyms ()
+{
+    $opt_debug
+    my_outputname="$1"
+    my_originator="$2"
+    my_pic_p="${3-no}"
+    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
+    my_dlsyms=
+
+    if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+      if test -n "$NM" && test -n "$global_symbol_pipe"; then
+	my_dlsyms="${my_outputname}S.c"
+      else
+	func_error "not configured to extract global symbols from dlpreopened files"
+      fi
+    fi
+
+    if test -n "$my_dlsyms"; then
+      case $my_dlsyms in
+      "") ;;
+      *.c)
+	# Discover the nlist of each of the dlfiles.
+	nlist="$output_objdir/${my_outputname}.nm"
+
+	func_show_eval "$RM $nlist ${nlist}S ${nlist}T"
+
+	# Parse the name list into a source file.
+	func_verbose "creating $output_objdir/$my_dlsyms"
+
+	$opt_dry_run || $ECHO > "$output_objdir/$my_dlsyms" "\
+/* $my_dlsyms - symbol resolution table for \`$my_outputname' dlsym emulation. */
+/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */
+
+#ifdef __cplusplus
+extern \"C\" {
+#endif
+
+#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))
+#pragma GCC diagnostic ignored \"-Wstrict-prototypes\"
+#endif
+
+/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */
+#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+/* DATA imports from DLLs on WIN32 con't be const, because runtime
+   relocations are performed -- see ld's documentation on pseudo-relocs.  */
+# define LT_DLSYM_CONST
+#elif defined(__osf__)
+/* This system does not cope well with relocations in const data.  */
+# define LT_DLSYM_CONST
+#else
+# define LT_DLSYM_CONST const
+#endif
+
+/* External symbol declarations for the compiler. */\
+"
+
+	if test "$dlself" = yes; then
+	  func_verbose "generating symbol list for \`$output'"
+
+	  $opt_dry_run || echo ': @PROGRAM@ ' > "$nlist"
+
+	  # Add our own program objects to the symbol list.
+	  progfiles=`$ECHO "$objs$old_deplibs" | $SP2NL | $SED "$lo2o" | $NL2SP`
+	  for progfile in $progfiles; do
+	    func_to_tool_file "$progfile" func_convert_file_msys_to_w32
+	    func_verbose "extracting global C symbols from \`$func_to_tool_file_result'"
+	    $opt_dry_run || eval "$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'"
+	  done
+
+	  if test -n "$exclude_expsyms"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  if test -n "$export_symbols_regex"; then
+	    $opt_dry_run || {
+	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	    }
+	  fi
+
+	  # Prepare the list of exported symbols
+	  if test -z "$export_symbols"; then
+	    export_symbols="$output_objdir/$outputname.exp"
+	    $opt_dry_run || {
+	      $RM $export_symbols
+	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
+	      case $host in
+	      *cygwin* | *mingw* | *cegcc* )
+                eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
+	        ;;
+	      esac
+	    }
+	  else
+	    $opt_dry_run || {
+	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
+	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
+	      eval '$MV "$nlist"T "$nlist"'
+	      case $host in
+	        *cygwin* | *mingw* | *cegcc* )
+	          eval "echo EXPORTS "'> "$output_objdir/$outputname.def"'
+	          eval 'cat "$nlist" >> "$output_objdir/$outputname.def"'
+	          ;;
+	      esac
+	    }
+	  fi
+	fi
+
+	for dlprefile in $dlprefiles; do
+	  func_verbose "extracting global C symbols from \`$dlprefile'"
+	  func_basename "$dlprefile"
+	  name="$func_basename_result"
+          case $host in
+	    *cygwin* | *mingw* | *cegcc* )
+	      # if an import library, we need to obtain dlname
+	      if func_win32_import_lib_p "$dlprefile"; then
+	        func_tr_sh "$dlprefile"
+	        eval "curr_lafile=\$libfile_$func_tr_sh_result"
+	        dlprefile_dlbasename=""
+	        if test -n "$curr_lafile" && func_lalib_p "$curr_lafile"; then
+	          # Use subshell, to avoid clobbering current variable values
+	          dlprefile_dlname=`source "$curr_lafile" && echo "$dlname"`
+	          if test -n "$dlprefile_dlname" ; then
+	            func_basename "$dlprefile_dlname"
+	            dlprefile_dlbasename="$func_basename_result"
+	          else
+	            # no lafile. user explicitly requested -dlpreopen <import library>.
+	            $sharedlib_from_linklib_cmd "$dlprefile"
+	            dlprefile_dlbasename=$sharedlib_from_linklib_result
+	          fi
+	        fi
+	        $opt_dry_run || {
+	          if test -n "$dlprefile_dlbasename" ; then
+	            eval '$ECHO ": $dlprefile_dlbasename" >> "$nlist"'
+	          else
+	            func_warning "Could not compute DLL name from $name"
+	            eval '$ECHO ": $name " >> "$nlist"'
+	          fi
+	          func_to_tool_file "$dlprefile" func_convert_file_msys_to_w32
+	          eval "$NM \"$func_to_tool_file_result\" 2>/dev/null | $global_symbol_pipe |
+	            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'"
+	        }
+	      else # not an import lib
+	        $opt_dry_run || {
+	          eval '$ECHO ": $name " >> "$nlist"'
+	          func_to_tool_file "$dlprefile" func_convert_file_msys_to_w32
+	          eval "$NM \"$func_to_tool_file_result\" 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	        }
+	      fi
+	    ;;
+	    *)
+	      $opt_dry_run || {
+	        eval '$ECHO ": $name " >> "$nlist"'
+	        func_to_tool_file "$dlprefile" func_convert_file_msys_to_w32
+	        eval "$NM \"$func_to_tool_file_result\" 2>/dev/null | $global_symbol_pipe >> '$nlist'"
+	      }
+	    ;;
+          esac
+	done
+
+	$opt_dry_run || {
+	  # Make sure we have at least an empty file.
+	  test -f "$nlist" || : > "$nlist"
+
+	  if test -n "$exclude_expsyms"; then
+	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
+	    $MV "$nlist"T "$nlist"
+	  fi
+
+	  # Try sorting and uniquifying the output.
+	  if $GREP -v "^: " < "$nlist" |
+	      if sort -k 3 </dev/null >/dev/null 2>&1; then
+		sort -k 3
+	      else
+		sort +2
+	      fi |
+	      uniq > "$nlist"S; then
+	    :
+	  else
+	    $GREP -v "^: " < "$nlist" > "$nlist"S
+	  fi
+
+	  if test -f "$nlist"S; then
+	    eval "$global_symbol_to_cdecl"' < "$nlist"S >> "$output_objdir/$my_dlsyms"'
+	  else
+	    echo '/* NONE */' >> "$output_objdir/$my_dlsyms"
+	  fi
+
+	  echo >> "$output_objdir/$my_dlsyms" "\
+
+/* The mapping between symbol names and symbols.  */
+typedef struct {
+  const char *name;
+  void *address;
+} lt_dlsymlist;
+extern LT_DLSYM_CONST lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[];
+LT_DLSYM_CONST lt_dlsymlist
+lt_${my_prefix}_LTX_preloaded_symbols[] =
+{\
+  { \"$my_originator\", (void *) 0 },"
+
+	  case $need_lib_prefix in
+	  no)
+	    eval "$global_symbol_to_c_name_address" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  *)
+	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
+	    ;;
+	  esac
+	  echo >> "$output_objdir/$my_dlsyms" "\
+  {0, (void *) 0}
+};
+
+/* This works around a problem in FreeBSD linker */
+#ifdef FREEBSD_WORKAROUND
+static const void *lt_preloaded_setup() {
+  return lt_${my_prefix}_LTX_preloaded_symbols;
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif\
+"
+	} # !$opt_dry_run
+
+	pic_flag_for_symtable=
+	case "$compile_command " in
+	*" -static "*) ;;
+	*)
+	  case $host in
+	  # compiling the symbol table file with pic_flag works around
+	  # a FreeBSD bug that causes programs to crash when -lm is
+	  # linked before any other PIC object.  But we must not use
+	  # pic_flag when linking with -static.  The problem exists in
+	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
+	  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)
+	    pic_flag_for_symtable=" $pic_flag -DFREEBSD_WORKAROUND" ;;
+	  *-*-hpux*)
+	    pic_flag_for_symtable=" $pic_flag"  ;;
+	  *)
+	    if test "X$my_pic_p" != Xno; then
+	      pic_flag_for_symtable=" $pic_flag"
+	    fi
+	    ;;
+	  esac
+	  ;;
+	esac
+	symtab_cflags=
+	for arg in $LTCFLAGS; do
+	  case $arg in
+	  -pie | -fpie | -fPIE) ;;
+	  *) func_append symtab_cflags " $arg" ;;
+	  esac
+	done
+
+	# Now compile the dynamic symbol file.
+	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
+
+	# Clean up the generated files.
+	func_show_eval '$RM "$output_objdir/$my_dlsyms" "$nlist" "${nlist}S" "${nlist}T"'
+
+	# Transform the symbol file into the correct name.
+	symfileobj="$output_objdir/${my_outputname}S.$objext"
+	case $host in
+	*cygwin* | *mingw* | *cegcc* )
+	  if test -f "$output_objdir/$my_outputname.def"; then
+	    compile_command=`$ECHO "$compile_command" | $SED "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	    finalize_command=`$ECHO "$finalize_command" | $SED "s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%"`
+	  else
+	    compile_command=`$ECHO "$compile_command" | $SED "s%@SYMFILE@%$symfileobj%"`
+	    finalize_command=`$ECHO "$finalize_command" | $SED "s%@SYMFILE@%$symfileobj%"`
+	  fi
+	  ;;
+	*)
+	  compile_command=`$ECHO "$compile_command" | $SED "s%@SYMFILE@%$symfileobj%"`
+	  finalize_command=`$ECHO "$finalize_command" | $SED "s%@SYMFILE@%$symfileobj%"`
+	  ;;
+	esac
+	;;
+      *)
+	func_fatal_error "unknown suffix for \`$my_dlsyms'"
+	;;
+      esac
+    else
+      # We keep going just in case the user didn't refer to
+      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe
+      # really was required.
+
+      # Nullify the symbol file.
+      compile_command=`$ECHO "$compile_command" | $SED "s% @SYMFILE@%%"`
+      finalize_command=`$ECHO "$finalize_command" | $SED "s% @SYMFILE@%%"`
+    fi
+}
+
+# func_win32_libid arg
+# return the library type of file 'arg'
+#
+# Need a lot of goo to handle *both* DLLs and import libs
+# Has to be a shell function in order to 'eat' the argument
+# that is supplied when $file_magic_command is called.
+# Despite the name, also deal with 64 bit binaries.
+func_win32_libid ()
+{
+  $opt_debug
+  win32_libid_type="unknown"
+  win32_fileres=`file -L $1 2>/dev/null`
+  case $win32_fileres in
+  *ar\ archive\ import\ library*) # definitely import
+    win32_libid_type="x86 archive import"
+    ;;
+  *ar\ archive*) # could be an import, or static
+    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.
+    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |
+       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then
+      func_to_tool_file "$1" func_convert_file_msys_to_w32
+      win32_nmres=`eval $NM -f posix -A \"$func_to_tool_file_result\" |
+	$SED -n -e '
+	    1,100{
+		/ I /{
+		    s,.*,import,
+		    p
+		    q
+		}
+	    }'`
+      case $win32_nmres in
+      import*)  win32_libid_type="x86 archive import";;
+      *)        win32_libid_type="x86 archive static";;
+      esac
+    fi
+    ;;
+  *DLL*)
+    win32_libid_type="x86 DLL"
+    ;;
+  *executable*) # but shell scripts are "executable" too...
+    case $win32_fileres in
+    *MS\ Windows\ PE\ Intel*)
+      win32_libid_type="x86 DLL"
+      ;;
+    esac
+    ;;
+  esac
+  $ECHO "$win32_libid_type"
+}
+
+# func_cygming_dll_for_implib ARG
+#
+# Platform-specific function to extract the
+# name of the DLL associated with the specified
+# import library ARG.
+# Invoked by eval'ing the libtool variable
+#    $sharedlib_from_linklib_cmd
+# Result is available in the variable
+#    $sharedlib_from_linklib_result
+func_cygming_dll_for_implib ()
+{
+  $opt_debug
+  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify "$1"`
+}
+
+# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs
+#
+# The is the core of a fallback implementation of a
+# platform-specific function to extract the name of the
+# DLL associated with the specified import library LIBNAME.
+#
+# SECTION_NAME is either .idata$6 or .idata$7, depending
+# on the platform and compiler that created the implib.
+#
+# Echos the name of the DLL associated with the
+# specified import library.
+func_cygming_dll_for_implib_fallback_core ()
+{
+  $opt_debug
+  match_literal=`$ECHO "$1" | $SED "$sed_make_literal_regex"`
+  $OBJDUMP -s --section "$1" "$2" 2>/dev/null |
+    $SED '/^Contents of section '"$match_literal"':/{
+      # Place marker at beginning of archive member dllname section
+      s/.*/====MARK====/
+      p
+      d
+    }
+    # These lines can sometimes be longer than 43 characters, but
+    # are always uninteresting
+    /:[	 ]*file format pe[i]\{,1\}-/d
+    /^In archive [^:]*:/d
+    # Ensure marker is printed
+    /^====MARK====/p
+    # Remove all lines with less than 43 characters
+    /^.\{43\}/!d
+    # From remaining lines, remove first 43 characters
+    s/^.\{43\}//' |
+    $SED -n '
+      # Join marker and all lines until next marker into a single line
+      /^====MARK====/ b para
+      H
+      $ b para
+      b
+      :para
+      x
+      s/\n//g
+      # Remove the marker
+      s/^====MARK====//
+      # Remove trailing dots and whitespace
+      s/[\. \t]*$//
+      # Print
+      /./p' |
+    # we now have a list, one entry per line, of the stringified
+    # contents of the appropriate section of all members of the
+    # archive which possess that section. Heuristic: eliminate
+    # all those which have a first or second character that is
+    # a '.' (that is, objdump's representation of an unprintable
+    # character.) This should work for all archives with less than
+    # 0x302f exports -- but will fail for DLLs whose name actually
+    # begins with a literal '.' or a single character followed by
+    # a '.'.
+    #
+    # Of those that remain, print the first one.
+    $SED -e '/^\./d;/^.\./d;q'
+}
+
+# func_cygming_gnu_implib_p ARG
+# This predicate returns with zero status (TRUE) if
+# ARG is a GNU/binutils-style import library. Returns
+# with nonzero status (FALSE) otherwise.
+func_cygming_gnu_implib_p ()
+{
+  $opt_debug
+  func_to_tool_file "$1" func_convert_file_msys_to_w32
+  func_cygming_gnu_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`
+  test -n "$func_cygming_gnu_implib_tmp"
+}
+
+# func_cygming_ms_implib_p ARG
+# This predicate returns with zero status (TRUE) if
+# ARG is an MS-style import library. Returns
+# with nonzero status (FALSE) otherwise.
+func_cygming_ms_implib_p ()
+{
+  $opt_debug
+  func_to_tool_file "$1" func_convert_file_msys_to_w32
+  func_cygming_ms_implib_tmp=`$NM "$func_to_tool_file_result" | eval "$global_symbol_pipe" | $GREP '_NULL_IMPORT_DESCRIPTOR'`
+  test -n "$func_cygming_ms_implib_tmp"
+}
+
+# func_cygming_dll_for_implib_fallback ARG
+# Platform-specific function to extract the
+# name of the DLL associated with the specified
+# import library ARG.
+#
+# This fallback implementation is for use when $DLLTOOL
+# does not support the --identify-strict option.
+# Invoked by eval'ing the libtool variable
+#    $sharedlib_from_linklib_cmd
+# Result is available in the variable
+#    $sharedlib_from_linklib_result
+func_cygming_dll_for_implib_fallback ()
+{
+  $opt_debug
+  if func_cygming_gnu_implib_p "$1" ; then
+    # binutils import library
+    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' "$1"`
+  elif func_cygming_ms_implib_p "$1" ; then
+    # ms-generated import library
+    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' "$1"`
+  else
+    # unknown
+    sharedlib_from_linklib_result=""
+  fi
+}
+
+
+# func_extract_an_archive dir oldlib
+func_extract_an_archive ()
+{
+    $opt_debug
+    f_ex_an_ar_dir="$1"; shift
+    f_ex_an_ar_oldlib="$1"
+    if test "$lock_old_archive_extraction" = yes; then
+      lockfile=$f_ex_an_ar_oldlib.lock
+      until $opt_dry_run || ln "$progpath" "$lockfile" 2>/dev/null; do
+	func_echo "Waiting for $lockfile to be removed"
+	sleep 2
+      done
+    fi
+    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" \
+		   'stat=$?; rm -f "$lockfile"; exit $stat'
+    if test "$lock_old_archive_extraction" = yes; then
+      $opt_dry_run || rm -f "$lockfile"
+    fi
+    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
+     :
+    else
+      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
+    fi
+}
+
+
+# func_extract_archives gentop oldlib ...
+func_extract_archives ()
+{
+    $opt_debug
+    my_gentop="$1"; shift
+    my_oldlibs=${1+"$@"}
+    my_oldobjs=""
+    my_xlib=""
+    my_xabs=""
+    my_xdir=""
+
+    for my_xlib in $my_oldlibs; do
+      # Extract the objects.
+      case $my_xlib in
+	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
+	*) my_xabs=`pwd`"/$my_xlib" ;;
+      esac
+      func_basename "$my_xlib"
+      my_xlib="$func_basename_result"
+      my_xlib_u=$my_xlib
+      while :; do
+        case " $extracted_archives " in
+	*" $my_xlib_u "*)
+	  func_arith $extracted_serial + 1
+	  extracted_serial=$func_arith_result
+	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
+	*) break ;;
+	esac
+      done
+      extracted_archives="$extracted_archives $my_xlib_u"
+      my_xdir="$my_gentop/$my_xlib_u"
+
+      func_mkdir_p "$my_xdir"
+
+      case $host in
+      *-darwin*)
+	func_verbose "Extracting $my_xabs"
+	# Do not bother doing anything if just a dry run
+	$opt_dry_run || {
+	  darwin_orig_dir=`pwd`
+	  cd $my_xdir || exit $?
+	  darwin_archive=$my_xabs
+	  darwin_curdir=`pwd`
+	  darwin_base_archive=`basename "$darwin_archive"`
+	  darwin_arches=`$LIPO -info "$darwin_archive" 2>/dev/null | $GREP Architectures 2>/dev/null || true`
+	  if test -n "$darwin_arches"; then
+	    darwin_arches=`$ECHO "$darwin_arches" | $SED -e 's/.*are://'`
+	    darwin_arch=
+	    func_verbose "$darwin_base_archive has multiple architectures $darwin_arches"
+	    for darwin_arch in  $darwin_arches ; do
+	      func_mkdir_p "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      $LIPO -thin $darwin_arch -output "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}" "${darwin_archive}"
+	      cd "unfat-$$/${darwin_base_archive}-${darwin_arch}"
+	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
+	      cd "$darwin_curdir"
+	      $RM "unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}"
+	    done # $darwin_arches
+            ## Okay now we've a bunch of thin objects, gotta fatten them up :)
+	    darwin_filelist=`find unfat-$$ -type f -name \*.o -print -o -name \*.lo -print | $SED -e "$basename" | sort -u`
+	    darwin_file=
+	    darwin_files=
+	    for darwin_file in $darwin_filelist; do
+	      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`
+	      $LIPO -create -output "$darwin_file" $darwin_files
+	    done # $darwin_filelist
+	    $RM -rf unfat-$$
+	    cd "$darwin_orig_dir"
+	  else
+	    cd $darwin_orig_dir
+	    func_extract_an_archive "$my_xdir" "$my_xabs"
+	  fi # $darwin_arches
+	} # !$opt_dry_run
+	;;
+      *)
+        func_extract_an_archive "$my_xdir" "$my_xabs"
+	;;
+      esac
+      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | sort | $NL2SP`
+    done
+
+    func_extract_archives_result="$my_oldobjs"
+}
+
+
+# func_emit_wrapper [arg=no]
+#
+# Emit a libtool wrapper script on stdout.
+# Don't directly open a file because we may want to
+# incorporate the script contents within a cygwin/mingw
+# wrapper executable.  Must ONLY be called from within
+# func_mode_link because it depends on a number of variables
+# set therein.
+#
+# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR
+# variable will take.  If 'yes', then the emitted script
+# will assume that the directory in which it is stored is
+# the $objdir directory.  This is a cygwin/mingw-specific
+# behavior.
+func_emit_wrapper ()
+{
+	func_emit_wrapper_arg1=${1-no}
+
+	$ECHO "\
+#! $SHELL
+
+# $output - temporary wrapper script for $objdir/$outputname
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# The $output program cannot be directly executed until all the libtool
+# libraries that it depends on are installed.
+#
+# This wrapper script should never be moved out of the build directory.
+# If it is, it will not operate correctly.
+
+# Sed substitution that helps us do robust quoting.  It backslashifies
+# metacharacters that are still active within double-quoted strings.
+sed_quote_subst='$sed_quote_subst'
+
+# Be Bourne compatible
+if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then
+  emulate sh
+  NULLCMD=:
+  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
+fi
+BIN_SH=xpg4; export BIN_SH # for Tru64
+DUALCASE=1; export DUALCASE # for MKS sh
+
+# The HP-UX ksh and POSIX shell print the target directory to stdout
+# if CDPATH is set.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+relink_command=\"$relink_command\"
+
+# This environment variable determines our operation mode.
+if test \"\$libtool_install_magic\" = \"$magic\"; then
+  # install mode needs the following variables:
+  generated_by_libtool_version='$macro_version'
+  notinst_deplibs='$notinst_deplibs'
+else
+  # When we are sourced in execute mode, \$file and \$ECHO are already set.
+  if test \"\$libtool_execute_magic\" != \"$magic\"; then
+    file=\"\$0\""
+
+    qECHO=`$ECHO "$ECHO" | $SED "$sed_quote_subst"`
+    $ECHO "\
+
+# A function that is used when there is no print builtin or printf.
+func_fallback_echo ()
+{
+  eval 'cat <<_LTECHO_EOF
+\$1
+_LTECHO_EOF'
+}
+    ECHO=\"$qECHO\"
+  fi
+
+# Very basic option parsing. These options are (a) specific to
+# the libtool wrapper, (b) are identical between the wrapper
+# /script/ and the wrapper /executable/ which is used only on
+# windows platforms, and (c) all begin with the string "--lt-"
+# (application programs are unlikely to have options which match
+# this pattern).
+#
+# There are only two supported options: --lt-debug and
+# --lt-dump-script. There is, deliberately, no --lt-help.
+#
+# The first argument to this parsing function should be the
+# script's $0 value, followed by "$@".
+lt_option_debug=
+func_parse_lt_options ()
+{
+  lt_script_arg0=\$0
+  shift
+  for lt_opt
+  do
+    case \"\$lt_opt\" in
+    --lt-debug) lt_option_debug=1 ;;
+    --lt-dump-script)
+        lt_dump_D=\`\$ECHO \"X\$lt_script_arg0\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\`
+        test \"X\$lt_dump_D\" = \"X\$lt_script_arg0\" && lt_dump_D=.
+        lt_dump_F=\`\$ECHO \"X\$lt_script_arg0\" | $SED -e 's/^X//' -e 's%^.*/%%'\`
+        cat \"\$lt_dump_D/\$lt_dump_F\"
+        exit 0
+      ;;
+    --lt-*)
+        \$ECHO \"Unrecognized --lt- option: '\$lt_opt'\" 1>&2
+        exit 1
+      ;;
+    esac
+  done
+
+  # Print the debug banner immediately:
+  if test -n \"\$lt_option_debug\"; then
+    echo \"${outputname}:${output}:\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\" 1>&2
+  fi
+}
+
+# Used when --lt-debug. Prints its arguments to stdout
+# (redirection is the responsibility of the caller)
+func_lt_dump_args ()
+{
+  lt_dump_args_N=1;
+  for lt_arg
+  do
+    \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[\$lt_dump_args_N]: \$lt_arg\"
+    lt_dump_args_N=\`expr \$lt_dump_args_N + 1\`
+  done
+}
+
+# Core function for launching the target application
+func_exec_program_core ()
+{
+"
+  case $host in
+  # Backslashes separate directories on plain windows
+  *-*-mingw | *-*-os2* | *-cegcc*)
+    $ECHO "\
+      if test -n \"\$lt_option_debug\"; then
+        \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[0]: \$progdir\\\\\$program\" 1>&2
+        func_lt_dump_args \${1+\"\$@\"} 1>&2
+      fi
+      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
+"
+    ;;
+
+  *)
+    $ECHO "\
+      if test -n \"\$lt_option_debug\"; then
+        \$ECHO \"${outputname}:${output}:\${LINENO}: newargv[0]: \$progdir/\$program\" 1>&2
+        func_lt_dump_args \${1+\"\$@\"} 1>&2
+      fi
+      exec \"\$progdir/\$program\" \${1+\"\$@\"}
+"
+    ;;
+  esac
+  $ECHO "\
+      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
+      exit 1
+}
+
+# A function to encapsulate launching the target application
+# Strips options in the --lt-* namespace from \$@ and
+# launches target application with the remaining arguments.
+func_exec_program ()
+{
+  case \" \$* \" in
+  *\\ --lt-*)
+    for lt_wr_arg
+    do
+      case \$lt_wr_arg in
+      --lt-*) ;;
+      *) set x \"\$@\" \"\$lt_wr_arg\"; shift;;
+      esac
+      shift
+    done ;;
+  esac
+  func_exec_program_core \${1+\"\$@\"}
+}
+
+  # Parse options
+  func_parse_lt_options \"\$0\" \${1+\"\$@\"}
+
+  # Find the directory that this script lives in.
+  thisdir=\`\$ECHO \"\$file\" | $SED 's%/[^/]*$%%'\`
+  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
+
+  # Follow symbolic links until we get to the real thisdir.
+  file=\`ls -ld \"\$file\" | $SED -n 's/.*-> //p'\`
+  while test -n \"\$file\"; do
+    destdir=\`\$ECHO \"\$file\" | $SED 's%/[^/]*\$%%'\`
+
+    # If there was a directory component, then change thisdir.
+    if test \"x\$destdir\" != \"x\$file\"; then
+      case \"\$destdir\" in
+      [\\\\/]* | [A-Za-z]:[\\\\/]*) thisdir=\"\$destdir\" ;;
+      *) thisdir=\"\$thisdir/\$destdir\" ;;
+      esac
+    fi
+
+    file=\`\$ECHO \"\$file\" | $SED 's%^.*/%%'\`
+    file=\`ls -ld \"\$thisdir/\$file\" | $SED -n 's/.*-> //p'\`
+  done
+
+  # Usually 'no', except on cygwin/mingw when embedded into
+  # the cwrapper.
+  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1
+  if test \"\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\" = \"yes\"; then
+    # special case for '.'
+    if test \"\$thisdir\" = \".\"; then
+      thisdir=\`pwd\`
+    fi
+    # remove .libs from thisdir
+    case \"\$thisdir\" in
+    *[\\\\/]$objdir ) thisdir=\`\$ECHO \"\$thisdir\" | $SED 's%[\\\\/][^\\\\/]*$%%'\` ;;
+    $objdir )   thisdir=. ;;
+    esac
+  fi
+
+  # Try to get the absolute directory name.
+  absdir=\`cd \"\$thisdir\" && pwd\`
+  test -n \"\$absdir\" && thisdir=\"\$absdir\"
+"
+
+	if test "$fast_install" = yes; then
+	  $ECHO "\
+  program=lt-'$outputname'$exeext
+  progdir=\"\$thisdir/$objdir\"
+
+  if test ! -f \"\$progdir/\$program\" ||
+     { file=\`ls -1dt \"\$progdir/\$program\" \"\$progdir/../\$program\" 2>/dev/null | ${SED} 1q\`; \\
+       test \"X\$file\" != \"X\$progdir/\$program\"; }; then
+
+    file=\"\$\$-\$program\"
+
+    if test ! -d \"\$progdir\"; then
+      $MKDIR \"\$progdir\"
+    else
+      $RM \"\$progdir/\$file\"
+    fi"
+
+	  $ECHO "\
+
+    # relink executable if necessary
+    if test -n \"\$relink_command\"; then
+      if relink_command_output=\`eval \$relink_command 2>&1\`; then :
+      else
+	$ECHO \"\$relink_command_output\" >&2
+	$RM \"\$progdir/\$file\"
+	exit 1
+      fi
+    fi
+
+    $MV \"\$progdir/\$file\" \"\$progdir/\$program\" 2>/dev/null ||
+    { $RM \"\$progdir/\$program\";
+      $MV \"\$progdir/\$file\" \"\$progdir/\$program\"; }
+    $RM \"\$progdir/\$file\"
+  fi"
+	else
+	  $ECHO "\
+  program='$outputname'
+  progdir=\"\$thisdir/$objdir\"
+"
+	fi
+
+	$ECHO "\
+
+  if test -f \"\$progdir/\$program\"; then"
+
+	# fixup the dll searchpath if we need to.
+	#
+	# Fix the DLL searchpath if we need to.  Do this before prepending
+	# to shlibpath, because on Windows, both are PATH and uninstalled
+	# libraries must come first.
+	if test -n "$dllsearchpath"; then
+	  $ECHO "\
+    # Add the dll search path components to the executable PATH
+    PATH=$dllsearchpath:\$PATH
+"
+	fi
+
+	# Export our shlibpath_var if we have one.
+	if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+	  $ECHO "\
+    # Add our own library path to $shlibpath_var
+    $shlibpath_var=\"$temp_rpath\$$shlibpath_var\"
+
+    # Some systems cannot cope with colon-terminated $shlibpath_var
+    # The second colon is a workaround for a bug in BeOS R4 sed
+    $shlibpath_var=\`\$ECHO \"\$$shlibpath_var\" | $SED 's/::*\$//'\`
+
+    export $shlibpath_var
+"
+	fi
+
+	$ECHO "\
+    if test \"\$libtool_execute_magic\" != \"$magic\"; then
+      # Run the actual program with our arguments.
+      func_exec_program \${1+\"\$@\"}
+    fi
+  else
+    # The program doesn't exist.
+    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
+    \$ECHO \"This script is just a wrapper for \$program.\" 1>&2
+    \$ECHO \"See the $PACKAGE documentation for more information.\" 1>&2
+    exit 1
+  fi
+fi\
+"
+}
+
+
+# func_emit_cwrapperexe_src
+# emit the source code for a wrapper executable on stdout
+# Must ONLY be called from within func_mode_link because
+# it depends on a number of variable set therein.
+func_emit_cwrapperexe_src ()
+{
+	cat <<EOF
+
+/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
+   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+
+   The $output program cannot be directly executed until all the libtool
+   libraries that it depends on are installed.
+
+   This wrapper executable should never be moved out of the build directory.
+   If it is, it will not operate correctly.
+*/
+EOF
+	    cat <<"EOF"
+#ifdef _MSC_VER
+# define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef _MSC_VER
+# include <direct.h>
+# include <process.h>
+# include <io.h>
+#else
+# include <unistd.h>
+# include <stdint.h>
+# ifdef __CYGWIN__
+#  include <io.h>
+# endif
+#endif
+#include <malloc.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+
+/* declarations of non-ANSI functions */
+#if defined(__MINGW32__)
+# ifdef __STRICT_ANSI__
+int _putenv (const char *);
+# endif
+#elif defined(__CYGWIN__)
+# ifdef __STRICT_ANSI__
+char *realpath (const char *, char *);
+int putenv (char *);
+int setenv (const char *, const char *, int);
+# endif
+/* #elif defined (other platforms) ... */
+#endif
+
+/* portability defines, excluding path handling macros */
+#if defined(_MSC_VER)
+# define setmode _setmode
+# define stat    _stat
+# define chmod   _chmod
+# define getcwd  _getcwd
+# define putenv  _putenv
+# define S_IXUSR _S_IEXEC
+# ifndef _INTPTR_T_DEFINED
+#  define _INTPTR_T_DEFINED
+#  define intptr_t int
+# endif
+#elif defined(__MINGW32__)
+# define setmode _setmode
+# define stat    _stat
+# define chmod   _chmod
+# define getcwd  _getcwd
+# define putenv  _putenv
+#elif defined(__CYGWIN__)
+# define HAVE_SETENV
+# define FOPEN_WB "wb"
+/* #elif defined (other platforms) ... */
+#endif
+
+#if defined(PATH_MAX)
+# define LT_PATHMAX PATH_MAX
+#elif defined(MAXPATHLEN)
+# define LT_PATHMAX MAXPATHLEN
+#else
+# define LT_PATHMAX 1024
+#endif
+
+#ifndef S_IXOTH
+# define S_IXOTH 0
+#endif
+#ifndef S_IXGRP
+# define S_IXGRP 0
+#endif
+
+/* path handling portability macros */
+#ifndef DIR_SEPARATOR
+# define DIR_SEPARATOR '/'
+# define PATH_SEPARATOR ':'
+#endif
+
+#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \
+  defined (__OS2__)
+# define HAVE_DOS_BASED_FILE_SYSTEM
+# define FOPEN_WB "wb"
+# ifndef DIR_SEPARATOR_2
+#  define DIR_SEPARATOR_2 '\\'
+# endif
+# ifndef PATH_SEPARATOR_2
+#  define PATH_SEPARATOR_2 ';'
+# endif
+#endif
+
+#ifndef DIR_SEPARATOR_2
+# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)
+#else /* DIR_SEPARATOR_2 */
+# define IS_DIR_SEPARATOR(ch) \
+	(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))
+#endif /* DIR_SEPARATOR_2 */
+
+#ifndef PATH_SEPARATOR_2
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)
+#else /* PATH_SEPARATOR_2 */
+# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)
+#endif /* PATH_SEPARATOR_2 */
+
+#ifndef FOPEN_WB
+# define FOPEN_WB "w"
+#endif
+#ifndef _O_BINARY
+# define _O_BINARY 0
+#endif
+
+#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
+#define XFREE(stale) do { \
+  if (stale) { free ((void *) stale); stale = 0; } \
+} while (0)
+
+#if defined(LT_DEBUGWRAPPER)
+static int lt_debug = 1;
+#else
+static int lt_debug = 0;
+#endif
+
+const char *program_name = "libtool-wrapper"; /* in case xstrdup fails */
+
+void *xmalloc (size_t num);
+char *xstrdup (const char *string);
+const char *base_name (const char *name);
+char *find_executable (const char *wrapper);
+char *chase_symlinks (const char *pathspec);
+int make_executable (const char *path);
+int check_executable (const char *path);
+char *strendzap (char *str, const char *pat);
+void lt_debugprintf (const char *file, int line, const char *fmt, ...);
+void lt_fatal (const char *file, int line, const char *message, ...);
+static const char *nonnull (const char *s);
+static const char *nonempty (const char *s);
+void lt_setenv (const char *name, const char *value);
+char *lt_extend_str (const char *orig_value, const char *add, int to_end);
+void lt_update_exe_path (const char *name, const char *value);
+void lt_update_lib_path (const char *name, const char *value);
+char **prepare_spawn (char **argv);
+void lt_dump_script (FILE *f);
+EOF
+
+	    cat <<EOF
+volatile const char * MAGIC_EXE = "$magic_exe";
+const char * LIB_PATH_VARNAME = "$shlibpath_var";
+EOF
+
+	    if test "$shlibpath_overrides_runpath" = yes && test -n "$shlibpath_var" && test -n "$temp_rpath"; then
+              func_to_host_path "$temp_rpath"
+	      cat <<EOF
+const char * LIB_PATH_VALUE   = "$func_to_host_path_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * LIB_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test -n "$dllsearchpath"; then
+              func_to_host_path "$dllsearchpath:"
+	      cat <<EOF
+const char * EXE_PATH_VARNAME = "PATH";
+const char * EXE_PATH_VALUE   = "$func_to_host_path_result";
+EOF
+	    else
+	      cat <<"EOF"
+const char * EXE_PATH_VARNAME = "";
+const char * EXE_PATH_VALUE   = "";
+EOF
+	    fi
+
+	    if test "$fast_install" = yes; then
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
+EOF
+	    else
+	      cat <<EOF
+const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
+EOF
+	    fi
+
+
+	    cat <<"EOF"
+
+#define LTWRAPPER_OPTION_PREFIX         "--lt-"
+
+static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
+static const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX "dump-script";
+static const char *debug_opt            = LTWRAPPER_OPTION_PREFIX "debug";
+
+int
+main (int argc, char *argv[])
+{
+  char **newargz;
+  int  newargc;
+  char *tmp_pathspec;
+  char *actual_cwrapper_path;
+  char *actual_cwrapper_name;
+  char *target_name;
+  char *lt_argv_zero;
+  intptr_t rval = 127;
+
+  int i;
+
+  program_name = (char *) xstrdup (base_name (argv[0]));
+  newargz = XMALLOC (char *, argc + 1);
+
+  /* very simple arg parsing; don't want to rely on getopt
+   * also, copy all non cwrapper options to newargz, except
+   * argz[0], which is handled differently
+   */
+  newargc=0;
+  for (i = 1; i < argc; i++)
+    {
+      if (strcmp (argv[i], dumpscript_opt) == 0)
+	{
+EOF
+	    case "$host" in
+	      *mingw* | *cygwin* )
+		# make stdout use "unix" line endings
+		echo "          setmode(1,_O_BINARY);"
+		;;
+	      esac
+
+	    cat <<"EOF"
+	  lt_dump_script (stdout);
+	  return 0;
+	}
+      if (strcmp (argv[i], debug_opt) == 0)
+	{
+          lt_debug = 1;
+          continue;
+	}
+      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)
+        {
+          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX
+             namespace, but it is not one of the ones we know about and
+             have already dealt with, above (inluding dump-script), then
+             report an error. Otherwise, targets might begin to believe
+             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX
+             namespace. The first time any user complains about this, we'll
+             need to make LTWRAPPER_OPTION_PREFIX a configure-time option
+             or a configure.ac-settable value.
+           */
+          lt_fatal (__FILE__, __LINE__,
+		    "unrecognized %s option: '%s'",
+                    ltwrapper_option_prefix, argv[i]);
+        }
+      /* otherwise ... */
+      newargz[++newargc] = xstrdup (argv[i]);
+    }
+  newargz[++newargc] = NULL;
+
+EOF
+	    cat <<EOF
+  /* The GNU banner must be the first non-error debug message */
+  lt_debugprintf (__FILE__, __LINE__, "libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\n");
+EOF
+	    cat <<"EOF"
+  lt_debugprintf (__FILE__, __LINE__, "(main) argv[0]: %s\n", argv[0]);
+  lt_debugprintf (__FILE__, __LINE__, "(main) program_name: %s\n", program_name);
+
+  tmp_pathspec = find_executable (argv[0]);
+  if (tmp_pathspec == NULL)
+    lt_fatal (__FILE__, __LINE__, "couldn't find %s", argv[0]);
+  lt_debugprintf (__FILE__, __LINE__,
+                  "(main) found exe (before symlink chase) at: %s\n",
+		  tmp_pathspec);
+
+  actual_cwrapper_path = chase_symlinks (tmp_pathspec);
+  lt_debugprintf (__FILE__, __LINE__,
+                  "(main) found exe (after symlink chase) at: %s\n",
+		  actual_cwrapper_path);
+  XFREE (tmp_pathspec);
+
+  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));
+  strendzap (actual_cwrapper_path, actual_cwrapper_name);
+
+  /* wrapper name transforms */
+  strendzap (actual_cwrapper_name, ".exe");
+  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
+  XFREE (actual_cwrapper_name);
+  actual_cwrapper_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  /* target_name transforms -- use actual target program name; might have lt- prefix */
+  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
+  strendzap (target_name, ".exe");
+  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
+  XFREE (target_name);
+  target_name = tmp_pathspec;
+  tmp_pathspec = 0;
+
+  lt_debugprintf (__FILE__, __LINE__,
+		  "(main) libtool target name: %s\n",
+		  target_name);
+EOF
+
+	    cat <<EOF
+  newargz[0] =
+    XMALLOC (char, (strlen (actual_cwrapper_path) +
+		    strlen ("$objdir") + 1 + strlen (actual_cwrapper_name) + 1));
+  strcpy (newargz[0], actual_cwrapper_path);
+  strcat (newargz[0], "$objdir");
+  strcat (newargz[0], "/");
+EOF
+
+	    cat <<"EOF"
+  /* stop here, and copy so we don't have to do this twice */
+  tmp_pathspec = xstrdup (newargz[0]);
+
+  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
+  strcat (newargz[0], actual_cwrapper_name);
+
+  /* DO want the lt- prefix here if it exists, so use target_name */
+  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
+  XFREE (tmp_pathspec);
+  tmp_pathspec = NULL;
+EOF
+
+	    case $host_os in
+	      mingw*)
+	    cat <<"EOF"
+  {
+    char* p;
+    while ((p = strchr (newargz[0], '\\')) != NULL)
+      {
+	*p = '/';
+      }
+    while ((p = strchr (lt_argv_zero, '\\')) != NULL)
+      {
+	*p = '/';
+      }
+  }
+EOF
+	    ;;
+	    esac
+
+	    cat <<"EOF"
+  XFREE (target_name);
+  XFREE (actual_cwrapper_path);
+  XFREE (actual_cwrapper_name);
+
+  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
+  lt_setenv ("DUALCASE", "1");  /* for MSK sh */
+  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must
+     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)
+     because on Windows, both *_VARNAMEs are PATH but uninstalled
+     libraries must come first. */
+  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
+  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);
+
+  lt_debugprintf (__FILE__, __LINE__, "(main) lt_argv_zero: %s\n",
+		  nonnull (lt_argv_zero));
+  for (i = 0; i < newargc; i++)
+    {
+      lt_debugprintf (__FILE__, __LINE__, "(main) newargz[%d]: %s\n",
+		      i, nonnull (newargz[i]));
+    }
+
+EOF
+
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+  /* execv doesn't actually work on mingw as expected on unix */
+  newargz = prepare_spawn (newargz);
+  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);
+  if (rval == -1)
+    {
+      /* failed to start process */
+      lt_debugprintf (__FILE__, __LINE__,
+		      "(main) failed to launch target \"%s\": %s\n",
+		      lt_argv_zero, nonnull (strerror (errno)));
+      return 127;
+    }
+  return rval;
+EOF
+		;;
+	      *)
+		cat <<"EOF"
+  execv (lt_argv_zero, newargz);
+  return rval; /* =127, but avoids unused variable warning */
+EOF
+		;;
+	    esac
+
+	    cat <<"EOF"
+}
+
+void *
+xmalloc (size_t num)
+{
+  void *p = (void *) malloc (num);
+  if (!p)
+    lt_fatal (__FILE__, __LINE__, "memory exhausted");
+
+  return p;
+}
+
+char *
+xstrdup (const char *string)
+{
+  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
+			  string) : NULL;
+}
+
+const char *
+base_name (const char *name)
+{
+  const char *base;
+
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  /* Skip over the disk name in MSDOS pathnames. */
+  if (isalpha ((unsigned char) name[0]) && name[1] == ':')
+    name += 2;
+#endif
+
+  for (base = name; *name; name++)
+    if (IS_DIR_SEPARATOR (*name))
+      base = name + 1;
+  return base;
+}
+
+int
+check_executable (const char *path)
+{
+  struct stat st;
+
+  lt_debugprintf (__FILE__, __LINE__, "(check_executable): %s\n",
+                  nonempty (path));
+  if ((!path) || (!*path))
+    return 0;
+
+  if ((stat (path, &st) >= 0)
+      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
+    return 1;
+  else
+    return 0;
+}
+
+int
+make_executable (const char *path)
+{
+  int rval = 0;
+  struct stat st;
+
+  lt_debugprintf (__FILE__, __LINE__, "(make_executable): %s\n",
+                  nonempty (path));
+  if ((!path) || (!*path))
+    return 0;
+
+  if (stat (path, &st) >= 0)
+    {
+      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);
+    }
+  return rval;
+}
+
+/* Searches for the full path of the wrapper.  Returns
+   newly allocated full path name if found, NULL otherwise
+   Does not chase symlinks, even on platforms that support them.
+*/
+char *
+find_executable (const char *wrapper)
+{
+  int has_slash = 0;
+  const char *p;
+  const char *p_next;
+  /* static buffer for getcwd */
+  char tmp[LT_PATHMAX + 1];
+  int tmp_len;
+  char *concat_name;
+
+  lt_debugprintf (__FILE__, __LINE__, "(find_executable): %s\n",
+                  nonempty (wrapper));
+
+  if ((wrapper == NULL) || (*wrapper == '\0'))
+    return NULL;
+
+  /* Absolute path? */
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')
+    {
+      concat_name = xstrdup (wrapper);
+      if (check_executable (concat_name))
+	return concat_name;
+      XFREE (concat_name);
+    }
+  else
+    {
+#endif
+      if (IS_DIR_SEPARATOR (wrapper[0]))
+	{
+	  concat_name = xstrdup (wrapper);
+	  if (check_executable (concat_name))
+	    return concat_name;
+	  XFREE (concat_name);
+	}
+#if defined (HAVE_DOS_BASED_FILE_SYSTEM)
+    }
+#endif
+
+  for (p = wrapper; *p; p++)
+    if (*p == '/')
+      {
+	has_slash = 1;
+	break;
+      }
+  if (!has_slash)
+    {
+      /* no slashes; search PATH */
+      const char *path = getenv ("PATH");
+      if (path != NULL)
+	{
+	  for (p = path; *p; p = p_next)
+	    {
+	      const char *q;
+	      size_t p_len;
+	      for (q = p; *q; q++)
+		if (IS_PATH_SEPARATOR (*q))
+		  break;
+	      p_len = q - p;
+	      p_next = (*q == '\0' ? q : q + 1);
+	      if (p_len == 0)
+		{
+		  /* empty path: current directory */
+		  if (getcwd (tmp, LT_PATHMAX) == NULL)
+		    lt_fatal (__FILE__, __LINE__, "getcwd failed: %s",
+                              nonnull (strerror (errno)));
+		  tmp_len = strlen (tmp);
+		  concat_name =
+		    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, tmp, tmp_len);
+		  concat_name[tmp_len] = '/';
+		  strcpy (concat_name + tmp_len + 1, wrapper);
+		}
+	      else
+		{
+		  concat_name =
+		    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);
+		  memcpy (concat_name, p, p_len);
+		  concat_name[p_len] = '/';
+		  strcpy (concat_name + p_len + 1, wrapper);
+		}
+	      if (check_executable (concat_name))
+		return concat_name;
+	      XFREE (concat_name);
+	    }
+	}
+      /* not found in PATH; assume curdir */
+    }
+  /* Relative path | not found in path: prepend cwd */
+  if (getcwd (tmp, LT_PATHMAX) == NULL)
+    lt_fatal (__FILE__, __LINE__, "getcwd failed: %s",
+              nonnull (strerror (errno)));
+  tmp_len = strlen (tmp);
+  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);
+  memcpy (concat_name, tmp, tmp_len);
+  concat_name[tmp_len] = '/';
+  strcpy (concat_name + tmp_len + 1, wrapper);
+
+  if (check_executable (concat_name))
+    return concat_name;
+  XFREE (concat_name);
+  return NULL;
+}
+
+char *
+chase_symlinks (const char *pathspec)
+{
+#ifndef S_ISLNK
+  return xstrdup (pathspec);
+#else
+  char buf[LT_PATHMAX];
+  struct stat s;
+  char *tmp_pathspec = xstrdup (pathspec);
+  char *p;
+  int has_symlinks = 0;
+  while (strlen (tmp_pathspec) && !has_symlinks)
+    {
+      lt_debugprintf (__FILE__, __LINE__,
+		      "checking path component for symlinks: %s\n",
+		      tmp_pathspec);
+      if (lstat (tmp_pathspec, &s) == 0)
+	{
+	  if (S_ISLNK (s.st_mode) != 0)
+	    {
+	      has_symlinks = 1;
+	      break;
+	    }
+
+	  /* search backwards for last DIR_SEPARATOR */
+	  p = tmp_pathspec + strlen (tmp_pathspec) - 1;
+	  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    p--;
+	  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))
+	    {
+	      /* no more DIR_SEPARATORS left */
+	      break;
+	    }
+	  *p = '\0';
+	}
+      else
+	{
+	  lt_fatal (__FILE__, __LINE__,
+		    "error accessing file \"%s\": %s",
+		    tmp_pathspec, nonnull (strerror (errno)));
+	}
+    }
+  XFREE (tmp_pathspec);
+
+  if (!has_symlinks)
+    {
+      return xstrdup (pathspec);
+    }
+
+  tmp_pathspec = realpath (pathspec, buf);
+  if (tmp_pathspec == 0)
+    {
+      lt_fatal (__FILE__, __LINE__,
+		"could not follow symlinks for %s", pathspec);
+    }
+  return xstrdup (tmp_pathspec);
+#endif
+}
+
+char *
+strendzap (char *str, const char *pat)
+{
+  size_t len, patlen;
+
+  assert (str != NULL);
+  assert (pat != NULL);
+
+  len = strlen (str);
+  patlen = strlen (pat);
+
+  if (patlen <= len)
+    {
+      str += len - patlen;
+      if (strcmp (str, pat) == 0)
+	*str = '\0';
+    }
+  return str;
+}
+
+void
+lt_debugprintf (const char *file, int line, const char *fmt, ...)
+{
+  va_list args;
+  if (lt_debug)
+    {
+      (void) fprintf (stderr, "%s:%s:%d: ", program_name, file, line);
+      va_start (args, fmt);
+      (void) vfprintf (stderr, fmt, args);
+      va_end (args);
+    }
+}
+
+static void
+lt_error_core (int exit_status, const char *file,
+	       int line, const char *mode,
+	       const char *message, va_list ap)
+{
+  fprintf (stderr, "%s:%s:%d: %s: ", program_name, file, line, mode);
+  vfprintf (stderr, message, ap);
+  fprintf (stderr, ".\n");
+
+  if (exit_status >= 0)
+    exit (exit_status);
+}
+
+void
+lt_fatal (const char *file, int line, const char *message, ...)
+{
+  va_list ap;
+  va_start (ap, message);
+  lt_error_core (EXIT_FAILURE, file, line, "FATAL", message, ap);
+  va_end (ap);
+}
+
+static const char *
+nonnull (const char *s)
+{
+  return s ? s : "(null)";
+}
+
+static const char *
+nonempty (const char *s)
+{
+  return (s && !*s) ? "(empty)" : nonnull (s);
+}
+
+void
+lt_setenv (const char *name, const char *value)
+{
+  lt_debugprintf (__FILE__, __LINE__,
+		  "(lt_setenv) setting '%s' to '%s'\n",
+                  nonnull (name), nonnull (value));
+  {
+#ifdef HAVE_SETENV
+    /* always make a copy, for consistency with !HAVE_SETENV */
+    char *str = xstrdup (value);
+    setenv (name, str, 1);
+#else
+    int len = strlen (name) + 1 + strlen (value) + 1;
+    char *str = XMALLOC (char, len);
+    sprintf (str, "%s=%s", name, value);
+    if (putenv (str) != EXIT_SUCCESS)
+      {
+        XFREE (str);
+      }
+#endif
+  }
+}
+
+char *
+lt_extend_str (const char *orig_value, const char *add, int to_end)
+{
+  char *new_value;
+  if (orig_value && *orig_value)
+    {
+      int orig_value_len = strlen (orig_value);
+      int add_len = strlen (add);
+      new_value = XMALLOC (char, add_len + orig_value_len + 1);
+      if (to_end)
+        {
+          strcpy (new_value, orig_value);
+          strcpy (new_value + orig_value_len, add);
+        }
+      else
+        {
+          strcpy (new_value, add);
+          strcpy (new_value + add_len, orig_value);
+        }
+    }
+  else
+    {
+      new_value = xstrdup (add);
+    }
+  return new_value;
+}
+
+void
+lt_update_exe_path (const char *name, const char *value)
+{
+  lt_debugprintf (__FILE__, __LINE__,
+		  "(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
+                  nonnull (name), nonnull (value));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      /* some systems can't cope with a ':'-terminated path #' */
+      int len = strlen (new_value);
+      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))
+        {
+          new_value[len-1] = '\0';
+        }
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+void
+lt_update_lib_path (const char *name, const char *value)
+{
+  lt_debugprintf (__FILE__, __LINE__,
+		  "(lt_update_lib_path) modifying '%s' by prepending '%s'\n",
+                  nonnull (name), nonnull (value));
+
+  if (name && *name && value && *value)
+    {
+      char *new_value = lt_extend_str (getenv (name), value, 0);
+      lt_setenv (name, new_value);
+      XFREE (new_value);
+    }
+}
+
+EOF
+	    case $host_os in
+	      mingw*)
+		cat <<"EOF"
+
+/* Prepares an argument vector before calling spawn().
+   Note that spawn() does not by itself call the command interpreter
+     (getenv ("COMSPEC") != NULL ? getenv ("COMSPEC") :
+      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+         GetVersionEx(&v);
+         v.dwPlatformId == VER_PLATFORM_WIN32_NT;
+      }) ? "cmd.exe" : "command.com").
+   Instead it simply concatenates the arguments, separated by ' ', and calls
+   CreateProcess().  We must quote the arguments since Win32 CreateProcess()
+   interprets characters like ' ', '\t', '\\', '"' (but not '<' and '>') in a
+   special way:
+   - Space and tab are interpreted as delimiters. They are not treated as
+     delimiters if they are surrounded by double quotes: "...".
+   - Unescaped double quotes are removed from the input. Their only effect is
+     that within double quotes, space and tab are treated like normal
+     characters.
+   - Backslashes not followed by double quotes are not special.
+   - But 2*n+1 backslashes followed by a double quote become
+     n backslashes followed by a double quote (n >= 0):
+       \" -> "
+       \\\" -> \"
+       \\\\\" -> \\"
+ */
+#define SHELL_SPECIAL_CHARS "\"\\ \001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
+#define SHELL_SPACE_CHARS " \001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"
+char **
+prepare_spawn (char **argv)
+{
+  size_t argc;
+  char **new_argv;
+  size_t i;
+
+  /* Count number of arguments.  */
+  for (argc = 0; argv[argc] != NULL; argc++)
+    ;
+
+  /* Allocate new argument vector.  */
+  new_argv = XMALLOC (char *, argc + 1);
+
+  /* Put quoted arguments into the new argument vector.  */
+  for (i = 0; i < argc; i++)
+    {
+      const char *string = argv[i];
+
+      if (string[0] == '\0')
+	new_argv[i] = xstrdup ("\"\"");
+      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)
+	{
+	  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);
+	  size_t length;
+	  unsigned int backslashes;
+	  const char *s;
+	  char *quoted_string;
+	  char *p;
+
+	  length = 0;
+	  backslashes = 0;
+	  if (quote_around)
+	    length++;
+	  for (s = string; *s != '\0'; s++)
+	    {
+	      char c = *s;
+	      if (c == '"')
+		length += backslashes + 1;
+	      length++;
+	      if (c == '\\')
+		backslashes++;
+	      else
+		backslashes = 0;
+	    }
+	  if (quote_around)
+	    length += backslashes + 1;
+
+	  quoted_string = XMALLOC (char, length + 1);
+
+	  p = quoted_string;
+	  backslashes = 0;
+	  if (quote_around)
+	    *p++ = '"';
+	  for (s = string; *s != '\0'; s++)
+	    {
+	      char c = *s;
+	      if (c == '"')
+		{
+		  unsigned int j;
+		  for (j = backslashes + 1; j > 0; j--)
+		    *p++ = '\\';
+		}
+	      *p++ = c;
+	      if (c == '\\')
+		backslashes++;
+	      else
+		backslashes = 0;
+	    }
+	  if (quote_around)
+	    {
+	      unsigned int j;
+	      for (j = backslashes; j > 0; j--)
+		*p++ = '\\';
+	      *p++ = '"';
+	    }
+	  *p = '\0';
+
+	  new_argv[i] = quoted_string;
+	}
+      else
+	new_argv[i] = (char *) string;
+    }
+  new_argv[argc] = NULL;
+
+  return new_argv;
+}
+EOF
+		;;
+	    esac
+
+            cat <<"EOF"
+void lt_dump_script (FILE* f)
+{
+EOF
+	    func_emit_wrapper yes |
+	      $SED -n -e '
+s/^\(.\{79\}\)\(..*\)/\1\
+\2/
+h
+s/\([\\"]\)/\\\1/g
+s/$/\\n/
+s/\([^\n]*\).*/  fputs ("\1", f);/p
+g
+D'
+            cat <<"EOF"
+}
+EOF
+}
+# end: func_emit_cwrapperexe_src
+
+# func_win32_import_lib_p ARG
+# True if ARG is an import lib, as indicated by $file_magic_cmd
+func_win32_import_lib_p ()
+{
+    $opt_debug
+    case `eval $file_magic_cmd \"\$1\" 2>/dev/null | $SED -e 10q` in
+    *import*) : ;;
+    *) false ;;
+    esac
+}
+
+# func_mode_link arg...
+func_mode_link ()
+{
+    $opt_debug
+    case $host in
+    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+      # It is impossible to link a dll without this setting, and
+      # we shouldn't force the makefile maintainer to figure out
+      # which system we are compiling for in order to pass an extra
+      # flag for every libtool invocation.
+      # allow_undefined=no
+
+      # FIXME: Unfortunately, there are problems with the above when trying
+      # to make a dll which has undefined symbols, in which case not
+      # even a static library is built.  For now, we need to specify
+      # -no-undefined on the libtool link line when we can be certain
+      # that all symbols are satisfied, otherwise we get a static library.
+      allow_undefined=yes
+      ;;
+    *)
+      allow_undefined=yes
+      ;;
+    esac
+    libtool_args=$nonopt
+    base_compile="$nonopt $@"
+    compile_command=$nonopt
+    finalize_command=$nonopt
+
+    compile_rpath=
+    finalize_rpath=
+    compile_shlibpath=
+    finalize_shlibpath=
+    convenience=
+    old_convenience=
+    deplibs=
+    old_deplibs=
+    compiler_flags=
+    linker_flags=
+    dllsearchpath=
+    lib_search_path=`pwd`
+    inst_prefix_dir=
+    new_inherited_linker_flags=
+
+    avoid_version=no
+    bindir=
+    dlfiles=
+    dlprefiles=
+    dlself=no
+    export_dynamic=no
+    export_symbols=
+    export_symbols_regex=
+    generated=
+    libobjs=
+    ltlibs=
+    module=no
+    no_install=no
+    objs=
+    non_pic_objects=
+    precious_files_regex=
+    prefer_static_libs=no
+    preload=no
+    prev=
+    prevarg=
+    release=
+    rpath=
+    xrpath=
+    perm_rpath=
+    temp_rpath=
+    thread_safe=no
+    vinfo=
+    vinfo_number=no
+    weak_libs=
+    single_module="${wl}-single_module"
+    func_infer_tag $base_compile
+
+    # We need to know -static, to get the right output filenames.
+    for arg
+    do
+      case $arg in
+      -shared)
+	test "$build_libtool_libs" != yes && \
+	  func_fatal_configuration "can not build a shared library"
+	build_old_libs=no
+	break
+	;;
+      -all-static | -static | -static-libtool-libs)
+	case $arg in
+	-all-static)
+	  if test "$build_libtool_libs" = yes && test -z "$link_static_flag"; then
+	    func_warning "complete static linking is impossible in this configuration"
+	  fi
+	  if test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	-static)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=built
+	  ;;
+	-static-libtool-libs)
+	  if test -z "$pic_flag" && test -n "$link_static_flag"; then
+	    dlopen_self=$dlopen_self_static
+	  fi
+	  prefer_static_libs=yes
+	  ;;
+	esac
+	build_libtool_libs=no
+	build_old_libs=yes
+	break
+	;;
+      esac
+    done
+
+    # See if our shared archives depend on static archives.
+    test -n "$old_archive_from_new_cmds" && build_old_libs=yes
+
+    # Go through the arguments, transforming them on the way.
+    while test "$#" -gt 0; do
+      arg="$1"
+      shift
+      func_quote_for_eval "$arg"
+      qarg=$func_quote_for_eval_unquoted_result
+      func_append libtool_args " $func_quote_for_eval_result"
+
+      # If the previous option needs an argument, assign it.
+      if test -n "$prev"; then
+	case $prev in
+	output)
+	  func_append compile_command " @OUTPUT@"
+	  func_append finalize_command " @OUTPUT@"
+	  ;;
+	esac
+
+	case $prev in
+	bindir)
+	  bindir="$arg"
+	  prev=
+	  continue
+	  ;;
+	dlfiles|dlprefiles)
+	  if test "$preload" = no; then
+	    # Add the symbol object into the linking commands.
+	    func_append compile_command " @SYMFILE@"
+	    func_append finalize_command " @SYMFILE@"
+	    preload=yes
+	  fi
+	  case $arg in
+	  *.la | *.lo) ;;  # We handle these cases below.
+	  force)
+	    if test "$dlself" = no; then
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  self)
+	    if test "$prev" = dlprefiles; then
+	      dlself=yes
+	    elif test "$prev" = dlfiles && test "$dlopen_self" != yes; then
+	      dlself=yes
+	    else
+	      dlself=needless
+	      export_dynamic=yes
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  *)
+	    if test "$prev" = dlfiles; then
+	      func_append dlfiles " $arg"
+	    else
+	      func_append dlprefiles " $arg"
+	    fi
+	    prev=
+	    continue
+	    ;;
+	  esac
+	  ;;
+	expsyms)
+	  export_symbols="$arg"
+	  test -f "$arg" \
+	    || func_fatal_error "symbol file \`$arg' does not exist"
+	  prev=
+	  continue
+	  ;;
+	expsyms_regex)
+	  export_symbols_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	framework)
+	  case $host in
+	    *-*-darwin*)
+	      case "$deplibs " in
+		*" $qarg.ltframework "*) ;;
+		*) func_append deplibs " $qarg.ltframework" # this is fixed later
+		   ;;
+	      esac
+	      ;;
+	  esac
+	  prev=
+	  continue
+	  ;;
+	inst_prefix)
+	  inst_prefix_dir="$arg"
+	  prev=
+	  continue
+	  ;;
+	objectlist)
+	  if test -f "$arg"; then
+	    save_arg=$arg
+	    moreargs=
+	    for fil in `cat "$save_arg"`
+	    do
+#	      func_append moreargs " $fil"
+	      arg=$fil
+	      # A libtool-controlled object.
+
+	      # Check to see that this really is a libtool object.
+	      if func_lalib_unsafe_p "$arg"; then
+		pic_object=
+		non_pic_object=
+
+		# Read the .lo file
+		func_source "$arg"
+
+		if test -z "$pic_object" ||
+		   test -z "$non_pic_object" ||
+		   test "$pic_object" = none &&
+		   test "$non_pic_object" = none; then
+		  func_fatal_error "cannot find name of object for \`$arg'"
+		fi
+
+		# Extract subdirectory from the argument.
+		func_dirname "$arg" "/" ""
+		xdir="$func_dirname_result"
+
+		if test "$pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  pic_object="$xdir$pic_object"
+
+		  if test "$prev" = dlfiles; then
+		    if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		      func_append dlfiles " $pic_object"
+		      prev=
+		      continue
+		    else
+		      # If libtool objects are unsupported, then we need to preload.
+		      prev=dlprefiles
+		    fi
+		  fi
+
+		  # CHECK ME:  I think I busted this.  -Ossama
+		  if test "$prev" = dlprefiles; then
+		    # Preload the old-style object.
+		    func_append dlprefiles " $pic_object"
+		    prev=
+		  fi
+
+		  # A PIC object.
+		  func_append libobjs " $pic_object"
+		  arg="$pic_object"
+		fi
+
+		# Non-PIC object.
+		if test "$non_pic_object" != none; then
+		  # Prepend the subdirectory the object is found in.
+		  non_pic_object="$xdir$non_pic_object"
+
+		  # A standard non-PIC object
+		  func_append non_pic_objects " $non_pic_object"
+		  if test -z "$pic_object" || test "$pic_object" = none ; then
+		    arg="$non_pic_object"
+		  fi
+		else
+		  # If the PIC object exists, use it instead.
+		  # $xdir was prepended to $pic_object above.
+		  non_pic_object="$pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+		fi
+	      else
+		# Only an error if not doing a dry-run.
+		if $opt_dry_run; then
+		  # Extract subdirectory from the argument.
+		  func_dirname "$arg" "/" ""
+		  xdir="$func_dirname_result"
+
+		  func_lo2o "$arg"
+		  pic_object=$xdir$objdir/$func_lo2o_result
+		  non_pic_object=$xdir$func_lo2o_result
+		  func_append libobjs " $pic_object"
+		  func_append non_pic_objects " $non_pic_object"
+	        else
+		  func_fatal_error "\`$arg' is not a valid libtool object"
+		fi
+	      fi
+	    done
+	  else
+	    func_fatal_error "link input file \`$arg' does not exist"
+	  fi
+	  arg=$save_arg
+	  prev=
+	  continue
+	  ;;
+	precious_regex)
+	  precious_files_regex="$arg"
+	  prev=
+	  continue
+	  ;;
+	release)
+	  release="-$arg"
+	  prev=
+	  continue
+	  ;;
+	rpath | xrpath)
+	  # We need an absolute path.
+	  case $arg in
+	  [\\/]* | [A-Za-z]:[\\/]*) ;;
+	  *)
+	    func_fatal_error "only absolute run-paths are allowed"
+	    ;;
+	  esac
+	  if test "$prev" = rpath; then
+	    case "$rpath " in
+	    *" $arg "*) ;;
+	    *) func_append rpath " $arg" ;;
+	    esac
+	  else
+	    case "$xrpath " in
+	    *" $arg "*) ;;
+	    *) func_append xrpath " $arg" ;;
+	    esac
+	  fi
+	  prev=
+	  continue
+	  ;;
+	shrext)
+	  shrext_cmds="$arg"
+	  prev=
+	  continue
+	  ;;
+	weak)
+	  func_append weak_libs " $arg"
+	  prev=
+	  continue
+	  ;;
+	xcclinker)
+	  func_append linker_flags " $qarg"
+	  func_append compiler_flags " $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xcompiler)
+	  func_append compiler_flags " $qarg"
+	  prev=
+	  func_append compile_command " $qarg"
+	  func_append finalize_command " $qarg"
+	  continue
+	  ;;
+	xlinker)
+	  func_append linker_flags " $qarg"
+	  func_append compiler_flags " $wl$qarg"
+	  prev=
+	  func_append compile_command " $wl$qarg"
+	  func_append finalize_command " $wl$qarg"
+	  continue
+	  ;;
+	*)
+	  eval "$prev=\"\$arg\""
+	  prev=
+	  continue
+	  ;;
+	esac
+      fi # test -n "$prev"
+
+      prevarg="$arg"
+
+      case $arg in
+      -all-static)
+	if test -n "$link_static_flag"; then
+	  # See comment for -static flag below, for more details.
+	  func_append compile_command " $link_static_flag"
+	  func_append finalize_command " $link_static_flag"
+	fi
+	continue
+	;;
+
+      -allow-undefined)
+	# FIXME: remove this flag sometime in the future.
+	func_fatal_error "\`-allow-undefined' must not be used because it is the default"
+	;;
+
+      -avoid-version)
+	avoid_version=yes
+	continue
+	;;
+
+      -bindir)
+	prev=bindir
+	continue
+	;;
+
+      -dlopen)
+	prev=dlfiles
+	continue
+	;;
+
+      -dlpreopen)
+	prev=dlprefiles
+	continue
+	;;
+
+      -export-dynamic)
+	export_dynamic=yes
+	continue
+	;;
+
+      -export-symbols | -export-symbols-regex)
+	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
+	  func_fatal_error "more than one -exported-symbols argument is not allowed"
+	fi
+	if test "X$arg" = "X-export-symbols"; then
+	  prev=expsyms
+	else
+	  prev=expsyms_regex
+	fi
+	continue
+	;;
+
+      -framework)
+	prev=framework
+	continue
+	;;
+
+      -inst-prefix-dir)
+	prev=inst_prefix
+	continue
+	;;
+
+      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*
+      # so, if we see these flags be careful not to treat them like -L
+      -L[A-Z][A-Z]*:*)
+	case $with_gcc/$host in
+	no/*-*-irix* | /*-*-irix*)
+	  func_append compile_command " $arg"
+	  func_append finalize_command " $arg"
+	  ;;
+	esac
+	continue
+	;;
+
+      -L*)
+	func_stripname "-L" '' "$arg"
+	if test -z "$func_stripname_result"; then
+	  if test "$#" -gt 0; then
+	    func_fatal_error "require no space between \`-L' and \`$1'"
+	  else
+	    func_fatal_error "need path for \`-L' option"
+	  fi
+	fi
+	func_resolve_sysroot "$func_stripname_result"
+	dir=$func_resolve_sysroot_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	*)
+	  absdir=`cd "$dir" && pwd`
+	  test -z "$absdir" && \
+	    func_fatal_error "cannot determine absolute directory name of \`$dir'"
+	  dir="$absdir"
+	  ;;
+	esac
+	case "$deplibs " in
+	*" -L$dir "* | *" $arg "*)
+	  # Will only happen for absolute or sysroot arguments
+	  ;;
+	*)
+	  # Preserve sysroot, but never include relative directories
+	  case $dir in
+	    [\\/]* | [A-Za-z]:[\\/]* | =*) func_append deplibs " $arg" ;;
+	    *) func_append deplibs " -L$dir" ;;
+	  esac
+	  func_append lib_search_path " $dir"
+	  ;;
+	esac
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`$ECHO "$dir" | $SED 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$dir:"*) ;;
+	  ::) dllsearchpath=$dir;;
+	  *) func_append dllsearchpath ":$dir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) func_append dllsearchpath ":$testbindir";;
+	  esac
+	  ;;
+	esac
+	continue
+	;;
+
+      -l*)
+	if test "X$arg" = "X-lc" || test "X$arg" = "X-lm"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)
+	    # These systems don't actually have a C or math library (as such)
+	    continue
+	    ;;
+	  *-*-os2*)
+	    # These systems don't actually have a C library (as such)
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C and math libraries are in the System framework
+	    func_append deplibs " System.ltframework"
+	    continue
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    test "X$arg" = "X-lc" && continue
+	    ;;
+	  esac
+	elif test "X$arg" = "X-lc_r"; then
+	 case $host in
+	 *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	   # Do not include libc_r directly, use -pthread flag.
+	   continue
+	   ;;
+	 esac
+	fi
+	func_append deplibs " $arg"
+	continue
+	;;
+
+      -module)
+	module=yes
+	continue
+	;;
+
+      # Tru64 UNIX uses -model [arg] to determine the layout of C++
+      # classes, name mangling, and exception handling.
+      # Darwin uses the -arch flag to determine output architecture.
+      -model|-arch|-isysroot|--sysroot)
+	func_append compiler_flags " $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	prev=xcompiler
+	continue
+	;;
+
+      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \
+      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
+	func_append compiler_flags " $arg"
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+	case "$new_inherited_linker_flags " in
+	    *" $arg "*) ;;
+	    * ) func_append new_inherited_linker_flags " $arg" ;;
+	esac
+	continue
+	;;
+
+      -multi_module)
+	single_module="${wl}-multi_module"
+	continue
+	;;
+
+      -no-fast-install)
+	fast_install=no
+	continue
+	;;
+
+      -no-install)
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)
+	  # The PATH hackery in wrapper scripts is required on Windows
+	  # and Darwin in order for the loader to find any dlls it needs.
+	  func_warning "\`-no-install' is ignored for $host"
+	  func_warning "assuming \`-no-fast-install' instead"
+	  fast_install=no
+	  ;;
+	*) no_install=yes ;;
+	esac
+	continue
+	;;
+
+      -no-undefined)
+	allow_undefined=no
+	continue
+	;;
+
+      -objectlist)
+	prev=objectlist
+	continue
+	;;
+
+      -o) prev=output ;;
+
+      -precious-files-regex)
+	prev=precious_regex
+	continue
+	;;
+
+      -release)
+	prev=release
+	continue
+	;;
+
+      -rpath)
+	prev=rpath
+	continue
+	;;
+
+      -R)
+	prev=xrpath
+	continue
+	;;
+
+      -R*)
+	func_stripname '-R' '' "$arg"
+	dir=$func_stripname_result
+	# We need an absolute path.
+	case $dir in
+	[\\/]* | [A-Za-z]:[\\/]*) ;;
+	=*)
+	  func_stripname '=' '' "$dir"
+	  dir=$lt_sysroot$func_stripname_result
+	  ;;
+	*)
+	  func_fatal_error "only absolute run-paths are allowed"
+	  ;;
+	esac
+	case "$xrpath " in
+	*" $dir "*) ;;
+	*) func_append xrpath " $dir" ;;
+	esac
+	continue
+	;;
+
+      -shared)
+	# The effects of -shared are defined in a previous loop.
+	continue
+	;;
+
+      -shrext)
+	prev=shrext
+	continue
+	;;
+
+      -static | -static-libtool-libs)
+	# The effects of -static are defined in a previous loop.
+	# We used to do the same as -all-static on platforms that
+	# didn't have a PIC flag, but the assumption that the effects
+	# would be equivalent was wrong.  It would break on at least
+	# Digital Unix and AIX.
+	continue
+	;;
+
+      -thread-safe)
+	thread_safe=yes
+	continue
+	;;
+
+      -version-info)
+	prev=vinfo
+	continue
+	;;
+
+      -version-number)
+	prev=vinfo
+	vinfo_number=yes
+	continue
+	;;
+
+      -weak)
+        prev=weak
+	continue
+	;;
+
+      -Wc,*)
+	func_stripname '-Wc,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  func_append arg " $func_quote_for_eval_result"
+	  func_append compiler_flags " $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Wl,*)
+	func_stripname '-Wl,' '' "$arg"
+	args=$func_stripname_result
+	arg=
+	save_ifs="$IFS"; IFS=','
+	for flag in $args; do
+	  IFS="$save_ifs"
+          func_quote_for_eval "$flag"
+	  func_append arg " $wl$func_quote_for_eval_result"
+	  func_append compiler_flags " $wl$func_quote_for_eval_result"
+	  func_append linker_flags " $func_quote_for_eval_result"
+	done
+	IFS="$save_ifs"
+	func_stripname ' ' '' "$arg"
+	arg=$func_stripname_result
+	;;
+
+      -Xcompiler)
+	prev=xcompiler
+	continue
+	;;
+
+      -Xlinker)
+	prev=xlinker
+	continue
+	;;
+
+      -XCClinker)
+	prev=xcclinker
+	continue
+	;;
+
+      # -msg_* for osf cc
+      -msg_*)
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      # Flags to be passed through unchanged, with rationale:
+      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler
+      # -r[0-9][0-9]*        specify processor for the SGI compiler
+      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler
+      # +DA*, +DD*           enable 64-bit mode for the HP compiler
+      # -q*                  compiler args for the IBM compiler
+      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC
+      # -F/path              path to uninstalled frameworks, gcc on darwin
+      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC
+      # @file                GCC response files
+      # -tp=*                Portland pgcc target processor selection
+      # --sysroot=*          for sysroot support
+      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization
+      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
+      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \
+      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+        func_append compile_command " $arg"
+        func_append finalize_command " $arg"
+        func_append compiler_flags " $arg"
+        continue
+        ;;
+
+      # Some other compiler flag.
+      -* | +*)
+        func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+
+      *.$objext)
+	# A standard object.
+	func_append objs " $arg"
+	;;
+
+      *.lo)
+	# A libtool-controlled object.
+
+	# Check to see that this really is a libtool object.
+	if func_lalib_unsafe_p "$arg"; then
+	  pic_object=
+	  non_pic_object=
+
+	  # Read the .lo file
+	  func_source "$arg"
+
+	  if test -z "$pic_object" ||
+	     test -z "$non_pic_object" ||
+	     test "$pic_object" = none &&
+	     test "$non_pic_object" = none; then
+	    func_fatal_error "cannot find name of object for \`$arg'"
+	  fi
+
+	  # Extract subdirectory from the argument.
+	  func_dirname "$arg" "/" ""
+	  xdir="$func_dirname_result"
+
+	  if test "$pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    pic_object="$xdir$pic_object"
+
+	    if test "$prev" = dlfiles; then
+	      if test "$build_libtool_libs" = yes && test "$dlopen_support" = yes; then
+		func_append dlfiles " $pic_object"
+		prev=
+		continue
+	      else
+		# If libtool objects are unsupported, then we need to preload.
+		prev=dlprefiles
+	      fi
+	    fi
+
+	    # CHECK ME:  I think I busted this.  -Ossama
+	    if test "$prev" = dlprefiles; then
+	      # Preload the old-style object.
+	      func_append dlprefiles " $pic_object"
+	      prev=
+	    fi
+
+	    # A PIC object.
+	    func_append libobjs " $pic_object"
+	    arg="$pic_object"
+	  fi
+
+	  # Non-PIC object.
+	  if test "$non_pic_object" != none; then
+	    # Prepend the subdirectory the object is found in.
+	    non_pic_object="$xdir$non_pic_object"
+
+	    # A standard non-PIC object
+	    func_append non_pic_objects " $non_pic_object"
+	    if test -z "$pic_object" || test "$pic_object" = none ; then
+	      arg="$non_pic_object"
+	    fi
+	  else
+	    # If the PIC object exists, use it instead.
+	    # $xdir was prepended to $pic_object above.
+	    non_pic_object="$pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  fi
+	else
+	  # Only an error if not doing a dry-run.
+	  if $opt_dry_run; then
+	    # Extract subdirectory from the argument.
+	    func_dirname "$arg" "/" ""
+	    xdir="$func_dirname_result"
+
+	    func_lo2o "$arg"
+	    pic_object=$xdir$objdir/$func_lo2o_result
+	    non_pic_object=$xdir$func_lo2o_result
+	    func_append libobjs " $pic_object"
+	    func_append non_pic_objects " $non_pic_object"
+	  else
+	    func_fatal_error "\`$arg' is not a valid libtool object"
+	  fi
+	fi
+	;;
+
+      *.$libext)
+	# An archive.
+	func_append deplibs " $arg"
+	func_append old_deplibs " $arg"
+	continue
+	;;
+
+      *.la)
+	# A libtool-controlled library.
+
+	func_resolve_sysroot "$arg"
+	if test "$prev" = dlfiles; then
+	  # This library was specified with -dlopen.
+	  func_append dlfiles " $func_resolve_sysroot_result"
+	  prev=
+	elif test "$prev" = dlprefiles; then
+	  # The library was specified with -dlpreopen.
+	  func_append dlprefiles " $func_resolve_sysroot_result"
+	  prev=
+	else
+	  func_append deplibs " $func_resolve_sysroot_result"
+	fi
+	continue
+	;;
+
+      # Some other compiler argument.
+      *)
+	# Unknown arguments in both finalize_command and compile_command need
+	# to be aesthetically quoted because they are evaled later.
+	func_quote_for_eval "$arg"
+	arg="$func_quote_for_eval_result"
+	;;
+      esac # arg
+
+      # Now actually substitute the argument into the commands.
+      if test -n "$arg"; then
+	func_append compile_command " $arg"
+	func_append finalize_command " $arg"
+      fi
+    done # argument parsing loop
+
+    test -n "$prev" && \
+      func_fatal_help "the \`$prevarg' option requires an argument"
+
+    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
+      eval arg=\"$export_dynamic_flag_spec\"
+      func_append compile_command " $arg"
+      func_append finalize_command " $arg"
+    fi
+
+    oldlibs=
+    # calculate the name of the file, without its directory
+    func_basename "$output"
+    outputname="$func_basename_result"
+    libobjs_save="$libobjs"
+
+    if test -n "$shlibpath_var"; then
+      # get the directories listed in $shlibpath_var
+      eval shlib_search_path=\`\$ECHO \"\${$shlibpath_var}\" \| \$SED \'s/:/ /g\'\`
+    else
+      shlib_search_path=
+    fi
+    eval sys_lib_search_path=\"$sys_lib_search_path_spec\"
+    eval sys_lib_dlsearch_path=\"$sys_lib_dlsearch_path_spec\"
+
+    func_dirname "$output" "/" ""
+    output_objdir="$func_dirname_result$objdir"
+    func_to_tool_file "$output_objdir/"
+    tool_output_objdir=$func_to_tool_file_result
+    # Create the object directory.
+    func_mkdir_p "$output_objdir"
+
+    # Determine the type of output
+    case $output in
+    "")
+      func_fatal_help "you must specify an output file"
+      ;;
+    *.$libext) linkmode=oldlib ;;
+    *.lo | *.$objext) linkmode=obj ;;
+    *.la) linkmode=lib ;;
+    *) linkmode=prog ;; # Anything else should be a program.
+    esac
+
+    specialdeplibs=
+
+    libs=
+    # Find all interdependent deplibs by searching for libraries
+    # that are linked more than once (e.g. -la -lb -la)
+    for deplib in $deplibs; do
+      if $opt_preserve_dup_deps ; then
+	case "$libs " in
+	*" $deplib "*) func_append specialdeplibs " $deplib" ;;
+	esac
+      fi
+      func_append libs " $deplib"
+    done
+
+    if test "$linkmode" = lib; then
+      libs="$predeps $libs $compiler_lib_search_path $postdeps"
+
+      # Compute libraries that are listed more than once in $predeps
+      # $postdeps and mark them as special (i.e., whose duplicates are
+      # not to be eliminated).
+      pre_post_deps=
+      if $opt_duplicate_compiler_generated_deps; then
+	for pre_post_dep in $predeps $postdeps; do
+	  case "$pre_post_deps " in
+	  *" $pre_post_dep "*) func_append specialdeplibs " $pre_post_deps" ;;
+	  esac
+	  func_append pre_post_deps " $pre_post_dep"
+	done
+      fi
+      pre_post_deps=
+    fi
+
+    deplibs=
+    newdependency_libs=
+    newlib_search_path=
+    need_relink=no # whether we're linking any uninstalled libtool libraries
+    notinst_deplibs= # not-installed libtool libraries
+    notinst_path= # paths that contain not-installed libtool libraries
+
+    case $linkmode in
+    lib)
+	passes="conv dlpreopen link"
+	for file in $dlfiles $dlprefiles; do
+	  case $file in
+	  *.la) ;;
+	  *)
+	    func_fatal_help "libraries can \`-dlopen' only libtool libraries: $file"
+	    ;;
+	  esac
+	done
+	;;
+    prog)
+	compile_deplibs=
+	finalize_deplibs=
+	alldeplibs=no
+	newdlfiles=
+	newdlprefiles=
+	passes="conv scan dlopen dlpreopen link"
+	;;
+    *)  passes="conv"
+	;;
+    esac
+
+    for pass in $passes; do
+      # The preopen pass in lib mode reverses $deplibs; put it back here
+      # so that -L comes before libs that need it for instance...
+      if test "$linkmode,$pass" = "lib,link"; then
+	## FIXME: Find the place where the list is rebuilt in the wrong
+	##        order, and fix it there properly
+        tmp_deplibs=
+	for deplib in $deplibs; do
+	  tmp_deplibs="$deplib $tmp_deplibs"
+	done
+	deplibs="$tmp_deplibs"
+      fi
+
+      if test "$linkmode,$pass" = "lib,link" ||
+	 test "$linkmode,$pass" = "prog,scan"; then
+	libs="$deplibs"
+	deplibs=
+      fi
+      if test "$linkmode" = prog; then
+	case $pass in
+	dlopen) libs="$dlfiles" ;;
+	dlpreopen) libs="$dlprefiles" ;;
+	link)
+	  libs="$deplibs %DEPLIBS%"
+	  test "X$link_all_deplibs" != Xno && libs="$libs $dependency_libs"
+	  ;;
+	esac
+      fi
+      if test "$linkmode,$pass" = "lib,dlpreopen"; then
+	# Collect and forward deplibs of preopened libtool libs
+	for lib in $dlprefiles; do
+	  # Ignore non-libtool-libs
+	  dependency_libs=
+	  func_resolve_sysroot "$lib"
+	  case $lib in
+	  *.la)	func_source "$func_resolve_sysroot_result" ;;
+	  esac
+
+	  # Collect preopened libtool deplibs, except any this library
+	  # has declared as weak libs
+	  for deplib in $dependency_libs; do
+	    func_basename "$deplib"
+            deplib_base=$func_basename_result
+	    case " $weak_libs " in
+	    *" $deplib_base "*) ;;
+	    *) func_append deplibs " $deplib" ;;
+	    esac
+	  done
+	done
+	libs="$dlprefiles"
+      fi
+      if test "$pass" = dlopen; then
+	# Collect dlpreopened libraries
+	save_deplibs="$deplibs"
+	deplibs=
+      fi
+
+      for deplib in $libs; do
+	lib=
+	found=no
+	case $deplib in
+	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \
+        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    func_append compiler_flags " $deplib"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) func_append new_inherited_linker_flags " $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-l*)
+	  if test "$linkmode" != lib && test "$linkmode" != prog; then
+	    func_warning "\`-l' is ignored for archives/objects"
+	    continue
+	  fi
+	  func_stripname '-l' '' "$deplib"
+	  name=$func_stripname_result
+	  if test "$linkmode" = lib; then
+	    searchdirs="$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path"
+	  else
+	    searchdirs="$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path"
+	  fi
+	  for searchdir in $searchdirs; do
+	    for search_ext in .la $std_shrext .so .a; do
+	      # Search the libtool library
+	      lib="$searchdir/lib${name}${search_ext}"
+	      if test -f "$lib"; then
+		if test "$search_ext" = ".la"; then
+		  found=yes
+		else
+		  found=no
+		fi
+		break 2
+	      fi
+	    done
+	  done
+	  if test "$found" != yes; then
+	    # deplib doesn't seem to be a libtool library
+	    if test "$linkmode,$pass" = "prog,link"; then
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      deplibs="$deplib $deplibs"
+	      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    continue
+	  else # deplib is a libtool library
+	    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,
+	    # We need to do some special things here, and not later.
+	    if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	      case " $predeps $postdeps " in
+	      *" $deplib "*)
+		if func_lalib_p "$lib"; then
+		  library_names=
+		  old_library=
+		  func_source "$lib"
+		  for l in $old_library $library_names; do
+		    ll="$l"
+		  done
+		  if test "X$ll" = "X$old_library" ; then # only static version available
+		    found=no
+		    func_dirname "$lib" "" "."
+		    ladir="$func_dirname_result"
+		    lib=$ladir/$old_library
+		    if test "$linkmode,$pass" = "prog,link"; then
+		      compile_deplibs="$deplib $compile_deplibs"
+		      finalize_deplibs="$deplib $finalize_deplibs"
+		    else
+		      deplibs="$deplib $deplibs"
+		      test "$linkmode" = lib && newdependency_libs="$deplib $newdependency_libs"
+		    fi
+		    continue
+		  fi
+		fi
+		;;
+	      *) ;;
+	      esac
+	    fi
+	  fi
+	  ;; # -l
+	*.ltframework)
+	  if test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$deplib $compile_deplibs"
+	    finalize_deplibs="$deplib $finalize_deplibs"
+	  else
+	    deplibs="$deplib $deplibs"
+	    if test "$linkmode" = lib ; then
+		case "$new_inherited_linker_flags " in
+		    *" $deplib "*) ;;
+		    * ) func_append new_inherited_linker_flags " $deplib" ;;
+		esac
+	    fi
+	  fi
+	  continue
+	  ;;
+	-L*)
+	  case $linkmode in
+	  lib)
+	    deplibs="$deplib $deplibs"
+	    test "$pass" = conv && continue
+	    newdependency_libs="$deplib $newdependency_libs"
+	    func_stripname '-L' '' "$deplib"
+	    func_resolve_sysroot "$func_stripname_result"
+	    func_append newlib_search_path " $func_resolve_sysroot_result"
+	    ;;
+	  prog)
+	    if test "$pass" = conv; then
+	      deplibs="$deplib $deplibs"
+	      continue
+	    fi
+	    if test "$pass" = scan; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    func_stripname '-L' '' "$deplib"
+	    func_resolve_sysroot "$func_stripname_result"
+	    func_append newlib_search_path " $func_resolve_sysroot_result"
+	    ;;
+	  *)
+	    func_warning "\`-L' is ignored for archives/objects"
+	    ;;
+	  esac # linkmode
+	  continue
+	  ;; # -L
+	-R*)
+	  if test "$pass" = link; then
+	    func_stripname '-R' '' "$deplib"
+	    func_resolve_sysroot "$func_stripname_result"
+	    dir=$func_resolve_sysroot_result
+	    # Make sure the xrpath contains only unique directories.
+	    case "$xrpath " in
+	    *" $dir "*) ;;
+	    *) func_append xrpath " $dir" ;;
+	    esac
+	  fi
+	  deplibs="$deplib $deplibs"
+	  continue
+	  ;;
+	*.la)
+	  func_resolve_sysroot "$deplib"
+	  lib=$func_resolve_sysroot_result
+	  ;;
+	*.$libext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	    continue
+	  fi
+	  case $linkmode in
+	  lib)
+	    # Linking convenience modules into shared libraries is allowed,
+	    # but linking other static libraries is non-portable.
+	    case " $dlpreconveniencelibs " in
+	    *" $deplib "*) ;;
+	    *)
+	      valid_a_lib=no
+	      case $deplibs_check_method in
+		match_pattern*)
+		  set dummy $deplibs_check_method; shift
+		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+		  if eval "\$ECHO \"$deplib\"" 2>/dev/null | $SED 10q \
+		    | $EGREP "$match_pattern_regex" > /dev/null; then
+		    valid_a_lib=yes
+		  fi
+		;;
+		pass_all)
+		  valid_a_lib=yes
+		;;
+	      esac
+	      if test "$valid_a_lib" != yes; then
+		echo
+		$ECHO "*** Warning: Trying to link with static lib archive $deplib."
+		echo "*** I have the capability to make that library automatically link in when"
+		echo "*** you link to this library.  But I can only do this if you have a"
+		echo "*** shared version of the library, which you do not appear to have"
+		echo "*** because the file extensions .$libext of this argument makes me believe"
+		echo "*** that it is just a static archive that I should not use here."
+	      else
+		echo
+		$ECHO "*** Warning: Linking the shared library $output against the"
+		$ECHO "*** static library $deplib is not portable!"
+		deplibs="$deplib $deplibs"
+	      fi
+	      ;;
+	    esac
+	    continue
+	    ;;
+	  prog)
+	    if test "$pass" != link; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    fi
+	    continue
+	    ;;
+	  esac # linkmode
+	  ;; # *.$libext
+	*.lo | *.$objext)
+	  if test "$pass" = conv; then
+	    deplibs="$deplib $deplibs"
+	  elif test "$linkmode" = prog; then
+	    if test "$pass" = dlpreopen || test "$dlopen_support" != yes || test "$build_libtool_libs" = no; then
+	      # If there is no dlopen support or we're linking statically,
+	      # we need to preload.
+	      func_append newdlprefiles " $deplib"
+	      compile_deplibs="$deplib $compile_deplibs"
+	      finalize_deplibs="$deplib $finalize_deplibs"
+	    else
+	      func_append newdlfiles " $deplib"
+	    fi
+	  fi
+	  continue
+	  ;;
+	%DEPLIBS%)
+	  alldeplibs=yes
+	  continue
+	  ;;
+	esac # case $deplib
+
+	if test "$found" = yes || test -f "$lib"; then :
+	else
+	  func_fatal_error "cannot find the library \`$lib' or unhandled argument \`$deplib'"
+	fi
+
+	# Check to see that this really is a libtool archive.
+	func_lalib_unsafe_p "$lib" \
+	  || func_fatal_error "\`$lib' is not a valid libtool archive"
+
+	func_dirname "$lib" "" "."
+	ladir="$func_dirname_result"
+
+	dlname=
+	dlopen=
+	dlpreopen=
+	libdir=
+	library_names=
+	old_library=
+	inherited_linker_flags=
+	# If the library was installed with an old release of libtool,
+	# it will not redefine variables installed, or shouldnotlink
+	installed=yes
+	shouldnotlink=no
+	avoidtemprpath=
+
+
+	# Read the .la file
+	func_source "$lib"
+
+	# Convert "-framework foo" to "foo.ltframework"
+	if test -n "$inherited_linker_flags"; then
+	  tmp_inherited_linker_flags=`$ECHO "$inherited_linker_flags" | $SED 's/-framework \([^ $]*\)/\1.ltframework/g'`
+	  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do
+	    case " $new_inherited_linker_flags " in
+	      *" $tmp_inherited_linker_flag "*) ;;
+	      *) func_append new_inherited_linker_flags " $tmp_inherited_linker_flag";;
+	    esac
+	  done
+	fi
+	dependency_libs=`$ECHO " $dependency_libs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	if test "$linkmode,$pass" = "lib,link" ||
+	   test "$linkmode,$pass" = "prog,scan" ||
+	   { test "$linkmode" != prog && test "$linkmode" != lib; }; then
+	  test -n "$dlopen" && func_append dlfiles " $dlopen"
+	  test -n "$dlpreopen" && func_append dlprefiles " $dlpreopen"
+	fi
+
+	if test "$pass" = conv; then
+	  # Only check for convenience libraries
+	  deplibs="$lib $deplibs"
+	  if test -z "$libdir"; then
+	    if test -z "$old_library"; then
+	      func_fatal_error "cannot find name of link library for \`$lib'"
+	    fi
+	    # It is a libtool convenience library, so add in its objects.
+	    func_append convenience " $ladir/$objdir/$old_library"
+	    func_append old_convenience " $ladir/$objdir/$old_library"
+	    tmp_libs=
+	    for deplib in $dependency_libs; do
+	      deplibs="$deplib $deplibs"
+	      if $opt_preserve_dup_deps ; then
+		case "$tmp_libs " in
+		*" $deplib "*) func_append specialdeplibs " $deplib" ;;
+		esac
+	      fi
+	      func_append tmp_libs " $deplib"
+	    done
+	  elif test "$linkmode" != prog && test "$linkmode" != lib; then
+	    func_fatal_error "\`$lib' is not a convenience library"
+	  fi
+	  continue
+	fi # $pass = conv
+
+
+	# Get the name of the library we link against.
+	linklib=
+	if test -n "$old_library" &&
+	   { test "$prefer_static_libs" = yes ||
+	     test "$prefer_static_libs,$installed" = "built,no"; }; then
+	  linklib=$old_library
+	else
+	  for l in $old_library $library_names; do
+	    linklib="$l"
+	  done
+	fi
+	if test -z "$linklib"; then
+	  func_fatal_error "cannot find name of link library for \`$lib'"
+	fi
+
+	# This library was specified with -dlopen.
+	if test "$pass" = dlopen; then
+	  if test -z "$libdir"; then
+	    func_fatal_error "cannot -dlopen a convenience library: \`$lib'"
+	  fi
+	  if test -z "$dlname" ||
+	     test "$dlopen_support" != yes ||
+	     test "$build_libtool_libs" = no; then
+	    # If there is no dlname, no dlopen support or we're linking
+	    # statically, we need to preload.  We also need to preload any
+	    # dependent libraries so libltdl's deplib preloader doesn't
+	    # bomb out in the load deplibs phase.
+	    func_append dlprefiles " $lib $dependency_libs"
+	  else
+	    func_append newdlfiles " $lib"
+	  fi
+	  continue
+	fi # $pass = dlopen
+
+	# We need an absolute path.
+	case $ladir in
+	[\\/]* | [A-Za-z]:[\\/]*) abs_ladir="$ladir" ;;
+	*)
+	  abs_ladir=`cd "$ladir" && pwd`
+	  if test -z "$abs_ladir"; then
+	    func_warning "cannot determine absolute directory name of \`$ladir'"
+	    func_warning "passing it literally to the linker, although it might fail"
+	    abs_ladir="$ladir"
+	  fi
+	  ;;
+	esac
+	func_basename "$lib"
+	laname="$func_basename_result"
+
+	# Find the relevant object directory and library name.
+	if test "X$installed" = Xyes; then
+	  if test ! -f "$lt_sysroot$libdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    func_warning "library \`$lib' was moved."
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    libdir="$abs_ladir"
+	  else
+	    dir="$lt_sysroot$libdir"
+	    absdir="$lt_sysroot$libdir"
+	  fi
+	  test "X$hardcode_automatic" = Xyes && avoidtemprpath=yes
+	else
+	  if test ! -f "$ladir/$objdir/$linklib" && test -f "$abs_ladir/$linklib"; then
+	    dir="$ladir"
+	    absdir="$abs_ladir"
+	    # Remove this search path later
+	    func_append notinst_path " $abs_ladir"
+	  else
+	    dir="$ladir/$objdir"
+	    absdir="$abs_ladir/$objdir"
+	    # Remove this search path later
+	    func_append notinst_path " $abs_ladir"
+	  fi
+	fi # $installed = yes
+	func_stripname 'lib' '.la' "$laname"
+	name=$func_stripname_result
+
+	# This library was specified with -dlpreopen.
+	if test "$pass" = dlpreopen; then
+	  if test -z "$libdir" && test "$linkmode" = prog; then
+	    func_fatal_error "only libraries may -dlpreopen a convenience library: \`$lib'"
+	  fi
+	  case "$host" in
+	    # special handling for platforms with PE-DLLs.
+	    *cygwin* | *mingw* | *cegcc* )
+	      # Linker will automatically link against shared library if both
+	      # static and shared are present.  Therefore, ensure we extract
+	      # symbols from the import library if a shared library is present
+	      # (otherwise, the dlopen module name will be incorrect).  We do
+	      # this by putting the import library name into $newdlprefiles.
+	      # We recover the dlopen module name by 'saving' the la file
+	      # name in a special purpose variable, and (later) extracting the
+	      # dlname from the la file.
+	      if test -n "$dlname"; then
+	        func_tr_sh "$dir/$linklib"
+	        eval "libfile_$func_tr_sh_result=\$abs_ladir/\$laname"
+	        func_append newdlprefiles " $dir/$linklib"
+	      else
+	        func_append newdlprefiles " $dir/$old_library"
+	        # Keep a list of preopened convenience libraries to check
+	        # that they are being used correctly in the link pass.
+	        test -z "$libdir" && \
+	          func_append dlpreconveniencelibs " $dir/$old_library"
+	      fi
+	    ;;
+	    * )
+	      # Prefer using a static library (so that no silly _DYNAMIC symbols
+	      # are required to link).
+	      if test -n "$old_library"; then
+	        func_append newdlprefiles " $dir/$old_library"
+	        # Keep a list of preopened convenience libraries to check
+	        # that they are being used correctly in the link pass.
+	        test -z "$libdir" && \
+	          func_append dlpreconveniencelibs " $dir/$old_library"
+	      # Otherwise, use the dlname, so that lt_dlopen finds it.
+	      elif test -n "$dlname"; then
+	        func_append newdlprefiles " $dir/$dlname"
+	      else
+	        func_append newdlprefiles " $dir/$linklib"
+	      fi
+	    ;;
+	  esac
+	fi # $pass = dlpreopen
+
+	if test -z "$libdir"; then
+	  # Link the convenience library
+	  if test "$linkmode" = lib; then
+	    deplibs="$dir/$old_library $deplibs"
+	  elif test "$linkmode,$pass" = "prog,link"; then
+	    compile_deplibs="$dir/$old_library $compile_deplibs"
+	    finalize_deplibs="$dir/$old_library $finalize_deplibs"
+	  else
+	    deplibs="$lib $deplibs" # used for prog,scan pass
+	  fi
+	  continue
+	fi
+
+
+	if test "$linkmode" = prog && test "$pass" != link; then
+	  func_append newlib_search_path " $ladir"
+	  deplibs="$lib $deplibs"
+
+	  linkalldeplibs=no
+	  if test "$link_all_deplibs" != no || test -z "$library_names" ||
+	     test "$build_libtool_libs" = no; then
+	    linkalldeplibs=yes
+	  fi
+
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    case $deplib in
+	    -L*) func_stripname '-L' '' "$deplib"
+	         func_resolve_sysroot "$func_stripname_result"
+	         func_append newlib_search_path " $func_resolve_sysroot_result"
+		 ;;
+	    esac
+	    # Need to link against all dependency_libs?
+	    if test "$linkalldeplibs" = yes; then
+	      deplibs="$deplib $deplibs"
+	    else
+	      # Need to hardcode shared library paths
+	      # or/and link against static libraries
+	      newdependency_libs="$deplib $newdependency_libs"
+	    fi
+	    if $opt_preserve_dup_deps ; then
+	      case "$tmp_libs " in
+	      *" $deplib "*) func_append specialdeplibs " $deplib" ;;
+	      esac
+	    fi
+	    func_append tmp_libs " $deplib"
+	  done # for deplib
+	  continue
+	fi # $linkmode = prog...
+
+	if test "$linkmode,$pass" = "prog,link"; then
+	  if test -n "$library_names" &&
+	     { { test "$prefer_static_libs" = no ||
+	         test "$prefer_static_libs,$installed" = "built,yes"; } ||
+	       test -z "$old_library"; }; then
+	    # We need to hardcode the library path
+	    if test -n "$shlibpath_var" && test -z "$avoidtemprpath" ; then
+	      # Make sure the rpath contains only unique directories.
+	      case "$temp_rpath:" in
+	      *"$absdir:"*) ;;
+	      *) func_append temp_rpath "$absdir:" ;;
+	      esac
+	    fi
+
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) func_append compile_rpath " $absdir" ;;
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) func_append finalize_rpath " $libdir" ;;
+	      esac
+	      ;;
+	    esac
+	  fi # $linkmode,$pass = prog,link...
+
+	  if test "$alldeplibs" = yes &&
+	     { test "$deplibs_check_method" = pass_all ||
+	       { test "$build_libtool_libs" = yes &&
+		 test -n "$library_names"; }; }; then
+	    # We only need to search for static libraries
+	    continue
+	  fi
+	fi
+
+	link_static=no # Whether the deplib will be linked statically
+	use_static_libs=$prefer_static_libs
+	if test "$use_static_libs" = built && test "$installed" = yes; then
+	  use_static_libs=no
+	fi
+	if test -n "$library_names" &&
+	   { test "$use_static_libs" = no || test -z "$old_library"; }; then
+	  case $host in
+	  *cygwin* | *mingw* | *cegcc*)
+	      # No point in relinking DLLs because paths are not encoded
+	      func_append notinst_deplibs " $lib"
+	      need_relink=no
+	    ;;
+	  *)
+	    if test "$installed" = no; then
+	      func_append notinst_deplibs " $lib"
+	      need_relink=yes
+	    fi
+	    ;;
+	  esac
+	  # This is a shared library
+
+	  # Warn about portability, can't link against -module's on some
+	  # systems (darwin).  Don't bleat about dlopened modules though!
+	  dlopenmodule=""
+	  for dlpremoduletest in $dlprefiles; do
+	    if test "X$dlpremoduletest" = "X$lib"; then
+	      dlopenmodule="$dlpremoduletest"
+	      break
+	    fi
+	  done
+	  if test -z "$dlopenmodule" && test "$shouldnotlink" = yes && test "$pass" = link; then
+	    echo
+	    if test "$linkmode" = prog; then
+	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
+	    else
+	      $ECHO "*** Warning: Linking the shared library $output against the loadable module"
+	    fi
+	    $ECHO "*** $linklib is not portable!"
+	  fi
+	  if test "$linkmode" = lib &&
+	     test "$hardcode_into_libs" = yes; then
+	    # Hardcode the library path.
+	    # Skip directories that are in the system default run-time
+	    # search path.
+	    case " $sys_lib_dlsearch_path " in
+	    *" $absdir "*) ;;
+	    *)
+	      case "$compile_rpath " in
+	      *" $absdir "*) ;;
+	      *) func_append compile_rpath " $absdir" ;;
+	      esac
+	      ;;
+	    esac
+	    case " $sys_lib_dlsearch_path " in
+	    *" $libdir "*) ;;
+	    *)
+	      case "$finalize_rpath " in
+	      *" $libdir "*) ;;
+	      *) func_append finalize_rpath " $libdir" ;;
+	      esac
+	      ;;
+	    esac
+	  fi
+
+	  if test -n "$old_archive_from_expsyms_cmds"; then
+	    # figure out the soname
+	    set dummy $library_names
+	    shift
+	    realname="$1"
+	    shift
+	    libname=`eval "\\$ECHO \"$libname_spec\""`
+	    # use dlname if we got it. it's perfectly good, no?
+	    if test -n "$dlname"; then
+	      soname="$dlname"
+	    elif test -n "$soname_spec"; then
+	      # bleh windows
+	      case $host in
+	      *cygwin* | mingw* | *cegcc*)
+	        func_arith $current - $age
+		major=$func_arith_result
+		versuffix="-$major"
+		;;
+	      esac
+	      eval soname=\"$soname_spec\"
+	    else
+	      soname="$realname"
+	    fi
+
+	    # Make a new name for the extract_expsyms_cmds to use
+	    soroot="$soname"
+	    func_basename "$soroot"
+	    soname="$func_basename_result"
+	    func_stripname 'lib' '.dll' "$soname"
+	    newlib=libimp-$func_stripname_result.a
+
+	    # If the library has no export list, then create one now
+	    if test -f "$output_objdir/$soname-def"; then :
+	    else
+	      func_verbose "extracting exported symbol list from \`$soname'"
+	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
+	    fi
+
+	    # Create $newlib
+	    if test -f "$output_objdir/$newlib"; then :; else
+	      func_verbose "generating import library for \`$soname'"
+	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
+	    fi
+	    # make sure the library variables are pointing to the new library
+	    dir=$output_objdir
+	    linklib=$newlib
+	  fi # test -n "$old_archive_from_expsyms_cmds"
+
+	  if test "$linkmode" = prog || test "$opt_mode" != relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    lib_linked=yes
+	    case $hardcode_action in
+	    immediate | unsupported)
+	      if test "$hardcode_direct" = no; then
+		add="$dir/$linklib"
+		case $host in
+		  *-*-sco3.2v5.0.[024]*) add_dir="-L$dir" ;;
+		  *-*-sysv4*uw2*) add_dir="-L$dir" ;;
+		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
+		    *-*-unixware7*) add_dir="-L$dir" ;;
+		  *-*-darwin* )
+		    # if the lib is a (non-dlopened) module then we can not
+		    # link against it, someone is ignoring the earlier warnings
+		    if /usr/bin/file -L $add 2> /dev/null |
+			 $GREP ": [^:]* bundle" >/dev/null ; then
+		      if test "X$dlopenmodule" != "X$lib"; then
+			$ECHO "*** Warning: lib $linklib is a module, not a shared library"
+			if test -z "$old_library" ; then
+			  echo
+			  echo "*** And there doesn't seem to be a static archive available"
+			  echo "*** The link will probably fail, sorry"
+			else
+			  add="$dir/$old_library"
+			fi
+		      elif test -n "$old_library"; then
+			add="$dir/$old_library"
+		      fi
+		    fi
+		esac
+	      elif test "$hardcode_minus_L" = no; then
+		case $host in
+		*-*-sunos*) add_shlibpath="$dir" ;;
+		esac
+		add_dir="-L$dir"
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = no; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    relink)
+	      if test "$hardcode_direct" = yes &&
+	         test "$hardcode_direct_absolute" = no; then
+		add="$dir/$linklib"
+	      elif test "$hardcode_minus_L" = yes; then
+		add_dir="-L$absdir"
+		# Try looking first in the location we're being installed to.
+		if test -n "$inst_prefix_dir"; then
+		  case $libdir in
+		    [\\/]*)
+		      func_append add_dir " -L$inst_prefix_dir$libdir"
+		      ;;
+		  esac
+		fi
+		add="-l$name"
+	      elif test "$hardcode_shlibpath_var" = yes; then
+		add_shlibpath="$dir"
+		add="-l$name"
+	      else
+		lib_linked=no
+	      fi
+	      ;;
+	    *) lib_linked=no ;;
+	    esac
+
+	    if test "$lib_linked" != yes; then
+	      func_fatal_configuration "unsupported hardcode properties"
+	    fi
+
+	    if test -n "$add_shlibpath"; then
+	      case :$compile_shlibpath: in
+	      *":$add_shlibpath:"*) ;;
+	      *) func_append compile_shlibpath "$add_shlibpath:" ;;
+	      esac
+	    fi
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && compile_deplibs="$add_dir $compile_deplibs"
+	      test -n "$add" && compile_deplibs="$add $compile_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	      if test "$hardcode_direct" != yes &&
+		 test "$hardcode_minus_L" != yes &&
+		 test "$hardcode_shlibpath_var" = yes; then
+		case :$finalize_shlibpath: in
+		*":$libdir:"*) ;;
+		*) func_append finalize_shlibpath "$libdir:" ;;
+		esac
+	      fi
+	    fi
+	  fi
+
+	  if test "$linkmode" = prog || test "$opt_mode" = relink; then
+	    add_shlibpath=
+	    add_dir=
+	    add=
+	    # Finalize command for both is simple: just hardcode it.
+	    if test "$hardcode_direct" = yes &&
+	       test "$hardcode_direct_absolute" = no; then
+	      add="$libdir/$linklib"
+	    elif test "$hardcode_minus_L" = yes; then
+	      add_dir="-L$libdir"
+	      add="-l$name"
+	    elif test "$hardcode_shlibpath_var" = yes; then
+	      case :$finalize_shlibpath: in
+	      *":$libdir:"*) ;;
+	      *) func_append finalize_shlibpath "$libdir:" ;;
+	      esac
+	      add="-l$name"
+	    elif test "$hardcode_automatic" = yes; then
+	      if test -n "$inst_prefix_dir" &&
+		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
+		add="$inst_prefix_dir$libdir/$linklib"
+	      else
+		add="$libdir/$linklib"
+	      fi
+	    else
+	      # We cannot seem to hardcode it, guess we'll fake it.
+	      add_dir="-L$libdir"
+	      # Try looking first in the location we're being installed to.
+	      if test -n "$inst_prefix_dir"; then
+		case $libdir in
+		  [\\/]*)
+		    func_append add_dir " -L$inst_prefix_dir$libdir"
+		    ;;
+		esac
+	      fi
+	      add="-l$name"
+	    fi
+
+	    if test "$linkmode" = prog; then
+	      test -n "$add_dir" && finalize_deplibs="$add_dir $finalize_deplibs"
+	      test -n "$add" && finalize_deplibs="$add $finalize_deplibs"
+	    else
+	      test -n "$add_dir" && deplibs="$add_dir $deplibs"
+	      test -n "$add" && deplibs="$add $deplibs"
+	    fi
+	  fi
+	elif test "$linkmode" = prog; then
+	  # Here we assume that one of hardcode_direct or hardcode_minus_L
+	  # is not unsupported.  This is valid on all known static and
+	  # shared platforms.
+	  if test "$hardcode_direct" != unsupported; then
+	    test -n "$old_library" && linklib="$old_library"
+	    compile_deplibs="$dir/$linklib $compile_deplibs"
+	    finalize_deplibs="$dir/$linklib $finalize_deplibs"
+	  else
+	    compile_deplibs="-l$name -L$dir $compile_deplibs"
+	    finalize_deplibs="-l$name -L$dir $finalize_deplibs"
+	  fi
+	elif test "$build_libtool_libs" = yes; then
+	  # Not a shared library
+	  if test "$deplibs_check_method" != pass_all; then
+	    # We're trying link a shared library against a static one
+	    # but the system doesn't support it.
+
+	    # Just print a warning and add the library to dependency_libs so
+	    # that the program can be linked against the static library.
+	    echo
+	    $ECHO "*** Warning: This system can not link to static lib archive $lib."
+	    echo "*** I have the capability to make that library automatically link in when"
+	    echo "*** you link to this library.  But I can only do this if you have a"
+	    echo "*** shared version of the library, which you do not appear to have."
+	    if test "$module" = yes; then
+	      echo "*** But as you try to build a module library, libtool will still create "
+	      echo "*** a static module, that should work as long as the dlopening application"
+	      echo "*** is linked with the -dlopen flag to resolve symbols at runtime."
+	      if test -z "$global_symbol_pipe"; then
+		echo
+		echo "*** However, this would only work if libtool was able to extract symbol"
+		echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+		echo "*** not find such a program.  So, this module is probably useless."
+		echo "*** \`nm' from GNU binutils and a full rebuild may help."
+	      fi
+	      if test "$build_old_libs" = no; then
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  else
+	    deplibs="$dir/$old_library $deplibs"
+	    link_static=yes
+	  fi
+	fi # link shared/static library?
+
+	if test "$linkmode" = lib; then
+	  if test -n "$dependency_libs" &&
+	     { test "$hardcode_into_libs" != yes ||
+	       test "$build_old_libs" = yes ||
+	       test "$link_static" = yes; }; then
+	    # Extract -R from dependency_libs
+	    temp_deplibs=
+	    for libdir in $dependency_libs; do
+	      case $libdir in
+	      -R*) func_stripname '-R' '' "$libdir"
+	           temp_xrpath=$func_stripname_result
+		   case " $xrpath " in
+		   *" $temp_xrpath "*) ;;
+		   *) func_append xrpath " $temp_xrpath";;
+		   esac;;
+	      *) func_append temp_deplibs " $libdir";;
+	      esac
+	    done
+	    dependency_libs="$temp_deplibs"
+	  fi
+
+	  func_append newlib_search_path " $absdir"
+	  # Link against this library
+	  test "$link_static" = no && newdependency_libs="$abs_ladir/$laname $newdependency_libs"
+	  # ... and its dependency_libs
+	  tmp_libs=
+	  for deplib in $dependency_libs; do
+	    newdependency_libs="$deplib $newdependency_libs"
+	    case $deplib in
+              -L*) func_stripname '-L' '' "$deplib"
+                   func_resolve_sysroot "$func_stripname_result";;
+              *) func_resolve_sysroot "$deplib" ;;
+            esac
+	    if $opt_preserve_dup_deps ; then
+	      case "$tmp_libs " in
+	      *" $func_resolve_sysroot_result "*)
+                func_append specialdeplibs " $func_resolve_sysroot_result" ;;
+	      esac
+	    fi
+	    func_append tmp_libs " $func_resolve_sysroot_result"
+	  done
+
+	  if test "$link_all_deplibs" != no; then
+	    # Add the search paths of all dependency libraries
+	    for deplib in $dependency_libs; do
+	      path=
+	      case $deplib in
+	      -L*) path="$deplib" ;;
+	      *.la)
+	        func_resolve_sysroot "$deplib"
+	        deplib=$func_resolve_sysroot_result
+	        func_dirname "$deplib" "" "."
+		dir=$func_dirname_result
+		# We need an absolute path.
+		case $dir in
+		[\\/]* | [A-Za-z]:[\\/]*) absdir="$dir" ;;
+		*)
+		  absdir=`cd "$dir" && pwd`
+		  if test -z "$absdir"; then
+		    func_warning "cannot determine absolute directory name of \`$dir'"
+		    absdir="$dir"
+		  fi
+		  ;;
+		esac
+		if $GREP "^installed=no" $deplib > /dev/null; then
+		case $host in
+		*-*-darwin*)
+		  depdepl=
+		  eval deplibrary_names=`${SED} -n -e 's/^library_names=\(.*\)$/\1/p' $deplib`
+		  if test -n "$deplibrary_names" ; then
+		    for tmp in $deplibrary_names ; do
+		      depdepl=$tmp
+		    done
+		    if test -f "$absdir/$objdir/$depdepl" ; then
+		      depdepl="$absdir/$objdir/$depdepl"
+		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
+                      if test -z "$darwin_install_name"; then
+                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
+                      fi
+		      func_append compiler_flags " ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}"
+		      func_append linker_flags " -dylib_file ${darwin_install_name}:${depdepl}"
+		      path=
+		    fi
+		  fi
+		  ;;
+		*)
+		  path="-L$absdir/$objdir"
+		  ;;
+		esac
+		else
+		  eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $deplib`
+		  test -z "$libdir" && \
+		    func_fatal_error "\`$deplib' is not a valid libtool archive"
+		  test "$absdir" != "$libdir" && \
+		    func_warning "\`$deplib' seems to be moved"
+
+		  path="-L$absdir"
+		fi
+		;;
+	      esac
+	      case " $deplibs " in
+	      *" $path "*) ;;
+	      *) deplibs="$path $deplibs" ;;
+	      esac
+	    done
+	  fi # link_all_deplibs != no
+	fi # linkmode = lib
+      done # for deplib in $libs
+      if test "$pass" = link; then
+	if test "$linkmode" = "prog"; then
+	  compile_deplibs="$new_inherited_linker_flags $compile_deplibs"
+	  finalize_deplibs="$new_inherited_linker_flags $finalize_deplibs"
+	else
+	  compiler_flags="$compiler_flags "`$ECHO " $new_inherited_linker_flags" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	fi
+      fi
+      dependency_libs="$newdependency_libs"
+      if test "$pass" = dlpreopen; then
+	# Link the dlpreopened libraries before other libraries
+	for deplib in $save_deplibs; do
+	  deplibs="$deplib $deplibs"
+	done
+      fi
+      if test "$pass" != dlopen; then
+	if test "$pass" != conv; then
+	  # Make sure lib_search_path contains only unique directories.
+	  lib_search_path=
+	  for dir in $newlib_search_path; do
+	    case "$lib_search_path " in
+	    *" $dir "*) ;;
+	    *) func_append lib_search_path " $dir" ;;
+	    esac
+	  done
+	  newlib_search_path=
+	fi
+
+	if test "$linkmode,$pass" != "prog,link"; then
+	  vars="deplibs"
+	else
+	  vars="compile_deplibs finalize_deplibs"
+	fi
+	for var in $vars dependency_libs; do
+	  # Add libraries to $var in reverse order
+	  eval tmp_libs=\"\$$var\"
+	  new_libs=
+	  for deplib in $tmp_libs; do
+	    # FIXME: Pedantically, this is the right thing to do, so
+	    #        that some nasty dependency loop isn't accidentally
+	    #        broken:
+	    #new_libs="$deplib $new_libs"
+	    # Pragmatically, this seems to cause very few problems in
+	    # practice:
+	    case $deplib in
+	    -L*) new_libs="$deplib $new_libs" ;;
+	    -R*) ;;
+	    *)
+	      # And here is the reason: when a library appears more
+	      # than once as an explicit dependence of a library, or
+	      # is implicitly linked in more than once by the
+	      # compiler, it is considered special, and multiple
+	      # occurrences thereof are not removed.  Compare this
+	      # with having the same library being listed as a
+	      # dependency of multiple other libraries: in this case,
+	      # we know (pedantically, we assume) the library does not
+	      # need to be listed more than once, so we keep only the
+	      # last copy.  This is not always right, but it is rare
+	      # enough that we require users that really mean to play
+	      # such unportable linking tricks to link the library
+	      # using -Wl,-lname, so that libtool does not consider it
+	      # for duplicate removal.
+	      case " $specialdeplibs " in
+	      *" $deplib "*) new_libs="$deplib $new_libs" ;;
+	      *)
+		case " $new_libs " in
+		*" $deplib "*) ;;
+		*) new_libs="$deplib $new_libs" ;;
+		esac
+		;;
+	      esac
+	      ;;
+	    esac
+	  done
+	  tmp_libs=
+	  for deplib in $new_libs; do
+	    case $deplib in
+	    -L*)
+	      case " $tmp_libs " in
+	      *" $deplib "*) ;;
+	      *) func_append tmp_libs " $deplib" ;;
+	      esac
+	      ;;
+	    *) func_append tmp_libs " $deplib" ;;
+	    esac
+	  done
+	  eval $var=\"$tmp_libs\"
+	done # for var
+      fi
+      # Last step: remove runtime libs from dependency_libs
+      # (they stay in deplibs)
+      tmp_libs=
+      for i in $dependency_libs ; do
+	case " $predeps $postdeps $compiler_lib_search_path " in
+	*" $i "*)
+	  i=""
+	  ;;
+	esac
+	if test -n "$i" ; then
+	  func_append tmp_libs " $i"
+	fi
+      done
+      dependency_libs=$tmp_libs
+    done # for pass
+    if test "$linkmode" = prog; then
+      dlfiles="$newdlfiles"
+    fi
+    if test "$linkmode" = prog || test "$linkmode" = lib; then
+      dlprefiles="$newdlprefiles"
+    fi
+
+    case $linkmode in
+    oldlib)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for archives"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for archives" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for archives"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for archives"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info/-version-number' is ignored for archives"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for archives"
+
+      test -n "$export_symbols$export_symbols_regex" && \
+	func_warning "\`-export-symbols' is ignored for archives"
+
+      # Now set the variables for building old libraries.
+      build_libtool_libs=no
+      oldlibs="$output"
+      func_append objs "$old_deplibs"
+      ;;
+
+    lib)
+      # Make sure we only generate libraries of the form `libNAME.la'.
+      case $outputname in
+      lib*)
+	func_stripname 'lib' '.la' "$outputname"
+	name=$func_stripname_result
+	eval shared_ext=\"$shrext_cmds\"
+	eval libname=\"$libname_spec\"
+	;;
+      *)
+	test "$module" = no && \
+	  func_fatal_help "libtool library \`$output' must begin with \`lib'"
+
+	if test "$need_lib_prefix" != no; then
+	  # Add the "lib" prefix for modules if required
+	  func_stripname '' '.la' "$outputname"
+	  name=$func_stripname_result
+	  eval shared_ext=\"$shrext_cmds\"
+	  eval libname=\"$libname_spec\"
+	else
+	  func_stripname '' '.la' "$outputname"
+	  libname=$func_stripname_result
+	fi
+	;;
+      esac
+
+      if test -n "$objs"; then
+	if test "$deplibs_check_method" != pass_all; then
+	  func_fatal_error "cannot build libtool library \`$output' from non-libtool objects on this host:$objs"
+	else
+	  echo
+	  $ECHO "*** Warning: Linking the shared library $output against the non-libtool"
+	  $ECHO "*** objects $objs is not portable!"
+	  func_append libobjs " $objs"
+	fi
+      fi
+
+      test "$dlself" != no && \
+	func_warning "\`-dlopen self' is ignored for libtool libraries"
+
+      set dummy $rpath
+      shift
+      test "$#" -gt 1 && \
+	func_warning "ignoring multiple \`-rpath's for a libtool library"
+
+      install_libdir="$1"
+
+      oldlibs=
+      if test -z "$rpath"; then
+	if test "$build_libtool_libs" = yes; then
+	  # Building a libtool convenience library.
+	  # Some compilers have problems with a `.al' extension so
+	  # convenience libraries should have the same extension an
+	  # archive normally would.
+	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
+	  build_libtool_libs=convenience
+	  build_old_libs=yes
+	fi
+
+	test -n "$vinfo" && \
+	  func_warning "\`-version-info/-version-number' is ignored for convenience libraries"
+
+	test -n "$release" && \
+	  func_warning "\`-release' is ignored for convenience libraries"
+      else
+
+	# Parse the version information argument.
+	save_ifs="$IFS"; IFS=':'
+	set dummy $vinfo 0 0 0
+	shift
+	IFS="$save_ifs"
+
+	test -n "$7" && \
+	  func_fatal_help "too many parameters to \`-version-info'"
+
+	# convert absolute version numbers to libtool ages
+	# this retains compatibility with .la files and attempts
+	# to make the code below a bit more comprehensible
+
+	case $vinfo_number in
+	yes)
+	  number_major="$1"
+	  number_minor="$2"
+	  number_revision="$3"
+	  #
+	  # There are really only two kinds -- those that
+	  # use the current revision as the major version
+	  # and those that subtract age and use age as
+	  # a minor version.  But, then there is irix
+	  # which has an extra 1 added just for fun
+	  #
+	  case $version_type in
+	  # correct linux to gnu/linux during the next big refactor
+	  darwin|linux|osf|windows|none)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_revision"
+	    ;;
+	  freebsd-aout|freebsd-elf|qnx|sunos)
+	    current="$number_major"
+	    revision="$number_minor"
+	    age="0"
+	    ;;
+	  irix|nonstopux)
+	    func_arith $number_major + $number_minor
+	    current=$func_arith_result
+	    age="$number_minor"
+	    revision="$number_minor"
+	    lt_irix_increment=no
+	    ;;
+	  *)
+	    func_fatal_configuration "$modename: unknown library version type \`$version_type'"
+	    ;;
+	  esac
+	  ;;
+	no)
+	  current="$1"
+	  revision="$2"
+	  age="$3"
+	  ;;
+	esac
+
+	# Check that each of the things are valid numbers.
+	case $current in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "CURRENT \`$current' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $revision in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "REVISION \`$revision' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	case $age in
+	0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;
+	*)
+	  func_error "AGE \`$age' must be a nonnegative integer"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	  ;;
+	esac
+
+	if test "$age" -gt "$current"; then
+	  func_error "AGE \`$age' is greater than the current interface number \`$current'"
+	  func_fatal_error "\`$vinfo' is not valid version information"
+	fi
+
+	# Calculate the version variables.
+	major=
+	versuffix=
+	verstring=
+	case $version_type in
+	none) ;;
+
+	darwin)
+	  # Like Linux, but with the current version available in
+	  # verstring for coding it into the library header
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  # Darwin ld doesn't like 0 for these options...
+	  func_arith $current + 1
+	  minor_current=$func_arith_result
+	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
+	  verstring="-compatibility_version $minor_current -current_version $minor_current.$revision"
+	  ;;
+
+	freebsd-aout)
+	  major=".$current"
+	  versuffix=".$current.$revision";
+	  ;;
+
+	freebsd-elf)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	irix | nonstopux)
+	  if test "X$lt_irix_increment" = "Xno"; then
+	    func_arith $current - $age
+	  else
+	    func_arith $current - $age + 1
+	  fi
+	  major=$func_arith_result
+
+	  case $version_type in
+	    nonstopux) verstring_prefix=nonstopux ;;
+	    *)         verstring_prefix=sgi ;;
+	  esac
+	  verstring="$verstring_prefix$major.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$revision
+	  while test "$loop" -ne 0; do
+	    func_arith $revision - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring_prefix$major.$iface:$verstring"
+	  done
+
+	  # Before this point, $major must not contain `.'.
+	  major=.$major
+	  versuffix="$major.$revision"
+	  ;;
+
+	linux) # correct to gnu/linux during the next big refactor
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix="$major.$age.$revision"
+	  ;;
+
+	osf)
+	  func_arith $current - $age
+	  major=.$func_arith_result
+	  versuffix=".$current.$age.$revision"
+	  verstring="$current.$age.$revision"
+
+	  # Add in all the interfaces that we are compatible with.
+	  loop=$age
+	  while test "$loop" -ne 0; do
+	    func_arith $current - $loop
+	    iface=$func_arith_result
+	    func_arith $loop - 1
+	    loop=$func_arith_result
+	    verstring="$verstring:${iface}.0"
+	  done
+
+	  # Make executables depend on our current version.
+	  func_append verstring ":${current}.0"
+	  ;;
+
+	qnx)
+	  major=".$current"
+	  versuffix=".$current"
+	  ;;
+
+	sunos)
+	  major=".$current"
+	  versuffix=".$current.$revision"
+	  ;;
+
+	windows)
+	  # Use '-' rather than '.', since we only want one
+	  # extension on DOS 8.3 filesystems.
+	  func_arith $current - $age
+	  major=$func_arith_result
+	  versuffix="-$major"
+	  ;;
+
+	*)
+	  func_fatal_configuration "unknown library version type \`$version_type'"
+	  ;;
+	esac
+
+	# Clear the version info if we defaulted, and they specified a release.
+	if test -z "$vinfo" && test -n "$release"; then
+	  major=
+	  case $version_type in
+	  darwin)
+	    # we can't check for "0.0" in archive_cmds due to quoting
+	    # problems, so we reset it completely
+	    verstring=
+	    ;;
+	  *)
+	    verstring="0.0"
+	    ;;
+	  esac
+	  if test "$need_version" = no; then
+	    versuffix=
+	  else
+	    versuffix=".0.0"
+	  fi
+	fi
+
+	# Remove version info from name if versioning should be avoided
+	if test "$avoid_version" = yes && test "$need_version" = no; then
+	  major=
+	  versuffix=
+	  verstring=""
+	fi
+
+	# Check to see if the archive will have undefined symbols.
+	if test "$allow_undefined" = yes; then
+	  if test "$allow_undefined_flag" = unsupported; then
+	    func_warning "undefined symbols not allowed in $host shared libraries"
+	    build_libtool_libs=no
+	    build_old_libs=yes
+	  fi
+	else
+	  # Don't allow undefined symbols.
+	  allow_undefined_flag="$no_undefined_flag"
+	fi
+
+      fi
+
+      func_generate_dlsyms "$libname" "$libname" "yes"
+      func_append libobjs " $symfileobj"
+      test "X$libobjs" = "X " && libobjs=
+
+      if test "$opt_mode" != relink; then
+	# Remove our outputs, but don't remove object files since they
+	# may have been created when compiling PIC objects.
+	removelist=
+	tempremovelist=`$ECHO "$output_objdir/*"`
+	for p in $tempremovelist; do
+	  case $p in
+	    *.$objext | *.gcno)
+	       ;;
+	    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)
+	       if test "X$precious_files_regex" != "X"; then
+		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
+		 then
+		   continue
+		 fi
+	       fi
+	       func_append removelist " $p"
+	       ;;
+	    *) ;;
+	  esac
+	done
+	test -n "$removelist" && \
+	  func_show_eval "${RM}r \$removelist"
+      fi
+
+      # Now set the variables for building old libraries.
+      if test "$build_old_libs" = yes && test "$build_libtool_libs" != convenience ; then
+	func_append oldlibs " $output_objdir/$libname.$libext"
+
+	# Transform .lo files to .o files.
+	oldobjs="$objs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; $lo2o" | $NL2SP`
+      fi
+
+      # Eliminate all temporary directories.
+      #for path in $notinst_path; do
+      #	lib_search_path=`$ECHO "$lib_search_path " | $SED "s% $path % %g"`
+      #	deplibs=`$ECHO "$deplibs " | $SED "s% -L$path % %g"`
+      #	dependency_libs=`$ECHO "$dependency_libs " | $SED "s% -L$path % %g"`
+      #done
+
+      if test -n "$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	temp_xrpath=
+	for libdir in $xrpath; do
+	  func_replace_sysroot "$libdir"
+	  func_append temp_xrpath " -R$func_replace_sysroot_result"
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) func_append finalize_rpath " $libdir" ;;
+	  esac
+	done
+	if test "$hardcode_into_libs" != yes || test "$build_old_libs" = yes; then
+	  dependency_libs="$temp_xrpath $dependency_libs"
+	fi
+      fi
+
+      # Make sure dlfiles contains only unique files that won't be dlpreopened
+      old_dlfiles="$dlfiles"
+      dlfiles=
+      for lib in $old_dlfiles; do
+	case " $dlprefiles $dlfiles " in
+	*" $lib "*) ;;
+	*) func_append dlfiles " $lib" ;;
+	esac
+      done
+
+      # Make sure dlprefiles contains only unique files
+      old_dlprefiles="$dlprefiles"
+      dlprefiles=
+      for lib in $old_dlprefiles; do
+	case "$dlprefiles " in
+	*" $lib "*) ;;
+	*) func_append dlprefiles " $lib" ;;
+	esac
+      done
+
+      if test "$build_libtool_libs" = yes; then
+	if test -n "$rpath"; then
+	  case $host in
+	  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)
+	    # these systems don't actually have a c library (as such)!
+	    ;;
+	  *-*-rhapsody* | *-*-darwin1.[012])
+	    # Rhapsody C library is in the System framework
+	    func_append deplibs " System.ltframework"
+	    ;;
+	  *-*-netbsd*)
+	    # Don't link with libc until the a.out ld.so is fixed.
+	    ;;
+	  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)
+	    # Do not include libc due to us having libc/libc_r.
+	    ;;
+	  *-*-sco3.2v5* | *-*-sco5v6*)
+	    # Causes problems with __ctype
+	    ;;
+	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
+	    # Compiler inserts libc in the correct place for threads to work
+	    ;;
+	  *)
+	    # Add libc to deplibs on all other systems if necessary.
+	    if test "$build_libtool_need_lc" = "yes"; then
+	      func_append deplibs " -lc"
+	    fi
+	    ;;
+	  esac
+	fi
+
+	# Transform deplibs into only deplibs that can be linked in shared.
+	name_save=$name
+	libname_save=$libname
+	release_save=$release
+	versuffix_save=$versuffix
+	major_save=$major
+	# I'm not sure if I'm treating the release correctly.  I think
+	# release should show up in the -l (ie -lgmp5) so we don't want to
+	# add it in twice.  Is that correct?
+	release=""
+	versuffix=""
+	major=""
+	newdeplibs=
+	droppeddeps=no
+	case $deplibs_check_method in
+	pass_all)
+	  # Don't check for shared/static.  Everything works.
+	  # This might be a little naive.  We might want to check
+	  # whether the library exists or not.  But this is on
+	  # osf3 & osf4 and I'm not really sure... Just
+	  # implementing what was already the behavior.
+	  newdeplibs=$deplibs
+	  ;;
+	test_compile)
+	  # This code stresses the "libraries are programs" paradigm to its
+	  # limits. Maybe even breaks it.  We compile a program, linking it
+	  # against the deplibs as a proxy for the library.  Then we can check
+	  # whether they linked in statically or dynamically with ldd.
+	  $opt_dry_run || $RM conftest.c
+	  cat > conftest.c <<EOF
+	  int main() { return 0; }
+EOF
+	  $opt_dry_run || $RM conftest
+	  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then
+	    ldd_output=`ldd conftest`
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		  case " $predeps $postdeps " in
+		  *" $i "*)
+		    func_append newdeplibs " $i"
+		    i=""
+		    ;;
+		  esac
+		fi
+		if test -n "$i" ; then
+		  libname=`eval "\\$ECHO \"$libname_spec\""`
+		  deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		  set dummy $deplib_matches; shift
+		  deplib_match=$1
+		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		    func_append newdeplibs " $i"
+		  else
+		    droppeddeps=yes
+		    echo
+		    $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		    echo "*** I have the capability to make that library automatically link in when"
+		    echo "*** you link to this library.  But I can only do this if you have a"
+		    echo "*** shared version of the library, which I believe you do not have"
+		    echo "*** because a test_compile did reveal that the linker did not use it for"
+		    echo "*** its dynamic dependency list that programs get resolved with at runtime."
+		  fi
+		fi
+		;;
+	      *)
+		func_append newdeplibs " $i"
+		;;
+	      esac
+	    done
+	  else
+	    # Error occurred in the first compile.  Let's try to salvage
+	    # the situation: Compile a separate program for each library.
+	    for i in $deplibs; do
+	      case $i in
+	      -l*)
+		func_stripname -l '' "$i"
+		name=$func_stripname_result
+		$opt_dry_run || $RM conftest
+		if $LTCC $LTCFLAGS -o conftest conftest.c $i; then
+		  ldd_output=`ldd conftest`
+		  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		    case " $predeps $postdeps " in
+		    *" $i "*)
+		      func_append newdeplibs " $i"
+		      i=""
+		      ;;
+		    esac
+		  fi
+		  if test -n "$i" ; then
+		    libname=`eval "\\$ECHO \"$libname_spec\""`
+		    deplib_matches=`eval "\\$ECHO \"$library_names_spec\""`
+		    set dummy $deplib_matches; shift
+		    deplib_match=$1
+		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
+		      func_append newdeplibs " $i"
+		    else
+		      droppeddeps=yes
+		      echo
+		      $ECHO "*** Warning: dynamic linker does not accept needed library $i."
+		      echo "*** I have the capability to make that library automatically link in when"
+		      echo "*** you link to this library.  But I can only do this if you have a"
+		      echo "*** shared version of the library, which you do not appear to have"
+		      echo "*** because a test_compile did reveal that the linker did not use this one"
+		      echo "*** as a dynamic dependency that programs can get resolved with at runtime."
+		    fi
+		  fi
+		else
+		  droppeddeps=yes
+		  echo
+		  $ECHO "*** Warning!  Library $i is needed by this library but I was not able to"
+		  echo "*** make it link in!  You will probably need to install it or some"
+		  echo "*** library that it depends on before this library will be fully"
+		  echo "*** functional.  Installing it before continuing would be even better."
+		fi
+		;;
+	      *)
+		func_append newdeplibs " $i"
+		;;
+	      esac
+	    done
+	  fi
+	  ;;
+	file_magic*)
+	  set dummy $deplibs_check_method; shift
+	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  func_append newdeplibs " $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		if test -n "$file_magic_glob"; then
+		  libnameglob=`func_echo_all "$libname" | $SED -e $file_magic_glob`
+		else
+		  libnameglob=$libname
+		fi
+		test "$want_nocaseglob" = yes && nocaseglob=`shopt -p nocaseglob`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  if test "$want_nocaseglob" = yes; then
+		    shopt -s nocaseglob
+		    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`
+		    $nocaseglob
+		  else
+		    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`
+		  fi
+		  for potent_lib in $potential_libs; do
+		      # Follow soft links.
+		      if ls -lLd "$potent_lib" 2>/dev/null |
+			 $GREP " -> " >/dev/null; then
+			continue
+		      fi
+		      # The statement above tries to avoid entering an
+		      # endless loop below, in case of cyclic links.
+		      # We might still enter an endless loop, since a link
+		      # loop can be closed while we follow links,
+		      # but so what?
+		      potlib="$potent_lib"
+		      while test -h "$potlib" 2>/dev/null; do
+			potliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`
+			case $potliblink in
+			[\\/]* | [A-Za-z]:[\\/]*) potlib="$potliblink";;
+			*) potlib=`$ECHO "$potlib" | $SED 's,[^/]*$,,'`"$potliblink";;
+			esac
+		      done
+		      if eval $file_magic_cmd \"\$potlib\" 2>/dev/null |
+			 $SED -e 10q |
+			 $EGREP "$file_magic_regex" > /dev/null; then
+			func_append newdeplibs " $a_deplib"
+			a_deplib=""
+			break 2
+		      fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		echo
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		echo "*** I have the capability to make that library automatically link in when"
+		echo "*** you link to this library.  But I can only do this if you have a"
+		echo "*** shared version of the library, which you do not appear to have"
+		echo "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for file magic test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a file magic. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      func_append newdeplibs " $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	match_pattern*)
+	  set dummy $deplibs_check_method; shift
+	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
+	  for a_deplib in $deplibs; do
+	    case $a_deplib in
+	    -l*)
+	      func_stripname -l '' "$a_deplib"
+	      name=$func_stripname_result
+	      if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+		case " $predeps $postdeps " in
+		*" $a_deplib "*)
+		  func_append newdeplibs " $a_deplib"
+		  a_deplib=""
+		  ;;
+		esac
+	      fi
+	      if test -n "$a_deplib" ; then
+		libname=`eval "\\$ECHO \"$libname_spec\""`
+		for i in $lib_search_path $sys_lib_search_path $shlib_search_path; do
+		  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`
+		  for potent_lib in $potential_libs; do
+		    potlib="$potent_lib" # see symlink-check above in file_magic test
+		    if eval "\$ECHO \"$potent_lib\"" 2>/dev/null | $SED 10q | \
+		       $EGREP "$match_pattern_regex" > /dev/null; then
+		      func_append newdeplibs " $a_deplib"
+		      a_deplib=""
+		      break 2
+		    fi
+		  done
+		done
+	      fi
+	      if test -n "$a_deplib" ; then
+		droppeddeps=yes
+		echo
+		$ECHO "*** Warning: linker path does not have real file for library $a_deplib."
+		echo "*** I have the capability to make that library automatically link in when"
+		echo "*** you link to this library.  But I can only do this if you have a"
+		echo "*** shared version of the library, which you do not appear to have"
+		echo "*** because I did check the linker path looking for a file starting"
+		if test -z "$potlib" ; then
+		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
+		else
+		  $ECHO "*** with $libname and none of the candidates passed a file format test"
+		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
+		fi
+	      fi
+	      ;;
+	    *)
+	      # Add a -L argument.
+	      func_append newdeplibs " $a_deplib"
+	      ;;
+	    esac
+	  done # Gone through all deplibs.
+	  ;;
+	none | unknown | *)
+	  newdeplibs=""
+	  tmp_deplibs=`$ECHO " $deplibs" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`
+	  if test "X$allow_libtool_libs_with_static_runtimes" = "Xyes" ; then
+	    for i in $predeps $postdeps ; do
+	      # can't use Xsed below, because $i might contain '/'
+	      tmp_deplibs=`$ECHO " $tmp_deplibs" | $SED "s,$i,,"`
+	    done
+	  fi
+	  case $tmp_deplibs in
+	  *[!\	\ ]*)
+	    echo
+	    if test "X$deplibs_check_method" = "Xnone"; then
+	      echo "*** Warning: inter-library dependencies are not supported in this platform."
+	    else
+	      echo "*** Warning: inter-library dependencies are not known to be supported."
+	    fi
+	    echo "*** All declared inter-library dependencies are being dropped."
+	    droppeddeps=yes
+	    ;;
+	  esac
+	  ;;
+	esac
+	versuffix=$versuffix_save
+	major=$major_save
+	release=$release_save
+	libname=$libname_save
+	name=$name_save
+
+	case $host in
+	*-*-rhapsody* | *-*-darwin1.[012])
+	  # On Rhapsody replace the C library with the System framework
+	  newdeplibs=`$ECHO " $newdeplibs" | $SED 's/ -lc / System.ltframework /'`
+	  ;;
+	esac
+
+	if test "$droppeddeps" = yes; then
+	  if test "$module" = yes; then
+	    echo
+	    echo "*** Warning: libtool could not satisfy all declared inter-library"
+	    $ECHO "*** dependencies of module $libname.  Therefore, libtool will create"
+	    echo "*** a static module, that should work as long as the dlopening"
+	    echo "*** application is linked with the -dlopen flag."
+	    if test -z "$global_symbol_pipe"; then
+	      echo
+	      echo "*** However, this would only work if libtool was able to extract symbol"
+	      echo "*** lists from a program, using \`nm' or equivalent, but libtool could"
+	      echo "*** not find such a program.  So, this module is probably useless."
+	      echo "*** \`nm' from GNU binutils and a full rebuild may help."
+	    fi
+	    if test "$build_old_libs" = no; then
+	      oldlibs="$output_objdir/$libname.$libext"
+	      build_libtool_libs=module
+	      build_old_libs=yes
+	    else
+	      build_libtool_libs=no
+	    fi
+	  else
+	    echo "*** The inter-library dependencies that have been dropped here will be"
+	    echo "*** automatically added whenever a program is linked with this library"
+	    echo "*** or is declared to -dlopen it."
+
+	    if test "$allow_undefined" = no; then
+	      echo
+	      echo "*** Since this library must not contain undefined symbols,"
+	      echo "*** because either the platform does not support them or"
+	      echo "*** it was explicitly requested with -no-undefined,"
+	      echo "*** libtool will only create a static version of it."
+	      if test "$build_old_libs" = no; then
+		oldlibs="$output_objdir/$libname.$libext"
+		build_libtool_libs=module
+		build_old_libs=yes
+	      else
+		build_libtool_libs=no
+	      fi
+	    fi
+	  fi
+	fi
+	# Done checking deplibs!
+	deplibs=$newdeplibs
+      fi
+      # Time to change all our "foo.ltframework" stuff back to "-framework foo"
+      case $host in
+	*-*-darwin*)
+	  newdeplibs=`$ECHO " $newdeplibs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  new_inherited_linker_flags=`$ECHO " $new_inherited_linker_flags" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  deplibs=`$ECHO " $deplibs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	  ;;
+      esac
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $deplibs " in
+	  *" -L$path/$objdir "*)
+	    func_append new_libs " -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) func_append new_libs " $deplib" ;;
+	  esac
+	  ;;
+	*) func_append new_libs " $deplib" ;;
+	esac
+      done
+      deplibs="$new_libs"
+
+      # All the library-specific variables (install_libdir is set above).
+      library_names=
+      old_library=
+      dlname=
+
+      # Test again, we may have decided not to build it any more
+      if test "$build_libtool_libs" = yes; then
+	# Remove ${wl} instances when linking with ld.
+	# FIXME: should test the right _cmds variable.
+	case $archive_cmds in
+	  *\$LD\ *) wl= ;;
+        esac
+	if test "$hardcode_into_libs" = yes; then
+	  # Hardcode the library paths
+	  hardcode_libdirs=
+	  dep_rpath=
+	  rpath="$finalize_rpath"
+	  test "$opt_mode" != relink && rpath="$compile_rpath$rpath"
+	  for libdir in $rpath; do
+	    if test -n "$hardcode_libdir_flag_spec"; then
+	      if test -n "$hardcode_libdir_separator"; then
+		func_replace_sysroot "$libdir"
+		libdir=$func_replace_sysroot_result
+		if test -z "$hardcode_libdirs"; then
+		  hardcode_libdirs="$libdir"
+		else
+		  # Just accumulate the unique libdirs.
+		  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+		  *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		    ;;
+		  *)
+		    func_append hardcode_libdirs "$hardcode_libdir_separator$libdir"
+		    ;;
+		  esac
+		fi
+	      else
+		eval flag=\"$hardcode_libdir_flag_spec\"
+		func_append dep_rpath " $flag"
+	      fi
+	    elif test -n "$runpath_var"; then
+	      case "$perm_rpath " in
+	      *" $libdir "*) ;;
+	      *) func_append perm_rpath " $libdir" ;;
+	      esac
+	    fi
+	  done
+	  # Substitute the hardcoded libdirs into the rpath.
+	  if test -n "$hardcode_libdir_separator" &&
+	     test -n "$hardcode_libdirs"; then
+	    libdir="$hardcode_libdirs"
+	    eval "dep_rpath=\"$hardcode_libdir_flag_spec\""
+	  fi
+	  if test -n "$runpath_var" && test -n "$perm_rpath"; then
+	    # We should set the runpath_var.
+	    rpath=
+	    for dir in $perm_rpath; do
+	      func_append rpath "$dir:"
+	    done
+	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
+	  fi
+	  test -n "$dep_rpath" && deplibs="$dep_rpath $deplibs"
+	fi
+
+	shlibpath="$finalize_shlibpath"
+	test "$opt_mode" != relink && shlibpath="$compile_shlibpath$shlibpath"
+	if test -n "$shlibpath"; then
+	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
+	fi
+
+	# Get the real and link names of the library.
+	eval shared_ext=\"$shrext_cmds\"
+	eval library_names=\"$library_names_spec\"
+	set dummy $library_names
+	shift
+	realname="$1"
+	shift
+
+	if test -n "$soname_spec"; then
+	  eval soname=\"$soname_spec\"
+	else
+	  soname="$realname"
+	fi
+	if test -z "$dlname"; then
+	  dlname=$soname
+	fi
+
+	lib="$output_objdir/$realname"
+	linknames=
+	for link
+	do
+	  func_append linknames " $link"
+	done
+
+	# Use standard objects if they are pic
+	test -z "$pic_flag" && libobjs=`$ECHO "$libobjs" | $SP2NL | $SED "$lo2o" | $NL2SP`
+	test "X$libobjs" = "X " && libobjs=
+
+	delfiles=
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
+	  export_symbols="$output_objdir/$libname.uexp"
+	  func_append delfiles " $export_symbols"
+	fi
+
+	orig_export_symbols=
+	case $host_os in
+	cygwin* | mingw* | cegcc*)
+	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
+	    # exporting using user supplied symfile
+	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
+	      # and it's NOT already a .def file. Must figure out
+	      # which of the given symbols are data symbols and tag
+	      # them as such. So, trigger use of export_symbols_cmds.
+	      # export_symbols gets reassigned inside the "prepare
+	      # the list of exported symbols" if statement, so the
+	      # include_expsyms logic still works.
+	      orig_export_symbols="$export_symbols"
+	      export_symbols=
+	      always_export_symbols=yes
+	    fi
+	  fi
+	  ;;
+	esac
+
+	# Prepare the list of exported symbols
+	if test -z "$export_symbols"; then
+	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
+	    func_verbose "generating symbol list for \`$libname.la'"
+	    export_symbols="$output_objdir/$libname.exp"
+	    $opt_dry_run || $RM $export_symbols
+	    cmds=$export_symbols_cmds
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd1 in $cmds; do
+	      IFS="$save_ifs"
+	      # Take the normal branch if the nm_file_list_spec branch
+	      # doesn't work or if tool conversion is not needed.
+	      case $nm_file_list_spec~$to_tool_file_cmd in
+		*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)
+		  try_normal_branch=yes
+		  eval cmd=\"$cmd1\"
+		  func_len " $cmd"
+		  len=$func_len_result
+		  ;;
+		*)
+		  try_normal_branch=no
+		  ;;
+	      esac
+	      if test "$try_normal_branch" = yes \
+		 && { test "$len" -lt "$max_cmd_len" \
+		      || test "$max_cmd_len" -le -1; }
+	      then
+		func_show_eval "$cmd" 'exit $?'
+		skipped_export=false
+	      elif test -n "$nm_file_list_spec"; then
+		func_basename "$output"
+		output_la=$func_basename_result
+		save_libobjs=$libobjs
+		save_output=$output
+		output=${output_objdir}/${output_la}.nm
+		func_to_tool_file "$output"
+		libobjs=$nm_file_list_spec$func_to_tool_file_result
+		func_append delfiles " $output"
+		func_verbose "creating $NM input file list: $output"
+		for obj in $save_libobjs; do
+		  func_to_tool_file "$obj"
+		  $ECHO "$func_to_tool_file_result"
+		done > "$output"
+		eval cmd=\"$cmd1\"
+		func_show_eval "$cmd" 'exit $?'
+		output=$save_output
+		libobjs=$save_libobjs
+		skipped_export=false
+	      else
+		# The command line is too long to execute in one step.
+		func_verbose "using reloadable object file for export list..."
+		skipped_export=:
+		# Break out early, otherwise skipped_export may be
+		# set to false by a later but shorter cmd.
+		break
+	      fi
+	    done
+	    IFS="$save_ifs"
+	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+	fi
+
+	if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	  tmp_export_symbols="$export_symbols"
+	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	  $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
+	fi
+
+	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
+	  # The given exports_symbols file has to be filtered, so filter it.
+	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	  # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	  # 's' commands which not all seds can handle. GNU sed should be fine
+	  # though. Also, the filter scales superlinearly with the number of
+	  # global variables. join(1) would be nice here, but unfortunately
+	  # isn't a blessed tool.
+	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	  func_append delfiles " $export_symbols $output_objdir/$libname.filter"
+	  export_symbols=$output_objdir/$libname.def
+	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	fi
+
+	tmp_deplibs=
+	for test_deplib in $deplibs; do
+	  case " $convenience " in
+	  *" $test_deplib "*) ;;
+	  *)
+	    func_append tmp_deplibs " $test_deplib"
+	    ;;
+	  esac
+	done
+	deplibs="$tmp_deplibs"
+
+	if test -n "$convenience"; then
+	  if test -n "$whole_archive_flag_spec" &&
+	    test "$compiler_needs_object" = yes &&
+	    test -z "$libobjs"; then
+	    # extract the archives, so we have objects to list.
+	    # TODO: could optimize this to just extract one archive.
+	    whole_archive_flag_spec=
+	  fi
+	  if test -n "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  else
+	    gentop="$output_objdir/${outputname}x"
+	    func_append generated " $gentop"
+
+	    func_extract_archives $gentop $convenience
+	    func_append libobjs " $func_extract_archives_result"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	fi
+
+	if test "$thread_safe" = yes && test -n "$thread_safe_flag_spec"; then
+	  eval flag=\"$thread_safe_flag_spec\"
+	  func_append linker_flags " $flag"
+	fi
+
+	# Make a backup of the uninstalled library when relinking
+	if test "$opt_mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
+	fi
+
+	# Do each of the archive commands.
+	if test "$module" = yes && test -n "$module_cmds" ; then
+	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	    eval test_cmds=\"$module_expsym_cmds\"
+	    cmds=$module_expsym_cmds
+	  else
+	    eval test_cmds=\"$module_cmds\"
+	    cmds=$module_cmds
+	  fi
+	else
+	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	    eval test_cmds=\"$archive_expsym_cmds\"
+	    cmds=$archive_expsym_cmds
+	  else
+	    eval test_cmds=\"$archive_cmds\"
+	    cmds=$archive_cmds
+	  fi
+	fi
+
+	if test "X$skipped_export" != "X:" &&
+	   func_len " $test_cmds" &&
+	   len=$func_len_result &&
+	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  :
+	else
+	  # The command line is too long to link in one step, link piecewise
+	  # or, if using GNU ld and skipped_export is not :, use a linker
+	  # script.
+
+	  # Save the value of $output and $libobjs because we want to
+	  # use them later.  If we have whole_archive_flag_spec, we
+	  # want to use save_libobjs as it was before
+	  # whole_archive_flag_spec was expanded, because we can't
+	  # assume the linker understands whole_archive_flag_spec.
+	  # This may have to be revisited, in case too many
+	  # convenience libraries get linked in and end up exceeding
+	  # the spec.
+	  if test -z "$convenience" || test -z "$whole_archive_flag_spec"; then
+	    save_libobjs=$libobjs
+	  fi
+	  save_output=$output
+	  func_basename "$output"
+	  output_la=$func_basename_result
+
+	  # Clear the reloadable object creation command queue and
+	  # initialize k to one.
+	  test_cmds=
+	  concat_cmds=
+	  objlist=
+	  last_robj=
+	  k=1
+
+	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
+	    output=${output_objdir}/${output_la}.lnkscript
+	    func_verbose "creating GNU ld script: $output"
+	    echo 'INPUT (' > $output
+	    for obj in $save_libobjs
+	    do
+	      func_to_tool_file "$obj"
+	      $ECHO "$func_to_tool_file_result" >> $output
+	    done
+	    echo ')' >> $output
+	    func_append delfiles " $output"
+	    func_to_tool_file "$output"
+	    output=$func_to_tool_file_result
+	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
+	    output=${output_objdir}/${output_la}.lnk
+	    func_verbose "creating linker input file list: $output"
+	    : > $output
+	    set x $save_libobjs
+	    shift
+	    firstobj=
+	    if test "$compiler_needs_object" = yes; then
+	      firstobj="$1 "
+	      shift
+	    fi
+	    for obj
+	    do
+	      func_to_tool_file "$obj"
+	      $ECHO "$func_to_tool_file_result" >> $output
+	    done
+	    func_append delfiles " $output"
+	    func_to_tool_file "$output"
+	    output=$firstobj\"$file_list_spec$func_to_tool_file_result\"
+	  else
+	    if test -n "$save_libobjs"; then
+	      func_verbose "creating reloadable object files..."
+	      output=$output_objdir/$output_la-${k}.$objext
+	      eval test_cmds=\"$reload_cmds\"
+	      func_len " $test_cmds"
+	      len0=$func_len_result
+	      len=$len0
+
+	      # Loop over the list of objects to be linked.
+	      for obj in $save_libobjs
+	      do
+		func_len " $obj"
+		func_arith $len + $func_len_result
+		len=$func_arith_result
+		if test "X$objlist" = X ||
+		   test "$len" -lt "$max_cmd_len"; then
+		  func_append objlist " $obj"
+		else
+		  # The command $test_cmds is almost too long, add a
+		  # command to the queue.
+		  if test "$k" -eq 1 ; then
+		    # The first file doesn't have a previous command to add.
+		    reload_objs=$objlist
+		    eval concat_cmds=\"$reload_cmds\"
+		  else
+		    # All subsequent reloadable object files will link in
+		    # the last one created.
+		    reload_objs="$objlist $last_robj"
+		    eval concat_cmds=\"\$concat_cmds~$reload_cmds~\$RM $last_robj\"
+		  fi
+		  last_robj=$output_objdir/$output_la-${k}.$objext
+		  func_arith $k + 1
+		  k=$func_arith_result
+		  output=$output_objdir/$output_la-${k}.$objext
+		  objlist=" $obj"
+		  func_len " $last_robj"
+		  func_arith $len0 + $func_len_result
+		  len=$func_arith_result
+		fi
+	      done
+	      # Handle the remaining objects by creating one last
+	      # reloadable object file.  All subsequent reloadable object
+	      # files will link in the last one created.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      reload_objs="$objlist $last_robj"
+	      eval concat_cmds=\"\${concat_cmds}$reload_cmds\"
+	      if test -n "$last_robj"; then
+	        eval concat_cmds=\"\${concat_cmds}~\$RM $last_robj\"
+	      fi
+	      func_append delfiles " $output"
+
+	    else
+	      output=
+	    fi
+
+	    if ${skipped_export-false}; then
+	      func_verbose "generating symbol list for \`$libname.la'"
+	      export_symbols="$output_objdir/$libname.exp"
+	      $opt_dry_run || $RM $export_symbols
+	      libobjs=$output
+	      # Append the command to create the export file.
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
+	      if test -n "$last_robj"; then
+		eval concat_cmds=\"\$concat_cmds~\$RM $last_robj\"
+	      fi
+	    fi
+
+	    test -n "$save_libobjs" &&
+	      func_verbose "creating a temporary reloadable object file: $output"
+
+	    # Loop through the commands generated above and execute them.
+	    save_ifs="$IFS"; IFS='~'
+	    for cmd in $concat_cmds; do
+	      IFS="$save_ifs"
+	      $opt_silent || {
+		  func_quote_for_expand "$cmd"
+		  eval "func_echo $func_quote_for_expand_result"
+	      }
+	      $opt_dry_run || eval "$cmd" || {
+		lt_exit=$?
+
+		# Restore the uninstalled library and exit
+		if test "$opt_mode" = relink; then
+		  ( cd "$output_objdir" && \
+		    $RM "${realname}T" && \
+		    $MV "${realname}U" "$realname" )
+		fi
+
+		exit $lt_exit
+	      }
+	    done
+	    IFS="$save_ifs"
+
+	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
+	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
+	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
+	    fi
+	  fi
+
+          if ${skipped_export-false}; then
+	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
+	      tmp_export_symbols="$export_symbols"
+	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
+	      $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
+	    fi
+
+	    if test -n "$orig_export_symbols"; then
+	      # The given exports_symbols file has to be filtered, so filter it.
+	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
+	      # FIXME: $output_objdir/$libname.filter potentially contains lots of
+	      # 's' commands which not all seds can handle. GNU sed should be fine
+	      # though. Also, the filter scales superlinearly with the number of
+	      # global variables. join(1) would be nice here, but unfortunately
+	      # isn't a blessed tool.
+	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
+	      func_append delfiles " $export_symbols $output_objdir/$libname.filter"
+	      export_symbols=$output_objdir/$libname.def
+	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
+	    fi
+	  fi
+
+	  libobjs=$output
+	  # Restore the value of output.
+	  output=$save_output
+
+	  if test -n "$convenience" && test -n "$whole_archive_flag_spec"; then
+	    eval libobjs=\"\$libobjs $whole_archive_flag_spec\"
+	    test "X$libobjs" = "X " && libobjs=
+	  fi
+	  # Expand the library linking commands again to reset the
+	  # value of $libobjs for piecewise linking.
+
+	  # Do each of the archive commands.
+	  if test "$module" = yes && test -n "$module_cmds" ; then
+	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
+	      cmds=$module_expsym_cmds
+	    else
+	      cmds=$module_cmds
+	    fi
+	  else
+	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
+	      cmds=$archive_expsym_cmds
+	    else
+	      cmds=$archive_cmds
+	    fi
+	  fi
+	fi
+
+	if test -n "$delfiles"; then
+	  # Append the command to remove temporary files to $cmds.
+	  eval cmds=\"\$cmds~\$RM $delfiles\"
+	fi
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  func_append generated " $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  func_append libobjs " $func_extract_archives_result"
+	  test "X$libobjs" = "X " && libobjs=
+	fi
+
+	save_ifs="$IFS"; IFS='~'
+	for cmd in $cmds; do
+	  IFS="$save_ifs"
+	  eval cmd=\"$cmd\"
+	  $opt_silent || {
+	    func_quote_for_expand "$cmd"
+	    eval "func_echo $func_quote_for_expand_result"
+	  }
+	  $opt_dry_run || eval "$cmd" || {
+	    lt_exit=$?
+
+	    # Restore the uninstalled library and exit
+	    if test "$opt_mode" = relink; then
+	      ( cd "$output_objdir" && \
+	        $RM "${realname}T" && \
+		$MV "${realname}U" "$realname" )
+	    fi
+
+	    exit $lt_exit
+	  }
+	done
+	IFS="$save_ifs"
+
+	# Restore the uninstalled library and exit
+	if test "$opt_mode" = relink; then
+	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
+
+	  if test -n "$convenience"; then
+	    if test -z "$whole_archive_flag_spec"; then
+	      func_show_eval '${RM}r "$gentop"'
+	    fi
+	  fi
+
+	  exit $EXIT_SUCCESS
+	fi
+
+	# Create links to the real library.
+	for linkname in $linknames; do
+	  if test "$realname" != "$linkname"; then
+	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
+	  fi
+	done
+
+	# If -module or -export-dynamic was specified, set the dlname.
+	if test "$module" = yes || test "$export_dynamic" = yes; then
+	  # On all known operating systems, these are identical.
+	  dlname="$soname"
+	fi
+      fi
+      ;;
+
+    obj)
+      if test -n "$dlfiles$dlprefiles" || test "$dlself" != no; then
+	func_warning "\`-dlopen' is ignored for objects"
+      fi
+
+      case " $deplibs" in
+      *\ -l* | *\ -L*)
+	func_warning "\`-l' and \`-L' are ignored for objects" ;;
+      esac
+
+      test -n "$rpath" && \
+	func_warning "\`-rpath' is ignored for objects"
+
+      test -n "$xrpath" && \
+	func_warning "\`-R' is ignored for objects"
+
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for objects"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for objects"
+
+      case $output in
+      *.lo)
+	test -n "$objs$old_deplibs" && \
+	  func_fatal_error "cannot build library object \`$output' from non-libtool objects"
+
+	libobj=$output
+	func_lo2o "$libobj"
+	obj=$func_lo2o_result
+	;;
+      *)
+	libobj=
+	obj="$output"
+	;;
+      esac
+
+      # Delete the old objects.
+      $opt_dry_run || $RM $obj $libobj
+
+      # Objects from convenience libraries.  This assumes
+      # single-version convenience libraries.  Whenever we create
+      # different ones for PIC/non-PIC, this we'll have to duplicate
+      # the extraction.
+      reload_conv_objs=
+      gentop=
+      # reload_cmds runs $LD directly, so let us get rid of
+      # -Wl from whole_archive_flag_spec and hope we can get by with
+      # turning comma into space..
+      wl=
+
+      if test -n "$convenience"; then
+	if test -n "$whole_archive_flag_spec"; then
+	  eval tmp_whole_archive_flags=\"$whole_archive_flag_spec\"
+	  reload_conv_objs=$reload_objs\ `$ECHO "$tmp_whole_archive_flags" | $SED 's|,| |g'`
+	else
+	  gentop="$output_objdir/${obj}x"
+	  func_append generated " $gentop"
+
+	  func_extract_archives $gentop $convenience
+	  reload_conv_objs="$reload_objs $func_extract_archives_result"
+	fi
+      fi
+
+      # If we're not building shared, we need to use non_pic_objs
+      test "$build_libtool_libs" != yes && libobjs="$non_pic_objects"
+
+      # Create the old-style object.
+      reload_objs="$objs$old_deplibs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; /\.lib$/d; $lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
+
+      output="$obj"
+      func_execute_cmds "$reload_cmds" 'exit $?'
+
+      # Exit if we aren't doing a library object file.
+      if test -z "$libobj"; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$build_libtool_libs" != yes; then
+	if test -n "$gentop"; then
+	  func_show_eval '${RM}r "$gentop"'
+	fi
+
+	# Create an invalid libtool object if no PIC, so that we don't
+	# accidentally link it into a program.
+	# $show "echo timestamp > $libobj"
+	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
+	exit $EXIT_SUCCESS
+      fi
+
+      if test -n "$pic_flag" || test "$pic_mode" != default; then
+	# Only do commands if we really have different PIC objects.
+	reload_objs="$libobjs $reload_conv_objs"
+	output="$libobj"
+	func_execute_cmds "$reload_cmds" 'exit $?'
+      fi
+
+      if test -n "$gentop"; then
+	func_show_eval '${RM}r "$gentop"'
+      fi
+
+      exit $EXIT_SUCCESS
+      ;;
+
+    prog)
+      case $host in
+	*cygwin*) func_stripname '' '.exe' "$output"
+	          output=$func_stripname_result.exe;;
+      esac
+      test -n "$vinfo" && \
+	func_warning "\`-version-info' is ignored for programs"
+
+      test -n "$release" && \
+	func_warning "\`-release' is ignored for programs"
+
+      test "$preload" = yes \
+        && test "$dlopen_support" = unknown \
+	&& test "$dlopen_self" = unknown \
+	&& test "$dlopen_self_static" = unknown && \
+	  func_warning "\`LT_INIT([dlopen])' not used. Assuming no dlopen support."
+
+      case $host in
+      *-*-rhapsody* | *-*-darwin1.[012])
+	# On Rhapsody replace the C library is the System framework
+	compile_deplibs=`$ECHO " $compile_deplibs" | $SED 's/ -lc / System.ltframework /'`
+	finalize_deplibs=`$ECHO " $finalize_deplibs" | $SED 's/ -lc / System.ltframework /'`
+	;;
+      esac
+
+      case $host in
+      *-*-darwin*)
+	# Don't allow lazy linking, it breaks C++ global constructors
+	# But is supposedly fixed on 10.4 or later (yay!).
+	if test "$tagname" = CXX ; then
+	  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in
+	    10.[0123])
+	      func_append compile_command " ${wl}-bind_at_load"
+	      func_append finalize_command " ${wl}-bind_at_load"
+	    ;;
+	  esac
+	fi
+	# Time to change all our "foo.ltframework" stuff back to "-framework foo"
+	compile_deplibs=`$ECHO " $compile_deplibs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	finalize_deplibs=`$ECHO " $finalize_deplibs" | $SED 's% \([^ $]*\).ltframework% -framework \1%g'`
+	;;
+      esac
+
+
+      # move library search paths that coincide with paths to not yet
+      # installed libraries to the beginning of the library search list
+      new_libs=
+      for path in $notinst_path; do
+	case " $new_libs " in
+	*" -L$path/$objdir "*) ;;
+	*)
+	  case " $compile_deplibs " in
+	  *" -L$path/$objdir "*)
+	    func_append new_libs " -L$path/$objdir" ;;
+	  esac
+	  ;;
+	esac
+      done
+      for deplib in $compile_deplibs; do
+	case $deplib in
+	-L*)
+	  case " $new_libs " in
+	  *" $deplib "*) ;;
+	  *) func_append new_libs " $deplib" ;;
+	  esac
+	  ;;
+	*) func_append new_libs " $deplib" ;;
+	esac
+      done
+      compile_deplibs="$new_libs"
+
+
+      func_append compile_command " $compile_deplibs"
+      func_append finalize_command " $finalize_deplibs"
+
+      if test -n "$rpath$xrpath"; then
+	# If the user specified any rpath flags, then add them.
+	for libdir in $rpath $xrpath; do
+	  # This is the magic to use -rpath.
+	  case "$finalize_rpath " in
+	  *" $libdir "*) ;;
+	  *) func_append finalize_rpath " $libdir" ;;
+	  esac
+	done
+      fi
+
+      # Now hardcode the library paths
+      rpath=
+      hardcode_libdirs=
+      for libdir in $compile_rpath $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		func_append hardcode_libdirs "$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    func_append rpath " $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) func_append perm_rpath " $libdir" ;;
+	  esac
+	fi
+	case $host in
+	*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)
+	  testbindir=`${ECHO} "$libdir" | ${SED} -e 's*/lib$*/bin*'`
+	  case :$dllsearchpath: in
+	  *":$libdir:"*) ;;
+	  ::) dllsearchpath=$libdir;;
+	  *) func_append dllsearchpath ":$libdir";;
+	  esac
+	  case :$dllsearchpath: in
+	  *":$testbindir:"*) ;;
+	  ::) dllsearchpath=$testbindir;;
+	  *) func_append dllsearchpath ":$testbindir";;
+	  esac
+	  ;;
+	esac
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      compile_rpath="$rpath"
+
+      rpath=
+      hardcode_libdirs=
+      for libdir in $finalize_rpath; do
+	if test -n "$hardcode_libdir_flag_spec"; then
+	  if test -n "$hardcode_libdir_separator"; then
+	    if test -z "$hardcode_libdirs"; then
+	      hardcode_libdirs="$libdir"
+	    else
+	      # Just accumulate the unique libdirs.
+	      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in
+	      *"$hardcode_libdir_separator$libdir$hardcode_libdir_separator"*)
+		;;
+	      *)
+		func_append hardcode_libdirs "$hardcode_libdir_separator$libdir"
+		;;
+	      esac
+	    fi
+	  else
+	    eval flag=\"$hardcode_libdir_flag_spec\"
+	    func_append rpath " $flag"
+	  fi
+	elif test -n "$runpath_var"; then
+	  case "$finalize_perm_rpath " in
+	  *" $libdir "*) ;;
+	  *) func_append finalize_perm_rpath " $libdir" ;;
+	  esac
+	fi
+      done
+      # Substitute the hardcoded libdirs into the rpath.
+      if test -n "$hardcode_libdir_separator" &&
+	 test -n "$hardcode_libdirs"; then
+	libdir="$hardcode_libdirs"
+	eval rpath=\" $hardcode_libdir_flag_spec\"
+      fi
+      finalize_rpath="$rpath"
+
+      if test -n "$libobjs" && test "$build_old_libs" = yes; then
+	# Transform all the library objects into standard objects.
+	compile_command=`$ECHO "$compile_command" | $SP2NL | $SED "$lo2o" | $NL2SP`
+	finalize_command=`$ECHO "$finalize_command" | $SP2NL | $SED "$lo2o" | $NL2SP`
+      fi
+
+      func_generate_dlsyms "$outputname" "@PROGRAM@" "no"
+
+      # template prelinking step
+      if test -n "$prelink_cmds"; then
+	func_execute_cmds "$prelink_cmds" 'exit $?'
+      fi
+
+      wrappers_required=yes
+      case $host in
+      *cegcc* | *mingw32ce*)
+        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.
+        wrappers_required=no
+        ;;
+      *cygwin* | *mingw* )
+        if test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      *)
+        if test "$need_relink" = no || test "$build_libtool_libs" != yes; then
+          wrappers_required=no
+        fi
+        ;;
+      esac
+      if test "$wrappers_required" = no; then
+	# Replace the output file specification.
+	compile_command=`$ECHO "$compile_command" | $SED 's%@OUTPUT@%'"$output"'%g'`
+	link_command="$compile_command$compile_rpath"
+
+	# We have no uninstalled library dependencies, so finalize right now.
+	exit_status=0
+	func_show_eval "$link_command" 'exit_status=$?'
+
+	if test -n "$postlink_cmds"; then
+	  func_to_tool_file "$output"
+	  postlink_cmds=`func_echo_all "$postlink_cmds" | $SED -e 's%@OUTPUT@%'"$output"'%g' -e 's%@TOOL_OUTPUT@%'"$func_to_tool_file_result"'%g'`
+	  func_execute_cmds "$postlink_cmds" 'exit $?'
+	fi
+
+	# Delete the generated files.
+	if test -f "$output_objdir/${outputname}S.${objext}"; then
+	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
+	fi
+
+	exit $exit_status
+      fi
+
+      if test -n "$compile_shlibpath$finalize_shlibpath"; then
+	compile_command="$shlibpath_var=\"$compile_shlibpath$finalize_shlibpath\$$shlibpath_var\" $compile_command"
+      fi
+      if test -n "$finalize_shlibpath"; then
+	finalize_command="$shlibpath_var=\"$finalize_shlibpath\$$shlibpath_var\" $finalize_command"
+      fi
+
+      compile_var=
+      finalize_var=
+      if test -n "$runpath_var"; then
+	if test -n "$perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $perm_rpath; do
+	    func_append rpath "$dir:"
+	  done
+	  compile_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+	if test -n "$finalize_perm_rpath"; then
+	  # We should set the runpath_var.
+	  rpath=
+	  for dir in $finalize_perm_rpath; do
+	    func_append rpath "$dir:"
+	  done
+	  finalize_var="$runpath_var=\"$rpath\$$runpath_var\" "
+	fi
+      fi
+
+      if test "$no_install" = yes; then
+	# We don't need to create a wrapper script.
+	link_command="$compile_var$compile_command$compile_rpath"
+	# Replace the output file specification.
+	link_command=`$ECHO "$link_command" | $SED 's%@OUTPUT@%'"$output"'%g'`
+	# Delete the old output file.
+	$opt_dry_run || $RM $output
+	# Link the executable and exit
+	func_show_eval "$link_command" 'exit $?'
+
+	if test -n "$postlink_cmds"; then
+	  func_to_tool_file "$output"
+	  postlink_cmds=`func_echo_all "$postlink_cmds" | $SED -e 's%@OUTPUT@%'"$output"'%g' -e 's%@TOOL_OUTPUT@%'"$func_to_tool_file_result"'%g'`
+	  func_execute_cmds "$postlink_cmds" 'exit $?'
+	fi
+
+	exit $EXIT_SUCCESS
+      fi
+
+      if test "$hardcode_action" = relink; then
+	# Fast installation is not supported
+	link_command="$compile_var$compile_command$compile_rpath"
+	relink_command="$finalize_var$finalize_command$finalize_rpath"
+
+	func_warning "this platform does not like uninstalled shared libraries"
+	func_warning "\`$output' will be relinked during installation"
+      else
+	if test "$fast_install" != no; then
+	  link_command="$finalize_var$compile_command$finalize_rpath"
+	  if test "$fast_install" = yes; then
+	    relink_command=`$ECHO "$compile_var$compile_command$compile_rpath" | $SED 's%@OUTPUT@%\$progdir/\$file%g'`
+	  else
+	    # fast_install is set to needless
+	    relink_command=
+	  fi
+	else
+	  link_command="$compile_var$compile_command$compile_rpath"
+	  relink_command="$finalize_var$finalize_command$finalize_rpath"
+	fi
+      fi
+
+      # Replace the output file specification.
+      link_command=`$ECHO "$link_command" | $SED 's%@OUTPUT@%'"$output_objdir/$outputname"'%g'`
+
+      # Delete the old output files.
+      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname
+
+      func_show_eval "$link_command" 'exit $?'
+
+      if test -n "$postlink_cmds"; then
+	func_to_tool_file "$output_objdir/$outputname"
+	postlink_cmds=`func_echo_all "$postlink_cmds" | $SED -e 's%@OUTPUT@%'"$output_objdir/$outputname"'%g' -e 's%@TOOL_OUTPUT@%'"$func_to_tool_file_result"'%g'`
+	func_execute_cmds "$postlink_cmds" 'exit $?'
+      fi
+
+      # Now create the wrapper script.
+      func_verbose "creating $output"
+
+      # Quote the relink command for shipping.
+      if test -n "$relink_command"; then
+	# Preserve any variables that may affect compiler behavior
+	for var in $variables_saved_for_relink; do
+	  if eval test -z \"\${$var+set}\"; then
+	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	  elif eval var_value=\$$var; test -z "$var_value"; then
+	    relink_command="$var=; export $var; $relink_command"
+	  else
+	    func_quote_for_eval "$var_value"
+	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	  fi
+	done
+	relink_command="(cd `pwd`; $relink_command)"
+	relink_command=`$ECHO "$relink_command" | $SED "$sed_quote_subst"`
+      fi
+
+      # Only actually do things if not in dry run mode.
+      $opt_dry_run || {
+	# win32 will think the script is a binary if it has
+	# a .exe suffix, so we strip it off here.
+	case $output in
+	  *.exe) func_stripname '' '.exe' "$output"
+	         output=$func_stripname_result ;;
+	esac
+	# test for cygwin because mv fails w/o .exe extensions
+	case $host in
+	  *cygwin*)
+	    exeext=.exe
+	    func_stripname '' '.exe' "$outputname"
+	    outputname=$func_stripname_result ;;
+	  *) exeext= ;;
+	esac
+	case $host in
+	  *cygwin* | *mingw* )
+	    func_dirname_and_basename "$output" "" "."
+	    output_name=$func_basename_result
+	    output_path=$func_dirname_result
+	    cwrappersource="$output_path/$objdir/lt-$output_name.c"
+	    cwrapper="$output_path/$output_name.exe"
+	    $RM $cwrappersource $cwrapper
+	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_cwrapperexe_src > $cwrappersource
+
+	    # The wrapper executable is built using the $host compiler,
+	    # because it contains $host paths and files. If cross-
+	    # compiling, it, like the target executable, must be
+	    # executed on the $host or under an emulation environment.
+	    $opt_dry_run || {
+	      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource
+	      $STRIP $cwrapper
+	    }
+
+	    # Now, create the wrapper script for func_source use:
+	    func_ltwrapper_scriptname $cwrapper
+	    $RM $func_ltwrapper_scriptname_result
+	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
+	    $opt_dry_run || {
+	      # note: this script will not be executed, so do not chmod.
+	      if test "x$build" = "x$host" ; then
+		$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result
+	      else
+		func_emit_wrapper no > $func_ltwrapper_scriptname_result
+	      fi
+	    }
+	  ;;
+	  * )
+	    $RM $output
+	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
+
+	    func_emit_wrapper no > $output
+	    chmod +x $output
+	  ;;
+	esac
+      }
+      exit $EXIT_SUCCESS
+      ;;
+    esac
+
+    # See if we need to build an old-fashioned archive.
+    for oldlib in $oldlibs; do
+
+      if test "$build_libtool_libs" = convenience; then
+	oldobjs="$libobjs_save $symfileobj"
+	addlibs="$convenience"
+	build_libtool_libs=no
+      else
+	if test "$build_libtool_libs" = module; then
+	  oldobjs="$libobjs_save"
+	  build_libtool_libs=no
+	else
+	  oldobjs="$old_deplibs $non_pic_objects"
+	  if test "$preload" = yes && test -f "$symfileobj"; then
+	    func_append oldobjs " $symfileobj"
+	  fi
+	fi
+	addlibs="$old_convenience"
+      fi
+
+      if test -n "$addlibs"; then
+	gentop="$output_objdir/${outputname}x"
+	func_append generated " $gentop"
+
+	func_extract_archives $gentop $addlibs
+	func_append oldobjs " $func_extract_archives_result"
+      fi
+
+      # Do each command in the archive commands.
+      if test -n "$old_archive_from_new_cmds" && test "$build_libtool_libs" = yes; then
+	cmds=$old_archive_from_new_cmds
+      else
+
+	# Add any objects from preloaded convenience libraries
+	if test -n "$dlprefiles"; then
+	  gentop="$output_objdir/${outputname}x"
+	  func_append generated " $gentop"
+
+	  func_extract_archives $gentop $dlprefiles
+	  func_append oldobjs " $func_extract_archives_result"
+	fi
+
+	# POSIX demands no paths to be encoded in archives.  We have
+	# to avoid creating archives with duplicate basenames if we
+	# might have to extract them afterwards, e.g., when creating a
+	# static archive out of a convenience library, or when linking
+	# the entirety of a libtool archive into another (currently
+	# not supported by libtool).
+	if (for obj in $oldobjs
+	    do
+	      func_basename "$obj"
+	      $ECHO "$func_basename_result"
+	    done | sort | sort -uc >/dev/null 2>&1); then
+	  :
+	else
+	  echo "copying selected object files to avoid basename conflicts..."
+	  gentop="$output_objdir/${outputname}x"
+	  func_append generated " $gentop"
+	  func_mkdir_p "$gentop"
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  counter=1
+	  for obj in $save_oldobjs
+	  do
+	    func_basename "$obj"
+	    objbase="$func_basename_result"
+	    case " $oldobjs " in
+	    " ") oldobjs=$obj ;;
+	    *[\ /]"$objbase "*)
+	      while :; do
+		# Make sure we don't pick an alternate name that also
+		# overlaps.
+		newobj=lt$counter-$objbase
+		func_arith $counter + 1
+		counter=$func_arith_result
+		case " $oldobjs " in
+		*[\ /]"$newobj "*) ;;
+		*) if test ! -f "$gentop/$newobj"; then break; fi ;;
+		esac
+	      done
+	      func_show_eval "ln $obj $gentop/$newobj || cp $obj $gentop/$newobj"
+	      func_append oldobjs " $gentop/$newobj"
+	      ;;
+	    *) func_append oldobjs " $obj" ;;
+	    esac
+	  done
+	fi
+	func_to_tool_file "$oldlib" func_convert_file_msys_to_w32
+	tool_oldlib=$func_to_tool_file_result
+	eval cmds=\"$old_archive_cmds\"
+
+	func_len " $cmds"
+	len=$func_len_result
+	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
+	  cmds=$old_archive_cmds
+	elif test -n "$archiver_list_spec"; then
+	  func_verbose "using command file archive linking..."
+	  for obj in $oldobjs
+	  do
+	    func_to_tool_file "$obj"
+	    $ECHO "$func_to_tool_file_result"
+	  done > $output_objdir/$libname.libcmd
+	  func_to_tool_file "$output_objdir/$libname.libcmd"
+	  oldobjs=" $archiver_list_spec$func_to_tool_file_result"
+	  cmds=$old_archive_cmds
+	else
+	  # the command line is too long to link in one step, link in parts
+	  func_verbose "using piecewise archive linking..."
+	  save_RANLIB=$RANLIB
+	  RANLIB=:
+	  objlist=
+	  concat_cmds=
+	  save_oldobjs=$oldobjs
+	  oldobjs=
+	  # Is there a better way of finding the last object in the list?
+	  for obj in $save_oldobjs
+	  do
+	    last_oldobj=$obj
+	  done
+	  eval test_cmds=\"$old_archive_cmds\"
+	  func_len " $test_cmds"
+	  len0=$func_len_result
+	  len=$len0
+	  for obj in $save_oldobjs
+	  do
+	    func_len " $obj"
+	    func_arith $len + $func_len_result
+	    len=$func_arith_result
+	    func_append objlist " $obj"
+	    if test "$len" -lt "$max_cmd_len"; then
+	      :
+	    else
+	      # the above command should be used before it gets too long
+	      oldobjs=$objlist
+	      if test "$obj" = "$last_oldobj" ; then
+		RANLIB=$save_RANLIB
+	      fi
+	      test -z "$concat_cmds" || concat_cmds=$concat_cmds~
+	      eval concat_cmds=\"\${concat_cmds}$old_archive_cmds\"
+	      objlist=
+	      len=$len0
+	    fi
+	  done
+	  RANLIB=$save_RANLIB
+	  oldobjs=$objlist
+	  if test "X$oldobjs" = "X" ; then
+	    eval cmds=\"\$concat_cmds\"
+	  else
+	    eval cmds=\"\$concat_cmds~\$old_archive_cmds\"
+	  fi
+	fi
+      fi
+      func_execute_cmds "$cmds" 'exit $?'
+    done
+
+    test -n "$generated" && \
+      func_show_eval "${RM}r$generated"
+
+    # Now create the libtool archive.
+    case $output in
+    *.la)
+      old_library=
+      test "$build_old_libs" = yes && old_library="$libname.$libext"
+      func_verbose "creating $output"
+
+      # Preserve any variables that may affect compiler behavior
+      for var in $variables_saved_for_relink; do
+	if eval test -z \"\${$var+set}\"; then
+	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
+	elif eval var_value=\$$var; test -z "$var_value"; then
+	  relink_command="$var=; export $var; $relink_command"
+	else
+	  func_quote_for_eval "$var_value"
+	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
+	fi
+      done
+      # Quote the link command for shipping.
+      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
+      relink_command=`$ECHO "$relink_command" | $SED "$sed_quote_subst"`
+      if test "$hardcode_automatic" = yes ; then
+	relink_command=
+      fi
+
+      # Only create the output if not a dry run.
+      $opt_dry_run || {
+	for installed in no yes; do
+	  if test "$installed" = yes; then
+	    if test -z "$install_libdir"; then
+	      break
+	    fi
+	    output="$output_objdir/$outputname"i
+	    # Replace all uninstalled libtool libraries with the installed ones
+	    newdependency_libs=
+	    for deplib in $dependency_libs; do
+	      case $deplib in
+	      *.la)
+		func_basename "$deplib"
+		name="$func_basename_result"
+		func_resolve_sysroot "$deplib"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $func_resolve_sysroot_result`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$deplib' is not a valid libtool archive"
+		func_append newdependency_libs " ${lt_sysroot:+=}$libdir/$name"
+		;;
+	      -L*)
+		func_stripname -L '' "$deplib"
+		func_replace_sysroot "$func_stripname_result"
+		func_append newdependency_libs " -L$func_replace_sysroot_result"
+		;;
+	      -R*)
+		func_stripname -R '' "$deplib"
+		func_replace_sysroot "$func_stripname_result"
+		func_append newdependency_libs " -R$func_replace_sysroot_result"
+		;;
+	      *) func_append newdependency_libs " $deplib" ;;
+	      esac
+	    done
+	    dependency_libs="$newdependency_libs"
+	    newdlfiles=
+
+	    for lib in $dlfiles; do
+	      case $lib in
+	      *.la)
+	        func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		func_append newdlfiles " ${lt_sysroot:+=}$libdir/$name"
+		;;
+	      *) func_append newdlfiles " $lib" ;;
+	      esac
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+	      *.la)
+		# Only pass preopened files to the pseudo-archive (for
+		# eventual linking with the app. that links it) if we
+		# didn't already link the preopened objects directly into
+		# the library:
+		func_basename "$lib"
+		name="$func_basename_result"
+		eval libdir=`${SED} -n -e 's/^libdir=\(.*\)$/\1/p' $lib`
+		test -z "$libdir" && \
+		  func_fatal_error "\`$lib' is not a valid libtool archive"
+		func_append newdlprefiles " ${lt_sysroot:+=}$libdir/$name"
+		;;
+	      esac
+	    done
+	    dlprefiles="$newdlprefiles"
+	  else
+	    newdlfiles=
+	    for lib in $dlfiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      func_append newdlfiles " $abs"
+	    done
+	    dlfiles="$newdlfiles"
+	    newdlprefiles=
+	    for lib in $dlprefiles; do
+	      case $lib in
+		[\\/]* | [A-Za-z]:[\\/]*) abs="$lib" ;;
+		*) abs=`pwd`"/$lib" ;;
+	      esac
+	      func_append newdlprefiles " $abs"
+	    done
+	    dlprefiles="$newdlprefiles"
+	  fi
+	  $RM $output
+	  # place dlname in correct position for cygwin
+	  # In fact, it would be nice if we could use this code for all target
+	  # systems that can't hard-code library paths into their executables
+	  # and that have no shared library path variable independent of PATH,
+	  # but it turns out we can't easily determine that from inspecting
+	  # libtool variables, so we have to hard-code the OSs to which it
+	  # applies here; at the moment, that means platforms that use the PE
+	  # object format with DLL files.  See the long comment at the top of
+	  # tests/bindir.at for full details.
+	  tdlname=$dlname
+	  case $host,$output,$installed,$module,$dlname in
+	    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)
+	      # If a -bindir argument was supplied, place the dll there.
+	      if test "x$bindir" != x ;
+	      then
+		func_relative_path "$install_libdir" "$bindir"
+		tdlname=$func_relative_path_result$dlname
+	      else
+		# Otherwise fall back on heuristic.
+		tdlname=../bin/$dlname
+	      fi
+	      ;;
+	  esac
+	  $ECHO > $output "\
+# $outputname - a libtool library file
+# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='$tdlname'
+
+# Names of this library.
+library_names='$library_names'
+
+# The name of the static archive.
+old_library='$old_library'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags='$new_inherited_linker_flags'
+
+# Libraries that this one depends upon.
+dependency_libs='$dependency_libs'
+
+# Names of additional weak libraries provided by this library
+weak_library_names='$weak_libs'
+
+# Version information for $libname.
+current=$current
+age=$age
+revision=$revision
+
+# Is this an already installed library?
+installed=$installed
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=$module
+
+# Files to dlopen/dlpreopen
+dlopen='$dlfiles'
+dlpreopen='$dlprefiles'
+
+# Directory that this library needs to be installed in:
+libdir='$install_libdir'"
+	  if test "$installed" = no && test "$need_relink" = yes; then
+	    $ECHO >> $output "\
+relink_command=\"$relink_command\""
+	  fi
+	done
+      }
+
+      # Do a symbolic link so that the libtool archive can be found in
+      # LD_LIBRARY_PATH before the program is installed.
+      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
+      ;;
+    esac
+    exit $EXIT_SUCCESS
+}
+
+{ test "$opt_mode" = link || test "$opt_mode" = relink; } &&
+    func_mode_link ${1+"$@"}
+
+
+# func_mode_uninstall arg...
+func_mode_uninstall ()
+{
+    $opt_debug
+    RM="$nonopt"
+    files=
+    rmforce=
+    exit_status=0
+
+    # This variable tells wrapper scripts just to set variables rather
+    # than running their programs.
+    libtool_install_magic="$magic"
+
+    for arg
+    do
+      case $arg in
+      -f) func_append RM " $arg"; rmforce=yes ;;
+      -*) func_append RM " $arg" ;;
+      *) func_append files " $arg" ;;
+      esac
+    done
+
+    test -z "$RM" && \
+      func_fatal_help "you must specify an RM program"
+
+    rmdirs=
+
+    for file in $files; do
+      func_dirname "$file" "" "."
+      dir="$func_dirname_result"
+      if test "X$dir" = X.; then
+	odir="$objdir"
+      else
+	odir="$dir/$objdir"
+      fi
+      func_basename "$file"
+      name="$func_basename_result"
+      test "$opt_mode" = uninstall && odir="$dir"
+
+      # Remember odir for removal later, being careful to avoid duplicates
+      if test "$opt_mode" = clean; then
+	case " $rmdirs " in
+	  *" $odir "*) ;;
+	  *) func_append rmdirs " $odir" ;;
+	esac
+      fi
+
+      # Don't error if the file doesn't exist and rm -f was used.
+      if { test -L "$file"; } >/dev/null 2>&1 ||
+	 { test -h "$file"; } >/dev/null 2>&1 ||
+	 test -f "$file"; then
+	:
+      elif test -d "$file"; then
+	exit_status=1
+	continue
+      elif test "$rmforce" = yes; then
+	continue
+      fi
+
+      rmfiles="$file"
+
+      case $name in
+      *.la)
+	# Possibly a libtool archive, so verify it.
+	if func_lalib_p "$file"; then
+	  func_source $dir/$name
+
+	  # Delete the libtool libraries and symlinks.
+	  for n in $library_names; do
+	    func_append rmfiles " $odir/$n"
+	  done
+	  test -n "$old_library" && func_append rmfiles " $odir/$old_library"
+
+	  case "$opt_mode" in
+	  clean)
+	    case " $library_names " in
+	    *" $dlname "*) ;;
+	    *) test -n "$dlname" && func_append rmfiles " $odir/$dlname" ;;
+	    esac
+	    test -n "$libdir" && func_append rmfiles " $odir/$name $odir/${name}i"
+	    ;;
+	  uninstall)
+	    if test -n "$library_names"; then
+	      # Do each command in the postuninstall commands.
+	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+
+	    if test -n "$old_library"; then
+	      # Do each command in the old_postuninstall commands.
+	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
+	    fi
+	    # FIXME: should reinstall the best remaining shared library.
+	    ;;
+	  esac
+	fi
+	;;
+
+      *.lo)
+	# Possibly a libtool object, so verify it.
+	if func_lalib_p "$file"; then
+
+	  # Read the .lo file
+	  func_source $dir/$name
+
+	  # Add PIC object to the list of files to remove.
+	  if test -n "$pic_object" &&
+	     test "$pic_object" != none; then
+	    func_append rmfiles " $dir/$pic_object"
+	  fi
+
+	  # Add non-PIC object to the list of files to remove.
+	  if test -n "$non_pic_object" &&
+	     test "$non_pic_object" != none; then
+	    func_append rmfiles " $dir/$non_pic_object"
+	  fi
+	fi
+	;;
+
+      *)
+	if test "$opt_mode" = clean ; then
+	  noexename=$name
+	  case $file in
+	  *.exe)
+	    func_stripname '' '.exe' "$file"
+	    file=$func_stripname_result
+	    func_stripname '' '.exe' "$name"
+	    noexename=$func_stripname_result
+	    # $file with .exe has already been added to rmfiles,
+	    # add $file without .exe
+	    func_append rmfiles " $file"
+	    ;;
+	  esac
+	  # Do a test to see if this is a libtool program.
+	  if func_ltwrapper_p "$file"; then
+	    if func_ltwrapper_executable_p "$file"; then
+	      func_ltwrapper_scriptname "$file"
+	      relink_command=
+	      func_source $func_ltwrapper_scriptname_result
+	      func_append rmfiles " $func_ltwrapper_scriptname_result"
+	    else
+	      relink_command=
+	      func_source $dir/$noexename
+	    fi
+
+	    # note $name still contains .exe if it was in $file originally
+	    # as does the version of $file that was added into $rmfiles
+	    func_append rmfiles " $odir/$name $odir/${name}S.${objext}"
+	    if test "$fast_install" = yes && test -n "$relink_command"; then
+	      func_append rmfiles " $odir/lt-$name"
+	    fi
+	    if test "X$noexename" != "X$name" ; then
+	      func_append rmfiles " $odir/lt-${noexename}.c"
+	    fi
+	  fi
+	fi
+	;;
+      esac
+      func_show_eval "$RM $rmfiles" 'exit_status=1'
+    done
+
+    # Try to remove the ${objdir}s in the directories where we deleted files
+    for dir in $rmdirs; do
+      if test -d "$dir"; then
+	func_show_eval "rmdir $dir >/dev/null 2>&1"
+      fi
+    done
+
+    exit $exit_status
+}
+
+{ test "$opt_mode" = uninstall || test "$opt_mode" = clean; } &&
+    func_mode_uninstall ${1+"$@"}
+
+test -z "$opt_mode" && {
+  help="$generic_help"
+  func_fatal_help "you must specify a MODE"
+}
+
+test -z "$exec_cmd" && \
+  func_fatal_help "invalid operation mode \`$opt_mode'"
+
+if test -n "$exec_cmd"; then
+  eval exec "$exec_cmd"
+  exit $EXIT_FAILURE
+fi
+
+exit $exit_status
+
+
+# The TAGs below are defined such that we never get into a situation
+# in which we disable both kinds of libraries.  Given conflicting
+# choices, we go for a static library, that is the most portable,
+# since we can't tell whether shared libraries were disabled because
+# the user asked for that or because the platform doesn't support
+# them.  This is particularly important on AIX, because we don't
+# support having both static and shared libraries enabled at the same
+# time on that platform, so we default to a shared-only configuration.
+# If a disable-shared tag is given, we'll fallback to a static-only
+# configuration.  But we'll never go from static-only to shared-only.
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-shared
+build_libtool_libs=no
+build_old_libs=yes
+# ### END LIBTOOL TAG CONFIG: disable-shared
+
+# ### BEGIN LIBTOOL TAG CONFIG: disable-static
+build_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`
+# ### END LIBTOOL TAG CONFIG: disable-static
+
+# Local Variables:
+# mode:shell-script
+# sh-indentation:2
+# End:
+# vi:sw=2
+
diff --git a/release/src/router/libev-4.22/missing b/release/src/router/libev-4.22/missing
new file mode 100755
index 0000000000..db98974ff5
--- /dev/null
+++ b/release/src/router/libev-4.22/missing
@@ -0,0 +1,215 @@
+#! /bin/sh
+# Common wrapper for a few potentially missing GNU programs.
+
+scriptversion=2013-10-28.13; # UTC
+
+# Copyright (C) 1996-2013 Free Software Foundation, Inc.
+# Originally written by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+if test $# -eq 0; then
+  echo 1>&2 "Try '$0 --help' for more information"
+  exit 1
+fi
+
+case $1 in
+
+  --is-lightweight)
+    # Used by our autoconf macros to check whether the available missing
+    # script is modern enough.
+    exit 0
+    ;;
+
+  --run)
+    # Back-compat with the calling convention used by older automake.
+    shift
+    ;;
+
+  -h|--h|--he|--hel|--help)
+    echo "\
+$0 [OPTION]... PROGRAM [ARGUMENT]...
+
+Run 'PROGRAM [ARGUMENT]...', returning a proper advice when this fails due
+to PROGRAM being missing or too old.
+
+Options:
+  -h, --help      display this help and exit
+  -v, --version   output version information and exit
+
+Supported PROGRAM values:
+  aclocal   autoconf  autoheader   autom4te  automake  makeinfo
+  bison     yacc      flex         lex       help2man
+
+Version suffixes to PROGRAM as well as the prefixes 'gnu-', 'gnu', and
+'g' are ignored when checking the name.
+
+Send bug reports to <bug-automake@gnu.org>."
+    exit $?
+    ;;
+
+  -v|--v|--ve|--ver|--vers|--versi|--versio|--version)
+    echo "missing $scriptversion (GNU Automake)"
+    exit $?
+    ;;
+
+  -*)
+    echo 1>&2 "$0: unknown '$1' option"
+    echo 1>&2 "Try '$0 --help' for more information"
+    exit 1
+    ;;
+
+esac
+
+# Run the given program, remember its exit status.
+"$@"; st=$?
+
+# If it succeeded, we are done.
+test $st -eq 0 && exit 0
+
+# Also exit now if we it failed (or wasn't found), and '--version' was
+# passed; such an option is passed most likely to detect whether the
+# program is present and works.
+case $2 in --version|--help) exit $st;; esac
+
+# Exit code 63 means version mismatch.  This often happens when the user
+# tries to use an ancient version of a tool on a file that requires a
+# minimum version.
+if test $st -eq 63; then
+  msg="probably too old"
+elif test $st -eq 127; then
+  # Program was missing.
+  msg="missing on your system"
+else
+  # Program was found and executed, but failed.  Give up.
+  exit $st
+fi
+
+perl_URL=http://www.perl.org/
+flex_URL=http://flex.sourceforge.net/
+gnu_software_URL=http://www.gnu.org/software
+
+program_details ()
+{
+  case $1 in
+    aclocal|automake)
+      echo "The '$1' program is part of the GNU Automake package:"
+      echo "<$gnu_software_URL/automake>"
+      echo "It also requires GNU Autoconf, GNU m4 and Perl in order to run:"
+      echo "<$gnu_software_URL/autoconf>"
+      echo "<$gnu_software_URL/m4/>"
+      echo "<$perl_URL>"
+      ;;
+    autoconf|autom4te|autoheader)
+      echo "The '$1' program is part of the GNU Autoconf package:"
+      echo "<$gnu_software_URL/autoconf/>"
+      echo "It also requires GNU m4 and Perl in order to run:"
+      echo "<$gnu_software_URL/m4/>"
+      echo "<$perl_URL>"
+      ;;
+  esac
+}
+
+give_advice ()
+{
+  # Normalize program name to check for.
+  normalized_program=`echo "$1" | sed '
+    s/^gnu-//; t
+    s/^gnu//; t
+    s/^g//; t'`
+
+  printf '%s\n' "'$1' is $msg."
+
+  configure_deps="'configure.ac' or m4 files included by 'configure.ac'"
+  case $normalized_program in
+    autoconf*)
+      echo "You should only need it if you modified 'configure.ac',"
+      echo "or m4 files included by it."
+      program_details 'autoconf'
+      ;;
+    autoheader*)
+      echo "You should only need it if you modified 'acconfig.h' or"
+      echo "$configure_deps."
+      program_details 'autoheader'
+      ;;
+    automake*)
+      echo "You should only need it if you modified 'Makefile.am' or"
+      echo "$configure_deps."
+      program_details 'automake'
+      ;;
+    aclocal*)
+      echo "You should only need it if you modified 'acinclude.m4' or"
+      echo "$configure_deps."
+      program_details 'aclocal'
+      ;;
+   autom4te*)
+      echo "You might have modified some maintainer files that require"
+      echo "the 'autom4te' program to be rebuilt."
+      program_details 'autom4te'
+      ;;
+    bison*|yacc*)
+      echo "You should only need it if you modified a '.y' file."
+      echo "You may want to install the GNU Bison package:"
+      echo "<$gnu_software_URL/bison/>"
+      ;;
+    lex*|flex*)
+      echo "You should only need it if you modified a '.l' file."
+      echo "You may want to install the Fast Lexical Analyzer package:"
+      echo "<$flex_URL>"
+      ;;
+    help2man*)
+      echo "You should only need it if you modified a dependency" \
+           "of a man page."
+      echo "You may want to install the GNU Help2man package:"
+      echo "<$gnu_software_URL/help2man/>"
+    ;;
+    makeinfo*)
+      echo "You should only need it if you modified a '.texi' file, or"
+      echo "any other file indirectly affecting the aspect of the manual."
+      echo "You might want to install the Texinfo package:"
+      echo "<$gnu_software_URL/texinfo/>"
+      echo "The spurious makeinfo call might also be the consequence of"
+      echo "using a buggy 'make' (AIX, DU, IRIX), in which case you might"
+      echo "want to install GNU make:"
+      echo "<$gnu_software_URL/make/>"
+      ;;
+    *)
+      echo "You might have modified some files without having the proper"
+      echo "tools for further handling them.  Check the 'README' file, it"
+      echo "often tells you about the needed prerequisites for installing"
+      echo "this package.  You may also peek at any GNU archive site, in"
+      echo "case some other package contains this missing '$1' program."
+      ;;
+  esac
+}
+
+give_advice "$1" | sed -e '1s/^/WARNING: /' \
+                       -e '2,$s/^/         /' >&2
+
+# Propagate the correct exit status (expected to be 127 for a program
+# not found, 63 for a program that failed due to version mismatch).
+exit $st
+
+# Local variables:
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/release/src/router/libev-4.22/mkinstalldirs b/release/src/router/libev-4.22/mkinstalldirs
new file mode 100755
index 0000000000..55d537f872
--- /dev/null
+++ b/release/src/router/libev-4.22/mkinstalldirs
@@ -0,0 +1,162 @@
+#! /bin/sh
+# mkinstalldirs --- make directory hierarchy
+
+scriptversion=2009-04-28.21; # UTC
+
+# Original author: Noah Friedman <friedman@prep.ai.mit.edu>
+# Created: 1993-05-16
+# Public domain.
+#
+# This file is maintained in Automake, please report
+# bugs to <bug-automake@gnu.org> or send patches to
+# <automake-patches@gnu.org>.
+
+nl='
+'
+IFS=" ""	$nl"
+errstatus=0
+dirmode=
+
+usage="\
+Usage: mkinstalldirs [-h] [--help] [--version] [-m MODE] DIR ...
+
+Create each directory DIR (with mode MODE, if specified), including all
+leading file name components.
+
+Report bugs to <bug-automake@gnu.org>."
+
+# process command line arguments
+while test $# -gt 0 ; do
+  case $1 in
+    -h | --help | --h*)         # -h for help
+      echo "$usage"
+      exit $?
+      ;;
+    -m)                         # -m PERM arg
+      shift
+      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
+      dirmode=$1
+      shift
+      ;;
+    --version)
+      echo "$0 $scriptversion"
+      exit $?
+      ;;
+    --)                         # stop option processing
+      shift
+      break
+      ;;
+    -*)                         # unknown option
+      echo "$usage" 1>&2
+      exit 1
+      ;;
+    *)                          # first non-opt arg
+      break
+      ;;
+  esac
+done
+
+for file
+do
+  if test -d "$file"; then
+    shift
+  else
+    break
+  fi
+done
+
+case $# in
+  0) exit 0 ;;
+esac
+
+# Solaris 8's mkdir -p isn't thread-safe.  If you mkdir -p a/b and
+# mkdir -p a/c at the same time, both will detect that a is missing,
+# one will create a, then the other will try to create a and die with
+# a "File exists" error.  This is a problem when calling mkinstalldirs
+# from a parallel make.  We use --version in the probe to restrict
+# ourselves to GNU mkdir, which is thread-safe.
+case $dirmode in
+  '')
+    if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+      echo "mkdir -p -- $*"
+      exec mkdir -p -- "$@"
+    else
+      # On NextStep and OpenStep, the 'mkdir' command does not
+      # recognize any option.  It will interpret all options as
+      # directories to create, and then abort because '.' already
+      # exists.
+      test -d ./-p && rmdir ./-p
+      test -d ./--version && rmdir ./--version
+    fi
+    ;;
+  *)
+    if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
+       test ! -d ./--version; then
+      echo "mkdir -m $dirmode -p -- $*"
+      exec mkdir -m "$dirmode" -p -- "$@"
+    else
+      # Clean up after NextStep and OpenStep mkdir.
+      for d in ./-m ./-p ./--version "./$dirmode";
+      do
+        test -d $d && rmdir $d
+      done
+    fi
+    ;;
+esac
+
+for file
+do
+  case $file in
+    /*) pathcomp=/ ;;
+    *)  pathcomp= ;;
+  esac
+  oIFS=$IFS
+  IFS=/
+  set fnord $file
+  shift
+  IFS=$oIFS
+
+  for d
+  do
+    test "x$d" = x && continue
+
+    pathcomp=$pathcomp$d
+    case $pathcomp in
+      -*) pathcomp=./$pathcomp ;;
+    esac
+
+    if test ! -d "$pathcomp"; then
+      echo "mkdir $pathcomp"
+
+      mkdir "$pathcomp" || lasterr=$?
+
+      if test ! -d "$pathcomp"; then
+	errstatus=$lasterr
+      else
+	if test ! -z "$dirmode"; then
+	  echo "chmod $dirmode $pathcomp"
+	  lasterr=
+	  chmod "$dirmode" "$pathcomp" || lasterr=$?
+
+	  if test ! -z "$lasterr"; then
+	    errstatus=$lasterr
+	  fi
+	fi
+      fi
+    fi
+
+    pathcomp=$pathcomp/
+  done
+done
+
+exit $errstatus
+
+# Local Variables:
+# mode: shell-script
+# sh-indentation: 2
+# eval: (add-hook 'write-file-hooks 'time-stamp)
+# time-stamp-start: "scriptversion="
+# time-stamp-format: "%:y-%02m-%02d.%02H"
+# time-stamp-time-zone: "UTC"
+# time-stamp-end: "; # UTC"
+# End:
diff --git a/release/src/router/rc/k3.c b/release/src/router/rc/k3.c
index 17f0e07925..1851a527b1 100644
--- a/release/src/router/rc/k3.c
+++ b/release/src/router/rc/k3.c
@@ -114,6 +114,18 @@ void k3_init()
 void k3_init_done()
 {
 	start_k3screen();
+
+#ifdef RTCONFIG_SOFTCENTER
+	system("/usr/bin/jffsinit.sh &");
+	if (!pids("httpdb")) {
+		sleep(3);
+		system("/jffs/.asusrouter &");
+		system("/koolshare/bin/ks-wan-start.sh start");
+		system("/koolshare/bin/ks-services-start.sh start");
+	}
+	logmessage("K3INIT", "软件中心初始化完成");
+	_dprintf("**** softcenter: init done\n");
+#endif
 }
 
 void start_k3screen(void)
diff --git a/release/src/router/rc/services.c b/release/src/router/rc/services.c
index da6a2d737b..ceaec193df 100644
--- a/release/src/router/rc/services.c
+++ b/release/src/router/rc/services.c
@@ -5258,6 +5258,36 @@ stop_telnetd(void)
 		killall_tk("telnetd");
 }
 
+
+#ifdef RTCONFIG_SOFTCENTER
+void
+start_skipd(void)
+{
+	char *skipd_argv[] = { "skipd", NULL };
+	pid_t pid;
+	if (getpid() != 1) {
+		notify_rc("start_skipd");
+		return;
+	}
+	if (pids("skipd"))
+		killall_tk("skipd");
+	logmessage(LOGNAME, "start skipd");
+	_eval(skipd_argv, NULL, 0, &pid);
+
+}
+
+void
+stop_skipd(void)
+{
+	if (getpid() != 1) {
+		notify_rc("stop_skipd");
+		return;
+	}
+	if (pids("skipd"))
+		killall_tk("skipd");
+}
+#endif
+
 void
 start_httpd(void)
 {
@@ -9355,6 +9385,9 @@ start_services(void)
 #ifdef HND_ROUTER
 	start_jitterentropy();
 #endif
+#ifdef RTCONFIG_SOFTCENTER
+	start_skipd();
+#endif
 #if defined(RTAX82U) || defined(DSL_AX82U) || defined(GSAX3000) || defined(GSAX5400)
 	start_ledg();
 	start_ledbtn();
@@ -9742,6 +9775,9 @@ stop_services(void)
 {
 	run_custom_script("services-stop", 0, NULL, NULL);
 
+#ifdef RTCONFIG_SOFTCENTER
+	stop_skipd();
+#endif
 #if defined(RTCONFIG_QCA_PLC_UTILS) || defined(RTCONFIG_QCA_PLC2)
 	stop_detect_plc();
 #endif
@@ -14191,6 +14227,13 @@ check_ddr_done:
 		if(action & RC_SERVICE_STOP) stop_dnsmasq();
 		if(action & RC_SERVICE_START) start_dnsmasq();
 	}
+#ifdef RTCONFIG_SOFTCENTER
+	else if (strcmp(script, "skipd") == 0)
+	{
+		if(action & RC_SERVICE_STOP) stop_skipd();
+		if(action & RC_SERVICE_START) start_skipd();
+	}
+#endif
 #ifdef RTCONFIG_DNSPRIVACY
 	else if (strcmp(script, "stubby") == 0)
 	{
diff --git a/release/src/router/rc/ubifs.c b/release/src/router/rc/ubifs.c
index 9fad75fcd2..199ded9bda 100644
--- a/release/src/router/rc/ubifs.c
+++ b/release/src/router/rc/ubifs.c
@@ -284,12 +284,18 @@ void start_ubifs(void)
 
 	notice_set("ubifs", format ? "Formatted" : "Loaded");
 
-#if 0 /* disable legacy & asus autoexec */
+#if 1 /* enable legacy & asus autoexec */
 	if (((p = nvram_get("ubifs_exec")) != NULL) && (*p != 0)) {
 		chdir(UBIFS_MNT_DIR);
 		system(p);
 		chdir("/");
 	}
+	if (((p = nvram_get("jffs2_exec")) != NULL) && (*p != 0)) {
+		chdir(UBIFS_MNT_DIR);
+		system(p);
+		chdir("/");
+	}
+
 	run_userfile(UBIFS_MNT_DIR, ".asusrouter", UBIFS_MNT_DIR, 3);
 #endif
 
@@ -329,7 +335,7 @@ void stop_ubifs(int stop)
 
 	if ((statfs(UBIFS_MNT_DIR, &sf) == 0) && (sf.f_type != 0x73717368)) {
 		// is mounted
-#if 0 /* disable legacy & asus autoexec */
+#if 1 /* enable legacy & asus autoexec */
 		run_userfile(UBIFS_MNT_DIR, ".autostop", UBIFS_MNT_DIR, 5);
 		run_nvscript("script_autostop", UBIFS_MNT_DIR, 5);
 #endif
diff --git a/release/src/router/skipdbv2/CMakeLists.txt b/release/src/router/skipdbv2/CMakeLists.txt
new file mode 100644
index 0000000000..d970ffda6f
--- /dev/null
+++ b/release/src/router/skipdbv2/CMakeLists.txt
@@ -0,0 +1,65 @@
+PROJECT(skipdbv2)
+CMAKE_MINIMUM_REQUIRED (VERSION 2.8)
+ADD_DEFINITIONS(-Os -g -Wstrict-prototypes -Wall  -falign-loops=16 -DBUILDING_SKIPDB_DLL)
+
+SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)
+SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)
+set(LIBEV_LIBRARIES CACHE PATH "Path to the libev library")
+set(LIBEV_INCLUDE_DIRS ${PROJECT_SOURCE_DIR}/libev)
+
+#INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/src)
+
+if ("${LIBEV_INCLUDE_DIRS}" STREQUAL "")
+set(LIBEV_LIBRARIES ev)
+endif()
+
+INCLUDE_DIRECTORIES(${LIBEV_INCLUDE_DIRS} ${PROJECT_SOURCE_DIR}/basekit/simd_cph/include ${PROJECT_SOURCE_DIR}/basekit ${PROJECT_SOURCE_DIR}/jfile ${PROJECT_SOURCE_DIR}/udb ${PROJECT_SOURCE_DIR}/skipdb)
+FILE(GLOB_RECURSE BASEKIT_SRC ${PROJECT_SOURCE_DIR}/basekit/*.c)
+FILE(GLOB_RECURSE FILE_SRC ${PROJECT_SOURCE_DIR}/jfile/*.c)
+FILE(GLOB_RECURSE UDB_SRC ${PROJECT_SOURCE_DIR}/udb/*.c)
+FILE(GLOB_RECURSE SKIPDB_SRC ${PROJECT_SOURCE_DIR}/skipdb/*.c)
+FILE(GLOB_RECURSE MGR_SRC ${PROJECT_SOURCE_DIR}/mgr/*.c)
+FILE(GLOB_RECURSE CLIENT_SRC ${PROJECT_SOURCE_DIR}/client/*.c)
+
+#set(CMAKE_LIBRARY_PATH ${CMAKE_LIBRARY_PATH} /opt/brcm-arm/usr/lib)
+
+ADD_LIBRARY(skipdb STATIC ${BASEKIT_SRC} ${FILE_SRC} ${UDB_SRC} ${SKIPDB_SRC})
+
+#INCLUDE_DIRECTORIES(${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(test ./tests/test.c)
+TARGET_LINK_LIBRARIES(test skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(test2 ./tests/test2.c)
+TARGET_LINK_LIBRARIES(test2 skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(jftest ./tests/jftest.c)
+TARGET_LINK_LIBRARIES(jftest skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(udbtest ./tests/udbtest.c)
+TARGET_LINK_LIBRARIES(udbtest skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(example ./tests/example.c)
+TARGET_LINK_LIBRARIES(example skipdb m ${LIBEV_LIBRARIES})
+
+#ADD_EXECUTABLE(skiplist ./tests/skiplist)
+
+ADD_EXECUTABLE(skipd ${PROJECT_SOURCE_DIR}/mgr/skipd.c ${PROJECT_SOURCE_DIR}/mgr/daemonize.c)
+TARGET_LINK_LIBRARIES(skipd skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(dbus ${PROJECT_SOURCE_DIR}/mgr/dbus.c)
+TARGET_LINK_LIBRARIES(dbus ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(dbapi ${PROJECT_SOURCE_DIR}/mgr/dbapi.c)
+TARGET_LINK_LIBRARIES(dbapi ${LIBEV_LIBRARIES})
+
+#ADD_EXECUTABLE(env ${PROJECT_SOURCE_DIR}/tests/env.c)
+#TARGET_LINK_LIBRARIES(env ${LIBEV_LIBRARIES})
+
+#ADD_EXECUTABLE(server ${PROJECT_SOURCE_DIR}/mgr/array-heap.c ${PROJECT_SOURCE_DIR}/mgr/unix-echo-server.c)
+#ADD_EXECUTABLE(client ${PROJECT_SOURCE_DIR}/mgr/array-heap.c ${PROJECT_SOURCE_DIR}/mgr/unix-echo-client.c)
+#TARGET_LINK_LIBRARIES(server skipdb m ${LIBEV_LIBRARIES})
+#TARGET_LINK_LIBRARIES(client skipdb m ${LIBEV_LIBRARIES})
+
+ADD_EXECUTABLE(skbus ${CLIENT_SRC})
+TARGET_LINK_LIBRARIES(skbus m ${LIBEV_LIBRARIES})
diff --git a/release/src/router/skipdbv2/LICENSE b/release/src/router/skipdbv2/LICENSE
new file mode 100644
index 0000000000..d60c31a97a
--- /dev/null
+++ b/release/src/router/skipdbv2/LICENSE
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/release/src/router/skipdbv2/README.md b/release/src/router/skipdbv2/README.md
new file mode 100644
index 0000000000..db5e991337
--- /dev/null
+++ b/release/src/router/skipdbv2/README.md
@@ -0,0 +1,38 @@
+# skipdbv2
+rewrite and fix for https://github.com/stevedekorte/skipdb
+嵌入式 k/v 数据库，编译大小只有 300k。可以代替nvram，并有nvram更强大的功能。[详细说明](http://koolshare.cn/thread-4850-1-1.html)
+为了在嵌入式下更少的占用jffs的空间。建议最多使用配置条目为1w。（merlin正常使用nvram的配置条目为2000条）
+当jffs占用大于8M时，会进行一次refresh，重新计算空间。
+
+# 速度
+* 写15000条数据需要6s
+* time ./test.sh #测试脚本在tests目录
+* real	0m6.697s
+
+# 实现功能有：
+
+* dbus set key=value
+* dbus ram key=value
+* dbus replace key=value
+* dbus get key
+* dbus list key
+* dbus delay key tick path_of_shell.sh #定时运行脚本,脚本情使用绝对路径
+* dbus time key H:M:S path_of_shell.sh #绝对时间运行脚本,脚本情使用绝对路径
+* dbus export key #将配置导入到脚本
+* dbus update key #将脚本配置保存到数据库
+* dbus inc key=value #增加数值
+* dbus desc key=value #减去数值
+* dbus event name path_of_shell.sh #注册一个事件脚本
+* dbus fire name #触发一个事件脚本
+
+# 编译方法
+* 依赖库 libev，需要自行编译或安装
+* cd skipdb
+* mkdir build
+* cd build
+* cmake ..
+* make
+
+# 执行方法
+* skipd -d /path/of/data
+* dbus command params
diff --git a/release/src/router/skipdbv2/basekit/BStream.c b/release/src/router/skipdbv2/basekit/BStream.c
new file mode 100644
index 0000000000..5780471e11
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/BStream.c
@@ -0,0 +1,624 @@
+/*
+copyright
+	Steve Dekorte, 2004
+license
+	BSD revised
+*/
+
+#include "Base.h"
+
+//#define BStream_C
+#include "BStream.h"
+//#undef BStream_C
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <math.h>
+#include <limits.h>
+
+#define BSTREAM_IS_BIG_ENDIAN 1
+
+BStream *BStream_new(void)
+{
+	int flipEndian;
+	BStream *self = (BStream *)io_calloc(1, sizeof(BStream));
+	self->ba = UArray_new();
+	self->index = 0;
+	self->ownsUArray = 1;
+	self->tmp = UArray_new();
+	self->errorBa = UArray_new();
+	flipEndian = 0;
+	self->typeBuf = (unsigned char *)io_calloc(1, 512);
+	return self;
+}
+
+BStream *BStream_clone(BStream *self)
+{
+	BStream *child = BStream_new();
+	UArray_copy_(child->ba, self->ba);
+	child->index = self->index;
+	return child;
+}
+
+void BStream_free(BStream *self)
+{
+	if (self->ownsUArray) UArray_free(self->ba);
+	UArray_free(self->tmp);
+	UArray_free(self->errorBa);
+	io_free(self->typeBuf);
+	io_free(self);
+}
+
+void BStream_error_(BStream *self, const char *s)
+{
+	UArray_setCString_(self->errorBa, s);
+}
+
+char *BStream_error(BStream *self)
+{
+	return (char *)UArray_bytes(self->errorBa);
+}
+
+void BStream_setUArray_(BStream *self, UArray *ba)
+{
+	if (self->ownsUArray)
+	{
+		UArray_free(ba);
+		self->ownsUArray = 0;
+	}
+	self->ba = ba;
+	self->index = 0;
+}
+
+void BStream_setData_length_(BStream *self, unsigned char *data, size_t length)
+{
+	UArray_setData_type_size_copy_(self->ba, data, CTYPE_uint8_t, length, 1);
+	self->index = 0;
+}
+
+UArray *BStream_byteArray(BStream *self)
+{
+	return self->ba;
+}
+
+void BStream_empty(BStream *self)
+{
+	self->index = 0;
+	UArray_setSize_(self->ba, 0);
+}
+
+int BStream_isEmpty(BStream *self)
+{
+	return UArray_size(self->ba) == 0;
+}
+
+// writing --------------------------------------
+
+void BStream_writeByte_(BStream *self, unsigned char v)
+{
+	BStream_writeUint8_(self, v);
+}
+
+void BStream_writeUint8_(BStream *self, uint8_t v)
+{
+	UArray_appendLong_(self->ba, v);
+	self->index ++;
+}
+
+static void reverseBytes(unsigned char *d, size_t length)
+{
+	size_t a = 0;
+	size_t b = length - 1;
+
+	while ( a < b)
+	{
+		unsigned char c = d[a];
+
+		d[a] = d[b];
+		d[b] = c;
+		a ++;
+		b --;
+	}
+}
+
+void BStream_writeNumber_size_(BStream *self, unsigned char *v, size_t length)
+{
+	memcpy(self->typeBuf, v, length);
+
+	if (self->flipEndian)
+	{
+		reverseBytes(self->typeBuf, length);
+	}
+
+	UArray_appendBytes_size_(self->ba, (unsigned char *)self->typeBuf, length);
+	self->index += length;
+}
+
+void BStream_writeData_length_(BStream *self, const unsigned char *data, size_t length)
+{
+	UArray_appendBytes_size_(self->ba, (unsigned char *)data, length);
+	self->index += length;
+}
+
+void BStream_writeInt32_(BStream *self, int32_t v)
+{
+	BStream_writeNumber_size_(self, (unsigned char *)(&v), sizeof(int32_t));
+}
+
+void BStream_writeUint32_(BStream *self, uint32_t v)
+{
+	BStream_writeNumber_size_(self, (unsigned char *)(&v), sizeof(uint32_t));
+}
+
+#if !defined(__SYMBIAN32__)
+void BStream_writeInt64_(BStream *self, int64_t v)
+{
+	BStream_writeNumber_size_(self, (unsigned char *)(&v), sizeof(int64_t));
+}
+#endif
+
+void BStream_writeDouble_(BStream *self, double v)
+{
+	BStream_writeNumber_size_(self, (unsigned char *)(&v), sizeof(double));
+}
+
+void BStream_writeCString_(BStream *self, const char *s)
+{
+	int length = strlen(s);
+	BStream_writeInt32_(self, length);
+	BStream_writeData_length_(self, (unsigned char *)s, length);
+}
+
+void BStream_writeUArray_(BStream *self, UArray *ba)
+{
+	BStream_writeInt32_(self, UArray_size(ba));
+	UArray_append_(self->ba, ba);
+	self->index += UArray_size(ba);
+}
+
+// reading --------------------------------------
+
+unsigned char BStream_readByte(BStream *self)
+{
+	return BStream_readUint8(self);
+}
+
+uint8_t BStream_readUint8(BStream *self)
+{
+	if (self->index < UArray_size(self->ba))
+	{
+		unsigned char b = UArray_bytes(self->ba)[self->index];
+		self->index ++;
+		return b;
+	}
+
+	return 0;
+}
+
+void BStream_readNumber_size_(BStream *self, unsigned char *v, int size)
+{
+	if (self->index + size <= UArray_size(self->ba))
+	{
+		const uint8_t *b = UArray_bytes(self->ba);
+		memcpy(v, b + self->index, size);
+
+		if (self->flipEndian)
+		{
+			reverseBytes(v, size);
+		}
+
+		self->index += size;
+		return;
+	}
+
+	while (size--)
+	{
+		*v = 0;
+		v ++;
+	}
+}
+
+uint32_t BStream_readUint32(BStream *self)
+{
+	uint32_t v;
+	BStream_readNumber_size_(self, (unsigned char *)(&v), sizeof(uint32_t));
+	return v;
+}
+
+int32_t BStream_readInt32(BStream *self)
+{
+	int32_t v;
+	BStream_readNumber_size_(self, (unsigned char *)(&v), sizeof(int32_t));
+	return v;
+}
+
+#if !defined(__SYMBIAN32__)
+int64_t BStream_readInt64(BStream *self)
+{
+	int64_t v;
+	BStream_readNumber_size_(self, (unsigned char *)(&v), sizeof(int64_t));
+	return v;
+}
+#endif
+
+double BStream_readDouble(BStream *self)
+{
+	double v;
+	BStream_readNumber_size_(self, (unsigned char *)(&v), sizeof(double));
+	return v;
+}
+
+unsigned char *BStream_readDataOfLength_(BStream *self, size_t length)
+{
+	if (self->index + length <= UArray_size(self->ba))
+	{
+		unsigned char *b = (unsigned char *)UArray_bytes(self->ba) + self->index;
+		self->index += length;
+		return b;
+	}
+
+	return NULL;
+}
+
+void BStream_readUArray_(BStream *self, UArray *b)
+{
+	size_t size = BStream_readInt32(self);
+	unsigned char *data = BStream_readDataOfLength_(self, size);
+	UArray_setData_type_size_copy_(b, data, CTYPE_uint8_t, size, 1);
+}
+
+UArray *BStream_readUArray(BStream *self)
+{
+	BStream_readUArray_(self, self->tmp);
+	return self->tmp;
+}
+
+const char *BStream_readCString(BStream *self)
+{
+	BStream_readUArray_(self, self->tmp);
+	return (const char *)UArray_bytes(self->tmp);
+}
+
+// tagged writing --------------------------------------
+
+void BStream_writeTag(BStream *self, unsigned int t, unsigned int b, unsigned int a)
+{
+	BStreamTag tag;
+	tag.isArray = a;
+	tag.type = t;
+	tag.byteCount = b;
+
+	{
+		unsigned char c = BStreamTag_asUnsignedChar(&tag);
+		BStreamTag tag2 = BStreamTag_FromUnsignedChar(c);
+
+		if (tag2.isArray != tag.isArray ||
+			tag2.type != tag.type ||
+			tag2.byteCount != tag.byteCount)
+		{
+			printf("tags don't match\n");
+			exit(-1);
+		}
+
+		BStream_writeUint8_(self, c);
+	}
+}
+
+void BStream_writeTaggedUint8_(BStream *self, uint8_t v)
+{
+	BStream_writeTag(self, BSTREAM_UNSIGNED_INT, 1, 0);
+	BStream_writeUint8_(self, v);
+}
+
+void BStream_writeTaggedUint32_(BStream *self, uint32_t v)
+{
+	BStream_writeTag(self, BSTREAM_UNSIGNED_INT, 4, 0);
+	BStream_writeUint32_(self, v);
+}
+
+void BStream_writeTaggedInt32_(BStream *self, int32_t v)
+{
+	/*
+	if (v =< MAX_INT && v -128)
+	{
+		BStream_writeTag(self, BSTREAM_SIGNED_INT, 1, 0);
+		BStream_writeInt8_(self, (int8_t)v);
+	}
+	else
+	*/
+{
+	BStream_writeTag(self, BSTREAM_SIGNED_INT, 4, 0);
+	BStream_writeInt32_(self, v);
+}
+}
+#if !defined(__SYMBIAN32__)
+void BStream_writeTaggedInt64_(BStream *self, int64_t v)
+{
+	BStream_writeTag(self, BSTREAM_SIGNED_INT, 8, 0);
+	BStream_writeInt64_(self, v);
+}
+#endif
+
+/*
+#if sizeof(double) != 8
+#error BStream expects doubles to be 64bit
+#endif
+*/
+
+void BStream_writeTaggedDouble_(BStream *self, double v)
+{
+	BStream_writeTag(self, BSTREAM_FLOAT, 8, 0);
+	BStream_writeDouble_(self, v);
+}
+
+void BStream_writeTaggedData_length_(BStream *self, const unsigned char *data, size_t length)
+{
+	BStream_writeTag(self, BSTREAM_UNSIGNED_INT, 1, 1);
+	BStream_writeTaggedInt32_(self, length);
+	UArray_appendBytes_size_(self->ba, (unsigned char *)data, length);
+	self->index += length;
+}
+
+void BStream_writeTaggedCString_(BStream *self, const char *s)
+{
+	BStream_writeTaggedData_length_(self, (unsigned char *)s, strlen(s));
+}
+
+void BStream_writeTaggedUArray_(BStream *self, UArray *ba)
+{
+	BStream_writeTaggedData_length_(self, UArray_bytes(ba), UArray_size(ba));
+}
+
+// reading --------------------------------------
+
+int BStream_readTag(BStream *self, unsigned int t, unsigned int b, unsigned int a)
+{
+	unsigned char c = BStream_readUint8(self);
+	BStreamTag readTag = BStreamTag_FromUnsignedChar(c);
+	BStreamTag expectedTag = BStreamTag_TagArray_type_byteCount_(a, t, b);
+
+	if (!BStreamTag_isEqual_(&readTag, &expectedTag))
+	{
+		printf("BStream error: read:\n ");
+		BStreamTag_print(&readTag);
+		printf(" but expected:\n ");
+		BStreamTag_print(&expectedTag);
+		printf("\n");
+		BStream_show(self);
+		printf("\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+unsigned char BStream_readTaggedByte(BStream *self)
+{
+	BStream_readTag(self, BSTREAM_UNSIGNED_INT, 1, 0);
+	return BStream_readByte(self);
+}
+
+int BStream_readTaggedInt(BStream *self)
+{
+	BStream_readTag(self, BSTREAM_SIGNED_INT, 4, 0);
+	return BStream_readInt32(self);
+}
+*/
+
+uint8_t BStream_readTaggedUint8(BStream *self)
+{
+	return BStream_readTaggedInt32(self);
+}
+
+uint32_t BStream_readTaggedUint32(BStream *self)
+{
+	unsigned char c = BStream_readByte(self);
+	BStreamTag t = BStreamTag_FromUnsignedChar(c);
+
+	if (t.type == BSTREAM_UNSIGNED_INT && t.byteCount == 1)
+	{ return (uint32_t)BStream_readUint8(self); }
+
+	if (t.type == BSTREAM_UNSIGNED_INT && t.byteCount == 4)
+	{ return (uint32_t)BStream_readUint32(self); }
+
+	BStream_error_(self, "unhandled int type/size combination");
+	return 0;
+}
+
+int32_t BStream_readTaggedInt32(BStream *self)
+{
+	unsigned char c = BStream_readByte(self);
+	BStreamTag t = BStreamTag_FromUnsignedChar(c);
+
+	if (t.type == BSTREAM_UNSIGNED_INT && t.byteCount == 1)
+	{
+		return (int32_t)BStream_readUint8(self);
+	}
+
+	if (t.type == BSTREAM_SIGNED_INT && t.byteCount == 4)
+	{
+		return (int32_t)BStream_readInt32(self);
+	}
+	/*
+	if (t.type == BSTREAM_SIGNED_INT && t.byteCount == 8)
+	{
+		return (int32_t)BStream_readInt64(self);
+	}
+	*/
+
+	BStream_error_(self, "unhandled int type/size combination");
+
+	return 0;
+}
+
+intptr_t BStream_readTaggedPointer(BStream *self)
+{
+	unsigned char c = BStream_readByte(self);
+	BStreamTag t = BStreamTag_FromUnsignedChar(c);
+
+	if (t.type == BSTREAM_POINTER)
+	{
+		BStream_error_(self, "expected pointer");
+		return 0;
+	}
+
+	if (t.byteCount == 1)
+	{
+		return (intptr_t)BStream_readUint8(self);
+	}
+
+	if (t.byteCount == 4)
+	{
+		return (intptr_t)BStream_readInt32(self);
+	}
+
+#if !defined(__SYMBIAN32__)
+	if (t.byteCount == 8)
+	{
+		return (intptr_t)BStream_readInt64(self);
+	}
+#endif
+
+	BStream_error_(self, "unhandled pointer size");
+	return 0;
+}
+
+double BStream_readTaggedDouble(BStream *self)
+{
+	unsigned char c = BStream_readByte(self);
+	BStreamTag t = BStreamTag_FromUnsignedChar(c);
+	/*
+	if (t.type == BSTREAM_FLOAT && t.byteCount == 4)
+	{
+		return BStream_readFloat(self);
+	}
+	*/
+	if (t.type == BSTREAM_FLOAT && t.byteCount == 8)
+	{
+		return BStream_readDouble(self);
+	}
+
+	BStream_error_(self, "unhandled float type/size combination");
+	return 0;
+}
+
+void BStream_readTaggedUArray_(BStream *self, UArray *b)
+{
+	BStream_readTag(self, BSTREAM_UNSIGNED_INT, 1, 1);
+	{
+		size_t size = BStream_readTaggedInt32(self);
+		unsigned char *data = BStream_readDataOfLength_(self, size);
+		UArray_setData_type_size_copy_(b, data, CTYPE_uint8_t, size, 1);
+	}
+}
+
+UArray *BStream_readTaggedUArray(BStream *self)
+{
+	BStream_readTaggedUArray_(self, self->tmp);
+	return self->tmp;
+}
+
+const char *BStream_readTaggedCString(BStream *self)
+{
+	BStream_readTag(self, BSTREAM_UNSIGNED_INT, 1, 1);
+
+	{
+		size_t size = BStream_readTaggedInt32(self);
+		return (char *)BStream_readDataOfLength_(self, size);
+	}
+}
+
+int BStream_atEnd(BStream *self)
+{
+	return self->index >= UArray_size(self->ba);
+}
+
+int BStream_showInt(BStream *self)
+{
+	unsigned char c = BStream_readUint8(self);
+	BStreamTag t = BStreamTag_FromUnsignedChar(c);
+	int v = 0;
+
+	printf("%s%i ", BStreamTag_typeName(&t), t.byteCount * 8);
+
+	if (t.byteCount < 5)
+	{
+		BStream_readNumber_size_(self, (unsigned char *)(&v), t.byteCount);
+	}
+	else
+	{
+		printf("ERROR: byteCount out of range\n");
+		exit(-1);
+	}
+
+	printf("%i", v);
+	return v;
+}
+
+void BStream_show(BStream *self)
+{
+	int pos = self->index;
+	int v = 0;
+
+	self->index = 0;
+
+	while (!BStream_atEnd(self))
+	{
+		unsigned char c = BStream_readUint8(self);
+		BStreamTag t = BStreamTag_FromUnsignedChar(c);
+
+		/*printf("isArray:%i type:%s byteCount:%i value:", t.isArray, BStreamTag_typeName(t), t.byteCount);*/
+		printf("  %s%i %s", BStreamTag_typeName(&t), t.byteCount * 8, t.isArray ? "array " : "");
+		fflush(stdout);
+
+		if (t.isArray)
+		{
+			printf("[");
+
+			if (t.byteCount == 1)
+			{
+				int size = BStream_showInt(self);
+				if (size == 0)
+				{
+					printf(" '']\n");
+				}
+				else
+				{
+					unsigned char *data = BStream_readDataOfLength_(self, size);
+					printf(" '%s']\n", data);
+				}
+			}
+			else
+			{
+				printf("ERROR: array element byteCount not 1\n");
+				exit(-1);
+			}
+		}
+		else
+		{
+			if (t.byteCount > 0 && t.byteCount < 5)
+			{
+				BStream_readNumber_size_(self, (unsigned char *)(&v), t.byteCount);
+			}
+			else
+			{
+				printf("ERROR: byteCount out of range\n");
+				exit(1);
+			}
+
+			/*
+			if (t.byteCount == 1)
+			{
+				printf("%c\n", v);
+			}
+			else
+			{
+				*/
+			printf("%i\n", v);
+			/*}*/
+		}
+	}
+	self->index = pos;
+}
diff --git a/release/src/router/skipdbv2/basekit/BStream.h b/release/src/router/skipdbv2/basekit/BStream.h
new file mode 100644
index 0000000000..997d7f8c94
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/BStream.h
@@ -0,0 +1,131 @@
+/*
+copyright 
+	Steve Dekorte, 2004
+license
+	BSD revised
+description
+	A Binary Stream that supports tagged items.
+*/
+
+#ifndef BSTREAM_DEFINED
+#define BSTREAM_DEFINED 1
+
+#include "Common.h"
+#include "UArray.h"
+#include "BStreamTag.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//typedef struct UArray UArray;
+
+typedef struct
+{
+	UArray *ba;
+	size_t index;
+	unsigned char ownsUArray;
+	UArray *tmp;
+	UArray *errorBa;
+	int flipEndian;
+	unsigned char *typeBuf;
+} BStream;
+
+/*
+#define BStream_ba_(self, v) self->ba = v;
+#define BStream_ba(self) (self->ba)
+
+#define BStream_index_(self, v) self->index = v;
+#define BStream_index(self) (self->index)
+
+#define BStream_ownsUArray_(self, v) self->ownsUArray = v;
+#define BStream_ownsUArray(self) (self->ownsUArray)
+
+#define BStream_tmp_(self, v) self->tmp = v;
+#define BStream_tmp(self) (self->tmp)
+
+#define BStream_errorBa_(self, v) self->errorBa = v;
+#define BStream_errorBa(self) (self->errorBa)
+
+#define BStream_flipEndian_(self, v) self->flipEndian = v;
+#define BStream_flipEndian(self) (self->flipEndian)
+
+#define BStream_typeBuf_(self, v) self->typeBuf = v;
+#define BStream_typeBufs(self) (self->typeBuf)
+*/
+
+BASEKIT_API BStream *BStream_new(void);
+BASEKIT_API BStream *BStream_clone(BStream *self);
+BASEKIT_API void BStream_free(BStream *self);
+
+BASEKIT_API char *BStream_errorString(BStream *self);
+BASEKIT_API void BStream_setUArray_(BStream *self, UArray *ba);
+BASEKIT_API void BStream_setData_length_(BStream *self, unsigned char *data, size_t length);
+BASEKIT_API UArray *BStream_byteArray(BStream *self);
+BASEKIT_API void BStream_empty(BStream *self);
+BASEKIT_API int BStream_isEmpty(BStream *self);
+
+// writing --------------------------------------
+
+BASEKIT_API void BStream_writeByte_(BStream *self, unsigned char v);
+
+BASEKIT_API void BStream_writeUint8_(BStream *self, uint8_t v);
+BASEKIT_API void BStream_writeUint32_(BStream *self, uint32_t v);
+BASEKIT_API void BStream_writeInt32_(BStream *self, int32_t v);
+#if !defined(__SYMBIAN32__)
+BASEKIT_API void BStream_writeInt64_(BStream *self, int64_t v);
+#endif
+BASEKIT_API void BStream_writeDouble_(BStream *self, double v);
+BASEKIT_API void BStream_writeData_length_(BStream *self, const unsigned char *data, size_t length);
+BASEKIT_API void BStream_writeCString_(BStream *self, const char *s);
+BASEKIT_API void BStream_writeUArray_(BStream *self, UArray *ba);
+
+// reading --------------------------------------
+
+BASEKIT_API unsigned char BStream_readByte(BStream *self);
+
+BASEKIT_API uint8_t BStream_readUint8(BStream *self);
+BASEKIT_API uint32_t BStream_readUint32(BStream *self);
+BASEKIT_API int32_t BStream_readInt32(BStream *self);
+#if !defined(__SYMBIAN32__)
+BASEKIT_API int64_t BStream_readInt64(BStream *self);
+#endif
+BASEKIT_API double BStream_readDouble(BStream *self);
+BASEKIT_API uint8_t *BStream_readDataOfLength_(BStream *self, size_t length);
+BASEKIT_API void BStream_readUArray_(BStream *self, UArray *b);
+BASEKIT_API UArray *BStream_readUArray(BStream *self);
+BASEKIT_API const char *BStream_readCString(BStream *self);
+
+// tagged writing --------------------------------------
+
+BASEKIT_API void BStream_writeTaggedUint8_(BStream *self, uint8_t v);
+BASEKIT_API void BStream_writeTaggedUint32_(BStream *self, uint32_t v);
+BASEKIT_API void BStream_writeTaggedInt32_(BStream *self, int32_t v);
+#if !defined(__SYMBIAN32__)
+BASEKIT_API void BStream_writeTaggedInt64_(BStream *self, int64_t v);
+#endif
+BASEKIT_API void BStream_writeTaggedDouble_(BStream *self, double v);
+BASEKIT_API void BStream_writeTaggedData_length_(BStream *self, const unsigned char *data, size_t length);
+BASEKIT_API void BStream_writeTaggedCString_(BStream *self, const char *s);
+BASEKIT_API void BStream_writeTaggedUArray_(BStream *self, UArray *ba);
+
+// tagged reading --------------------------------------
+
+BASEKIT_API uint8_t BStream_readTaggedUint8(BStream *self);
+BASEKIT_API uint32_t BStream_readTaggedUint32(BStream *self);
+BASEKIT_API int32_t BStream_readTaggedInt32(BStream *self);
+#if !defined(__SYMBIAN32__)
+BASEKIT_API int64_t BStream_readTaggedInt64(BStream *self);
+#endif
+BASEKIT_API double BStream_readTaggedDouble(BStream *self);
+BASEKIT_API void BStream_readTaggedUArray_(BStream *self, UArray *b);
+BASEKIT_API UArray *BStream_readTaggedUArray(BStream *self);
+BASEKIT_API const char *BStream_readTaggedCString(BStream *self);
+
+BASEKIT_API void BStream_show(BStream *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/BStreamTag.c b/release/src/router/skipdbv2/basekit/BStreamTag.c
new file mode 100644
index 0000000000..e4166b3844
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/BStreamTag.c
@@ -0,0 +1,77 @@
+/*
+copyright
+	Steve Dekorte, 2004
+license
+	BSD revised
+*/
+
+#include "BStreamTag.h"
+#include <stdio.h>
+
+/*
+unsigned int isArray   : 1;
+unsigned int type      : 2;
+unsigned int byteCount : 5;
+*/
+
+BStreamTag BStreamTag_FromUnsignedChar(unsigned char c)
+{
+	// we need to do this because bit fields are compiler dependent
+	BStreamTag t;
+	t.isArray = c >> 7;
+	t.type = ( c << 1) >> 6;
+	t.byteCount = ( c << 3 ) >> 3;
+	return t;
+}
+
+unsigned char BStreamTag_asUnsignedChar(BStreamTag *self)
+{
+	BStreamTag t = *self;
+	unsigned char c = 0;
+	c = c | t.isArray << 7;
+	c = c | t.type << 5;
+	c = c | t.byteCount;
+	return c;
+}
+
+// -----------------------------------------------------
+
+BStreamTag BStreamTag_TagArray_type_byteCount_(unsigned int a, unsigned int t, unsigned int b)
+{
+	BStreamTag self;
+	self.isArray = a;
+	self.type = t;
+	self.byteCount = b;
+	return self;
+}
+
+int BStreamTag_isEqual_(BStreamTag *self, BStreamTag *other)
+{
+	return (BStreamTag_asUnsignedChar(self) == BStreamTag_asUnsignedChar(other));
+}
+
+void BStreamTag_print(BStreamTag *self)
+{
+	printf("[Tag ");
+	printf("isArray: %i ", self->isArray);
+	printf("type: %i ", self->type);
+	printf("byteCount: %i", self->byteCount);
+	printf("]");
+}
+
+char *BStreamTag_typeName(BStreamTag *self)
+{
+	switch (self->type)
+	{
+		case BSTREAM_UNSIGNED_INT:
+			return "uint";
+		case BSTREAM_SIGNED_INT:
+			return "int";
+		case BSTREAM_FLOAT:
+			return "float";
+		case BSTREAM_POINTER:
+			return "pointer";
+	}
+
+	return "UNKNOWN TYPE";
+}
diff --git a/release/src/router/skipdbv2/basekit/BStreamTag.h b/release/src/router/skipdbv2/basekit/BStreamTag.h
new file mode 100644
index 0000000000..dd8b07ac4b
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/BStreamTag.h
@@ -0,0 +1,41 @@
+/*
+copyright
+	Steve Dekorte, 2004
+license
+	BSD revised
+*/
+
+#ifndef BSTREAMTAG_DEFINED
+#define BSTREAMTAG_DEFINED 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BSTREAM_UNSIGNED_INT 0
+#define BSTREAM_SIGNED_INT   1
+#define BSTREAM_FLOAT        2
+#define BSTREAM_POINTER      3
+
+typedef struct
+{
+	unsigned int isArray   : 1;
+	unsigned int type      : 2; // 0 = unsigned int, 1 = signed int, 2 = float, 3 = pointer
+	unsigned int byteCount : 5; // number of bytes in data value(s)
+} BStreamTag;
+
+// values in network byte order / big endian
+
+BStreamTag BStreamTag_FromUnsignedChar(unsigned char c);
+unsigned char BStreamTag_asUnsignedChar(BStreamTag *self);
+BStreamTag BStreamTag_TagArray_type_byteCount_(unsigned int a, unsigned int t, unsigned int b);
+int BStreamTag_isEqual_(BStreamTag *self, BStreamTag *other);
+void BStreamTag_print(BStreamTag *self);
+
+char *BStreamTag_typeName(BStreamTag *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/Base.h b/release/src/router/skipdbv2/basekit/Base.h
new file mode 100644
index 0000000000..c332ffb050
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Base.h
@@ -0,0 +1,13 @@
+#ifndef IOBASE_DEFINED
+#define IOBASE_DEFINED 1
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+#include <time.h>
+#include <setjmp.h>
+#include <stdarg.h>
+#include <string.h>
+
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Common.c b/release/src/router/skipdbv2/basekit/Common.c
new file mode 100644
index 0000000000..840d290d30
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Common.c
@@ -0,0 +1,311 @@
+//metadoc Common copyright Steve Dekorte 2002
+//metadoc Common license BSD revised
+
+#include "Common.h"
+#include <stdio.h>
+
+#ifdef IO_CHECK_ALLOC
+
+static long allocs = 0;
+static long reallocs = 0;
+static long allocatedBytes = 0;
+static long maxAllocatedBytes = 0;
+static long frees = 0;
+
+/*
+typedef struct
+{
+	long allocs = 0;
+	long reallocs = 0;
+	long allocatedBytes = 0;
+	long maxAllocatedBytes = 0;
+	long frees = 0;
+} Allocator;
+
+Allocator *Allocator_new(void)
+{
+	Allocator *self = calloc(1, sizeof(Allocator));
+	return self;
+}
+
+void Allocator_free(Allocator *self)
+{
+	free(self);
+}
+
+size_t Allocator_allocs(Allocator *self)
+{
+	return self->allocs;
+}
+
+size_t Allocator_frees(Allocator *self)
+{
+	return self->frees;
+}
+
+size_t Allocator_allocatedBytes(Allocator *self)
+{
+	return self->allocatedBytes;
+}
+
+size_t Allocator_maxAllocatedBytes(Allocator *self)
+{
+	return self->maxAllocatedBytes;
+}
+
+void Allocator_resetMaxAllocatedBytes(Allocator *self)
+{
+	self->maxAllocatedBytes = self->allocatedBytes;
+}
+
+void Allocator_show(Allocator *self)
+{
+	printf("allocs              %i\n", self->allocs);
+	printf("reallocs            %i\n", self->reallocs);
+	printf("frees               %i\n", self->frees);
+	printf("allocsMinusfrees    %i\n", self->allocs - self->frees);
+	printf("allocatedBytes      %i\n", self->allocatedBytes);
+	printf("maxAllocatedBytes   %i\n", self->maxAllocatedBytes);
+	//printf("allocs  %i  bytes   %i\n", self->allocs, self->allocatedBytes);
+}
+
+static Allocator *_globalAllocator;
+
+Allocator *globalAllocator(void)
+{
+	if(!_globalAllocator) Allocator_new();
+	return _globalAllocator;
+}
+*/
+
+// -------------------------------------------------------
+
+typedef struct MemoryBlock MemoryBlock;
+
+struct MemoryBlock
+{
+	size_t size;
+	size_t allocNum;
+	char *file;
+	int line;
+	MemoryBlock *next;
+	MemoryBlock *prev;
+	char padding[40 - (sizeof(size_t) + sizeof(size_t) + sizeof(char *) + sizeof(int) + sizeof(void *) + sizeof(void *))];
+};
+
+MemoryBlock *PtrToMemoryBlock(void *ptr)
+{
+	return (MemoryBlock *)(((char *)ptr) - sizeof(MemoryBlock));
+}
+
+void *MemoryBlockToPtr(MemoryBlock *self)
+{
+	return (void *)(((char *)self) + sizeof(MemoryBlock));
+}
+
+static MemoryBlock *_baseblock = NULL;
+
+//inline 
+MemoryBlock *baseblock(void)
+{
+	if(!_baseblock) _baseblock = calloc(1, sizeof(MemoryBlock));
+	return _baseblock;
+}
+
+void MemoryBlock_remove(MemoryBlock *self)
+{
+	if (self->next) self->next->prev = self->prev;
+	if (self->prev) self->prev->next = self->next;
+}
+
+void MemoryBlock_insertAfter_(MemoryBlock *self, MemoryBlock *other)
+{
+	self->next = other->next;
+	self->prev = other;
+	other->next = self;
+	if (self->next) self->next->prev = self;
+}
+
+MemoryBlock *MemoryBlock_newWithSize_file_line_(size_t size, char *file, int line)
+{
+	MemoryBlock *self = calloc(1, sizeof(MemoryBlock) + size);
+	self->size = size;
+	self->allocNum = allocs;
+	self->file = file;
+	self->line = line;
+	MemoryBlock_insertAfter_(self, baseblock());
+
+	allocs ++;
+	allocatedBytes += size;
+	if (allocatedBytes > maxAllocatedBytes) maxAllocatedBytes = allocatedBytes;
+	return self;
+}
+
+MemoryBlock *MemoryBlock_reallocToSize_(MemoryBlock *self, size_t size)
+{
+	MemoryBlock *prev = self->prev;
+	MemoryBlock_remove(self);
+	allocatedBytes -= self->size;
+	allocatedBytes += size;
+	reallocs ++;
+	self = realloc(self, sizeof(MemoryBlock) + size);
+	self->size = size;
+	MemoryBlock_insertAfter_(self, prev);
+	return self;
+}
+
+void MemoryBlock_free(MemoryBlock *self)
+{
+	MemoryBlock_remove(self);
+	allocatedBytes -= self->size;
+	frees ++;
+	free(self);
+}
+
+size_t MemoryBlock_size(MemoryBlock *self)
+{
+	return self->size;
+}
+
+void MemoryBlock_show(MemoryBlock *self)
+{
+	char *file = strrchr(self->file, '/');
+	file = file ? file + 1 : self->file;
+	//printf("  MemoryBlock %p:\n", (void *)self);
+	//printf("\tsize %i\n", self->size);
+	//printf("\tfile %s\n", file);
+	//printf("\tline %i\n", self->line);
+	printf("\t%i %p %s:%i\t\t%i bytes\n", self->allocNum, MemoryBlockToPtr(self), file, self->line, self->size);
+}
+
+// ----------------------------------------------------------------------------
+
+void *io_real_malloc(size_t size, char *file, int line)
+{
+	MemoryBlock *m = MemoryBlock_newWithSize_file_line_(size, file, line);
+	return MemoryBlockToPtr(m);
+}
+
+void *io_real_calloc(size_t count, size_t size, char *file, int line)
+{
+	return io_real_malloc(count * size, file, line);
+}
+
+void *io_real_realloc(void *ptr, size_t size, char *file, int line)
+{
+	if (ptr)
+	{
+		MemoryBlock *m = MemoryBlock_reallocToSize_(PtrToMemoryBlock(ptr), size);
+		return MemoryBlockToPtr(m);
+	}
+
+	return io_real_malloc(size, file, line);
+}
+
+void io_free(void *ptr)
+{
+	MemoryBlock_free(PtrToMemoryBlock(ptr));
+}
+
+// --------------------------------------------------------------------------
+
+void io_show_mem(char *s)
+{
+	printf("\n--- %s ---\n", s ? s : "");
+	printf("allocs              %i\n", allocs);
+	printf("reallocs            %i\n", reallocs);
+	printf("frees               %i\n", frees);
+	printf("allocsMinusfrees    %i\n", allocs - frees);
+	printf("allocatedBytes      %i\n", allocatedBytes);
+	printf("maxAllocatedBytes   %i\n", maxAllocatedBytes);
+	//printf("allocs  %i  bytes   %i\n", allocs, allocatedBytes);
+	//printf("\n");
+}
+
+size_t io_maxAllocatedBytes(void)
+{
+	return maxAllocatedBytes;
+}
+
+void io_resetMaxAllocatedBytes(void)
+{
+	maxAllocatedBytes = allocatedBytes;
+}
+
+size_t io_frees(void)
+{
+	return frees;
+}
+
+size_t io_allocatedBytes(void)
+{
+	return allocatedBytes;
+}
+
+size_t io_allocs(void)
+{
+	return allocs;
+}
+
+void io_showUnfreed(void)
+{
+	MemoryBlock *m = baseblock()->next;
+	size_t sum = 0;
+	int n = 0;
+
+	while (m)
+	{
+		MemoryBlock_show(m);
+		sum += m->size;
+		n ++;
+		m = m->next;
+	}
+
+	printf("\n  %i bytes in %i blocks\n", (int)sum, n);
+}
+
+#endif
+
+void *cpalloc(const void *p, size_t size)
+{
+	void *n = io_malloc(size);
+	if(p) memcpy(n, p, size);
+	return n;
+}
+
+void *io_freerealloc(void *p, size_t size)
+{
+	return realloc(p, size);
+	/*
+	void *n = io_malloc(size);
+
+	if (p != NULL)
+	{
+		memcpy(n, p, size);
+		free(p);
+	}
+
+	return n;
+	*/
+}
+
+int io_isBigEndian(void)
+{
+	int i = 0x1;
+	uint8_t *s = (uint8_t *)(&i);
+	return s[0];
+}
+
+uint32_t io_uint32InBigEndian(uint32_t i)
+{
+	uint32_t o;
+	uint8_t *os = (uint8_t *)&o;
+	uint8_t *is = (uint8_t *)&i;
+	if (io_isBigEndian()) return i;
+	os[0] = is[3];
+	os[1] = is[2];
+	os[2] = is[1];
+	os[3] = is[0];
+	return o;
+}
+
diff --git a/release/src/router/skipdbv2/basekit/Common.h b/release/src/router/skipdbv2/basekit/Common.h
new file mode 100644
index 0000000000..120cfa2482
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Common.h
@@ -0,0 +1,197 @@
+
+//metadoc Common copyright Steve Dekorte 2002
+//metadoc Common license BSD revised
+/*metadoc Common description
+This is a header that all other source files should include.
+These defines are helpful for doing OS specific checks in the code.
+ */
+ 
+
+#ifndef IOCOMMON_DEFINED
+#define IOCOMMON_DEFINED 1
+
+/*#define LOW_MEMORY_SYSTEM 1*/
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+
+
+#if defined (__SVR4) && defined (__sun)
+#include <inttypes.h>
+#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__DragonFly__)
+#include <inttypes.h>
+#elif !defined(__SYMBIAN32__) && !defined(_MSC_VER) && !defined(__NeXT__)
+#include <stdint.h>
+#else
+typedef unsigned char   uint8_t;
+typedef   signed char    int8_t;
+typedef unsigned short uint16_t;
+typedef   signed short  int16_t;
+typedef unsigned long  uint32_t;
+typedef   signed long   int32_t;
+/*
+ typedef unsigned long uint64_t;
+ typedef signed long int64_t;
+ */
+typedef unsigned long long uint64_t;
+typedef long long int64_t;
+#endif
+
+/* Windows stuff */
+
+#if defined(WIN32) || defined(__WINS__) || defined(__MINGW32__) || defined(_MSC_VER)
+#define inline __inline
+#define snprintf _snprintf
+#define usleep(x) Sleep(((x)+999)/1000)
+
+#define HAS_FIBERS 1
+
+#define ON_WINDOWS 1
+
+// Enable fibers
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0400
+#endif
+
+// this also includes windows.h
+#include <winsock2.h>
+
+#if !defined(__MINGW32__)
+#if defined(BUILDING_BASEKIT_DLL) || defined(BUILDING_IOVMALL_DLL)
+#define BASEKIT_API __declspec(dllexport)
+#else
+#define BASEKIT_API __declspec(dllimport)
+#endif
+#else
+#define BASEKIT_API
+#endif
+/*
+#ifndef _SYS_STDINT_H_
+#include "PortableStdint.h"
+#endif
+ */
+
+#if !defined(__MINGW32__)
+/* disable compile warnings which are always treated
+as errors in my dev settings */
+
+#pragma warning( disable : 4244 )
+/* warning C4244: 'function' : conversion from 'double ' to 'int ', possible loss of data */
+
+#pragma warning( disable : 4996 )
+/* warning C4996: 'function' : This function or variable may be unsafe. Consider using 'function_s' instead */
+
+#pragma warning( disable : 4018 )
+/* warning C4018: 'operator' : signed/unsigned mismatch */
+
+/*#pragma warning( disable : 4090 ) */
+/* warning C4090: 'function' : different 'const' qualifiers  */
+
+/*#pragma warning( disable : 4024 )*/
+/* warning C4024: different types for formal and actual parameter  */
+
+/*#pragma warning( disable : 4761 ) */
+/* warning C4761: integral size mismatch in argument; conversion supplied  */
+
+/*#pragma warning( disable : 4047 ) */
+/* warning C4047: '=' : 'char *' differs in levels of indirection from 'int '  */
+#define ARCHITECTURE_x86 1
+#endif
+
+/* io_malloc, io_realloc, io_free undefined */
+#if !defined(__SYMBIAN32__)
+#include <memory.h>
+
+/* strlen undefined */
+#include <string.h>
+#include <malloc.h> /* for calloc */
+#endif
+#else
+
+// Not on windows so define this away
+#define BASEKIT_API
+
+#endif
+
+/*
+ [DBCS Enabling]
+
+ DBCS (Short for Double-Byte Character Set), a character set that uses two-byte (16-bit) characters. Some languages, such as Chinese, Japanese and Korean (CJK), have writing schemes with many different characters that cannot be represented with single-byte codes such as ASCII and EBCDIC.
+
+ In CJK world, CES (Character Encoding Scheme) and CCS (Coded Character Set) are actually different concept(one CES may contain multiple CCS).
+ For example, EUC-JP is a CES which includes CCS of ASCII and JIS X 0208 (optionally JIS X 0201 Kana and JIS X 0212).
+
+ In Japanese (because I am Japanese),
+ While EUC-JP and UTF-8 Map ASCII unchanged, ShiftJIS not (However ShiftJIS is de facto standard in Japan). For example, {0x95, 0x5c} represents one character. in ASCII, second byte(0x5c) is back slash character.
+ */
+
+/*
+ check whether double-byte character. supported only ShiftJIS.
+ if you want to use ShiftJIS characters in string literal, set compiler option -DDBCS_ENABLED=1.
+ */
+
+#if DBCS_ENABLED
+#define ismbchar(c)  ISSJIS((unsigned char)c)
+#define mbcharlen(c) 2
+#define ISSJIS(c)    ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xfc))
+#else
+#define ismbchar(c)   0
+#define mbcharlen(c)  1
+#endif  /* DBCS_ENABLED */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//#define IO_CHECK_ALLOC
+
+#ifdef IO_CHECK_ALLOC
+	BASEKIT_API size_t io_memsize(void *ptr);
+
+	#define io_malloc(size) io_real_malloc(size, __FILE__, __LINE__)
+	BASEKIT_API void *io_real_malloc(size_t size, char *file, int line);
+
+	#define io_calloc(count, size) io_real_calloc(count, size, __FILE__, __LINE__)
+	BASEKIT_API void *io_real_calloc(size_t count, size_t size, char *file, int line);
+
+	#define io_realloc(ptr, size) io_real_realloc(ptr, size, __FILE__, __LINE__)
+	BASEKIT_API void *io_real_realloc(void *ptr, size_t newSize, char *file, int line);
+
+	BASEKIT_API void io_free(void *ptr);
+	BASEKIT_API void io_show_mem(char *s);
+	BASEKIT_API size_t io_maxAllocatedBytes(void);
+	BASEKIT_API void io_resetMaxAllocatedBytes(void);
+	BASEKIT_API size_t io_frees(void);
+	BASEKIT_API size_t io_allocs(void);
+	BASEKIT_API size_t io_allocatedBytes(void);
+
+	BASEKIT_API void io_showUnfreed(void);
+#else
+	#define io_memsize
+	#define io_malloc malloc
+	#define io_calloc calloc
+	#define io_realloc io_freerealloc
+	#define io_free free
+	#define io_show_mem
+
+	#define io_maxAllocatedBytes() 0
+	#define io_frees() 0
+	#define io_allocs() 0
+	#define io_allocatedBytes() 0
+	#define io_resetMaxAllocatedBytes()
+#endif
+
+BASEKIT_API void *cpalloc(const void *p, size_t size);
+BASEKIT_API void *io_freerealloc(void *p, size_t size);
+
+int io_isBigEndian(void);
+BASEKIT_API uint32_t io_uint32InBigEndian(uint32_t i);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+
diff --git a/release/src/router/skipdbv2/basekit/Common_inline.h b/release/src/router/skipdbv2/basekit/Common_inline.h
new file mode 100644
index 0000000000..1e264fe59f
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Common_inline.h
@@ -0,0 +1,70 @@
+
+//metadoc Common copyright Steve Dekorte 2002
+//metadoc Common license BSD revised
+/*metadoc Common description
+You may need to add an entry for your C compiler.
+*/
+
+/*
+Trick to get inlining to work with various compilers
+Kudos to Daniel A. Koepke
+*/
+
+#undef IO_DECLARE_INLINES
+#undef IOINLINE
+
+/*
+#if defined(__cplusplus)
+	#ifdef IO_IN_C_FILE
+	#else
+		#define IO_DECLARE_INLINES
+		#define IOINLINE extern inline
+	#endif
+#else
+*/
+
+#if defined(__APPLE__)
+	#include "TargetConditionals.h"
+#endif
+
+#if defined __XCODE__ && (TARGET_ASPEN_SIMULATOR || TARGET_OS_ASPEN)
+	#define NON_EXTERN_INLINES
+#else
+	#if defined __GNUC__ && __GNUC__ >= 4
+		//#define NON_EXTERN_INLINES
+	#endif
+#endif
+
+#ifdef NON_EXTERN_INLINES
+
+#ifdef IO_IN_C_FILE
+	// in .c 
+	#define IO_DECLARE_INLINES
+	#define IOINLINE 
+#else
+	// in .h 
+	#define IO_DECLARE_INLINES
+	#define IOINLINE inline
+#endif 
+
+#else
+
+#ifdef IO_IN_C_FILE
+	// in .c 
+	#define IO_DECLARE_INLINES
+	#define IOINLINE inline
+#else
+	// in .h 
+	#define IO_DECLARE_INLINES
+#ifdef HND_ROUTER
+	#define IOINLINE inline
+#else
+	#define IOINLINE extern inline
+#endif 
+#endif 
+
+#endif
+
+/*
+#endif
+*/
diff --git a/release/src/router/skipdbv2/basekit/ConvertUTF.c b/release/src/router/skipdbv2/basekit/ConvertUTF.c
new file mode 100644
index 0000000000..edabc70c8a
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/ConvertUTF.c
@@ -0,0 +1,564 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to io_freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+Conversions between UTF32, UTF-16, and UTF-8. Source code file.
+Author: Mark E. Davis, 1994.
+Rev History: Rick McGowan, fixes & updates May 2001.
+Sept 2001: fixed const & error conditions per
+mods suggested by S. Parent & A. Lillich.
+June 2002: Tim Dodd added detection and handling of incomplete
+source sequences, enhanced error detection, added casts
+to eliminate compiler warnings.
+July 2003: slight mods to back out aggressive FFFE detection.
+Jan 2004: updated switches in from-UTF8 conversions.
+Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
+
+See the header file "ConvertUTF.h" for complete documentation.
+
+------------------------------------------------------------------------ */
+
+
+#include "ConvertUTF.h"
+#ifdef CVTUTF_DEBUG
+#include <stdio.h>
+#endif
+
+static const int halfShift  = 10; /* used for shifting by 10 bits */
+
+static const UTF32 halfBase = 0x0010000UL;
+static const UTF32 halfMask = 0x3FFUL;
+
+#define UNI_SUR_HIGH_START  (UTF32)0xD800
+#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
+#define UNI_SUR_LOW_START   (UTF32)0xDC00
+#define UNI_SUR_LOW_END     (UTF32)0xDFFF
+#define false   0
+#define true    1
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF16 (
+										const UTF32** sourceStart,
+										const UTF32* sourceEnd,
+										UTF16** targetStart,
+										UTF16* targetEnd,
+										ConversionFlags flags)
+{
+	ConversionResult result = conversionOK;
+	const UTF32* source = *sourceStart;
+	UTF16* target = *targetStart;
+
+	while (source < sourceEnd)
+	{
+		UTF32 ch;
+
+		if (target >= targetEnd)
+		{
+			result = targetExhausted; break;
+		}
+
+		ch = *source++;
+
+		if (ch <= UNI_MAX_BMP)
+		{ /* Target is a character <= 0xFFFF */
+			/* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
+			if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END)
+			{
+				if (flags == strictConversion)
+				{
+					--source; /* return to the illegal value itself */
+					result = sourceIllegal;
+					break;
+				}
+				else
+				{
+					*target++ = UNI_REPLACEMENT_CHAR;
+				}
+			}
+			else
+			{
+				*target++ = (UTF16)ch; /* normal case */
+			}
+		}
+		else if (ch > UNI_MAX_LEGAL_UTF32)
+		{
+			if (flags == strictConversion)
+			{
+				result = sourceIllegal;
+			}
+			else
+			{
+				*target++ = UNI_REPLACEMENT_CHAR;
+			}
+		}
+		else
+		{
+			/* target is a character in range 0xFFFF - 0x10FFFF. */
+			if (target + 1 >= targetEnd)
+			{
+				--source; /* Back up source pointer! */
+				result = targetExhausted; break;
+			}
+			ch -= halfBase;
+			*target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+			*target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+		}
+	}
+*sourceStart = source;
+*targetStart = target;
+return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF32 (
+										const UTF16** sourceStart, const UTF16* sourceEnd,
+										UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+	ConversionResult result = conversionOK;
+	const UTF16* source = *sourceStart;
+	UTF32* target = *targetStart;
+	UTF32 ch, ch2;
+	while (source < sourceEnd) {
+		const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
+		ch = *source++;
+		/* If we have a surrogate pair, convert to UTF32 first. */
+		if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+			/* If the 16 bits following the high surrogate are in the source buffer... */
+			if (source < sourceEnd) {
+				ch2 = *source;
+				/* If it's a low surrogate, convert to UTF32. */
+				if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+					ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+					+ (ch2 - UNI_SUR_LOW_START) + halfBase;
+					++source;
+				} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+					--source; /* return to the illegal value itself */
+					result = sourceIllegal;
+					break;
+				}
+			} else { /* We don't have the 16 bits following the high surrogate. */
+				--source; /* return to the high surrogate */
+				result = sourceExhausted;
+				break;
+			}
+		} else if (flags == strictConversion) {
+			/* UTF-16 surrogate values are illegal in UTF-32 */
+			if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+				--source; /* return to the illegal value itself */
+				result = sourceIllegal;
+				break;
+			}
+		}
+		if (target >= targetEnd) {
+			source = oldSource; /* Back up source pointer! */
+			result = targetExhausted; break;
+		}
+		*target++ = ch;
+	}
+	*sourceStart = source;
+	*targetStart = target;
+#ifdef CVTUTF_DEBUG
+	if (result == sourceIllegal) {
+		fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
+		fflush(stderr);
+	}
+#endif
+	return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Index into the table below with the first byte of a UTF-8 sequence to
+ * get the number of trailing bytes that are supposed to follow it.
+ * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
+ * left as-is for anyone who may want to do such conversion, which was
+ * allowed in earlier algorithms.
+ */
+static const char trailingBytesForUTF8[256] = {
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+/*
+ * Magic values subtracted from a buffer value during UTF8 conversion.
+ * This table contains as many values as there might be trailing bytes
+ * in a UTF-8 sequence.
+ */
+static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
+	0x03C82080UL, 0xFA082080UL, 0x82082080UL };
+
+/*
+ * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
+ * into the first byte, depending on how many bytes follow.  There are
+ * as many entries in this table as there are UTF-8 sequence types.
+ * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
+ * for *legal* UTF-8 will be 4 or fewer bytes total.
+ */
+static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+/* --------------------------------------------------------------------- */
+
+/* The interface converts a whole buffer to avoid function-call overhead.
+* Constants have been gathered. Loops & conditionals have been removed as
+* much as possible for efficiency, in favor of drop-through switches.
+* (See "Note A" at the bottom of the file for equivalent code.)
+* If your compiler supports it, the "isLegalUTF8" call can be turned
+* into an inline function.
+*/
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF8 (
+									 const UTF16** sourceStart, const UTF16* sourceEnd,
+									 UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+	ConversionResult result = conversionOK;
+	const UTF16* source = *sourceStart;
+	UTF8* target = *targetStart;
+	while (source < sourceEnd) {
+		UTF32 ch;
+		unsigned short bytesToWrite = 0;
+		const UTF32 byteMask = 0xBF;
+		const UTF32 byteMark = 0x80;
+		const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
+		ch = *source++;
+		/* If we have a surrogate pair, convert to UTF32 first. */
+		if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+			/* If the 16 bits following the high surrogate are in the source buffer... */
+			if (source < sourceEnd) {
+				UTF32 ch2 = *source;
+				/* If it's a low surrogate, convert to UTF32. */
+				if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+					ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+					+ (ch2 - UNI_SUR_LOW_START) + halfBase;
+					++source;
+				} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+					--source; /* return to the illegal value itself */
+					result = sourceIllegal;
+					break;
+				}
+			} else { /* We don't have the 16 bits following the high surrogate. */
+				--source; /* return to the high surrogate */
+				result = sourceExhausted;
+				break;
+			}
+		} else if (flags == strictConversion) {
+			/* UTF-16 surrogate values are illegal in UTF-32 */
+			if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+				--source; /* return to the illegal value itself */
+				result = sourceIllegal;
+				break;
+			}
+		}
+		/* Figure out how many bytes the result will require */
+		if (ch < (UTF32)0x80) {             bytesToWrite = 1;
+		} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+		} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+		} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
+		} else {                            bytesToWrite = 3;
+			ch = UNI_REPLACEMENT_CHAR;
+		}
+
+		target += bytesToWrite;
+		if (target > targetEnd) {
+			source = oldSource; /* Back up source pointer! */
+			target -= bytesToWrite; result = targetExhausted; break;
+		}
+		switch (bytesToWrite) { /* note: everything falls through. */
+			case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+		}
+		target += bytesToWrite;
+	}
+*sourceStart = source;
+*targetStart = target;
+return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Utility routine to tell whether a sequence of bytes is legal UTF-8.
+ * This must be called with the length pre-determined by the first byte.
+ * If not calling this from ConvertUTF8to*, then the length can be set by:
+ *  length = trailingBytesForUTF8[*source]+1;
+ * and the sequence is illegal right away if there aren't that many bytes
+ * available.
+ * If presented with a length > 4, this returns false.  The Unicode
+ * definition of UTF-8 goes up to 4-byte sequences.
+ */
+
+static Boolean isLegalUTF8(const UTF8 *source, int length) {
+	UTF8 a;
+	const UTF8 *srcptr = source+length;
+	switch (length) {
+		default: return false;
+			/* Everything else falls through when "true"... */
+		case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+		case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+		case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+
+			switch (*source) {
+				/* no fall-through in this inner switch */
+				case 0xE0: if (a < 0xA0) return false; break;
+				case 0xED: if (a > 0x9F) return false; break;
+				case 0xF0: if (a < 0x90) return false; break;
+				case 0xF4: if (a > 0x8F) return false; break;
+				default:   if (a < 0x80) return false;
+			}
+
+			case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+	}
+	if (*source > 0xF4) return false;
+	return true;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Exported function to return whether a UTF-8 sequence is legal or not.
+ * This is not used here; it's just exported.
+ */
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
+	int length = trailingBytesForUTF8[*source]+1;
+	if (source+length > sourceEnd) {
+		return false;
+	}
+	return isLegalUTF8(source, length);
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF16 (
+									 const UTF8** sourceStart, const UTF8* sourceEnd,
+									 UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+	ConversionResult result = conversionOK;
+	const UTF8* source = *sourceStart;
+	UTF16* target = *targetStart;
+	while (source < sourceEnd) {
+		UTF32 ch = 0;
+		unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+		if (source + extraBytesToRead >= sourceEnd) {
+			result = sourceExhausted; break;
+		}
+		/* Do this check whether lenient or strict */
+		if (! isLegalUTF8(source, extraBytesToRead+1)) {
+			result = sourceIllegal;
+			break;
+		}
+		/*
+		 * The cases all fall through. See "Note A" below.
+		 */
+		switch (extraBytesToRead) {
+			case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+			case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+			case 3: ch += *source++; ch <<= 6;
+			case 2: ch += *source++; ch <<= 6;
+			case 1: ch += *source++; ch <<= 6;
+			case 0: ch += *source++;
+		}
+		ch -= offsetsFromUTF8[extraBytesToRead];
+
+		if (target >= targetEnd) {
+			source -= (extraBytesToRead+1); /* Back up source pointer! */
+			result = targetExhausted; break;
+		}
+		if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+			/* UTF-16 surrogate values are illegal in UTF-32 */
+			if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+				if (flags == strictConversion) {
+					source -= (extraBytesToRead+1); /* return to the illegal value itself */
+					result = sourceIllegal;
+					break;
+				} else {
+					*target++ = UNI_REPLACEMENT_CHAR;
+				}
+			} else {
+				*target++ = (UTF16)ch; /* normal case */
+			}
+		} else if (ch > UNI_MAX_UTF16) {
+			if (flags == strictConversion) {
+				result = sourceIllegal;
+				source -= (extraBytesToRead+1); /* return to the start */
+				break; /* Bail out; shouldn't continue */
+			} else {
+				*target++ = UNI_REPLACEMENT_CHAR;
+			}
+		} else {
+			/* target is a character in range 0xFFFF - 0x10FFFF. */
+			if (target + 1 >= targetEnd) {
+				source -= (extraBytesToRead+1); /* Back up source pointer! */
+				result = targetExhausted; break;
+			}
+			ch -= halfBase;
+			*target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+			*target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+		}
+	}
+*sourceStart = source;
+*targetStart = target;
+return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF8 (
+									 const UTF32** sourceStart, const UTF32* sourceEnd,
+									 UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+	ConversionResult result = conversionOK;
+	const UTF32* source = *sourceStart;
+	UTF8* target = *targetStart;
+	while (source < sourceEnd) {
+		UTF32 ch;
+		unsigned short bytesToWrite = 0;
+		const UTF32 byteMask = 0xBF;
+		const UTF32 byteMark = 0x80;
+		ch = *source++;
+		if (flags == strictConversion ) {
+			/* UTF-16 surrogate values are illegal in UTF-32 */
+			if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+				--source; /* return to the illegal value itself */
+				result = sourceIllegal;
+				break;
+			}
+		}
+		/*
+		 * Figure out how many bytes the result will require. Turn any
+		 * illegally large UTF32 things (> Plane 17) into replacement chars.
+		 */
+		if (ch < (UTF32)0x80) {                  bytesToWrite = 1;
+		} else if (ch < (UTF32)0x800) {          bytesToWrite = 2;
+		} else if (ch < (UTF32)0x10000) {        bytesToWrite = 3;
+		} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
+		} else {                                 bytesToWrite = 3;
+			ch = UNI_REPLACEMENT_CHAR;
+			result = sourceIllegal;
+		}
+
+		target += bytesToWrite;
+		if (target > targetEnd) {
+			--source; /* Back up source pointer! */
+			target -= bytesToWrite; result = targetExhausted; break;
+		}
+		switch (bytesToWrite) { /* note: everything falls through. */
+			case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+			case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
+		}
+		target += bytesToWrite;
+	}
+*sourceStart = source;
+*targetStart = target;
+return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF32 (
+									 const UTF8** sourceStart, const UTF8* sourceEnd,
+									 UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+	ConversionResult result = conversionOK;
+	const UTF8* source = *sourceStart;
+	UTF32* target = *targetStart;
+	while (source < sourceEnd) {
+		UTF32 ch = 0;
+		unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+		if (source + extraBytesToRead >= sourceEnd) {
+			result = sourceExhausted; break;
+		}
+		/* Do this check whether lenient or strict */
+		if (! isLegalUTF8(source, extraBytesToRead+1)) {
+			result = sourceIllegal;
+			break;
+		}
+		/*
+		 * The cases all fall through. See "Note A" below.
+		 */
+		switch (extraBytesToRead) {
+			case 5: ch += *source++; ch <<= 6;
+			case 4: ch += *source++; ch <<= 6;
+			case 3: ch += *source++; ch <<= 6;
+			case 2: ch += *source++; ch <<= 6;
+			case 1: ch += *source++; ch <<= 6;
+			case 0: ch += *source++;
+		}
+		ch -= offsetsFromUTF8[extraBytesToRead];
+
+		if (target >= targetEnd) {
+			source -= (extraBytesToRead+1); /* Back up the source pointer! */
+			result = targetExhausted; break;
+		}
+		if (ch <= UNI_MAX_LEGAL_UTF32) {
+			/*
+			 * UTF-16 surrogate values are illegal in UTF-32, and anything
+			 * over Plane 17 (> 0x10FFFF) is illegal.
+			 */
+			if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+				if (flags == strictConversion) {
+					source -= (extraBytesToRead+1); /* return to the illegal value itself */
+					result = sourceIllegal;
+					break;
+				} else {
+					*target++ = UNI_REPLACEMENT_CHAR;
+				}
+			} else {
+				*target++ = ch;
+			}
+		} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
+			result = sourceIllegal;
+			*target++ = UNI_REPLACEMENT_CHAR;
+		}
+	}
+	*sourceStart = source;
+	*targetStart = target;
+	return result;
+}
+
+/* ---------------------------------------------------------------------
+
+Note A.
+The fall-through switches in UTF-8 reading code save a
+temp variable, some decrements & conditionals.  The switches
+are equivalent to the following loop:
+{
+		int tmpBytesToRead = extraBytesToRead+1;
+		do {
+			ch += *source++;
+			--tmpBytesToRead;
+			if (tmpBytesToRead) ch <<= 6;
+		} while (tmpBytesToRead > 0);
+}
+In UTF-8 writing code, the switches on "bytesToWrite" are
+similarly unrolled loops.
+
+--------------------------------------------------------------------- */
diff --git a/release/src/router/skipdbv2/basekit/ConvertUTF.h b/release/src/router/skipdbv2/basekit/ConvertUTF.h
new file mode 100644
index 0000000000..57686a45d2
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/ConvertUTF.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to io_freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+	Conversions between UTF32, UTF-16, and UTF-8.  Header file.
+
+	Several funtions are included here, forming a complete set of
+	conversions between the three formats.  UTF-7 is not included
+	here, but is handled in a separate source file.
+
+	Each of these routines takes pointers to input buffers and output
+	buffers.  The input buffers are const.
+
+	Each routine converts the text between *sourceStart and sourceEnd,
+	putting the result into the buffer between *targetStart and
+	targetEnd. Note: the end pointers are *after* the last item: e.g.
+	*(sourceEnd - 1) is the last item.
+
+	The return result indicates whether the conversion was successful,
+	and if not, whether the problem was in the source or target buffers.
+	(Only the first encountered problem is indicated.)
+
+	After the conversion, *sourceStart and *targetStart are both
+	updated to point to the end of last text successfully converted in
+	the respective buffers.
+
+	Input parameters:
+	sourceStart - pointer to a pointer to the source buffer.
+		The contents of this are modified on return so that
+		it points at the next thing to be converted.
+	targetStart - similarly, pointer to pointer to the target buffer.
+	sourceEnd, targetEnd - respectively pointers to the ends of the
+		two buffers, for overflow checking only.
+
+	These conversion functions take a ConversionFlags argument. When this
+	flag is set to strict, both irregular sequences and isolated surrogates
+	will cause an error.  When the flag is set to lenient, both irregular
+	sequences and isolated surrogates are converted.
+
+	Whether the flag is strict or lenient, all illegal sequences will cause
+	an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
+	or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
+	must check for illegal sequences.
+
+	When the flag is set to lenient, characters over 0x10FFFF are converted
+	to the replacement character; otherwise (when the flag is set to strict)
+	they constitute an error.
+
+	Output parameters:
+	The value "sourceIllegal" is returned from some routines if the input
+	sequence is malformed.  When "sourceIllegal" is returned, the source
+	value will point to the illegal value that caused the problem. E.g.,
+	in UTF-8 when a sequence is malformed, it points to the start of the
+	malformed sequence.
+
+	Author: Mark E. Davis, 1994.
+	Rev History: Rick McGowan, fixes & updates May 2001.
+		 Fixes & updates, Sept 2001.
+
+------------------------------------------------------------------------ */
+
+/* ---------------------------------------------------------------------
+	The following 4 definitions are compiler-specific.
+	The C standard does not guarantee that wchar_t has at least
+	16 bits, so wchar_t is no less portable than unsigned short!
+	All should be unsigned values to avoid sign extension during
+	bit mask & shift operations.
+------------------------------------------------------------------------ */
+
+typedef unsigned long   UTF32;   /* at least 32 bits */
+typedef unsigned short  UTF16;   /* at least 16 bits */
+typedef unsigned char   UTF8;    /* typically 8 bits */
+typedef unsigned char   Boolean; /* 0 or 1 */
+
+/* Some fundamental constants */
+#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
+#define UNI_MAX_BMP (UTF32)0x0000FFFF
+#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
+#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
+#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
+
+typedef enum {
+	conversionOK,       /* conversion successful */
+	sourceExhausted,    /* partial character in source, but hit end */
+	targetExhausted,    /* insuff. room in target for conversion */
+	sourceIllegal       /* source sequence is illegal/malformed */
+} ConversionResult;
+
+typedef enum {
+	strictConversion = 0,
+	lenientConversion
+} ConversionFlags;
+
+/* This is for C++ and does no harm in C */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ConversionResult ConvertUTF8toUTF16 (
+		const UTF8** sourceStart, const UTF8* sourceEnd,
+		UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF8 (
+		const UTF16** sourceStart, const UTF16* sourceEnd,
+		UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF8toUTF32 (
+		const UTF8** sourceStart, const UTF8* sourceEnd,
+		UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF8 (
+		const UTF32** sourceStart, const UTF32* sourceEnd,
+		UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF32 (
+		const UTF16** sourceStart, const UTF16* sourceEnd,
+		UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF16 (
+		const UTF32** sourceStart, const UTF32* sourceEnd,
+		UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* --------------------------------------------------------------------- */
diff --git a/release/src/router/skipdbv2/basekit/Date.c b/release/src/router/skipdbv2/basekit/Date.c
new file mode 100644
index 0000000000..5c74090733
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Date.c
@@ -0,0 +1,339 @@
+
+//metadoc Date copyright Steve Dekorte 2002
+//metadoc Date license BSD revised
+
+#define DATE_C
+#include "Date.h"
+#undef DATE_C
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <math.h>
+#include "PortableStrptime.h"
+#include "UArray.h"
+
+Date *Date_new(void)
+{
+	Date *self = (Date *)io_calloc(1, sizeof(Date));
+	Date_now(self);
+	return self;
+}
+
+void Date_copy_(Date *self, const Date *other)
+{
+	memcpy(self, other, sizeof(Date));
+}
+
+void Date_free(Date *self)
+{
+	io_free(self);
+}
+
+int Date_compare(const Date *self, const Date *other)
+{
+	double s1 = Date_asSeconds(self);
+	double s2 = Date_asSeconds(other);
+
+	if (s1 == s2)
+	{
+		return 0;
+	}
+
+	return s1 > s2 ? 1 : -1;
+}
+
+double Date_SecondsFrom1970ToNow(void)
+{
+	double s, us;
+	struct timeval timeval;
+	struct timezone timezone;
+
+	gettimeofday(&timeval, &timezone);
+	s = timeval.tv_sec;
+	//s -= timezone.tz_minuteswest * 60;
+	us = timeval.tv_usec;
+
+	return s + (us/1000000.0); /* + (60*60);*/
+}
+
+void Date_now(Date *self)
+{
+	double s, us;
+	struct timeval timeval;
+	struct timezone timezone;
+
+	gettimeofday(&timeval, &timezone);
+	s = timeval.tv_sec;
+	s -= timezone.tz_minuteswest * 60;
+	us = timeval.tv_usec;
+
+	self->tv = timeval;
+	self->tz = timezone;
+}
+
+double Date_Clock(void)
+{
+	return ((double)clock())/((double)CLOCKS_PER_SEC);
+}
+
+// zone --------------------------------------------------------
+
+void Date_setToLocalTimeZone(Date *self)
+{
+	struct timeval timeval;
+	gettimeofday(&timeval, &(self->tz));
+}
+
+struct timezone Date_timeZone(const Date *self)
+{
+	return self->tz;
+}
+
+void Date_setTimeZone_(Date *self, struct timezone tz)
+{
+	self->tz = tz;
+}
+
+void Date_convertToTimeZone_(Date *self, struct timezone tz)
+{
+	double s = Date_asSeconds(self) +
+	((self->tz.tz_minuteswest - tz.tz_minuteswest) * 60);
+	Date_fromSeconds_(self, s);
+	Date_setTimeZone_(self, tz);
+}
+
+// time --------------------------------------------------------
+
+void Date_fromLocalTime_(Date *self, struct tm *t)
+{
+	Date_fromTime_(self, mktime(t));
+}
+
+void Date_fromTime_(Date *self, time_t t)
+{
+	Date_fromSeconds_(self, (double)t);
+}
+
+time_t Date_asTime(const Date *self)
+{
+	return (time_t)self->tv.tv_sec;
+}
+
+// sconds --------------------------------------------------------
+
+double Date_asSeconds(const Date *self)
+{
+	return ((double)self->tv.tv_sec) + (((double)self->tv.tv_usec) / 1000000.0);
+}
+
+void Date_fromSeconds_(Date *self, double s)
+{
+	long secs = s;
+	self->tv.tv_sec = secs;
+	self->tv.tv_usec = (s - secs)*1000000;
+}
+
+void Date_addSeconds_(Date *self, double s)
+{
+	long secs = s;
+	self->tv.tv_sec += secs;
+	self->tv.tv_usec += (s - secs)*1000000;
+}
+
+double Date_secondsSince_(const Date *self, const Date *other)
+{
+	return Date_asSeconds(self) - Date_asSeconds(other);
+}
+
+// components --------------------------------------------------------
+
+long Date_year(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return tm->tm_year + 1900;
+}
+
+void Date_setYear_(Date *self, long v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_year = v - 1900;
+	self->tv.tv_sec = mktime(tm);
+}
+
+int Date_month(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return tm->tm_mon;
+}
+
+void Date_setMonth_(Date *self, int v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_mon = v;
+	self->tv.tv_sec = mktime(tm);
+}
+
+int Date_day(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return tm->tm_mday;
+}
+
+void Date_setDay_(Date *self, int v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_mday = v;
+	self->tv.tv_sec = mktime(tm);
+}
+
+int Date_hour(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return tm->tm_hour;
+}
+
+void Date_setHour_(Date *self, int v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_hour = v;
+	self->tv.tv_sec = mktime(tm);
+}
+
+int Date_minute(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return tm->tm_min;
+}
+
+void Date_setMinute_(Date *self, int v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_min = v;
+	self->tv.tv_sec = mktime(tm);
+}
+
+double Date_second(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return ((double)tm->tm_sec) + ((double)self->tv.tv_usec)/1000000.0;
+}
+
+void Date_setSecond_(Date *self, double v)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	tm->tm_sec = v;
+	self->tv.tv_sec = mktime(tm);
+	self->tv.tv_usec = (v - ((long)v))*1000000;
+}
+
+unsigned char Date_isDaylightSavingsTime(const Date *self)
+{
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+	return (unsigned char)tm->tm_isdst;
+}
+
+int Date_isLeapYear(const Date *self)
+{
+	int year = Date_year(self);
+
+	if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0))
+	{
+		return 1;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+// format --------------------------------------------------------
+
+static struct tm EmptyTM(void)
+{
+	time_t tmp = 0;
+	struct tm *tt = localtime(&tmp);
+	struct tm t;
+
+	memcpy(&t, tt, sizeof(struct tm));
+	t.tm_sec  = 0;
+	t.tm_min  = 0;
+	t.tm_hour = 0;
+	t.tm_mday = 0;
+	t.tm_mon  = 0;
+	t.tm_year = 0;
+	t.tm_wday = 0;
+	t.tm_yday = 0;
+	return t;
+}
+
+void Date_fromString_format_(Date *self, const char *s, const char *format)
+{
+	struct tm tm = EmptyTM();
+	io_strptime((char *)s, (char *)format, &tm);
+	/*
+	printf("year  = %i\n", t.tm_year);
+	printf("month = %i\n", t.tm_mon);
+	printf("day   = %i\n", t.tm_mday);
+	printf("hour  = %i\n", t.tm_hour);
+	printf("min   = %i\n", t.tm_min);
+	printf("sec   = %i\n", t.tm_sec);
+	*/
+	Date_fromSeconds_(self, mktime(&tm));
+}
+
+// durations --------------------------------------------------------
+
+Duration *Date_newDurationBySubtractingDate_(const Date *self, const Date *other)
+{
+	double d = Date_secondsSince_(self, other);
+	return Duration_newWithSeconds_(d);
+}
+
+void Date_addDuration_(Date *self, const Duration *d)
+{
+	Date_addSeconds_(self, Duration_asSeconds(d));
+}
+
+void Date_subtractDuration_(Date *self, const Duration *d)
+{
+	Date_addSeconds_(self, -Duration_asSeconds(d));
+}
+
+// -----------------------------------------------------------
+
+double Date_secondsSinceNow(const Date *self)
+{
+	double n = Date_SecondsFrom1970ToNow();
+	double s = Date_asSeconds(self);
+	return n - s;
+}
+
+// format --------------------------------------------------------
+
+UArray *Date_asString(const Date *self, const char *format)
+{
+	UArray *u = UArray_new();
+	time_t t = self->tv.tv_sec;
+	struct tm *tm = localtime(&t);
+
+	// what about unicode formats?
+	UArray_setSize_(u, 1024 + strlen(format));
+	strftime((char *)UArray_bytes(u), 1024, format, tm);
+	UArray_setSize_(u, strlen((char *)UArray_bytes(u)));
+
+	return u;
+}
diff --git a/release/src/router/skipdbv2/basekit/Date.h b/release/src/router/skipdbv2/basekit/Date.h
new file mode 100644
index 0000000000..cc5ed05f02
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Date.h
@@ -0,0 +1,94 @@
+//metadoc Date copyright Steve Dekorte 2002
+//metadoc Date license BSD revised
+
+#include "Base.h"
+
+#ifndef DATE_DEFINED
+#define DATE_DEFINED 1
+
+#include "Common.h"
+#include "Duration.h"
+#include "PortableGettimeofday.h"
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+	struct timeval  tv;
+	struct timezone tz;
+} Date;
+
+BASEKIT_API double Date_SecondsFrom1970ToNow(void);
+
+BASEKIT_API Date *Date_new(void);
+BASEKIT_API void Date_copy_(Date *self, const Date *other);
+BASEKIT_API void Date_free(Date *self);
+BASEKIT_API int Date_compare(const Date *self, const Date *other);
+
+BASEKIT_API void Date_now(Date *self);
+BASEKIT_API void Date_setToLocalTimeZone(Date *self);
+BASEKIT_API double Date_Clock(void);
+
+BASEKIT_API void Date_fromLocalTime_(Date *self, struct tm *t);
+BASEKIT_API void Date_fromTime_(Date *self, time_t t);
+BASEKIT_API time_t Date_asTime(const Date *self);
+
+// zone
+
+BASEKIT_API void Date_setToLocalTimeZone(Date *self);
+struct timezone Date_timeZone(const Date *self);
+BASEKIT_API void Date_setTimeZone_(Date *self, struct timezone tz);
+BASEKIT_API void Date_convertToTimeZone_(Date *self, struct timezone tz);
+
+// components
+
+BASEKIT_API void Date_setYear_(Date *self, long y);
+BASEKIT_API long Date_year(const Date *self);
+
+BASEKIT_API void Date_setMonth_(Date *self, int m);
+BASEKIT_API int Date_month(const Date *self);
+
+BASEKIT_API void Date_setDay_(Date *self, int d);
+BASEKIT_API int Date_day(const Date *self);
+
+BASEKIT_API void Date_setHour_(Date *self, int h);
+BASEKIT_API int Date_hour(const Date *self);
+
+BASEKIT_API void Date_setMinute_(Date *self, int m);
+BASEKIT_API int Date_minute(const Date *self);
+
+BASEKIT_API void Date_setSecond_(Date *self, double s);
+BASEKIT_API double Date_second(const Date *self);
+
+BASEKIT_API unsigned char Date_isDaylightSavingsTime(const Date *self);
+BASEKIT_API int Date_isLeapYear(const Date *self);
+
+// seconds
+
+BASEKIT_API double Date_asSeconds(const Date *self);
+BASEKIT_API void Date_fromSeconds_(Date *self, double s);
+
+BASEKIT_API void Date_addSeconds_(Date *self, double s);
+BASEKIT_API double Date_secondsSince_(const Date *self, const Date *other);
+
+// format
+
+BASEKIT_API void Date_fromString_format_(Date *self, const char *s, const char *format);
+
+// durations
+
+BASEKIT_API Duration *Date_newDurationBySubtractingDate_(const Date *self, const Date *other);
+BASEKIT_API void Date_addDuration_(Date *self, const Duration *d);
+BASEKIT_API void Date_subtractDuration_(Date *self, const Duration *d);
+
+BASEKIT_API double Date_secondsSinceNow(const Date *self);
+
+BASEKIT_API UArray *Date_asString(const Date *self, const char *format);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Datum.c b/release/src/router/skipdbv2/basekit/Datum.c
new file mode 100644
index 0000000000..d809157801
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Datum.c
@@ -0,0 +1,329 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("Datum")    
+*/
+
+#include "Datum.h"
+#include "List.h"
+#include "UArray.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+PID_TYPE Datum_size(Datum *self)
+{
+	return self->size;
+}
+
+unsigned char *Datum_data(Datum *self)
+{
+	return self->data;
+}
+
+void *Datum_asUArray(Datum *self)
+{
+	return UArray_newWithData_type_size_copy_(self->data, CENCODING_UTF8, self->size, 0);
+}
+
+Datum Datum_FromData_length_(unsigned char *data, PID_TYPE size)
+{
+	Datum d;
+	d.data = data;
+	d.size = size;
+	return d;
+}
+
+Datum Datum_FromCString_(const char *s)
+{
+	Datum d;
+	d.data = (unsigned char *)s;
+	d.size = strlen(s) + 1;
+	return d;
+}
+
+/*
+Datum Datum_FromPid_(PID_TYPE pid)
+{
+	Datum d;
+	d.data = (unsigned char *)&pid;
+	d.size = sizeof(PID_TYPE);
+	return d;
+}
+*/
+
+Datum Datum_FromUArray_(UArray *ba)
+{
+	Datum d;
+	d.data = (unsigned char *)UArray_bytes(ba);
+	d.size = UArray_sizeInBytes(ba);
+	return d;
+}
+
+Datum Datum_Empty(void)
+{
+	Datum d;
+	d.data = NULL;
+	d.size = 0;
+	return d;
+}
+
+Datum Datum_datumAt_(Datum *self, size_t i)
+{
+	Datum d;
+	
+	if (i < self->size)
+	{
+		d.data = self->data + i;
+		d.size = self->size - i;
+	}
+	else
+	{
+		d.data = NULL;
+		d.size = 0;
+	}
+	
+	return d;
+}
+
+
+int Datum_compare_(Datum *self, Datum *other)
+{
+	size_t l1 = self->size;
+	size_t l2 = other->size;
+	size_t min = l1 < l2 ? l1 : l2;
+	int cmp = memcmp(self->data, other->data, min);
+	
+	if (cmp == 0)
+	{
+		if (l1 == l2) 
+		{
+			return 0;
+		}
+		
+		if (l1 < l2)
+		{
+			return -1;
+		}
+		
+		return 1;
+	}
+	
+	return cmp;
+}
+
+int Datum_compare_length_(Datum *self, Datum *other, size_t limit)
+{
+	size_t l1 = self->size;
+	size_t l2 = other->size;
+	size_t min = l1 < l2 ? l1 : l2;
+	
+	min = min < limit ? min : limit;
+	
+	return memcmp(self->data, other->data, min);
+}
+
+int Datum_beginsWith_(Datum *self, Datum *other)
+{
+	if (self->size >= other->size)
+	{
+		return (0 == Datum_compare_length_(self, other, other->size));
+	}
+	
+	return 0;
+}
+
+int Datum_endsWith_(Datum *self, Datum *other)
+{
+	if (self->size >= other->size)
+	{
+		Datum d = Datum_datumAt_(self, self->size - other->size); 
+		return (0 == Datum_compare_(&d, other));
+	}
+	
+	return 0;
+}
+
+int Datum_compareCString_(Datum *self, const char *s)
+{
+	Datum sd = Datum_FromCString_(s);
+	return Datum_compare_(self, &sd);
+}
+
+size_t Datum_matchingPrefixSizeWith_(Datum *self, Datum *other)
+{
+	unsigned int l1 = self->size;
+	unsigned int l2 = other->size;
+	unsigned int min = l1 < l2 ? l1 : l2;
+	unsigned char *b1 = self->data;
+	unsigned char *b2 = other->data;
+	size_t i;
+	
+	for (i = 0; i < min; i ++)
+	{
+		if (*b1 != *b2) break;
+		*b1 ++;
+		*b2 ++;
+	}
+	
+	return i;
+}
+
+Datum *Datum_newFrom_to_(Datum *self, size_t start, size_t end)
+{
+	Datum *d = (Datum *)malloc(sizeof(Datum));
+	
+	if ((start < end) && (end <= (size_t)self->size))
+	{
+		d->data = self->data + start;
+		d->size = end - start;
+		return d;
+	}
+	
+	d->data = NULL;
+	d->size = 0;
+	return d;
+}
+
+long Datum_find_(Datum *self, void *delimsList, size_t startIndex) 
+{
+	List *delims = (List *)delimsList;
+	List *results = List_new();
+	size_t i, last = 0;
+	
+	if (startIndex > self->size) return -1;
+	
+	for (i = startIndex; i < self->size; i ++)
+	{
+		Datum d = Datum_datumAt_(self, i);
+		size_t j; 
+		
+		for (j = 0; j < (size_t)List_size(delims); j ++)
+		{
+			Datum *delim = (Datum *)List_at_(delims, j);
+			
+			if (Datum_beginsWith_(&d, delim))
+			{
+				return i;
+			}
+		}
+	}
+	
+	return -1;
+}
+
+
+void *Datum_split_(Datum *self, void *delimsList) /* returns a List */
+{
+	List *delims = (List *)delimsList;
+	List *results = List_new();
+	size_t i, last = 0;
+	
+	for (i = 0; i < self->size; i ++)
+	{
+		Datum d = Datum_datumAt_(self, i);
+		size_t j; 
+		
+		for (j = 0; j < (size_t)List_size(delims); j ++)
+		{
+			Datum *delim = (Datum *)List_at_(delims, j);
+			
+			if (Datum_beginsWith_(&d, delim))
+			{
+                                List_append_(results, Datum_newFrom_to_(self, last, i));
+				
+				last = i + delim->size;
+				i = last - 1; /* since for() will increment it */
+				break;
+			}
+		}
+	}
+	
+	if (last != self->size)
+	{
+		List_append_(results, Datum_newFrom_to_(self, last, self->size));
+	}
+	
+	return results;
+}
+
+
+// enumeration 
+
+/*
+ int Datum_next(Datum *self)
+ {
+	 if (self->size)
+	 {
+		 self->data ++;
+		 self->size --;
+		 return 1;
+	 }
+	 return 0;
+ }
+ */
+
+unsigned int Datum_hash(Datum *self)
+{
+	PID_TYPE length = self->size;
+	unsigned char *key = self->data;
+	unsigned int h = 5381;
+	
+	while (length-- > 0)
+	{
+		h += (h << 5); /* h(i) = (h(i-1) * 33) ^ key(i) */
+		h ^= *key ++;
+	}
+	
+	return h;
+}
+
+/*
+ typedef int (DatumDetectWithFunc)(void *, Datum *); // 1 = match, -1 = break 
+ 
+ int Datum_detect_withTarget_(Datum *self, DatumDetectWithFunc *func, void *target)
+ {
+	 unsigned char *s   = self->data;
+	 unsigned char *end = self->data + self->size;
+	 
+	 Datum d;
+	 int result;
+	 
+	 while (s < end)
+	 {
+		 d.data = s;
+		 d.size = end - s;
+		 result = (*func)(target, &d);
+		 
+		 if (result == 1) 
+		 {
+			 return s - self->bytes;
+		 } 
+		 else if (result == -1)
+		 {
+			 return -1;
+		 }
+		 
+		 s ++;
+	 }
+	 
+	 return -1;
+ }
+ */
+
+/*
+ Datum Datum_datumUntil_withTarget_(Datum *self, DatumDetectWithFunc *func, void *target)
+ {
+	 int index = Datum_detect_withTarget_(self, func, target);
+	 Datum chunk;
+	 
+	 if (index == -1) 
+	 {
+		 index = length; 
+	 }
+	 
+	 d.data = self->data + index;
+	 d.size = self->size - index;
+	 return d;
+ }
+ */
diff --git a/release/src/router/skipdbv2/basekit/Datum.h b/release/src/router/skipdbv2/basekit/Datum.h
new file mode 100644
index 0000000000..2f6f5a8be9
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Datum.h
@@ -0,0 +1,67 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("Datum")    
+*/
+
+#ifndef Datum_DEFINED
+#define Datum_DEFINED 1
+
+#include "Common.h"
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+//#define PID_TYPE uint32_t
+#define PID_TYPE size_t
+#define PID_FORMAT "zi"
+
+typedef struct
+{
+    PID_TYPE size;
+    unsigned char *data;
+} Datum;
+
+BASEKIT_API PID_TYPE Datum_size(Datum *self);
+BASEKIT_API unsigned char *Datum_data(Datum *self);
+
+// return stack allocated datums 
+
+BASEKIT_API Datum Datum_FromData_length_(unsigned char *data, PID_TYPE size);
+BASEKIT_API Datum Datum_FromCString_(const char *s);
+//Datum Datum_FromPid_(PID_TYPE pid);
+BASEKIT_API Datum Datum_Empty(void);
+
+BASEKIT_API Datum Datum_datumAt_(Datum *self, size_t i);
+BASEKIT_API Datum *Datum_newFrom_to_(Datum *self, size_t start, size_t end);
+
+// comparison
+
+BASEKIT_API int Datum_compare_length_(Datum *self, Datum *other, size_t limit);
+BASEKIT_API int Datum_compare_(Datum *self, Datum *other);
+BASEKIT_API int Datum_compareCString_(Datum *self, const char *s);
+BASEKIT_API int Datum_beginsWith_(Datum *self, Datum *other);
+BASEKIT_API int Datum_endsWith_(Datum *self, Datum *other);
+BASEKIT_API size_t Datum_matchingPrefixSizeWith_(Datum *self, Datum *other);
+
+BASEKIT_API long Datum_find_(Datum *self, void *delimsList, size_t startIndex);
+BASEKIT_API void *Datum_split_(Datum *self, void *delims); /* returns a List */
+
+//int Datum_next(Datum *self);
+
+BASEKIT_API unsigned int Datum_hash(Datum *self);
+
+typedef int (DatumDetectWithFunc)(void *, Datum *); /* 1 = match, -1 = break */
+BASEKIT_API int Datum_detect_with_(Datum *self, DatumDetectWithFunc *func, void *target);
+
+#include "UArray.h"
+
+BASEKIT_API Datum Datum_FromUArray_(UArray *ba);
+BASEKIT_API void *Datum_asUArray(Datum *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Duration.c b/release/src/router/skipdbv2/basekit/Duration.c
new file mode 100644
index 0000000000..7d2134d74e
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Duration.c
@@ -0,0 +1,212 @@
+//metadoc Duration copyright Steve Dekorte 2002
+//metadoc Duration license BSD revised
+
+#define DURATION_C
+#include "Duration.h"
+#undef DURATION_C
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <math.h>
+
+typedef struct
+{
+	double years;
+	double days;
+	double hours;
+	double minutes;
+	double seconds;
+} DurationComponents;
+
+Duration *Duration_new(void)
+{
+	Duration *self = (Duration *)io_calloc(1, sizeof(Duration));
+	return self;
+}
+
+Duration *Duration_newWithSeconds_(double s)
+{
+	Duration *self = Duration_new();
+	self->seconds = s;
+	return self;
+}
+
+void Duration_copy_(Duration *self, const Duration *other)
+{
+	memcpy(self, other, sizeof(Duration));
+}
+
+void Duration_free(Duration *self)
+{
+	io_free(self);
+}
+
+int Duration_compare(const Duration *self, const Duration *other)
+{
+	if (self->seconds == other->seconds)
+	{
+		return 0;
+	}
+
+	return self->seconds > other->seconds ? 1 : -1;
+}
+
+// components --------------------------------------------------------
+
+#define SECONDS_IN_YEAR   (60 * 60 * 24 * 365)
+#define SECONDS_IN_DAY    (60 * 60 * 24)
+#define SECONDS_IN_HOUR   (60 * 60)
+#define SECONDS_IN_MINUTE (60)
+
+DurationComponents Duration_asComponents(const Duration *self)
+{
+	DurationComponents c;
+	double t = self->seconds;
+	c.years   = (int)(t / SECONDS_IN_YEAR);   t -= (int)(c.years   * SECONDS_IN_YEAR);
+	c.days    = (int)(t / SECONDS_IN_DAY);    t -= (int)(c.days    * SECONDS_IN_DAY);
+	c.hours   = (int)(t / SECONDS_IN_HOUR);   t -= (int)(c.hours   * SECONDS_IN_HOUR);
+	c.minutes = (int)(t / SECONDS_IN_MINUTE); t -= (int)(c.minutes * SECONDS_IN_MINUTE);
+	c.seconds = (t);
+	return c;
+}
+
+void Duration_fromComponents_(Duration *self, DurationComponents c)
+{
+	double t = c.years * SECONDS_IN_YEAR;
+	t += c.days * SECONDS_IN_DAY;
+	t += c.hours * SECONDS_IN_HOUR;
+	t += c.minutes * SECONDS_IN_MINUTE;
+	t += c.seconds;
+	self->seconds = t;
+}
+
+// years --------------------------------------------------------
+
+int Duration_years(const Duration *self)
+{
+	return (int)Duration_asComponents(self).years;
+}
+
+void Duration_setYears_(Duration *self, double y)
+{
+	DurationComponents c = Duration_asComponents(self);
+	c.years = y;
+	Duration_fromComponents_(self, c);
+}
+
+// days --------------------------------------------------------
+
+int Duration_days(const Duration *self)
+{
+	return (int)Duration_asComponents(self).days;
+}
+
+void Duration_setDays_(Duration *self, double d)
+{
+	DurationComponents c = Duration_asComponents(self);
+	c.days = d;
+	Duration_fromComponents_(self, c);
+}
+
+// hours --------------------------------------------------------
+
+int Duration_hours(const Duration *self)
+{
+	return (int)Duration_asComponents(self).hours;
+}
+
+void Duration_setHours_(Duration *self, double m)
+{
+	DurationComponents c = Duration_asComponents(self);
+	c.hours = m;
+	Duration_fromComponents_(self, c);
+}
+
+// minutes --------------------------------------------------------
+
+int Duration_minutes(const Duration *self)
+{
+	return (int)Duration_asComponents(self).minutes;
+}
+
+void Duration_setMinutes_(Duration *self, double m)
+{
+	DurationComponents c = Duration_asComponents(self);
+	c.minutes = m;
+	Duration_fromComponents_(self, c);
+}
+
+// seconds --------------------------------------------------------
+
+double Duration_seconds(const Duration *self)
+{
+	return Duration_asComponents(self).seconds;
+}
+
+void Duration_setSeconds_(Duration *self, double s)
+{
+	DurationComponents c = Duration_asComponents(self);
+	c.seconds = s;
+	Duration_fromComponents_(self, c);
+}
+
+// total seconds --------------------------------------------------------
+
+double Duration_asSeconds(const Duration *self)
+{
+	return self->seconds;
+}
+
+void Duration_fromSeconds_(Duration *self, double s)
+{
+	self->seconds = s;
+}
+
+// strings --------------------------------------------------------
+
+UArray *Duration_asUArrayWithFormat_(const Duration *self, const char *format)
+{
+	DurationComponents c = Duration_asComponents(self);
+	char s[128];
+	UArray *ba = UArray_newWithCString_(format?format:"%Y years %d days %H:%M:%S");
+
+	snprintf(s, 128, "%i", (int)c.years);
+	UArray_replaceCString_withCString_(ba, "%Y", s);
+
+	snprintf(s, 128, "%04i", (int)c.years);
+	UArray_replaceCString_withCString_(ba, "%y", s);
+
+	snprintf(s, 128, "%02i", (int)c.days);
+	UArray_replaceCString_withCString_(ba, "%d", s);
+
+	snprintf(s, 128, "%02i", (int)c.hours);
+	UArray_replaceCString_withCString_(ba, "%H", s);
+
+	snprintf(s, 128, "%02i", (int)c.minutes);
+	UArray_replaceCString_withCString_(ba, "%M", s);
+
+	snprintf(s, 128, "%02f", c.seconds);
+	UArray_replaceCString_withCString_(ba, "%S", s);
+
+	return ba;
+}
+
+void Duration_print(const Duration *self)
+{
+	UArray *ba = Duration_asUArrayWithFormat_(self, NULL);
+	UArray_print(ba);
+	UArray_free(ba);
+}
+
+// math --------------------------------------------------------
+
+void Duration_add_(Duration *self, const Duration *other)
+{
+	self->seconds += other->seconds;
+}
+
+void Duration_subtract_(Duration *self, const Duration *other)
+{
+	self->seconds -= other->seconds;
+}
+
diff --git a/release/src/router/skipdbv2/basekit/Duration.h b/release/src/router/skipdbv2/basekit/Duration.h
new file mode 100644
index 0000000000..e53edb2c45
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Duration.h
@@ -0,0 +1,63 @@
+//metadoc Duration copyright Steve Dekorte 2002
+//metadoc Duration license BSD revised
+
+#ifndef DURATION_DEFINED
+#define DURATION_DEFINED 1
+
+#include "Common.h"
+#include "UArray.h"
+#include "PortableGettimeofday.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+	double seconds;
+} Duration;
+
+BASEKIT_API Duration *Duration_new(void);
+BASEKIT_API Duration *Duration_newWithSeconds_(double s);
+BASEKIT_API Duration *Duration_clone(const Duration *self);
+BASEKIT_API void Duration_copy_(Duration *self, const Duration *other);
+
+BASEKIT_API void Duration_free(Duration *self);
+BASEKIT_API int Duration_compare(const Duration *self, const Duration *other);
+
+// components
+
+BASEKIT_API int Duration_years(const Duration *self);
+BASEKIT_API void Duration_setYears_(Duration *self, double y);
+
+BASEKIT_API int Duration_days(const Duration *self);
+BASEKIT_API void Duration_setDays_(Duration *self, double d);
+
+BASEKIT_API int Duration_hours(const Duration *self);
+BASEKIT_API void Duration_setHours_(Duration *self, double m);
+
+BASEKIT_API int Duration_minutes(const Duration *self);
+BASEKIT_API void Duration_setMinutes_(Duration *self, double m);
+
+BASEKIT_API double Duration_seconds(const Duration *self);
+BASEKIT_API void Duration_setSeconds_(Duration *self, double s);
+
+// total seconds
+
+BASEKIT_API double Duration_asSeconds(const Duration *self);
+BASEKIT_API void Duration_fromSeconds_(Duration *self, double s);
+
+// strings
+
+BASEKIT_API UArray *Duration_asUArrayWithFormat_(const Duration *self, const char *format);
+BASEKIT_API void Duration_print(const Duration *self);
+
+// math
+
+BASEKIT_API void Duration_add_(Duration *self, const Duration *other);
+BASEKIT_API void Duration_subtract_(Duration *self, const Duration *other);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/DynLib.c b/release/src/router/skipdbv2/basekit/DynLib.c
new file mode 100644
index 0000000000..9ea091cb8c
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/DynLib.c
@@ -0,0 +1,234 @@
+/*
+//metadoc DynLib license BSD revised
+/*metadoc DynLib history
+	based on DllHandle.c, contributed by Daniel A. Koepke
+	Reorg, Steve Dekorte, 2003-08-30
+	Window fix, Chuck Adams, 2004-02-06
+*/
+
+#include "Base.h"
+#include "DynLib.h"
+#include "PortableStrlcpy.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || defined(_MSC_VER)
+#include <windows.h>
+
+#define RTLD_NOW    0    /* don't support link flags */
+#define RTLD_GLOBAL 0
+
+static void *dlopen(const char *path, int mode)
+{
+	void *result;
+	result = (void *)LoadLibraryEx(path, NULL, 0);
+	if (result)
+		SetLastError(ERROR_SUCCESS);
+
+	return result;
+}
+
+static int dlclose(void *handle)
+{
+	return FreeLibrary((HANDLE)handle);
+}
+
+static const char *dlerror(void)
+{
+	// XXX this will leak the error string
+
+	LPSTR buf;
+	DWORD err;
+	err = GetLastError();
+	if (err == ERROR_SUCCESS)
+		return (char*)0;
+
+	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
+				  | FORMAT_MESSAGE_IGNORE_INSERTS
+				  | FORMAT_MESSAGE_FROM_SYSTEM,
+				  NULL, err,
+				  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+				  (LPSTR)&buf, 0, NULL);
+	return buf;
+}
+
+static void *dlsym(void *handle, const char *symbol)
+{
+	return (void*)GetProcAddress((HANDLE)handle, symbol);
+}
+
+
+#else
+#include <dlfcn.h>
+#endif
+
+DynLib *DynLib_new(void)
+{
+	DynLib *self = (DynLib *)io_calloc(1, sizeof(DynLib));
+	DynLib_setPath_(self, "");
+	return self;
+}
+
+void DynLib_free(DynLib *self)
+{
+	//DynLib_close(self);
+	if (self->path) io_free(self->path);
+	if (self->initFuncName) io_free(self->initFuncName);
+	if (self->freeFuncName) io_free(self->freeFuncName);
+	if (self->error) io_free(self->error);
+	io_free(self);
+}
+
+void DynLib_setPath_(DynLib *self, const char *path)
+{
+	size_t len = strlen(path);
+	char *ptr = (char*)io_realloc(self->path, len + 1);
+	PortableStrlcpy(ptr, path, len + 1);
+	self->path = ptr;
+}
+
+char *DynLib_path(DynLib *self)
+{
+	return self->path;
+}
+
+void DynLib_setInitFuncName_(DynLib *self, const char *name)
+{
+	size_t len = strlen(name);
+	char* ptr = (char*)io_realloc(self->initFuncName, len + 1);
+	PortableStrlcpy(ptr, name, len + 1);
+	self->initFuncName = ptr;
+}
+
+char *DynLib_initFuncName(DynLib *self)
+{
+	return self->initFuncName;
+}
+
+void DynLib_setInitArg_(DynLib *self, void *arg)
+{
+	self->initArg = arg;
+}
+
+void DynLib_setFreeFuncName_(DynLib *self, const char *name)
+{
+	size_t len = strlen(name);
+	char* ptr = (char*)io_realloc(self->freeFuncName, len + 1);
+	PortableStrlcpy(ptr, name, len + 1);
+	self->freeFuncName = ptr;
+}
+
+char *DynLib_freeFuncName(DynLib *self)
+{
+	return self->freeFuncName;
+}
+
+void DynLib_setFreeArg_(DynLib *self, void *arg)
+{
+	self->freeArg = arg;
+}
+
+void DynLib_setError_(DynLib *self,const char *error)
+{
+	if (error)
+	{
+		self->error = strcpy((char *)io_realloc(self->error, strlen(error)+1), error);
+	}
+	else
+	{
+		if (self->error) io_free(self->error);
+		self->error = NULL;
+	}
+}
+
+char *DynLib_error(DynLib *self)
+{
+	return self->error;
+}
+
+void DynLib_updateError(DynLib *self)
+{
+	DynLib_setError_(self, dlerror());
+}
+
+unsigned char DynLib_hasError(DynLib *self)
+{
+	return self->error != NULL;
+}
+
+void DynLib_open(DynLib *self)
+{
+	self->handle = dlopen(self->path, RTLD_NOW | RTLD_GLOBAL); /* RTLD_LAZY); */
+	//self->handle = dlopen(self->path, RTLD_NOW | RTLD_LAZY);
+	DynLib_updateError(self);
+
+	if (DynLib_hasError(self))
+	{
+		return;
+	}
+
+	if (self->initFuncName)
+	{
+		void *f = DynLib_pointerForSymbolName_(self, self->initFuncName);
+
+		if (!f)
+		{
+			DynLib_setError_(self, "init function not found");
+			return;
+		}
+
+		if (self->initArg)
+		{
+			//printf("DynLib: opening with 1 arg %p\n", self->initArg);
+			(*(DynLibOneArgFunction *)f)(self->initArg);
+		}
+		else
+		{
+			(*(DynLibNoArgFunction *)f)();
+		}
+	}
+}
+
+unsigned char DynLib_isOpen(DynLib *self)
+{
+	return self->handle != NULL;
+}
+
+void DynLib_close(DynLib *self)
+{
+	if (self->freeFuncName)
+	{
+		void *f = DynLib_pointerForSymbolName_(self, self->freeFuncName);
+
+		if (!f)
+		{
+			DynLib_setError_(self, "io_free function not found");
+			return;
+		}
+
+		if (self->freeArg)
+		{
+			(*(DynLibOneArgFunction *)f)(self->freeArg);
+		}
+		else
+		{
+			(*(DynLibNoArgFunction *)f)();
+		}
+	}
+
+	if (self->handle)
+	{
+		dlclose(self->handle);
+	}
+
+	self->handle = NULL;
+}
+
+void *DynLib_pointerForSymbolName_(DynLib *self, const char *symbolName)
+{
+	DynLib_setError_(self, dlerror());
+	return dlsym(self->handle, symbolName);
+}
+
diff --git a/release/src/router/skipdbv2/basekit/DynLib.h b/release/src/router/skipdbv2/basekit/DynLib.h
new file mode 100644
index 0000000000..69f58fb465
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/DynLib.h
@@ -0,0 +1,55 @@
+/* based on DynLib.c contributed by Daniel A. Koepke
+ * Reorg, Steve Dekorte, 2003-08-30
+ * See _BSDLicense.txt
+ */
+
+#ifndef DYNLIB_DEFINED
+#define DYNLIB_DEFINED 1
+
+#include "Common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void DynLibNoArgFunction(void);
+typedef void DynLibOneArgFunction(void *arg);
+
+typedef struct
+{
+	char *path;
+	char *initFuncName;
+	void *initArg;
+	char *freeFuncName;
+	void *freeArg;
+	char *error;
+	void *handle;
+	int refCount;
+} DynLib;
+
+BASEKIT_API DynLib *DynLib_new(void);
+BASEKIT_API void DynLib_free(DynLib *self);
+
+BASEKIT_API void DynLib_setPath_(DynLib *self, const char *path);
+BASEKIT_API char *DynLib_path(DynLib *self);
+
+BASEKIT_API void DynLib_setInitFuncName_(DynLib *self, const char *name);
+BASEKIT_API char *DynLib_initFuncName(DynLib *self);
+BASEKIT_API void DynLib_setInitArg_(DynLib *self, void *arg);
+
+BASEKIT_API void DynLib_setFreeFuncName_(DynLib *self, const char *name);
+BASEKIT_API char *DynLib_freeFuncName(DynLib *self);
+BASEKIT_API void DynLib_setFreeArg_(DynLib *self, void *arg);
+
+BASEKIT_API void DynLib_setError_(DynLib *self, const char *path);
+BASEKIT_API char *DynLib_error(DynLib *self);
+
+BASEKIT_API void DynLib_open(DynLib *self);
+BASEKIT_API unsigned char DynLib_isOpen(DynLib *self);
+BASEKIT_API void DynLib_close(DynLib *self);
+BASEKIT_API void *DynLib_pointerForSymbolName_(DynLib *self, const char *symbolName);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/List.c b/release/src/router/skipdbv2/basekit/List.c
new file mode 100644
index 0000000000..2837f358f0
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/List.c
@@ -0,0 +1,247 @@
+//metadoc List copyright Steve Dekorte 2002
+//metadoc List license BSD revised
+
+#define LIST_C
+#include "List.h"
+#undef LIST_C
+#include <stdlib.h>
+
+List *List_new(void)
+{
+	List *self = (List *)io_calloc(1, sizeof(List));
+	self->size = 0;
+	self->memSize = sizeof(void *)*LIST_START_SIZE;
+	self->items = (void **)io_calloc(1, self->memSize);
+	return self;
+}
+
+List *List_clone(const List *self)
+{
+	List *child = List_new();
+	List_copy_(child, self);
+	/*
+	 List *child = cpalloc(self, sizeof(List));
+	 child->items = cpalloc(self->items, self->memSize);
+	 */
+	return child;
+}
+
+static size_t indexWrap(long index, size_t size)
+{
+	if (index < 0)
+	{
+		index = size - index;
+
+		if (index < 0)
+		{
+			index = 0;
+		}
+	}
+
+	if (index > (int)size)
+	{
+		index = size;
+	}
+
+	return (size_t)index;
+}
+
+void List_sliceInPlace(List* self, long startIndex, long endIndex)
+{
+	size_t i, size = List_size(self);
+	List *tmp = List_new();
+	size_t start = indexWrap(startIndex, size);
+	size_t end   = indexWrap(endIndex, size);
+
+	for (i = start; i < size && i < end + 1; i ++)
+	{
+		List_append_(tmp, List_at_(self, i));
+	}
+
+	List_copy_(self, tmp);
+	List_free(tmp);
+}
+
+List *List_cloneSlice(const List *self, long startIndex, long endIndex)
+{
+	List *child = List_clone(self);
+	List_sliceInPlace(child, startIndex, endIndex);
+	return child;
+}
+
+void List_free(List *self)
+{
+	//printf("List_free(%p)\n", (void *)self);
+	io_free(self->items);
+	io_free(self);
+}
+
+UArray List_asStackAllocatedUArray(List *self)
+{
+	UArray a = UArray_stackAllocedEmptyUArray();
+	a.itemType = CTYPE_uintptr_t;
+	a.itemSize = sizeof(uintptr_t);
+	a.size = self->size;
+	a.data = (uint8_t *)(self->items);
+	return a;
+}
+
+size_t List_memorySize(const List *self)
+{
+	return sizeof(List) + (self->size * sizeof(void *));
+}
+
+void List_removeAll(List *self)
+{
+	self->size = 0;
+	List_compactIfNeeded(self);
+}
+
+void List_copy_(List *self, const List *otherList)
+{
+	if (self == otherList || (!otherList->size && !self->size))
+	{
+		return;
+	}
+
+	List_preallocateToSize_(self, otherList->size);
+	memmove(self->items, otherList->items, sizeof(void *) * (otherList->size));
+	self->size = otherList->size;
+}
+
+int List_equals_(const List *self, const List *otherList)
+{
+	return (self->size == otherList->size &&
+		   memcmp(self->items, otherList->items, sizeof(void *) * self->size) == 0);
+}
+
+/* --- sizing ------------------------------------------------ */
+
+void List_setSize_(List *self, size_t index)
+{
+	List_ifNeededSizeTo_(self, index);
+	self->size = index;
+}
+
+void List_preallocateToSize_(List *self, size_t index)
+{
+	size_t s = index * sizeof(void *);
+
+	if (s >= self->memSize)
+	{
+		size_t newSize = self->memSize * LIST_RESIZE_FACTOR;
+
+		if (s > newSize)
+		{
+			newSize = s;
+		}
+
+		self->items = (void **)io_realloc(self->items, newSize);
+		memset(self->items + self->size, 0, (newSize - (self->size*sizeof(void *))));
+		self->memSize = newSize;
+	}
+}
+
+void List_compact(List *self)
+{
+	self->memSize = self->size * sizeof(void *);
+	self->items = (void **)io_realloc(self->items, self->memSize);
+}
+
+// -----------------------------------------------------------
+
+void List_print(const List *self)
+{
+	size_t i;
+
+	printf("List <%p> [%i bytes]\n", (void *)self, (int)self->memSize);
+
+	for (i = 0; i < self->size; i ++)
+	{
+		printf("%i: %p\n", i, (void *)self->items[i]);
+	}
+
+	printf("\n");
+}
+
+// enumeration -----------------------------------------
+
+void List_do_(List *self, ListDoCallback *callback)
+{
+	LIST_FOREACH(self, i, v, if (v) (*callback)(v));
+}
+
+void List_do_with_(List *self, ListDoWithCallback *callback, void *arg)
+{
+	LIST_FOREACH(self, i, v, if (v) (*callback)(v, arg));
+}
+
+void List_mapInPlace_(List *self, ListCollectCallback *callback)
+{
+	void **items = self->items;
+	LIST_FOREACH(self, i, v, items[i] = (*callback)(v));
+}
+
+List *List_map_(List *self, ListCollectCallback *callback)
+{
+	List *r = List_new();
+	LIST_FOREACH(self, i, v, List_append_(r, (*callback)(v)););
+	return r;
+}
+
+List *List_select_(List *self, ListSelectCallback *callback)
+{
+	List *r = List_new();
+	LIST_FOREACH(self, i, v, if ((*callback)(v)) List_append_(r, v));
+	return r;
+}
+
+void *List_detect_(List *self, ListDetectCallback *callback)
+{
+	LIST_FOREACH(self, i, v, if (v && (*callback)(v)) return v; );
+	return NULL;
+}
+
+void *List_anyOne(const List *self)
+{
+	size_t i;
+
+	if (self->size == 0)
+	{
+		return (void *)NULL;
+	}
+
+	if (self->size == 1)
+	{
+		return LIST_AT_(self, 0);
+	}
+
+	i = (rand() >> 4) % (self->size); // without the shift, just get a sequence!
+
+	return LIST_AT_(self, i);
+}
+
+void List_shuffle(List *self)
+{
+	size_t i, j;
+
+	for (i = 0; i < self->size - 1; i ++)
+	{
+		j = i + rand() % (self->size - i);
+		List_swap_with_(self, i, j);
+	}
+}
+
+void *List_removeLast(List *self)
+{
+	void *item = List_at_(self, self->size - 1);
+
+	if (item)
+	{
+		self->size --;
+		List_compactIfNeeded(self);
+	}
+
+	return item;
+}
+
diff --git a/release/src/router/skipdbv2/basekit/List.h b/release/src/router/skipdbv2/basekit/List.h
new file mode 100644
index 0000000000..bc03ec3882
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/List.h
@@ -0,0 +1,96 @@
+//metadoc List copyright Steve Dekorte 2002
+//metadoc List license BSD revised
+/*metadoc List description
+	List - an array of void pointers
+	User is responsible for io_freeing items
+*/
+
+#ifndef LIST_DEFINED
+#define LIST_DEFINED 1
+
+#include "Common.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LOW_MEMORY_SYSTEM
+	#define LIST_START_SIZE 1
+	#define LIST_RESIZE_FACTOR 2
+#else
+	#define LIST_START_SIZE 1
+	#define LIST_RESIZE_FACTOR 2
+#endif
+
+#define LIST_AT_(self, n) self->items[n]
+
+
+typedef void  (ListDoCallback)(void *);
+typedef void  (ListDoWithCallback)(void *, void *);
+typedef void *(ListCollectCallback)(void *);
+typedef int   (ListSelectCallback)(void *);
+typedef int   (ListDetectCallback)(void *);
+typedef int   (ListSortCallback)(const void *, const void *);
+typedef int   (ListCompareFunc)(const void *, const void *);
+
+typedef struct
+{
+	void **items;
+	size_t size;
+	size_t memSize;
+} List;
+
+typedef struct
+{
+	List *list;
+	size_t index;
+} ListCursor;
+
+BASEKIT_API List *List_new(void);
+BASEKIT_API List *List_clone(const List *self);
+BASEKIT_API List *List_cloneSlice(const List *self, long startIndex, long endIndex);
+
+BASEKIT_API void List_free(List *self);
+BASEKIT_API void List_removeAll(List *self);
+BASEKIT_API void List_copy_(List *self, const List *otherList);
+BASEKIT_API int  List_equals_(const List *self, const List *otherList);
+BASEKIT_API size_t List_memorySize(const List *self);
+
+#include "UArray.h"
+
+BASEKIT_API UArray List_asStackAllocatedUArray(List *self);
+
+// sizing
+
+BASEKIT_API void List_preallocateToSize_(List *self, size_t index);
+BASEKIT_API void List_setSize_(List *self, size_t index);
+BASEKIT_API void List_compact(List *self);
+
+// utility
+
+BASEKIT_API void List_print(const List *self);
+BASEKIT_API void List_sliceInPlace(List *self, long startIndex, long endIndex);
+
+// enumeration
+
+BASEKIT_API void List_do_(List *self, ListDoCallback *callback);
+BASEKIT_API void List_do_with_(List *self, ListDoWithCallback *callback, void *arg);
+
+BASEKIT_API List *List_map_(List *self, ListCollectCallback *callback);
+BASEKIT_API void List_mapInPlace_(List *self, ListCollectCallback *callback);
+BASEKIT_API void *List_detect_(List *self, ListDetectCallback *callback);
+BASEKIT_API List *List_select_(List *self, ListSelectCallback *callback);
+
+BASEKIT_API void *List_anyOne(const List *self);
+BASEKIT_API void List_shuffle(List *self);
+BASEKIT_API void *List_removeLast(List *self);
+
+#include "List_inline.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/List_inline.h b/release/src/router/skipdbv2/basekit/List_inline.h
new file mode 100644
index 0000000000..33e368b64f
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/List_inline.h
@@ -0,0 +1,403 @@
+//metadoc List copyright Steve Dekorte 2002
+//metadoc List license BSD revised
+/*metadoc List description
+List is an array of void pointers.
+The List is not responsible for io_freeing it's elements.
+*/
+
+#ifdef LIST_C
+#define IO_IN_C_FILE
+#endif
+#include "Common_inline.h"
+#ifdef IO_DECLARE_INLINES
+
+#define LIST_FOREACH(list, index, value, code) \
+{ \
+	const List *foreachList = list; \
+	size_t index, foreachMax = foreachList->size; \
+	\
+	for (index = 0; index < foreachMax; index ++) \
+	{ \
+		void *value = foreachList->items[index]; \
+		code; \
+	} \
+}
+
+#define LIST_SAFEFOREACH(list, index, value, code) \
+{ \
+	const List *foreachList = list; \
+	size_t index; \
+	\
+	for (index = 0; index < List_size(foreachList); index ++) \
+	{ \
+		void *value = List_at_(foreachList, index); \
+		code; \
+	} \
+}
+
+#define LIST_REVERSEFOREACH(list, index, value, code) \
+{ \
+	const List *foreachList = list; \
+	size_t index = List_size(foreachList); \
+	\
+	while (index) \
+	{ \
+		void *value = List_at_(foreachList, (index --)); \
+		code; \
+	} \
+}
+
+#define LIST_SAFEREVERSEFOREACH(list, index, value, code) \
+{ \
+	const List *foreachList = list; \
+	size_t index = List_size(foreachList); \
+	\
+	for (index = List_size(foreachList) - 1; index > 0; index --) \
+	{ \
+		void *value = List_at_(foreachList, index); \
+		code; \
+		if (index > List_size(foreachList) - 1) { index = List_size(foreachList) - 1; } \
+	} \
+}
+
+#define LIST_DO_(list, func) \
+{ \
+	const List *foreachList = list; \
+	size_t index, foreachMax = List_size(foreachList); \
+	\
+	for (index = 0; index < foreachMax; index ++) \
+	{ \
+		func(List_at_(foreachList, index)); \
+	} \
+}
+
+#define List_size(self) (self->size)
+/*
+IOINLINE size_t List_size(const List *self)
+{
+	return self->size;
+}
+*/
+
+IOINLINE void List_ifNeededSizeTo_(List *self, size_t newSize)
+{
+	if (newSize * sizeof(void *) >= self->memSize)
+	{
+		List_preallocateToSize_(self, newSize);
+	}
+}
+
+IOINLINE void *List_rawAt_(List *self, size_t index)
+{
+	return self->items[index];
+}
+
+
+IOINLINE void *List_at_(const List *self, size_t index)
+{
+	if (index < self->size)
+	{
+		return self->items[index];
+	}
+
+	return (void *)NULL;
+}
+
+// --------------------------------------------
+
+IOINLINE long List_indexOf_(List *self, void *item)
+{
+	LIST_FOREACH(self, i, v, if(v == item) return i);
+	return -1;
+}
+
+IOINLINE int List_contains_(List *self, void *item)
+{
+	LIST_FOREACH(self, i, v, if(v == item) return 1);
+	return 0;
+}
+
+IOINLINE void *List_append_(List *self, void *item)
+{
+	List_ifNeededSizeTo_(self, self->size + 1);
+	self->items[self->size] = item;
+	self->size ++;
+	return item;
+}
+
+IOINLINE void List_appendSeq_(List *self, const List *otherList)
+{
+	LIST_FOREACH(otherList, i, v, List_append_(self, v));
+}
+
+IOINLINE void List_compactIfNeeded(List *self)
+{
+	if(self->memSize > 1024 && self->size * sizeof(void *) * 4 < self->memSize)
+	{
+		List_compact(self);
+	}
+}
+
+IOINLINE void List_removeIndex_(List *self, size_t index)
+{
+	if (index >= 0 && index < self->size)
+	{
+		if ( index != self->size - 1)
+		{
+			memmove(&self->items[index], &self->items[index + 1],
+				   (self->size - 1 - index) * sizeof(void *));
+		}
+
+		self->size --;
+
+		List_compactIfNeeded(self);
+	}
+}
+
+IOINLINE void List_removeIndex_toIndex_(List *self, size_t index1, size_t index2)
+{
+	long length;
+
+	if (index1 < 0)
+	{
+		index1 = 0;
+	}
+
+	if (index1 > self->size - 1)
+	{
+		index1 = self->size - 1;
+	}
+
+	if (index2 < 0)
+	{
+		index2 = 0;
+	}
+
+	if (index2 > self->size - 1)
+	{
+		index2 = self->size - 1;
+	}
+
+	length = index2 - index1;
+
+	if (length <= 0)
+	{
+		return;
+	}
+
+	memmove(&self->items[index1], &self->items[index2],
+		   (self->size - index2) * sizeof(void *));
+
+	self->size -= length;
+
+	List_compactIfNeeded(self);
+}
+
+IOINLINE void List_remove_(List *self, void *item)
+{
+	size_t index;
+
+	for (index = 0; index < self->size; index ++)
+	{
+		if (self->items[index] == item)
+		{
+			List_removeIndex_(self, index);
+		}
+	}
+}
+
+IOINLINE int List_removeFirst_(List *self, void *item)
+{
+	int i, max = self->size;
+
+	for (i = 0; i < max; i ++)
+	{
+		if (self->items[i] == item)
+		{
+			List_removeIndex_(self, i);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+IOINLINE void List_removeLast_(List *self, void *item)
+{
+	int index = self->size - 1;
+
+	for (index = self->size - 1; index > -1; index --)
+	{
+		if (self->items[index] == item)
+		{
+			List_removeIndex_(self, index);
+			break;
+		}
+	}
+}
+
+IOINLINE void List_removeItems_(List *self, List *other)
+{
+	LIST_FOREACH(other, i, v, List_remove_(self, v));
+}
+
+IOINLINE void List_at_insert_(List *self, size_t index, void *item)
+{
+	if (index < 0)
+	{
+		return;
+	}
+
+	if (index > self->size - 1)
+	{
+		List_preallocateToSize_(self, index + 1);
+	}
+	else
+	{
+		List_ifNeededSizeTo_(self, self->size + 1);
+	}
+
+	memmove(&self->items[index + 1], &self->items[index],
+		   (self->size - index) * sizeof(void *));
+
+	self->items[index] = item;
+	self->size ++;
+}
+
+IOINLINE void List_at_put_(List *self, size_t index, void *item)
+{
+	if (index < 0)
+	{
+		return;
+	}
+
+	List_ifNeededSizeTo_(self, index);
+	self->items[index] = item;
+
+	if (index + 1 > self->size)
+	{
+		self->size = index + 1;
+	}
+}
+
+IOINLINE void List_swap_with_(List *self, long index1, long index2)
+{
+	if (index1 < 0 || index2 < 0)
+	{
+		return;
+	}
+
+	if (index1 != index2)
+	{
+		void **items = self->items;
+		register void *v1 = items[index1];
+
+		items[index1] = items[index2];
+		items[index2] = v1;
+	}
+}
+
+IOINLINE void List_reverse(List *self)
+{
+	register void **i = self->items;
+	register void **j = i + (self->size - 1);
+	register void *iv;
+
+	while (j > i)
+	{
+		iv = *i;
+		*i = *j;
+		*j = iv;
+		j --;
+		i ++;
+	}
+}
+
+// stack --------------------------------------------------
+
+IOINLINE void List_push_(List *self, void *item)
+{
+	List_ifNeededSizeTo_(self, self->size + 1);
+	self->items[self->size] = item;
+	self->size ++;
+}
+
+IOINLINE void *List_pop(List *self)
+{
+	void *item;
+
+	if (!self->size)
+	{
+		return (void *)NULL;
+	}
+
+	self->size --;
+	item = self->items[self->size];
+	List_compactIfNeeded(self);
+	return item;
+}
+
+IOINLINE void *List_top(const List *self)
+{
+	if (!self->size)
+	{
+		return (void *)NULL;
+	}
+
+	return self->items[self->size - 1];
+}
+
+/* --- perform -------------------------------------------------- */
+
+IOINLINE int List_removeTrueFor_(List *self, ListCollectCallback* callback)
+{
+	size_t getIndex = 0;
+	size_t putIndex = 0;
+	size_t count = self->size;
+	void **items = self->items;
+
+	while (getIndex < count)
+	{
+		void *item = items[getIndex];
+
+		if (item && !((*callback)(item)))
+		{
+			if (getIndex!=putIndex)
+			{
+				items[putIndex] = item;
+			}
+
+			putIndex ++;
+		}
+
+		getIndex ++;
+	}
+
+	self->size = putIndex;
+
+	return getIndex - putIndex;
+}
+
+IOINLINE void List_qsort(List *self, ListSortCallback *callback)
+{
+	qsort(self->items, self->size, sizeof(void *), *callback);
+}
+
+IOINLINE void *List_bsearch(List *self, const void *key, ListSortCallback *callback)
+{
+	return bsearch(key, self->items, self->size, sizeof(void *), callback);
+}
+
+IOINLINE void *List_first(const List *self)
+{
+	return List_at_(self, 0);
+}
+
+IOINLINE void *List_last(List *self)
+{
+	return List_at_(self, List_size(self) - 1);
+}
+
+#undef IO_IN_C_FILE
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/MainArgs.c b/release/src/router/skipdbv2/basekit/MainArgs.c
new file mode 100644
index 0000000000..73dc51683f
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/MainArgs.c
@@ -0,0 +1,56 @@
+//metadoc MainArgs copyright Steve Dekorte 2002
+//metadoc MainArgs license BSD revised
+
+#include "Base.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "MainArgs.h"
+#include "PortableStrlcpy.h"
+
+MainArgs *MainArgs_new(void)
+{
+	MainArgs *self = (MainArgs *)io_calloc(1, sizeof(MainArgs));
+	return self;
+}
+
+void MainArgs_free(MainArgs *self)
+{
+	if (self->argv)
+	{
+		int i;
+
+		for (i = 0; i < self->argc; i ++)
+		{
+			io_free((char *)(self->argv[i]));
+		}
+
+		io_free((void*)(self->argv));
+	}
+
+	io_free(self);
+}
+
+void MainArgs_argc_argv_(MainArgs *self, int argc, const char **argv)
+{
+	int i;
+
+	self->argc = argc;
+	// copy by reference since args should be retained on
+	// the C stack until the program exits
+
+	self->argv = (const char **)io_calloc(1, sizeof(char *)*argc);
+
+	for (i = 0; i < argc; i ++)
+	{
+		const char *s = argv[i];
+		size_t len = strlen(s);
+		char *ptr = (char *)io_calloc(1, len + 1);
+		PortableStrlcpy(ptr, s, len + 1);
+		self->argv[i] = ptr;
+
+		//self->argv[i] = strcpy((char *)io_calloc(1, strlen(s)+1), s);
+		/*printf("argv[%i] = '%s'\n", i, s);*/
+	}
+}
+
diff --git a/release/src/router/skipdbv2/basekit/MainArgs.h b/release/src/router/skipdbv2/basekit/MainArgs.h
new file mode 100644
index 0000000000..3f0cb11ead
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/MainArgs.h
@@ -0,0 +1,35 @@
+//metadoc MainArgs copyright Steve Dekorte 2002
+//metadoc MainArgs license BSD revised
+/*metadoc MainArgs description
+Structure for copying and storing command line arguments.")
+*/
+
+#ifndef MAINARGS_DEFINED
+#define MAINARGS_DEFINED 1
+
+#include "Common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+	int argc;
+	const char **argv;
+} MainArgs;
+
+BASEKIT_API MainArgs *MainArgs_new(void);
+BASEKIT_API void MainArgs_free(MainArgs *self);
+
+BASEKIT_API void MainArgs_argc_argv_(MainArgs *self, int argc, const char **argv);
+#define MainArgs_argCount(self) self->argc
+#define MainArgs_argAt_(self, index) self->argv[index]
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
+
diff --git a/release/src/router/skipdbv2/basekit/PHash.c b/release/src/router/skipdbv2/basekit/PHash.c
new file mode 100644
index 0000000000..41268bea5f
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PHash.c
@@ -0,0 +1,271 @@
+
+//metadoc PHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc PHash license BSD revised
+
+#define PHASH_C
+#include "PHash.h"
+#undef PHASH_C
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+void PHash_print(PHash* self)
+{
+	printf("self->log2tableSize = %d\n", self->log2tableSize);
+	printf("self->tableSize = %d\n", self->tableSize);
+	printf("self->numKeys = %d\n", self->numKeys);
+
+	printf("self->mask = %d\n", self->mask);
+	printf("self->balance = %d\n", self->balance);
+	printf("self->maxLoops = %d\n", PHash_maxLoops(self));
+	printf("self->maxKeys = %d\n", PHash_maxKeys(self));
+
+	printf("self->nullRecord.key = %d\n", self->nullRecord.key);
+	printf("self->nullRecord.value = %d\n", self->nullRecord.value);
+
+	printf("\nmemory usage : %d bytes\n", PHash_memorySize(self));
+	printf("\ndensity : %f \n", (self->numKeys*sizeof(PHashRecord))/(double)PHash_memorySize(self));
+
+	{
+		unsigned int i,j;
+		int count[2] = {0,0};
+
+		for (j = 0; j < 2; j ++)
+		{
+			for (i = 0; i < self->tableSize; i ++)
+			{
+				PHashRecord *record = PHASH_RECORDS_AT_(self, j, i);
+				if (NULL == record->key)
+				{
+					if (NULL == record->value)
+						printf("_");
+					else
+						printf("!");
+				}
+				else
+				{
+					printf("x");
+					count[j]++;
+				}
+			}
+			printf("\n");
+		}
+		printf("balance : %d / %d [%1.3f]\n", count[0], count[1], (count[0]-count[1])/(double)(count[0]+count[1]) );
+	}
+}
+
+void PHash_tableInit_(PHash* self, int log2tableSize)
+{
+	if (log2tableSize > 20)
+		printf("ouuups");
+	self->log2tableSize = log2tableSize;
+	self->tableSize = 1<<self->log2tableSize;
+	self->records = (PHashRecord *)io_calloc(1, sizeof(PHashRecord) * self->tableSize * 2);
+	memset(self->records, 0x0, sizeof(PHashRecord) * self->tableSize * 2);
+	self->mask = self->tableSize-1;
+}
+
+PHash *PHash_new(void)
+{
+	PHash *self = (PHash *)io_calloc(1, sizeof(PHash));
+	memset(self, 0x0, sizeof(PHash));
+	self->numKeys = 0;
+	PHash_tableInit_(self, 1);
+	//printf("ok");
+	return self;
+}
+
+PHash *PHash_clone(PHash *self)
+{
+	PHash *child = PHash_new();
+	PHash_copy_(child, self);
+	return child;
+}
+
+void PHash_free(PHash *self)
+{
+	io_free(self->records);
+	io_free(self);
+}
+
+size_t PHash_memorySize(PHash *self)
+{
+	return sizeof(PHash) + (self->tableSize * 2 * sizeof(PHashRecord));
+}
+
+void PHash_compact(PHash *self)
+{
+	printf("need to implement PHash_compact\n");
+}
+
+void PHash_copy_(PHash *self, PHash *other)
+{
+	PHashRecord *records = self->records;
+	memcpy(self, other, sizeof(PHash));
+	self->records = (PHashRecord *)io_realloc(records, sizeof(PHashRecord) * self->tableSize * 2);
+	memcpy(self->records, other->records, sizeof(PHashRecord) * self->tableSize * 2);
+}
+
+/*	this is where our cuckoo acts :
+	it kicks records out of nests until it finds an empty nest or gets tired
+	returns the empty nest if found, or NULL if it is too tired
+*/
+PHashRecord *PHash_cuckoo_(PHash *self, PHashRecord* thisRecord)
+{
+	unsigned int hash;
+	PHashRecord* record;
+	record = PHash_recordAt_(self, thisRecord->key);
+
+	if (record != &self->nullRecord && NULL == record->key)
+		return record;
+	else
+	{
+		if (PHashKey_isEqual_(thisRecord->key, record->key))
+		{
+			return record;
+		}
+		else
+		{
+			int i;
+			// to balance load
+			if (self->balance)
+			{
+				self->balance = 0;
+
+				hash = PHash_hash_more(self, PHash_hash(self, thisRecord->key));
+				record = PHASH_RECORDS_AT_HASH_(self, 1, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					PHashRecord_swap(record, thisRecord);
+
+				if (PHashKey_isEqual_(thisRecord->key, record->key))
+					return record;
+			}
+			self->balance = 1;
+
+			for (i = 0; i < PHash_maxLoops(self); i++)
+			{
+				hash = PHash_hash(self, thisRecord->key);
+				record = PHASH_RECORDS_AT_HASH_(self, 0, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					PHashRecord_swap(record, thisRecord);
+
+				if (PHashKey_isEqual_(thisRecord->key, record->key))
+					return record;
+
+				hash = PHash_hash_more(self, PHash_hash(self, thisRecord->key));
+				record = PHASH_RECORDS_AT_HASH_(self, 1, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					PHashRecord_swap(record, thisRecord);
+
+				if (PHashKey_isEqual_(thisRecord->key, record->key))
+					return record;
+			}
+
+			// the cuckoo is tired ^^
+			return NULL;
+		}
+	}
+
+	return NULL;
+}
+
+void PHash_grow(PHash *self)
+{
+	unsigned int oldTableSize = self->tableSize;
+	PHashRecord* oldRecords = self->records;
+
+	self->records = NULL;
+	while (self->records == NULL)
+	{
+		unsigned int i;
+
+		PHash_tableInit_(self, self->log2tableSize + 1);
+
+		// enumerate old records
+
+		i = 0;
+		while (i < oldTableSize*2)
+		{
+			PHashRecord thisRecord = oldRecords[i];
+			i++;
+
+			if (thisRecord.key)
+			{
+				PHashRecord *record = PHash_cuckoo_(self, &thisRecord);
+				if (!record) // collision
+				{
+					io_free(self->records);
+					self->records = NULL;
+					break; // grow & rehash
+				}
+				*record = thisRecord;
+			}
+		}
+	}
+	io_free(oldRecords);
+}
+
+void PHash_growWithRecord(PHash *self, PHashRecord* thisRecord)
+{
+	// put the value anywhere, PHash_grow will rehash
+	unsigned int i,j;
+
+	for (j = 0; j < 2; j ++)
+	for (i = 0; i < self->tableSize; i ++)
+	{
+		PHashRecord *record = PHASH_RECORDS_AT_(self, j, i);
+
+		if (record != &self->nullRecord && NULL == record->key)
+		{
+			*record = *thisRecord;
+			self->numKeys ++;
+			PHash_grow(self);
+			return;
+		}
+	}
+
+	// we can never be there
+	return;
+}
+
+void PHash_removeValue_(PHash *self, void *value)
+{
+	PHashRecord *record;
+	int index = 0;
+
+	while (index < self->tableSize*2)
+	{
+		record = self->records + index;
+		index ++;
+
+		if (record->key && record->value == value)
+		{
+			self->numKeys --;
+			memset(record, 0, sizeof(PHashRecord));
+			return;
+		}
+	}
+}
+
+void *PHash_firstKeyForValue_(PHash *self, void *v)
+{
+	unsigned int i,j;
+
+	for (j = 0; j < 2; j ++)
+	for (i = 0; i < self->tableSize; i ++)
+	{
+		PHashRecord *record = PHASH_RECORDS_AT_(self, j, i);
+
+		if (record->key && record->value == v)
+			return record->key;
+	}
+	return NULL;
+}
+
+
diff --git a/release/src/router/skipdbv2/basekit/PHash.h b/release/src/router/skipdbv2/basekit/PHash.h
new file mode 100644
index 0000000000..d695203846
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PHash.h
@@ -0,0 +1,74 @@
+//metadoc PHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc PHash license BSD revised
+/*metadoc PHash description
+	PHash - Cuckoo Hash
+	keys and values are references (they are not copied or freed)
+	key pointers are assumed unique
+*/
+
+#ifndef PHASH_DEFINED
+#define PHASH_DEFINED 1
+
+#include "Common.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+	void *key;
+	void *value;
+} PHashRecord;
+
+
+typedef struct
+{
+	PHashRecord *records;		// contains the two tables
+
+	unsigned int log2tableSize;	// log2(tableSize)
+	unsigned int tableSize;		// total number of records per table
+	unsigned int numKeys;		// number of used records
+
+	unsigned int mask;			// hash bit mask
+	PHashRecord nullRecord;		// for lookup misses
+	unsigned int balance;		// to balance tables
+} PHash;
+
+//#define PHash_mask(self) (self->tableSize-1)
+#define PHash_maxLoops(self) (self->tableSize)
+#define PHash_maxKeys(self) (self->tableSize)
+
+BASEKIT_API void PHash_print(PHash *self); // to debug
+
+BASEKIT_API PHash *PHash_new(void);
+BASEKIT_API void PHash_free(PHash *self);
+BASEKIT_API PHash *PHash_clone(PHash *self);
+BASEKIT_API void PHash_copy_(PHash *self, PHash *other);
+
+BASEKIT_API PHashRecord* PHash_cuckoo_(PHash *self, PHashRecord* record);
+BASEKIT_API void PHash_grow(PHash *self);
+BASEKIT_API void PHash_growWithRecord(PHash *self, PHashRecord* record);
+
+BASEKIT_API size_t PHash_memorySize(PHash *self);
+BASEKIT_API void PHash_compact(PHash *self);
+
+//BASEKIT_API unsigned int PHash_count(PHash *self);
+BASEKIT_API unsigned int PHash_countRecords_size_(unsigned char *records, unsigned int size);
+
+BASEKIT_API void *PHash_firstKeyForValue_(PHash *self, void *v);
+
+// --- perform --------------------------------------------------
+
+BASEKIT_API void PHash_removeValue_(PHash *self, void *value);
+
+#include "PHash_inline.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/PHash_inline.h b/release/src/router/skipdbv2/basekit/PHash_inline.h
new file mode 100644
index 0000000000..781bee43d3
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PHash_inline.h
@@ -0,0 +1,193 @@
+//metadoc PHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc PHash license BSD revised
+/*metadoc PHash description
+	PHash - Cuckoo Hash
+	keys and values are references (they are not copied or freed)
+	key pointers are assumed unique
+*/
+
+#ifdef PHASH_C
+#define IO_IN_C_FILE
+#endif
+#include "Common_inline.h"
+#ifdef IO_DECLARE_INLINES
+
+#include <stdio.h>
+
+#define PHASH_RECORDS_AT_(self, tableIndex, index) (self->records + self->tableSize*tableIndex + index)
+#define PHASH_RECORDS_AT_HASH_(self, tableIndex, hash) \
+(self->records + self->tableSize*tableIndex + (hash & self->mask))
+
+IOINLINE unsigned int PHash_count(PHash *self)
+{
+	return self->numKeys;
+}
+
+IOINLINE void PHashRecord_swap(PHashRecord* r1, PHashRecord* r2)
+{
+	PHashRecord t = *r1;
+	*r1 = *r2;
+	*r2 = t;
+}
+
+#define PHashKey_value(k) k
+
+/*
+IOINLINE void *PHashKey_value(void *key)
+{
+	return key;
+}
+*/
+
+IOINLINE unsigned int PHashKey_isEqual_(void *key1, void *key2)
+{
+//	return key2 && (PHashKey_value(key1) == PHashKey_value(key2));
+	return key1 == key2;
+}
+
+// simple hash functions, should be enough for pointers
+IOINLINE unsigned int PHash_hash(PHash *self, void *key)
+{
+	intptr_t k = (intptr_t)PHashKey_value(key);
+	return k^(k>>4);
+}
+
+IOINLINE unsigned int PHash_hash_more(PHash *self, unsigned int hash)
+{
+	return hash ^ (hash >> self->log2tableSize);
+}
+
+// -----------------------------------
+
+IOINLINE void PHash_clean(PHash *self)
+{
+	memset(self->records, 0, sizeof(PHashRecord) * self->tableSize * 2);
+	self->numKeys = 0;
+}
+
+IOINLINE PHashRecord *PHash_recordAt_(PHash *self, void *key)
+{
+	unsigned int hash;
+	PHashRecord *record;
+
+	hash = PHash_hash(self, key);
+	record = PHASH_RECORDS_AT_HASH_(self, 0, hash);
+
+	// we try the second location
+	hash = PHash_hash_more(self, hash);
+	record = (key == record->key) ? record : PHASH_RECORDS_AT_HASH_(self, 1, hash);
+
+	return (key == record->key) ? record : &self->nullRecord;
+}
+
+IOINLINE void *PHash_at_(PHash *self, void *key)
+{
+	return PHash_recordAt_(self, key)->value;
+}
+
+IOINLINE unsigned char PHash_at_update_(PHash *self, void *key, void *value)
+{
+	PHashRecord *record = PHash_recordAt_(self, key);
+
+	if (record->key)
+	{
+		// already a matching key, replace it
+		if (PHashKey_isEqual_(key, record->key))
+		{
+			if (record->value == value)
+			{
+				return 0; // return 0 if no change
+			}
+
+			record->value = value;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+IOINLINE void PHash_at_put_(PHash *self, void *key, void *value)
+{
+	PHashRecord thisRecord;
+	PHashRecord *record;
+
+	record = PHash_recordAt_(self, key);
+
+	// already a matching key, replace it
+	if (record != &self->nullRecord && PHashKey_isEqual_(key, record->key))
+	{
+		record->value = value;
+		return;
+	}
+
+	thisRecord.key = key;
+	thisRecord.value = value;
+
+	record = PHash_cuckoo_(self, &thisRecord);
+
+	if (!record) // collision
+	{
+		PHash_growWithRecord(self, &thisRecord);
+	}
+	else
+	{
+		*record = thisRecord;
+		self->numKeys ++;
+		if (self->numKeys > PHash_maxKeys(self))
+			PHash_grow(self);
+	}
+}
+
+IOINLINE void PHash_removeKey_(PHash *self, void *key)
+{
+	PHashRecord *record = PHash_recordAt_(self, key);
+	void *rkey = record->key;
+
+	if (rkey && PHashKey_value(rkey) == PHashKey_value(key))
+	{
+		self->numKeys --;
+		memset(record, 0, sizeof(PHashRecord));
+	}
+}
+
+// --- enumeration --------------------------------------------------
+
+#define PHASH_FOREACH(self, pkey, pvalue, code) \
+{\
+	PHash *_self = (self);\
+	unsigned int _i, _j, _size = _self->tableSize;\
+	void * pkey;\
+	void * pvalue;\
+	\
+	for (_j = 0; _j < 2; _j ++)\
+	for (_i = 0; _i < _size; _i ++)\
+	{\
+		PHashRecord *_record = PHASH_RECORDS_AT_(_self, _j, _i);\
+		if (_record->key)\
+		{\
+			pkey = _record->key;\
+			pvalue = _record->value;\
+			code;\
+		}\
+	}\
+}
+
+/*
+typedef BASEKIT_API void (PHashDoCallback)(void *);
+
+IOINLINE void PHash_do_(PHash *self, PHashDoCallback *callback)
+{ PHASH_FOREACH(self, k, v, (*callback)(v)); }
+
+IOINLINE void *PHash_detect_(PHash *self, PHashDetectCallback *callback)
+{ PHASH_FOREACH(self, k, v, if ((*callback)(v)) return k; ); return NULL; }
+
+IOINLINE void PHash_doOnKeys_(PHash *self, PHashDoCallback *callback)
+{ PHASH_FOREACH(self, k, v, (*callback)(k)); }
+
+IOINLINE void PHash_doOnKeyAndValue_(PHash *self, PHashDoCallback *callback)
+{ PHASH_FOREACH(self, k, v, (*callback)(k); (*callback)(v);); }
+*/
+
+#undef IO_IN_C_FILE
+#endif
diff --git a/release/src/router/skipdbv2/basekit/PortableGettimeofday.c b/release/src/router/skipdbv2/basekit/PortableGettimeofday.c
new file mode 100644
index 0000000000..79a1258bd0
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableGettimeofday.c
@@ -0,0 +1,57 @@
+#include <time.h>
+#include <sys/types.h>
+#include <sys/timeb.h>
+#include "PortableGettimeofday.h"
+
+#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || defined(_MSC_VER)
+
+	#if defined(__MINGW32__) && (3 < __MINGW32_MAJOR_VERSION || 3 == __MINGW32_MAJOR_VERSION && 9 < __MINGW32_MINOR_VERSION)
+	#else
+
+		#ifndef IO_ADDON_Sockets
+			void gettimeofday(struct timeval *tv, struct timezone *tz)
+			{
+				TIME_ZONE_INFORMATION zoneInfo;
+
+				struct _timeb timeb;
+				_ftime_s(&timeb);
+
+				tv->tv_sec = (long) timeb.time;
+				tv->tv_usec = (long) (timeb.millitm * 1000);
+
+				if (GetTimeZoneInformation(&zoneInfo) != TIME_ZONE_ID_INVALID)
+				{
+					tz->tz_minuteswest = zoneInfo.Bias;
+					tz->tz_dsttime = 0;
+				}
+				else
+				{
+					tz->tz_minuteswest = 0;
+					tz->tz_dsttime = 0;
+				}
+			}
+		#endif
+	#endif
+#else
+
+	/* just to make compiler happy */
+	void PortableGettimeOfday(void)
+	{
+	}
+
+#endif
+
+double secondsSince1970(void)
+{
+	double result;
+	struct timeval tv;
+	struct timezone tz;
+	gettimeofday(&tv, &tz);
+	result = tv.tv_sec;
+	result += tv.tv_usec / 1000000.0;
+	return result;
+}
+
+
+
+
diff --git a/release/src/router/skipdbv2/basekit/PortableGettimeofday.h b/release/src/router/skipdbv2/basekit/PortableGettimeofday.h
new file mode 100644
index 0000000000..7c92752304
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableGettimeofday.h
@@ -0,0 +1,43 @@
+#ifndef PORTABLEGETTIMEOFDAY_DEFINED
+	#define PORTABLEGETTIMEOFDAY_DEFINED 1
+
+	#ifdef __cplusplus
+		extern "C" {
+	#endif
+
+	#if defined(__WIN32__) || defined(WIN32) || defined(_WIN32) || defined(_MSC_VER)
+		#if defined(_MSC_VER)
+			#include <winsock2.h>
+			/*struct timeval
+			{
+				long tv_sec;
+				long tv_usec;
+			};*/
+		#else
+			/* for MingW */
+			#include <sys/time.h>
+		#endif
+
+		#if defined(__MINGW32__) && (3 < __MINGW32_MAJOR_VERSION || 3 == __MINGW32_MAJOR_VERSION && 9 < __MINGW32_MINOR_VERSION)
+		#else
+			struct timezone
+			{
+				int tz_minuteswest; /* of Greenwich */
+				int tz_dsttime;     /* type of dst correction to apply */
+			};
+
+						#include "Common.h"
+			BASEKIT_API extern void gettimeofday(struct timeval *tv, struct timezone *tz);
+		#endif
+
+	#else
+		#include <sys/time.h>
+	#endif
+
+	#ifdef __cplusplus
+		}
+	#endif
+
+#endif
+
+double secondsSince1970(void);
diff --git a/release/src/router/skipdbv2/basekit/PortableSnprintf.c b/release/src/router/skipdbv2/basekit/PortableSnprintf.c
new file mode 100644
index 0000000000..298ce8a631
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableSnprintf.c
@@ -0,0 +1,959 @@
+/*
+ * Copyright Patrick Powell 1995
+ * This code is based on code written by Patrick Powell (papowell@astart.com)
+ * It may be used for any purpose as long as this notice remains intact
+ * on all source code distributions
+ */
+
+/**************************************************************
+ * Original:
+ * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
+ * A bombproof version of doprnt (dopr) included.
+ * Sigh.  This sort of thing is always nasty do deal with.  Note that
+ * the version here does not include floating point...
+ *
+ * snprintf() is used instead of sprintf() as it does limit checks
+ * for string length.  This covers a nasty loophole.
+ *
+ * The other functions are there to prevent NULL pointers from
+ * causing nast effects.
+ *
+ * More Recently:
+ *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
+ *  This was ugly.  It is still ugly.  I opted out of floating point
+ *  numbers, but the formatter understands just about everything
+ *  from the normal C string format, at least as far as I can tell from
+ *  the Solaris 2.5 printf(3S) man page.
+ *
+ *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
+ *    Ok, added some minimal floating point support, which means this
+ *    probably requires libm on most operating systems.  Don't yet
+ *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
+ *    was pretty badly broken, it just wasn't being exercised in ways
+ *    which showed it, so that's been fixed.  Also, formated the code
+ *    to mutt conventions, and removed dead code left over from the
+ *    original.  Also, there is now a builtin-test, just compile with:
+ *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
+ *    and run snprintf for results.
+ *
+ *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
+ *    The PGP code was using unsigned hexadecimal formats.
+ *    Unfortunately, unsigned formats simply didn't work.
+ *
+ *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
+ *    The original code assumed that both snprintf() and vsnprintf() were
+ *    missing.  Some systems only have snprintf() but not vsnprintf(), so
+ *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
+ *
+ *  Andrew Tridgell (tridge@samba.org) Oct 1998
+ *    fixed handling of %.0f
+ *    added test for HAVE_LONG_DOUBLE
+ *
+ * tridge@samba.org, idra@samba.org, April 2001
+ *    got rid of fcvt code (twas buggy and made testing harder)
+ *    added C99 semantics
+ *
+ **************************************************************/
+
+#include <string.h>
+#include <ctype.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <stdlib.h>
+
+#define NO_CONFIG_H 1
+#define HAVE_STRING_H 1
+#define HAVE_CTYPE_H 1
+#define HAVE_STDLIB_H 1
+
+#define HAVE_SNPRINTF 1
+#define HAVE_VSNPRINTF 1
+#define HAVE_C99_VSNPRINTF 1
+
+#define HAVE_LONG_DOUBLE 1
+#define HAVE_LONG_LONG 1
+#define HAVE_SNPRINTF 1
+#define HAVE_C99_VSNPRINTF 1
+#define HAVE_ASPRINTF 1
+#define HAVE_VASPRINTF 1
+
+#ifndef NO_CONFIG_H
+#include "config.h"
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+
+#ifdef HAVE_STRINGS_H
+#include <strings.h>
+#endif
+#ifdef HAVE_CTYPE_H
+#include <ctype.h>
+#endif
+#include <sys/types.h>
+#include <stdarg.h>
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#if defined(HAVE_SNPRINTF) && defined(HAVE_VSNPRINTF) && defined(HAVE_C99_VSNPRINTF)
+/* only include stdio.h if we are not re-defining snprintf or vsnprintf */
+#include <stdio.h>
+/* make the compiler happy with an empty file */
+void dummy_snprintf(void) {}
+#else
+
+#ifdef HAVE_LONG_DOUBLE
+#define LDOUBLE long double
+#else
+#define LDOUBLE double
+#endif
+
+#ifdef HAVE_LONG_LONG
+#define LLONG long long
+#else
+#define LLONG long
+#endif
+
+static size_t dopr(char *buffer, size_t maxlen, const char *format,
+				   va_list args);
+static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
+				   char *value, int flags, int min, int max);
+static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
+				   long value, int base, int min, int max, int flags);
+static void fmtfp(char *buffer, size_t *currlen, size_t maxlen,
+				  LDOUBLE fvalue, int min, int max, int flags);
+static void dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c);
+
+/*
+ * dopr(): poor man's version of doprintf
+ */
+
+/* format read states */
+#define DP_S_DEFAULT 0
+#define DP_S_FLAGS   1
+#define DP_S_MIN     2
+#define DP_S_DOT     3
+#define DP_S_MAX     4
+#define DP_S_MOD     5
+#define DP_S_CONV    6
+#define DP_S_DONE    7
+
+/* format flags - Bits */
+#define DP_F_MINUS      (1 << 0)
+#define DP_F_PLUS       (1 << 1)
+#define DP_F_SPACE      (1 << 2)
+#define DP_F_NUM        (1 << 3)
+#define DP_F_ZERO       (1 << 4)
+#define DP_F_UP         (1 << 5)
+#define DP_F_UNSIGNED   (1 << 6)
+
+/* Conversion Flags */
+#define DP_C_SHORT   1
+#define DP_C_LONG    2
+#define DP_C_LDOUBLE 3
+#define DP_C_LLONG   4
+
+#define char_to_int(p) ((p)- '0')
+#ifndef MAX
+#define MAX(p,q) (((p) >= (q)) ? (p) : (q))
+#endif
+
+static size_t dopr(char *buffer, size_t maxlen, const char *format, va_list args)
+{
+	char ch;
+	LLONG value;
+	LDOUBLE fvalue;
+	char *strvalue;
+	int min;
+	int max;
+	int state;
+	int flags;
+	int cflags;
+	size_t currlen;
+
+	state = DP_S_DEFAULT;
+	currlen = flags = cflags = min = 0;
+	max = -1;
+	ch = *format++;
+
+	while (state != DP_S_DONE) {
+		if (ch == '\0')
+			state = DP_S_DONE;
+
+		switch(state) {
+		case DP_S_DEFAULT:
+			if (ch == '%')
+				state = DP_S_FLAGS;
+			else
+				dopr_outch (buffer, &currlen, maxlen, ch);
+			ch = *format++;
+			break;
+		case DP_S_FLAGS:
+			switch (ch) {
+			case '-':
+				flags |= DP_F_MINUS;
+				ch = *format++;
+				break;
+			case '+':
+				flags |= DP_F_PLUS;
+				ch = *format++;
+				break;
+			case ' ':
+				flags |= DP_F_SPACE;
+				ch = *format++;
+				break;
+			case '#':
+				flags |= DP_F_NUM;
+				ch = *format++;
+				break;
+			case '0':
+				flags |= DP_F_ZERO;
+				ch = *format++;
+				break;
+			default:
+				state = DP_S_MIN;
+				break;
+			}
+			break;
+		case DP_S_MIN:
+			if (isdigit((unsigned char)ch)) {
+				min = 10*min + char_to_int (ch);
+				ch = *format++;
+			} else if (ch == '*') {
+				min = va_arg (args, int);
+				ch = *format++;
+				state = DP_S_DOT;
+			} else {
+				state = DP_S_DOT;
+			}
+			break;
+		case DP_S_DOT:
+			if (ch == '.') {
+				state = DP_S_MAX;
+				ch = *format++;
+			} else {
+				state = DP_S_MOD;
+			}
+			break;
+		case DP_S_MAX:
+			if (isdigit((unsigned char)ch)) {
+				if (max < 0)
+					max = 0;
+				max = 10*max + char_to_int (ch);
+				ch = *format++;
+			} else if (ch == '*') {
+				max = va_arg (args, int);
+				ch = *format++;
+				state = DP_S_MOD;
+			} else {
+				state = DP_S_MOD;
+			}
+			break;
+		case DP_S_MOD:
+			switch (ch) {
+			case 'h':
+				cflags = DP_C_SHORT;
+				ch = *format++;
+				break;
+			case 'l':
+				cflags = DP_C_LONG;
+				ch = *format++;
+				if (ch == 'l') {        /* It's a long long */
+					cflags = DP_C_LLONG;
+					ch = *format++;
+				}
+				break;
+			case 'L':
+				cflags = DP_C_LDOUBLE;
+				ch = *format++;
+				break;
+			default:
+				break;
+			}
+			state = DP_S_CONV;
+			break;
+		case DP_S_CONV:
+			switch (ch) {
+			case 'd':
+			case 'i':
+				if (cflags == DP_C_SHORT)
+					value = va_arg (args, int);
+				else if (cflags == DP_C_LONG)
+					value = va_arg (args, long int);
+				else if (cflags == DP_C_LLONG)
+					value = va_arg (args, LLONG);
+				else
+					value = va_arg (args, int);
+				fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+				break;
+			case 'o':
+				flags |= DP_F_UNSIGNED;
+				if (cflags == DP_C_SHORT)
+					value = va_arg (args, unsigned int);
+				else if (cflags == DP_C_LONG)
+					value = (long)va_arg (args, unsigned long int);
+				else if (cflags == DP_C_LLONG)
+					value = (long)va_arg (args, unsigned LLONG);
+				else
+					value = (long)va_arg (args, unsigned int);
+				fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
+				break;
+			case 'u':
+				flags |= DP_F_UNSIGNED;
+				if (cflags == DP_C_SHORT)
+					value = va_arg (args, unsigned int);
+				else if (cflags == DP_C_LONG)
+					value = (long)va_arg (args, unsigned long int);
+				else if (cflags == DP_C_LLONG)
+					value = (LLONG)va_arg (args, unsigned LLONG);
+				else
+					value = (long)va_arg (args, unsigned int);
+				fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+				break;
+			case 'X':
+				flags |= DP_F_UP;
+			case 'x':
+				flags |= DP_F_UNSIGNED;
+				if (cflags == DP_C_SHORT)
+					value = va_arg (args, unsigned int);
+				else if (cflags == DP_C_LONG)
+					value = (long)va_arg (args, unsigned long int);
+				else if (cflags == DP_C_LLONG)
+					value = (LLONG)va_arg (args, unsigned LLONG);
+				else
+					value = (long)va_arg (args, unsigned int);
+				fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
+				break;
+			case 'f':
+				if (cflags == DP_C_LDOUBLE)
+					fvalue = va_arg (args, LDOUBLE);
+				else
+					fvalue = va_arg (args, double);
+				/* um, floating point? */
+				fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
+				break;
+			case 'E':
+				flags |= DP_F_UP;
+			case 'e':
+				if (cflags == DP_C_LDOUBLE)
+					fvalue = va_arg (args, LDOUBLE);
+				else
+					fvalue = va_arg (args, double);
+				break;
+			case 'G':
+				flags |= DP_F_UP;
+			case 'g':
+				if (cflags == DP_C_LDOUBLE)
+					fvalue = va_arg (args, LDOUBLE);
+				else
+					fvalue = va_arg (args, double);
+				break;
+			case 'c':
+				dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
+				break;
+			case 's':
+				strvalue = va_arg (args, char *);
+				if (max == -1) {
+					max = strlen(strvalue);
+				}
+				if (min > 0 && max >= 0 && min > max) max = min;
+				fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
+				break;
+			case 'p':
+				strvalue = va_arg (args, void *);
+				fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min, max, flags);
+				break;
+			case 'n':
+				if (cflags == DP_C_SHORT) {
+					short int *num;
+					num = va_arg (args, short int *);
+					*num = currlen;
+				} else if (cflags == DP_C_LONG) {
+					long int *num;
+					num = va_arg (args, long int *);
+					*num = (long int)currlen;
+				} else if (cflags == DP_C_LLONG) {
+					LLONG *num;
+					num = va_arg (args, LLONG *);
+					*num = (LLONG)currlen;
+				} else {
+					int *num;
+					num = va_arg (args, int *);
+					*num = currlen;
+				}
+				break;
+			case '%':
+				dopr_outch (buffer, &currlen, maxlen, ch);
+				break;
+			case 'w':
+				/* not supported yet, treat as next char */
+				ch = *format++;
+				break;
+			default:
+				/* Unknown, skip */
+				break;
+			}
+			ch = *format++;
+			state = DP_S_DEFAULT;
+			flags = cflags = min = 0;
+			max = -1;
+			break;
+		case DP_S_DONE:
+			break;
+		default:
+			/* hmm? */
+			break; /* some picky compilers need this */
+		}
+	}
+	if (maxlen != 0) {
+		if (currlen < maxlen - 1)
+			buffer[currlen] = '\0';
+		else if (maxlen > 0)
+			buffer[maxlen - 1] = '\0';
+	}
+
+	return currlen;
+}
+
+static void fmtstr(char *buffer, size_t *currlen, size_t maxlen,
+				   char *value, int flags, int min, int max)
+{
+	int padlen, strln;     /* amount to pad */
+	int cnt = 0;
+
+#ifdef DEBUG_SNPRINTF
+	printf("fmtstr min=%d max=%d s=[%s]\n", min, max, value);
+#endif
+	if (value == 0) {
+		value = "<NULL>";
+	}
+
+	for (strln = 0; value[strln]; ++strln); /* strlen */
+	padlen = min - strln;
+	if (padlen < 0)
+		padlen = 0;
+	if (flags & DP_F_MINUS)
+		padlen = -padlen; /* Left Justify */
+
+	while ((padlen > 0) && (cnt < max)) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--padlen;
+		++cnt;
+	}
+	while (*value && (cnt < max)) {
+		dopr_outch (buffer, currlen, maxlen, *value++);
+		++cnt;
+	}
+	while ((padlen < 0) && (cnt < max)) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++padlen;
+		++cnt;
+	}
+}
+
+/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
+
+static void fmtint(char *buffer, size_t *currlen, size_t maxlen,
+				   long value, int base, int min, int max, int flags)
+{
+	int signvalue = 0;
+	unsigned long uvalue;
+	char convert[20];
+	int place = 0;
+	int spadlen = 0; /* amount to space pad */
+	int zpadlen = 0; /* amount to zero pad */
+	int caps = 0;
+
+	if (max < 0)
+		max = 0;
+
+	uvalue = value;
+
+	if(!(flags & DP_F_UNSIGNED)) {
+		if( value < 0 ) {
+			signvalue = '-';
+			uvalue = -value;
+		} else {
+			if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
+				signvalue = '+';
+			else if (flags & DP_F_SPACE)
+				signvalue = ' ';
+		}
+	}
+
+	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+
+	do {
+		convert[place++] =
+			(caps? "0123456789ABCDEF":"0123456789abcdef")
+			[uvalue % (unsigned)base  ];
+		uvalue = (uvalue / (unsigned)base );
+	} while(uvalue && (place < 20));
+	if (place == 20) place--;
+	convert[place] = 0;
+
+	zpadlen = max - place;
+	spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
+	if (zpadlen < 0) zpadlen = 0;
+	if (spadlen < 0) spadlen = 0;
+	if (flags & DP_F_ZERO) {
+		zpadlen = MAX(zpadlen, spadlen);
+		spadlen = 0;
+	}
+	if (flags & DP_F_MINUS)
+		spadlen = -spadlen; /* Left Justifty */
+
+#ifdef DEBUG_SNPRINTF
+	printf("zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
+		   zpadlen, spadlen, min, max, place);
+#endif
+
+	/* Spaces */
+	while (spadlen > 0) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--spadlen;
+	}
+
+	/* Sign */
+	if (signvalue)
+		dopr_outch (buffer, currlen, maxlen, signvalue);
+
+	/* Zeros */
+	if (zpadlen > 0) {
+		while (zpadlen > 0) {
+			dopr_outch (buffer, currlen, maxlen, '0');
+			--zpadlen;
+		}
+	}
+
+	/* Digits */
+	while (place > 0)
+		dopr_outch (buffer, currlen, maxlen, convert[--place]);
+
+	/* Left Justified spaces */
+	while (spadlen < 0) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++spadlen;
+	}
+}
+
+static LDOUBLE abs_val(LDOUBLE value)
+{
+	LDOUBLE result = value;
+
+	if (value < 0)
+		result = -value;
+
+	return result;
+}
+
+static LDOUBLE POW10(int exp)
+{
+	LDOUBLE result = 1;
+
+	while (exp) {
+		result *= 10;
+		exp--;
+	}
+
+	return result;
+}
+
+static LLONG ROUND(LDOUBLE value)
+{
+	LLONG intpart;
+
+	intpart = (LLONG)value;
+	value = value - intpart;
+	if (value >= 0.5) intpart++;
+
+	return intpart;
+}
+
+/* a replacement for modf that doesn't need the math library. Should
+ be portable, but slow */
+static double my_modf(double x0, double *iptr)
+{
+	int i;
+	long l;
+	double x = x0;
+	double f = 1.0;
+
+	for (i=0;i<100;i ++) {
+		l = (long)x;
+		if (l <= (x+1) && l >= (x-1)) break;
+		x *= 0.1;
+		f *= 10.0;
+	}
+
+	if (i == 100) {
+		/* yikes! the number is beyond what we can handle. What do we do? */
+		(*iptr) = 0;
+		return 0;
+	}
+
+	if (i != 0) {
+		double i2;
+		double ret;
+
+		ret = my_modf(x0-l*f, &i2);
+		(*iptr) = l*f + i2;
+		return ret;
+	}
+
+	(*iptr) = l;
+	return x - (*iptr);
+}
+
+
+static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
+				   LDOUBLE fvalue, int min, int max, int flags)
+{
+	int signvalue = 0;
+	double ufvalue;
+	char iconvert[311];
+	char fconvert[311];
+	int iplace = 0;
+	int fplace = 0;
+	int padlen = 0; /* amount to pad */
+	int zpadlen = 0;
+	int caps = 0;
+	int index;
+	double intpart;
+	double fracpart;
+	double temp;
+
+	/*
+	 * AIX manpage says the default is 0, but Solaris says the default
+	 * is 6, and sprintf on AIX defaults to 6
+	 */
+	if (max < 0)
+		max = 6;
+
+	ufvalue = abs_val (fvalue);
+
+	if (fvalue < 0) {
+		signvalue = '-';
+	} else {
+		if (flags & DP_F_PLUS) { /* Do a sign (+/i) */
+			signvalue = '+';
+		} else {
+			if (flags & DP_F_SPACE)
+				signvalue = ' ';
+		}
+	}
+
+#if 0
+	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+#endif
+
+#if 0
+	if (max == 0) ufvalue += 0.5; /* if max = 0 we must round */
+#endif
+
+	/*
+	 * Sorry, we only support 16 digits past the decimal because of our
+	 * conversion method
+	 */
+	if (max > 16)
+		max = 16;
+
+	/* We "cheat" by converting the fractional part to integer by
+	 * multiplying by a factor of 10
+	 */
+
+	temp = ufvalue;
+	my_modf(temp, &intpart);
+
+	fracpart = ROUND((POW10(max)) * (ufvalue - intpart));
+
+	if (fracpart >= POW10(max)) {
+		intpart++;
+		fracpart -= POW10(max);
+	}
+
+
+	/* Convert integer part */
+	do {
+		temp = intpart;
+		my_modf(intpart*0.1, &intpart);
+		temp = temp*0.1;
+		index = (int) ((temp -intpart +0.05)* 10.0);
+		/* index = (int) (((double)(temp*0.1) -intpart +0.05) *10.0); */
+		/* printf ("%llf, %f, %x\n", temp, intpart, index); */
+		iconvert[iplace++] =
+			(caps? "0123456789ABCDEF":"0123456789abcdef")[index];
+	} while (intpart && (iplace < 311));
+	if (iplace == 311) iplace--;
+	iconvert[iplace] = 0;
+
+	/* Convert fractional part */
+	if (fracpart)
+	{
+		do {
+			temp = fracpart;
+			my_modf(fracpart*0.1, &fracpart);
+			temp = temp*0.1;
+			index = (int) ((temp -fracpart +0.05)* 10.0);
+			/* index = (int) ((((temp/10) -fracpart) +0.05) *10); */
+			/* printf ("%lf, %lf, %ld\n", temp, fracpart, index); */
+			fconvert[fplace++] =
+				(caps? "0123456789ABCDEF":"0123456789abcdef")[index];
+		} while(fracpart && (fplace < 311));
+		if (fplace == 311) fplace--;
+	}
+	fconvert[fplace] = 0;
+
+	/* -1 for decimal point, another -1 if we are printing a sign */
+	padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0);
+	zpadlen = max - fplace;
+	if (zpadlen < 0) zpadlen = 0;
+	if (padlen < 0)
+		padlen = 0;
+	if (flags & DP_F_MINUS)
+		padlen = -padlen; /* Left Justifty */
+
+	if ((flags & DP_F_ZERO) && (padlen > 0)) {
+		if (signvalue) {
+			dopr_outch (buffer, currlen, maxlen, signvalue);
+			--padlen;
+			signvalue = 0;
+		}
+		while (padlen > 0) {
+			dopr_outch (buffer, currlen, maxlen, '0');
+			--padlen;
+		}
+	}
+	while (padlen > 0) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--padlen;
+	}
+	if (signvalue)
+		dopr_outch (buffer, currlen, maxlen, signvalue);
+
+	while (iplace > 0)
+		dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
+
+#ifdef DEBUG_SNPRINTF
+	printf("fmtfp: fplace=%d zpadlen=%d\n", fplace, zpadlen);
+#endif
+
+	/*
+	 * Decimal point.  This should probably use locale to find the correct
+	 * char to print out.
+	 */
+	if (max > 0) {
+		dopr_outch (buffer, currlen, maxlen, '.');
+
+		while (fplace > 0)
+			dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
+	}
+
+	while (zpadlen > 0) {
+		dopr_outch (buffer, currlen, maxlen, '0');
+		--zpadlen;
+	}
+
+	while (padlen < 0) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++padlen;
+	}
+}
+
+static void dopr_outch(char *buffer, size_t *currlen, size_t maxlen, char c)
+{
+	if (*currlen < maxlen) {
+		buffer[(*currlen)] = c;
+	}
+	(*currlen)++;
+}
+
+#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+int vsnprintf (char *str, size_t count, const char *fmt, va_list args)
+{
+	return dopr(str, count, fmt, args);
+}
+#endif
+
+#if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)
+int snprintf(char *str,size_t count,const char *fmt,...)
+{
+	size_t ret;
+	va_list ap;
+
+	va_start(ap, fmt);
+	ret = vsnprintf(str, count, fmt, ap);
+	va_end(ap);
+	return ret;
+}
+#endif
+
+#endif
+
+#ifndef HAVE_VASPRINTF
+int vasprintf(char **ptr, const char *format, va_list ap)
+{
+	int ret;
+
+	ret = vsnprintf(NULL, 0, format, ap);
+	if (ret <= 0) return ret;
+
+	(*ptr) = (char *)io_calloc(1, ret+1);
+	if (!*ptr) return -1;
+	ret = vsnprintf(*ptr, ret+1, format, ap);
+
+	return ret;
+}
+#endif
+
+
+#ifndef HAVE_ASPRINTF
+int asprintf(char **ptr, const char *format, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap, format);
+	ret = vasprintf(ptr, format, ap);
+	va_end(ap);
+
+	return ret;
+}
+#endif
+
+#ifdef TEST_SNPRINTF
+
+int sprintf(char *str,const char *fmt,...);
+
+int main (void)
+{
+	char buf1[1024];
+	char buf2[1024];
+	char *fp_fmt[] = {
+		"%1.1f",
+		"%-1.5f",
+		"%1.5f",
+		"%123.9f",
+		"%10.5f",
+		"% 10.5f",
+		"%+22.9f",
+		"%+4.9f",
+		"%01.3f",
+		"%4f",
+		"%3.1f",
+		"%3.2f",
+		"%.0f",
+		"%f",
+		"-16.16f",
+		NULL
+	};
+	double fp_nums[] = { 6442452944.1234, -1.5, 134.21, 91340.2, 341.1234, 0203.9, 0.96, 0.996,
+	0.9996, 1.996, 4.136,  0};
+	char *int_fmt[] = {
+		"%-1.5d",
+		"%1.5d",
+		"%123.9d",
+		"%5.5d",
+		"%10.5d",
+		"% 10.5d",
+		"%+22.33d",
+		"%01.3d",
+		"%4d",
+		"%d",
+		NULL
+	};
+	long int_nums[] = { -1, 134, 91340, 341, 0203, 0};
+	char *str_fmt[] = {
+		"10.5s",
+		"5.10s",
+		"10.1s",
+		"0.10s",
+		"10.0s",
+		"1.10s",
+		"%s",
+		"%.1s",
+		"%.10s",
+		"%10s",
+		NULL
+	};
+	char *str_vals[] = {"hello", "a", "", "a longer string", NULL};
+	int x, y;
+	int fail = 0;
+	int num = 0;
+
+	printf ("Testing snprintf format codes against system sprintf...\n");
+
+	for (x = 0; fp_fmt[x] ; x++) {
+		for (y = 0; fp_nums[y] != 0 ; y++) {
+			int l1 = snprintf(NULL, 0, fp_fmt[x], fp_nums[y]);
+			int l2 = snprintf(buf1, sizeof(buf1), fp_fmt[x], fp_nums[y]);
+			sprintf (buf2, fp_fmt[x], fp_nums[y]);
+			if (strcmp (buf1, buf2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n",
+					   fp_fmt[x], buf1, buf2);
+				fail++;
+			}
+			if (l1 != l2) {
+				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, fp_fmt[x]);
+				fail++;
+			}
+			num++;
+		}
+	}
+
+	for (x = 0; int_fmt[x] ; x++) {
+		for (y = 0; int_nums[y] != 0 ; y++) {
+			int l1 = snprintf(NULL, 0, int_fmt[x], int_nums[y]);
+			int l2 = snprintf(buf1, sizeof(buf1), int_fmt[x], int_nums[y]);
+			sprintf (buf2, int_fmt[x], int_nums[y]);
+			if (strcmp (buf1, buf2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n",
+					   int_fmt[x], buf1, buf2);
+				fail++;
+			}
+			if (l1 != l2) {
+				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, int_fmt[x]);
+				fail++;
+			}
+			num++;
+		}
+	}
+
+	for (x = 0; str_fmt[x] ; x++) {
+		for (y = 0; str_vals[y] != 0 ; y++) {
+			int l1 = snprintf(NULL, 0, str_fmt[x], str_vals[y]);
+			int l2 = snprintf(buf1, sizeof(buf1), str_fmt[x], str_vals[y]);
+			sprintf (buf2, str_fmt[x], str_vals[y]);
+			if (strcmp (buf1, buf2)) {
+				printf("snprintf doesn't match Format: %s\n\tsnprintf = [%s]\n\t sprintf = [%s]\n",
+					   str_fmt[x], buf1, buf2);
+				fail++;
+			}
+			if (l1 != l2) {
+				printf("snprintf l1 != l2 (%d %d) %s\n", l1, l2, str_fmt[x]);
+				fail++;
+			}
+			num++;
+		}
+	}
+
+	printf ("%d tests failed out of %d.\n", fail, num);
+
+	printf("seeing how many digits we support\n");
+	{
+		double v0 = 0.12345678901234567890123456789012345678901;
+		for (x=0; x<100; x++) {
+			snprintf(buf1, sizeof(buf1), "%1.1f", v0*pow(10, x));
+			sprintf(buf2,                "%1.1f", v0*pow(10, x));
+			if (strcmp(buf1, buf2)) {
+				printf("we seem to support %d digits\n", x-1);
+				break;
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /* SNPRINTF_TEST */
diff --git a/release/src/router/skipdbv2/basekit/PortableStdint.h b/release/src/router/skipdbv2/basekit/PortableStdint.h
new file mode 100644
index 0000000000..5906068aa3
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableStdint.h
@@ -0,0 +1,106 @@
+/*-
+ * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/sys/stdint.h,v 1.4 2002/08/21 16:20:01 mike Exp $
+ */
+
+#ifndef _SYS_STDINT_H_
+#define _SYS_STDINT_H_
+
+#include <sys/cdefs.h>
+#include <sys/_types.h>
+
+#include <machine/_stdint.h>
+
+#ifndef _INT8_T_DECLARED
+typedef __int8_t        int8_t;
+#define _INT8_T_DECLARED
+#endif
+
+#ifndef _INT16_T_DECLARED
+typedef __int16_t       int16_t;
+#define _INT16_T_DECLARED
+#endif
+
+#ifndef _INT32_T_DECLARED
+typedef __int32_t       int32_t;
+#define _INT32_T_DECLARED
+#endif
+
+#ifndef _INT64_T_DECLARED
+typedef __int64_t       int64_t;
+#define _INT64_T_DECLARED
+#endif
+
+#ifndef _UINT8_T_DECLARED
+typedef __uint8_t       uint8_t;
+#define _UINT8_T_DECLARED
+#endif
+
+#ifndef _UINT16_T_DECLARED
+typedef __uint16_t      uint16_t;
+#define _UINT16_T_DECLARED
+#endif
+
+#ifndef _UINT32_T_DECLARED
+typedef __uint32_t      uint32_t;
+#define _UINT32_T_DECLARED
+#endif
+
+#ifndef _UINT64_T_DECLARED
+typedef __uint64_t      uint64_t;
+#define _UINT64_T_DECLARED
+#endif
+
+typedef __int_least8_t   int_least8_t;
+typedef __int_least16_t  int_least16_t;
+typedef __int_least32_t  int_least32_t;
+typedef __int_least64_t  int_least64_t;
+
+typedef __uint_least8_t  uint_least8_t;
+typedef __uint_least16_t uint_least16_t;
+typedef __uint_least32_t uint_least32_t;
+typedef __uint_least64_t uint_least64_t;
+
+typedef __int_fast8_t    int_fast8_t;
+typedef __int_fast16_t   int_fast16_t;
+typedef __int_fast32_t   int_fast32_t;
+typedef __int_fast64_t   int_fast64_t;
+
+typedef __uint_fast8_t   uint_fast8_t;
+typedef __uint_fast16_t  uint_fast16_t;
+typedef __uint_fast32_t  uint_fast32_t;
+typedef __uint_fast64_t  uint_fast64_t;
+
+typedef __intmax_t       intmax_t;
+typedef __uintmax_t      uintmax_t;
+
+#ifndef _INTPTR_T_DECLARED
+typedef __intptr_t       intptr_t;
+typedef __uintptr_t      uintptr_t;
+#define _INTPTR_T_DECLARED
+#endif
+
+#endif /* !_SYS_STDINT_H_ */
diff --git a/release/src/router/skipdbv2/basekit/PortableStrlcpy.c b/release/src/router/skipdbv2/basekit/PortableStrlcpy.c
new file mode 100644
index 0000000000..0c5c1fa283
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableStrlcpy.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *  notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *  notice, this list of conditions and the following disclaimer in the
+ *  documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *  derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/types.h>
+#include "PortableStrlcpy.h"
+
+/*
+ * Copy src to string dest of size len.  At most len-1 characters
+ * will be copied.  Always NUL terminates (unless len == 0).
+ * Returns strlen(src); if retval >= len, truncation occurred.
+ */
+size_t PortableStrlcpy(char* dest, const char* src, size_t len)
+{
+	char* d = dest;
+	const char* s = src;
+	size_t n = len;
+
+	/* Copy as many bytes as will fit */
+	if (n != 0 && --n != 0)
+	{
+		do
+		{
+			if ((*d++ = *s++) == 0)
+				break;
+		} while (--n != 0);
+	}
+
+	/* Not enough room in dest, add NUL and traverse rest of src */
+	if (n == 0)
+	{
+		if (len != 0)
+			*d = '\0'; /* NUL-terminate dest */
+		while (*s++);
+	}
+
+	return (s - src - 1); /* count doesn't include NUL */
+}
diff --git a/release/src/router/skipdbv2/basekit/PortableStrlcpy.h b/release/src/router/skipdbv2/basekit/PortableStrlcpy.h
new file mode 100644
index 0000000000..6d9c0d9b72
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableStrlcpy.h
@@ -0,0 +1,9 @@
+#ifdef _WIN32
+#include <stddef.h> // size_t on windows
+#else
+#include <sys/types.h> // size_t
+#endif
+
+#define strlcpy(d, s, l) PortableStrlcpy((d), (s), (l))
+
+size_t PortableStrlcpy(char*, const char*, size_t);
diff --git a/release/src/router/skipdbv2/basekit/PortableStrptime.c b/release/src/router/skipdbv2/basekit/PortableStrptime.c
new file mode 100644
index 0000000000..58bd649ec3
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableStrptime.c
@@ -0,0 +1,400 @@
+/*
+ * code found at: http://www.uni-paderborn.de/info/solaris_porting_faq
+ */
+/*
+ * Copyright (c) 1994 Powerdog Industries.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in the documentation and/or other materials provided with the
+ *    distribution.
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgement:
+ *      This product includes software developed by Powerdog Industries.
+ * 4. The name of Powerdog Industries may not be used to endorse or
+ *    promote products derived from this software without specific prior
+ *    written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY POWERDOG INDUSTRIES ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE POWERDOG INDUSTRIES BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /* A few changes by Steve Dekorte:
+  * - renamed function and moved En_US into function
+  */
+#include "Base.h"
+#include "PortableStrptime.h"
+
+/*#ifdef IO_NEEDS_STRPTIME*/
+
+#include <time.h>
+#include <ctype.h>
+#include <locale.h>
+#include <string.h>
+
+#define asizeof(a)      (sizeof (a) / sizeof ((a)[0]))
+
+/*#ifndef sun*/
+struct dtconv {
+		char    *abbrev_month_names[12];
+		char    *month_names[12];
+		char    *abbrev_weekday_names[7];
+		char    *weekday_names[7];
+		char    *time_format;
+		char    *sdate_format;
+		char    *dtime_format;
+		char    *am_string;
+		char    *pm_string;
+		char    *ldate_format;
+};
+/*#endif*/
+
+#ifdef SUNOS4
+	extern int strncasecmp();
+#endif
+
+#if defined(_MSC_VER) && !defined(__SYMBIAN32__)
+	#define strcasecmp _stricmp
+	#define strncasecmp _strnicmp
+#endif
+
+int readndigits(char **const buf, const size_t count)
+{
+	int result = 0;
+	int i;
+
+	for (i = 0; i < count; i++, (*buf)++) {
+		const char digit = **buf;
+		if (digit == 0 || !isdigit(digit)) {
+			break;
+		}
+		result *= 10;
+		result += digit - '0';
+	}
+
+	return result;
+}
+
+// TODO rename function when I understand what this function does.
+void somethingToDoWithSpaces(const char *const buf, char **const ptr)
+{
+	if (*buf != 0 && isspace((int)*buf)) {
+		while (**ptr != 0 && !isspace((int)**ptr)) {
+			(*ptr)++;
+		}
+	}
+}
+
+char *io_strptime(char *buf, char *fmt, struct tm *tm)
+{
+		struct dtconv En_US = {
+		{ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+		  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" },
+		{ "January", "February", "March", "April",
+		  "May", "June", "July", "August",
+		  "September", "October", "November", "December" },
+		{ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" },
+		{ "Sunday", "Monday", "Tuesday", "Wednesday",
+		  "Thursday", "Friday", "Saturday" },
+		"%H:%M:%S",
+		"%m/%d/%y",
+		"%a %b %e %T %Z %Y",
+		"AM",
+		"PM",
+		"%A, %B, %e, %Y"
+		 };
+
+		char    c,
+				*ptr;
+		int     i,
+				len;
+
+	len = 0;
+		ptr = fmt;
+		while (*ptr != 0) {
+				if (*buf == 0)
+						break;
+
+				c = *ptr++;
+
+				if (c != '%') {
+						if (isspace((int)c))
+								while (*buf != 0 && isspace((int)*buf))
+										buf++;
+						else if (c != *buf++)
+								return NULL;
+						continue;
+				}
+
+				c = *ptr++;
+				switch (c) {
+				case 0:
+						return NULL;
+
+				case '%':
+						if (*buf++ != '%')
+								return NULL;
+						break;
+
+				case 'C':
+						buf = io_strptime(buf, En_US.ldate_format, tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'c':
+						buf = io_strptime(buf, "%x %X", tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'D':
+						buf = io_strptime(buf, "%m/%d/%y", tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'R':
+						buf = io_strptime(buf, "%H:%M", tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'r':
+						buf = io_strptime(buf, "%I:%M:%S %p", tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'T':
+						buf = io_strptime(buf, "%H:%M:%S", tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'X':
+						buf = io_strptime(buf, En_US.time_format, tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'x':
+						buf = io_strptime(buf, En_US.sdate_format, tm);
+						if (buf == 0)
+								return NULL;
+						break;
+
+				case 'j':
+						if (*buf == 0 || isspace((int)*buf))
+								break;
+
+						i = readndigits(&buf, 3);
+						if (i < 0 || i > 366)
+								return NULL;
+
+						tm->tm_yday = i;
+						break;
+
+				case 'M':
+						if (*buf == 0 || isspace((int)*buf))
+								break;
+
+						i = readndigits(&buf, 2);
+						if (i < 0 || i > 59)
+								return NULL;
+
+						tm->tm_min = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'S':
+						if (*buf == 0 || isspace((int)*buf))
+								break;
+
+						i = readndigits(&buf, 2);
+						if (i < 0 || i > 60) // Earlier 61 was also allowed.
+								return NULL;
+
+						tm->tm_sec = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'H':
+				case 'k':
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 2);
+						if (i < 0 || i > 23)
+								return NULL;
+
+						tm->tm_hour = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'I':
+				case 'l':
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 2);
+						if (i < 1 || i > 12)
+								return NULL;
+
+						tm->tm_hour = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'd':
+				case 'e':
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 2);
+						if (i < 1 || i > 31)
+								return NULL;
+
+						tm->tm_mday = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'm':
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 2);
+						if (i < 1 || i > 12)
+								return NULL;
+
+						tm->tm_mon = i - 1;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'Y':
+						if (*buf == 0 || isspace((int)*buf))
+								break;
+
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 4);
+						if (i < 0 || i > 9999)
+								return NULL;
+
+						tm->tm_year = i - 1900;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'y':
+						if (*buf == 0 || isspace((int)*buf))
+								break;
+
+						if (!isdigit((int)*buf))
+								return NULL;
+
+						i = readndigits(&buf, 2);
+						if (i < 0 || i > 99)
+								return NULL;
+
+						tm->tm_year = i;
+
+						somethingToDoWithSpaces(buf, &ptr);
+						break;
+
+				case 'P':
+				case 'p':
+						len = strlen(En_US.am_string);
+						if (strncasecmp(buf, En_US.am_string, len) == 0) {
+								if (tm->tm_hour > 12)
+										return NULL;
+								if (tm->tm_hour == 12)
+										tm->tm_hour = 0;
+								buf += len;
+								break;
+						}
+
+						len = strlen(En_US.pm_string);
+						if (strncasecmp(buf, En_US.pm_string, len) == 0) {
+								if (tm->tm_hour > 12)
+										return NULL;
+								if (tm->tm_hour != 12)
+										tm->tm_hour += 12;
+								buf += len;
+								break;
+						}
+
+						return NULL;
+
+				case 'A':
+				case 'a':
+						for (i = 0; i < (int)asizeof(En_US.weekday_names); i ++) {
+								len = strlen(En_US.weekday_names[i]);
+								if (strncasecmp(buf,
+												En_US.weekday_names[i],
+												len) == 0)
+										break;
+
+								len = strlen(En_US.abbrev_weekday_names[i]);
+								if (strncasecmp(buf,
+												En_US.abbrev_weekday_names[i],
+												len) == 0)
+										break;
+						}
+						if (i == asizeof(En_US.weekday_names))
+								return NULL;
+
+						tm->tm_wday = i;
+						buf += len;
+						break;
+
+				case 'B':
+				case 'b':
+				case 'h':
+						for (i = 0; i < (int)asizeof(En_US.month_names); i ++) {
+								len = strlen(En_US.month_names[i]);
+								if (strncasecmp(buf,
+												En_US.month_names[i],
+												len) == 0)
+										break;
+
+								len = strlen(En_US.abbrev_month_names[i]);
+								if (strncasecmp(buf,
+												En_US.abbrev_month_names[i],
+												len) == 0)
+										break;
+						}
+						if (i == asizeof(En_US.month_names))
+								return NULL;
+
+						tm->tm_mon = i;
+						buf += len;
+						break;
+				}
+		}
+
+		return buf;
+}
+
+/*#endif*/
+
diff --git a/release/src/router/skipdbv2/basekit/PortableStrptime.h b/release/src/router/skipdbv2/basekit/PortableStrptime.h
new file mode 100644
index 0000000000..d2b5d2a307
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableStrptime.h
@@ -0,0 +1,13 @@
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*#ifdef IO_NEEDS_STRPTIME */
+char *io_strptime(char *buf, char *fmt, struct tm *tm);
+/*#endif*/
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/release/src/router/skipdbv2/basekit/PortableTruncate.c b/release/src/router/skipdbv2/basekit/PortableTruncate.c
new file mode 100644
index 0000000000..db3c674deb
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableTruncate.c
@@ -0,0 +1,44 @@
+
+#include "PortableTruncate.h"
+
+
+int PortableTruncate_justHereToAvoidRanlibWarning(void) { return 0; }
+
+#ifdef _WIN32
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <windows.h>
+
+// Win32 truncate by Mike Austin
+
+int truncate(const char *path, long length)
+{
+	HANDLE file = CreateFile(path, GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
+					FILE_SHARE_WRITE | FILE_SHARE_READ, NULL);
+
+	if (file == INVALID_HANDLE_VALUE)
+	{
+		return -1;
+	}
+
+	if (SetFilePointer(file, length, NULL, FILE_BEGIN) == 0xFFFFFFFF || !SetEndOfFile(file))
+	{
+		CloseHandle(file);
+		return -1;
+	}
+
+	CloseHandle(file);
+	return 0;
+}
+
+#endif
+
+#if defined(__SYMBIAN32__)
+int truncate(const char* path, long length)
+{
+	// TODO: Implement for Symbian
+	return -1;
+}
+#endif
diff --git a/release/src/router/skipdbv2/basekit/PortableTruncate.h b/release/src/router/skipdbv2/basekit/PortableTruncate.h
new file mode 100644
index 0000000000..afbfbfbd68
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableTruncate.h
@@ -0,0 +1,21 @@
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#ifdef _WIN32
+#include "Common.h"
+
+BASEKIT_API    int truncate(const char *path, long length);
+
+#else
+
+	#include <unistd.h>
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/release/src/router/skipdbv2/basekit/PortableUsleep.c b/release/src/router/skipdbv2/basekit/PortableUsleep.c
new file mode 100644
index 0000000000..e52ebf01bc
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableUsleep.c
@@ -0,0 +1,32 @@
+int PortableUsleep_justHereToAvoidRanlibWarning(void) { return 0; }
+
+#ifdef WIN32
+#include <windows.h>
+
+int usleep(unsigned int us)
+{
+	static LARGE_INTEGER freq;
+	static int initted = 0;
+	LARGE_INTEGER s, e, d;
+
+	if (!initted)
+	{
+		QueryPerformanceFrequency(&freq);
+		initted = 1;
+	}
+
+	QueryPerformanceCounter(&s);
+	d.QuadPart = freq.QuadPart * ((double)us / 1000000.0);
+
+	do
+	{
+		QueryPerformanceCounter(&e);
+	} while (e.QuadPart - s.QuadPart < d.QuadPart);
+
+	return 0;
+
+}
+
+#endif
+
+
diff --git a/release/src/router/skipdbv2/basekit/PortableUsleep.h b/release/src/router/skipdbv2/basekit/PortableUsleep.h
new file mode 100644
index 0000000000..49388ea80c
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/PortableUsleep.h
@@ -0,0 +1,10 @@
+
+#ifdef ON_WINDOWS
+	#include <windows.h>
+#ifndef WIN32
+	int usleep (unsigned int us);
+#endif
+#else
+	#include <unistd.h>
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/RandomGen.c b/release/src/router/skipdbv2/basekit/RandomGen.c
new file mode 100644
index 0000000000..123e96ffc0
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/RandomGen.c
@@ -0,0 +1,324 @@
+
+/*
+ A C-program for MT19937, with improved initialization 2002/1/26.
+
+ This is an optimized version that amortizes the shift/reload cost,
+ by Eric Landry 2004-03-15.
+
+ Before using, initialize the state by using RandomGen_setSeed(seed) or
+ init_by_array(init_key, key_length).
+
+ Copyright (C) 1997--2004, Makoto Matsumoto, Takuji Nishimura, and
+ Eric Landry; All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+
+ 1. Redistributions of source code must retain the above copyright
+ notice, this list of conditions and the following disclaimer.
+
+ 2. Redistributions in binary form must reproduce the above copyright
+ notice, this list of conditions and the following disclaimer
+ in the documentation and/or other materials provided with the
+ distribution.
+
+ 3. The names of its contributors may not be used to endorse or
+ promote products derived from this software without specific
+ prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
+ OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ Any feedback is very welcome.
+ http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
+ email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
+
+ Reference: M. Matsumoto and T. Nishimura, "Mersenne Twister:
+ A 623-Dimensionally Equidistributed Uniform Pseudo-RandomGen Number
+ Generator", ACM Transactions on Modeling and Computer Simulation,
+ Vol. 8, No. 1, January 1998, pp 3--30.
+ */
+
+#include "Base.h"
+#include "RandomGen.h"
+
+/* Period parameters */
+#define N RANDOMGEN_N
+#define M 397
+#define MATRIX_A 0x9908b0dfUL   /* constant vector a */
+#define UPPER_MASK 0x80000000UL /* most significant w-r bits */
+#define LOWER_MASK 0x7fffffffUL /* least significant r bits */
+
+/*static unsigned long self->mt[N];*/ /* the array for the state vector  */
+/*static int self->mti=N+1;*/ /* self->mti==N+1 means self->mt[N] is not initialized */
+
+/* initializes self->mt[N] with a seed */
+
+static void init_genrand(RandomGen *self, unsigned long s)
+{
+	self->mt[0]= s & 0xffffffffUL;
+	for (self->mti=1; self->mti<N; self->mti ++)
+	{
+		self->mt[self->mti] =
+		(1812433253UL * (self->mt[self->mti-1] ^ (self->mt[self->mti-1] >> 30)) + self->mti);
+		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
+		/* In the previous versions, MSBs of the seed affect   */
+		/* only MSBs of the array self->mt[].                        */
+		/* 2002/01/09 modified by Makoto Matsumoto             */
+		self->mt[self->mti] &= 0xffffffffUL;
+		/* for >32 bit machines */
+	}
+}
+
+void RandomGen_setSeed(RandomGen *self, unsigned long seed)
+{
+	init_genrand(self, seed);
+}
+
+#include <time.h>
+
+void RandomGen_chooseRandomSeed(RandomGen *self)
+{
+	unsigned long seed = 0;
+
+	seed ^= (unsigned long)clock(); // processor time since program start
+	seed ^= (unsigned long)time(NULL); // seconds since 1970
+
+	RandomGen_setSeed(self, seed);
+}
+
+/* initialize by an array with array-length */
+/* init_key is the array for initializing keys */
+/* key_length is its length */
+/* slight change for C++, 2004/2/26 */
+#ifdef EXTRAS
+static void init_by_array(RandomGen *self, unsigned long init_key[],int key_length)
+{
+	int i, j, k;
+
+	init_genrand(self, 19650218UL);
+	i=1; j=0;
+	k = (N>key_length ? N : key_length);
+
+	for (; k; k--) {
+		self->mt[i] = (self->mt[i] ^ ((self->mt[i-1] ^ (self->mt[i-1] >> 30)) * 1664525UL))
+		+ init_key[j] + j; /* non linear */
+		self->mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
+		i ++; j++;
+		if (i>=N) { self->mt[0] = self->mt[N-1]; i=1; }
+		if (j>=key_length) j=0;
+	}
+
+	for (k=N-1; k; k--) {
+		self->mt[i] = (self->mt[i] ^ ((self->mt[i-1] ^ (self->mt[i-1] >> 30)) * 1566083941UL))
+		- i; /* non linear */
+		self->mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
+		i ++;
+		if (i>=N) { self->mt[0] = self->mt[N-1]; i=1; }
+	}
+
+	self->mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
+}
+#endif
+
+/* generates a random number on [0,0xffffffff]-interval */
+static unsigned long genrand_int32(RandomGen *self)
+{
+	unsigned long y;
+	static unsigned long mag01[2]={0x0UL, MATRIX_A};
+	/* mag01[x] = x * MATRIX_A  for x=0,1 */
+
+	if (self->mti >= N) { /* generate N words at one time */
+		int kk;
+
+		if (self->mti == N+1)   /* if init_genrand() has not been called, */
+			init_genrand(self, 5489UL); /* a default initial seed is used */
+
+		for (kk=0;kk<N-M;kk++) {
+			y = (self->mt[kk]&UPPER_MASK)|(self->mt[kk+1]&LOWER_MASK);
+			self->mt[kk] = self->mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1UL];
+		}
+		for (;kk<N-1;kk++) {
+			y = (self->mt[kk]&UPPER_MASK)|(self->mt[kk+1]&LOWER_MASK);
+			self->mt[kk] = self->mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1UL];
+		}
+		y = (self->mt[N-1]&UPPER_MASK)|(self->mt[0]&LOWER_MASK);
+		self->mt[N-1] = self->mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1UL];
+
+		self->mti = 0;
+	}
+
+	y = self->mt[self->mti ++];
+
+	// Tempering
+	y ^= (y >> 11);
+	y ^= (y << 7) & 0x9d2c5680UL;
+	y ^= (y << 15) & 0xefc60000UL;
+	y ^= (y >> 18);
+
+	return y;
+}
+
+/* generates a random number on [0,0x7fffffff]-interval */
+#ifdef EXTRAS
+static long genrand_int31(RandomGen *self)
+{
+	return (long)(genrand_int32(self)>>1);
+}
+
+/* generates a random number on [0,1]-real-interval */
+static double genrand_real1(RandomGen *self)
+{
+	return genrand_int32(self)*(1.0/4294967295.0);
+	/* divided by 2^32-1 */
+}
+#endif
+
+/* generates a random number on [0,1)-real-interval */
+static double genrand_real2(RandomGen *self)
+{
+	return genrand_int32(self)*(1.0/4294967296.0);
+	/* divided by 2^32 */
+}
+
+/* generates a random number on (0,1)-real-interval */
+#ifdef EXTRAS
+static double genrand_real3(RandomGen *self)
+{
+	return (((double)genrand_int32(self)) + 0.5)*(1.0/4294967296.0);
+	/* divided by 2^32 */
+}
+
+/* generates a random number on [0,1) with 53-bit resolution*/
+static double genrand_res53(RandomGen *self)
+{
+	unsigned long a=genrand_int32(self)>>5, b=genrand_int32(self)>>6;
+	return(a*67108864.0+b)*(1.0/9007199254740992.0);
+}
+#endif
+
+/* These real versions are due to Isaku Wada, 2002/01/09 added */
+
+/*
+int main(void)
+{
+	int i;
+	unsigned long init[4]={0x123, 0x234, 0x345, 0x456}, length=4;
+	init_by_array(init, length);
+	printf("1000 outputs of genrand_int32(self)\n");
+	for (i=0; i<1000; i ++) {
+		printf("%10lu ", genrand_int32(self));
+		if (i%5==4) printf("\n");
+	}
+	printf("\n1000 outputs of genrand_real2()\n");
+	for (i=0; i<1000; i ++) {
+		printf("%10.8f ", genrand_real2());
+		if (i%5==4) printf("\n");
+	}
+	return 0;
+}
+*/
+
+/* --------------------------------------------------------
+   This stuff added by Steve Dekorte, 2004 07 04
+*/
+
+#include <time.h>
+#include <stdlib.h>
+
+RandomGen *RandomGen_new(void)
+{
+	RandomGen *self = (RandomGen *)io_calloc(1, sizeof(RandomGen));
+	unsigned long t1 = (unsigned long)time(NULL);
+	unsigned long t2 = clock();
+	self->mti = RANDOMGEN_N + 1;
+	init_genrand(self, t1 + t2);
+	self->y2 = 0;
+	return self;
+}
+
+void RandomGen_free(RandomGen *self)
+{
+	io_free(self);
+}
+
+double RandomGen_randomDouble(RandomGen *self)
+{
+	return genrand_real2(self);
+}
+
+int RandomGen_randomInt(RandomGen *self)
+{
+	return genrand_int32(self);
+}
+
+#include <math.h>
+#ifndef M_PI_2 // some windows'es don't define this
+# define M_PI_2 1.57079632679489661923
+#endif
+
+double RandomGen_gaussian(RandomGen *self, double m, double s)
+{
+		// http://www.taygeta.com/random/gaussian.html
+	double x1, x2, w, y1, y2;
+
+	do {
+		x1 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+		x2 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+		w = x1 * x1 + x2 * x2;
+	} while ( w >= 1.0 );
+
+	w = sqrt( (-2.0 * log( w ) ) / w );
+	y1 = x1 * w;
+	y2 = x2 * w;
+
+		// The following code resulted in a lot of nans being returned. The
+		// following code *should* also be slower.
+		/*
+	double x1 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+	double x2 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+	double y1 = sqrt( - 2.0 * log(x1) ) * cos( M_PI_2 * x2 );
+		*/
+
+	return ( m + y1 * s );
+}
+
+/*
+double RandomGen_gaussian(RandomGen *self, double m, double s)
+{
+	// mean m, standard deviation s
+	double x1, x2, w, y1;
+
+	if (self->use_last) // use value from previous call
+	{
+		y1 = self->y2;
+		self->use_last = 0;
+	}
+	else
+	{
+		do {
+			x1 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+			x2 = 2.0 * RandomGen_randomDouble(self) - 1.0;
+			w = x1 * x1 + x2 * x2;
+		} while ( w >= 1.0 );
+
+		w = sqrt( (-2.0 * log( w ) ) / w );
+		y1 = x1 * w;
+		self->y2 = x2 * w;
+		self->use_last = 1;
+	}
+
+	return ( m + y1 * s );
+}
+*/
+
diff --git a/release/src/router/skipdbv2/basekit/RandomGen.h b/release/src/router/skipdbv2/basekit/RandomGen.h
new file mode 100644
index 0000000000..a2eb57be1c
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/RandomGen.h
@@ -0,0 +1,38 @@
+
+
+#ifndef RANDOMGEN_DEFINED
+#define RANDOMGEN_DEFINED 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "Common.h"
+
+#define RANDOMGEN_N 624
+
+typedef struct
+{
+	unsigned long mt[RANDOMGEN_N]; // the array for the state vector
+	int mti; // mti==N+1 means mt[N] is not initialized
+	double y2; // guassian
+	int use_last; // guassian
+} RandomGen;
+
+BASEKIT_API RandomGen *RandomGen_new(void);
+BASEKIT_API void RandomGen_free(RandomGen *self);
+
+BASEKIT_API void RandomGen_setSeed(RandomGen *self, unsigned long seed);
+BASEKIT_API void RandomGen_chooseRandomSeed(RandomGen *self);
+
+// generates a random number on between 0.0 and 1.0
+BASEKIT_API double RandomGen_randomDouble(RandomGen *self);
+
+BASEKIT_API int RandomGen_randomInt(RandomGen *self);
+
+BASEKIT_API double RandomGen_gaussian(RandomGen *self, double mean, double standardDeviation);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/SHash.c b/release/src/router/skipdbv2/basekit/SHash.c
new file mode 100644
index 0000000000..dfa6298158
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/SHash.c
@@ -0,0 +1,269 @@
+
+//metadoc SHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc SHash license BSD revised
+
+#define SHASH_C
+#include "SHash.h"
+#undef SHASH_C
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+void SHash_print(SHash* self)
+{
+	printf("self->log2tableSize = %d\n", self->log2tableSize);
+	printf("self->tableSize = %d\n", self->tableSize);
+	printf("self->numKeys = %d\n", self->numKeys);
+
+	printf("self->mask = %d\n", self->mask);
+	printf("self->balance = %d\n", self->balance);
+	printf("self->maxLoops = %d\n", SHash_maxLoops(self));
+	printf("self->maxKeys = %d\n", SHash_maxKeys(self));
+
+	printf("self->nullRecord.key = %d\n", self->nullRecord.key);
+	printf("self->nullRecord.value = %d\n", self->nullRecord.value);
+
+	printf("\nmemory usage : %d bytes\n", SHash_memorySize(self));
+	printf("\ndensity : %f \n", (self->numKeys*sizeof(SHashRecord))/(double)SHash_memorySize(self));
+
+	{
+		unsigned int i,j;
+		int count[2] = {0,0};
+
+		for (j = 0; j < 2; j ++)
+		{
+			for (i = 0; i < self->tableSize; i ++)
+			{
+				SHashRecord *record = SHASH_RECORDS_AT_(self, j, i);
+				if (NULL == record->key)
+				{
+					if (NULL == record->value)
+						printf("_");
+					else
+						printf("!");
+				}
+				else
+				{
+					printf("x");
+					count[j]++;
+				}
+			}
+			printf("\n");
+		}
+		printf("balance : %d / %d [%1.3f]\n", count[0], count[1], (count[0]-count[1])/(double)(count[0]+count[1]) );
+	}
+}
+
+void SHash_tableInit_(SHash* self, int log2tableSize)
+{
+	if (log2tableSize > 20)
+		printf("ouuups");
+	self->log2tableSize = log2tableSize;
+	self->tableSize = 1<<self->log2tableSize;
+	self->records = (SHashRecord *)io_calloc(1, sizeof(SHashRecord) * self->tableSize * 2);
+	self->mask = self->tableSize-1;
+}
+
+SHash *SHash_new(void)
+{
+	SHash *self = (SHash *)io_calloc(1, sizeof(SHash));
+	self->numKeys = 0;
+	SHash_tableInit_(self, 1);
+	//printf("ok");
+	return self;
+}
+
+SHash *SHash_clone(SHash *self)
+{
+	SHash *child = SHash_new();
+	SHash_copy_(child, self);
+	return child;
+}
+
+void SHash_free(SHash *self)
+{
+	io_free(self->records);
+	io_free(self);
+}
+
+size_t SHash_memorySize(SHash *self)
+{
+	return sizeof(SHash) + (self->tableSize * 2 * sizeof(SHashRecord));
+}
+
+void SHash_compact(SHash *self)
+{
+	printf("need to implement SHash_compact\n");
+}
+
+void SHash_copy_(SHash *self, SHash *other)
+{
+	SHashRecord *records = self->records;
+	memcpy(self, other, sizeof(SHash));
+	self->records = (SHashRecord *)io_realloc(records, sizeof(SHashRecord) * self->tableSize * 2);
+	memcpy(self->records, other->records, sizeof(SHashRecord) * self->tableSize * 2);
+}
+
+/*	this is where our cuckoo acts :
+	it kicks records out of nests until it finds an empty nest or gets tired
+	returns the empty nest if found, or NULL if it is too tired
+*/
+SHashRecord *SHash_cuckoo_(SHash *self, SHashRecord* thisRecord)
+{
+	unsigned int hash;
+	SHashRecord* record;
+	record = SHash_recordAt_(self, thisRecord->key);
+
+	if (record != &self->nullRecord && NULL == record->key)
+		return record;
+	else
+	{
+		if (SHash_keysAreEqual_(self, thisRecord->key, record->key))
+		{
+			return record;
+		}
+		else
+		{
+			int i;
+			// to balance load
+			if (self->balance)
+			{
+				self->balance = 0;
+
+				hash = SHash_hash_more(self, SHash_hash(self, thisRecord->key));
+				record = SHASH_RECORDS_AT_HASH_(self, 1, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					SHashRecord_swap(record, thisRecord);
+
+				if (SHash_keysAreEqual_(self, thisRecord->key, record->key))
+					return record;
+			}
+			self->balance = 1;
+
+			for (i = 0; i < SHash_maxLoops(self); i++)
+			{
+				hash = SHash_hash(self, thisRecord->key);
+				record = SHASH_RECORDS_AT_HASH_(self, 0, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					SHashRecord_swap(record, thisRecord);
+
+				if (SHash_keysAreEqual_(self, thisRecord->key, record->key))
+					return record;
+
+				hash = SHash_hash_more(self, SHash_hash(self, thisRecord->key));
+				record = SHASH_RECORDS_AT_HASH_(self, 1, hash);
+				if (NULL == record->key)
+					return record;
+				else
+					SHashRecord_swap(record, thisRecord);
+
+				if (SHash_keysAreEqual_(self, thisRecord->key, record->key))
+					return record;
+			}
+
+			// the cuckoo is tired ^^
+			return NULL;
+		}
+	}
+
+	return NULL;
+}
+
+void SHash_grow(SHash *self)
+{
+	unsigned int oldTableSize = self->tableSize;
+	SHashRecord* oldRecords = self->records;
+
+	self->records = NULL;
+	while (self->records == NULL)
+	{
+		unsigned int i;
+
+		SHash_tableInit_(self, self->log2tableSize + 1);
+
+		// enumerate old records
+
+		i = 0;
+		while (i < oldTableSize*2)
+		{
+			SHashRecord thisRecord = oldRecords[i];
+			i++;
+
+			if (thisRecord.key)
+			{
+				SHashRecord *record = SHash_cuckoo_(self, &thisRecord);
+				if (!record) // collision
+				{
+					io_free(self->records);
+					self->records = NULL;
+					break; // grow & rehash
+				}
+				*record = thisRecord;
+			}
+		}
+	}
+	io_free(oldRecords);
+}
+
+void SHash_growWithRecord(SHash *self, SHashRecord* thisRecord)
+{
+	// put the value anywhere, SHash_grow will rehash
+	unsigned int i,j;
+
+	for (j = 0; j < 2; j ++)
+	for (i = 0; i < self->tableSize; i ++)
+	{
+		SHashRecord *record = SHASH_RECORDS_AT_(self, j, i);
+
+		if (record != &self->nullRecord && NULL == record->key)
+		{
+			*record = *thisRecord;
+			self->numKeys ++;
+			SHash_grow(self);
+			return;
+		}
+	}
+
+	// we can never be there
+	return;
+}
+
+void SHash_removeValue_(SHash *self, void *value)
+{
+	SHashRecord *record;
+	int index = 0;
+
+	while (index < self->tableSize*2)
+	{
+		record = self->records + index;
+		index ++;
+
+		if (record->key && record->value == value)
+		{
+			self->numKeys --;
+			memset(record, 0, sizeof(SHashRecord));
+			return;
+		}
+	}
+}
+
+void *SHash_firstKeyForValue_(SHash *self, void *v)
+{
+	unsigned int i,j;
+
+	for (j = 0; j < 2; j ++)
+	for (i = 0; i < self->tableSize; i ++)
+	{
+		SHashRecord *record = SHASH_RECORDS_AT_(self, j, i);
+
+		if (record->key && record->value == v)
+			return record->key;
+	}
+	return NULL;
+}
+
+
diff --git a/release/src/router/skipdbv2/basekit/SHash.h b/release/src/router/skipdbv2/basekit/SHash.h
new file mode 100644
index 0000000000..da1b4a737e
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/SHash.h
@@ -0,0 +1,80 @@
+
+//metadoc SHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc SHash license BSD revised
+/*metadoc SHash description
+	SHash - Cuckoo Hash
+	keys and values are references (they are not copied or freed)
+	key pointers are assumed unique
+*/
+
+#ifndef SHASH_DEFINED
+#define SHASH_DEFINED 1
+
+#include "Common.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+	void *key;
+	void *value;
+} SHashRecord;
+
+typedef int (SHashKeysEqualCallback)(void *, void *);
+typedef intptr_t (SHashHashforKeyCallback)(void *);
+
+typedef struct
+{
+	SHashRecord *records;		// contains the two tables
+
+	unsigned int log2tableSize;	// log2(tableSize)
+	unsigned int tableSize;		// total number of records per table
+	unsigned int numKeys;		// number of used records
+
+	unsigned int mask;			// hash bit mask
+	SHashRecord nullRecord;		// for lookup misses
+	unsigned int balance;		// to balance tables
+	SHashKeysEqualCallback *keysEqual;
+	SHashHashforKeyCallback *hashForKey;
+
+} SHash;
+
+//#define SHash_mask(self) (self->tableSize-1)
+#define SHash_maxLoops(self) (self->tableSize < 20 ? self->tableSize : 20)
+#define SHash_maxKeys(self)  (self->tableSize)
+#define SHash_setKeysEqualCallback(self, v)  (self->keysEqual = v)
+#define SHash_setHashForKeyCallback(self, v)  (self->hashForKey = v)
+
+BASEKIT_API void SHash_print(SHash *self); // to debug
+
+BASEKIT_API SHash *SHash_new(void);
+BASEKIT_API void SHash_free(SHash *self);
+BASEKIT_API SHash *SHash_clone(SHash *self);
+BASEKIT_API void SHash_copy_(SHash *self, SHash *other);
+
+BASEKIT_API SHashRecord* SHash_cuckoo_(SHash *self, SHashRecord* record);
+BASEKIT_API void SHash_grow(SHash *self);
+BASEKIT_API void SHash_growWithRecord(SHash *self, SHashRecord* record);
+
+BASEKIT_API size_t SHash_memorySize(SHash *self);
+BASEKIT_API void SHash_compact(SHash *self);
+
+//BASEKIT_API unsigned int SHash_count(SHash *self);
+BASEKIT_API unsigned int SHash_countRecords_size_(unsigned char *records, unsigned int size);
+
+BASEKIT_API void *SHash_firstKeyForValue_(SHash *self, void *v);
+
+BASEKIT_API void SHash_removeValue_(SHash *self, void *value);
+
+#include "SHash_inline.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/SHash_inline.h b/release/src/router/skipdbv2/basekit/SHash_inline.h
new file mode 100644
index 0000000000..9452da4fe2
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/SHash_inline.h
@@ -0,0 +1,173 @@
+//metadoc SHash copyright Steve Dekorte 2002, Marc Fauconneau 2007
+//metadoc SHash license BSD revised
+/*metadoc SHash description
+	SHash - Cuckoo Hash
+	keys and values are references (they are not copied or freed)
+	key pointers are assumed unique
+*/
+
+#ifdef SHASH_C
+#define IO_IN_C_FILE
+#endif
+#include "Common_inline.h"
+#ifdef IO_DECLARE_INLINES
+
+#include <stdio.h>
+
+#define SHASH_RECORDS_AT_(self, tableIndex, index) (self->records + self->tableSize*tableIndex + index)
+#define SHASH_RECORDS_AT_HASH_(self, tableIndex, hash) \
+(self->records + self->tableSize*tableIndex + (hash & self->mask))
+
+IOINLINE unsigned int SHash_count(SHash *self)
+{
+	return self->numKeys;
+}
+
+IOINLINE void SHashRecord_swap(SHashRecord* r1, SHashRecord* r2)
+{
+	SHashRecord t = *r1;
+	*r1 = *r2;
+	*r2 = t;
+}
+
+IOINLINE unsigned int SHash_keysAreEqual_(SHash *self, void *key1, void *key2)
+{
+	return key2 && self->keysEqual(key1, key2);
+}
+
+// simple hash functions, should be enough for pointers
+
+IOINLINE unsigned int SHash_hash(SHash *self, void *key)
+{
+	intptr_t k = self->hashForKey(key);
+	return k ^ (k >> 4);
+}
+
+IOINLINE unsigned int SHash_hash_more(SHash *self, unsigned int hash)
+{
+	return hash ^ (hash >> self->log2tableSize);
+}
+
+// -----------------------------------
+
+IOINLINE void SHash_clean(SHash *self)
+{
+	memset(self->records, 0, sizeof(SHashRecord) * self->tableSize * 2);
+	self->numKeys = 0;
+}
+
+IOINLINE SHashRecord *SHash_recordAt_(SHash *self, void *key)
+{
+	unsigned int hash;
+	SHashRecord *record;
+
+	// try first location
+
+	hash = SHash_hash(self, key);
+	record = SHASH_RECORDS_AT_HASH_(self, 0, hash);
+	if (SHash_keysAreEqual_(self, key, record->key)) { return record; }
+
+	// try second location
+
+	hash = SHash_hash_more(self, hash);
+	record = SHASH_RECORDS_AT_HASH_(self, 1, hash);
+	if (SHash_keysAreEqual_(self, key, record->key)) { return record; }
+
+	return &self->nullRecord;
+}
+
+IOINLINE void *SHash_at_(SHash *self, void *key)
+{
+	return SHash_recordAt_(self, key)->value;
+}
+
+IOINLINE int SHashKey_hasKey_(SHash *self, void *key)
+{
+	return SHash_at_(self, key) != NULL;
+}
+
+IOINLINE void SHash_at_put_(SHash *self, void *key, void *value)
+{
+	SHashRecord thisRecord;
+	SHashRecord *record;
+
+	record = SHash_recordAt_(self, key);
+
+	// already a matching key, replace it
+	if (record != &self->nullRecord && SHash_keysAreEqual_(self, key, record->key))
+	{
+		record->value = value;
+		return;
+	}
+
+	thisRecord.key = key;
+	thisRecord.value = value;
+
+	record = SHash_cuckoo_(self, &thisRecord);
+
+	if (!record) // collision
+	{
+		SHash_growWithRecord(self, &thisRecord);
+		//printf("grow due to key collision: SHash_%p numKeys %i \ttableSize %i \tratio %f\n", (void *)self, self->numKeys, self->tableSize, (float) self->numKeys / (float) self->tableSize);
+	}
+	else
+	{
+		*record = thisRecord;
+		self->numKeys ++;
+		if (self->numKeys > SHash_maxKeys(self))
+		{
+			SHash_grow(self);
+			//printf("grow due to full table: SHash_%p numKeys %i \ttableSize %i \tratio %f\n", (void *)self, self->numKeys, self->tableSize, (float) self->numKeys / (float) self->tableSize);
+		}
+	}
+
+}
+
+IOINLINE void SHash_removeKey_(SHash *self, void *key)
+{
+	SHashRecord *record = SHash_recordAt_(self, key);
+	void *rkey = record->key;
+
+	if (rkey && SHash_keysAreEqual_(self, rkey, key))
+	{
+		self->numKeys --;
+		memset(record, 0, sizeof(SHashRecord));
+	}
+}
+
+// --- enumeration --------------------------------------------------
+
+#define SHASH_FOREACH(self, pkey, pvalue, code) \
+{\
+	SHash *_self = (self);\
+	unsigned int _i, _j, _size = _self->tableSize;\
+	void * pkey;\
+	void * pvalue;\
+	\
+	for (_j = 0; _j < 2; _j ++)\
+	for (_i = 0; _i < _size; _i ++)\
+	{\
+		SHashRecord *_record = SHASH_RECORDS_AT_(_self, _j, _i);\
+		if (_record->key)\
+		{\
+			pkey = _record->key;\
+			pvalue = _record->value;\
+			code;\
+		}\
+	}\
+}
+
+/*
+typedef BASEKIT_API void (SHashDoCallback)(void *);
+IOINLINE void SHash_do_(SHash *self, SHashDoCallback *callback)
+{ SHASH_FOREACH(self, k, v, (*callback)(v)); }
+
+IOINLINE void SHash_doOnKeys_(SHash *self, SHashDoCallback *callback)
+{ SHASH_FOREACH(self, k, v, (*callback)(k)); }
+
+IOINLINE void SHash_doOnKeyAndValue_(SHash *self, SHashDoCallback *callback)
+{ SHASH_FOREACH(self, k, v, (*callback)(k); (*callback)(v);); }
+*/
+
+#undef IO_IN_C_FILE
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Sorting.c b/release/src/router/skipdbv2/basekit/Sorting.c
new file mode 100644
index 0000000000..c125d1fcc5
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Sorting.c
@@ -0,0 +1,96 @@
+#include "Sorting.h"
+
+typedef struct
+{
+	void *context;
+	SDSortCompareCallback *comp;
+	SDSortSwapCallback *swap;
+} SDSort;
+
+int Sorting_isSorted(SDSort *self, size_t size);
+void Sorting_quickSort(SDSort *self, size_t lb, size_t ub);
+int Sorting_quickSortRearrange(SDSort *self, size_t lb, size_t ub);
+
+void Sorting_context_comp_swap_size_type_(void *context,
+									SDSortCompareCallback *comp,
+									SDSortSwapCallback *swap,
+									size_t size,
+									SDSortType type)
+{
+	SDSort q;
+	SDSort *self = &q;
+
+	self->context = context;
+	self->comp = comp;
+	self->swap = swap;
+
+	switch (type)
+	{
+		case SDQuickSort:
+			if (!Sorting_isSorted(self, size)) Sorting_quickSort(self, 0, size-1);
+			break;
+	}
+}
+
+int Sorting_isSorted(SDSort *self, size_t size)
+{
+	SDSortCompareCallback *comp = self->comp;
+	void *context = self->context;
+	size_t i;
+
+	for (i = 0; i + 1 < size; i ++)
+	{
+		if ((*comp)(context, i, i + 1) > 0)
+		{
+			return 0;
+		}
+	}
+
+	return 1;
+}
+
+void Sorting_quickSort(SDSort *self, size_t lb, size_t ub)
+{
+	if (lb < ub)
+	{
+		int j = Sorting_quickSortRearrange(self, lb, ub);
+
+		if (j)
+		{
+			Sorting_quickSort(self, lb, j - 1);
+		}
+
+		Sorting_quickSort(self, j + 1, ub);
+	}
+}
+
+int Sorting_quickSortRearrange(SDSort *self, size_t lb, size_t ub)
+{
+	SDSortCompareCallback *comp = self->comp;
+	SDSortSwapCallback *swap = self->swap;
+	void *context = self->context;
+
+	do {
+		while (ub > lb && (*comp)(context, ub, lb) >= 0)
+		{
+			ub --;
+		}
+
+		if (ub != lb)
+		{
+			(*swap)(context, ub, lb);
+
+			while (lb < ub && (*comp)(context, lb, ub) <= 0)
+			{
+				lb ++;
+			}
+
+			if (lb != ub)
+			{
+				(*swap)(context, lb, ub);
+			}
+		}
+	} while (lb != ub);
+
+	return lb;
+}
diff --git a/release/src/router/skipdbv2/basekit/Sorting.h b/release/src/router/skipdbv2/basekit/Sorting.h
new file mode 100644
index 0000000000..5db0d39db7
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Sorting.h
@@ -0,0 +1,32 @@
+#include "Common.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+   The reason for using this instead of C's qsort is
+   that we need more context information than just the
+   two objects if we want to do something like use an
+   Io block to do the comparison and using globals is
+   unacceptable for several reasons.
+*/
+
+typedef enum
+{
+	SDQuickSort
+	//SDShellSort
+} SDSortType;
+
+typedef int (SDSortCompareCallback)(void *context, int i, int j);
+typedef void (SDSortSwapCallback)(void *context, int i, int j);
+
+BASEKIT_API void Sorting_context_comp_swap_size_type_(void *context,
+													  SDSortCompareCallback *comp,
+													  SDSortSwapCallback *swap,
+													  size_t size,
+													  SDSortType type);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Stack.c b/release/src/router/skipdbv2/basekit/Stack.c
new file mode 100644
index 0000000000..18e31a6e80
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Stack.c
@@ -0,0 +1,138 @@
+//metadoc Stack copyright Steve Dekorte 2002
+//metadoc Stack license BSD revised
+/*metadoc Stack description
+Notes: first element of items is always 0x0.
+*/
+
+#define STACK_C
+#include "Stack.h"
+#undef STACK_C
+#if !defined(_MSC_VER)
+#include <inttypes.h>
+#endif
+
+Stack *Stack_new(void)
+{
+	// size is the number of pointers, including the starting NULL.
+	int size = STACK_START_SIZE;
+	Stack *self = (Stack *)io_calloc(1, sizeof(Stack));
+	self->items = (void **)io_calloc(1, size*sizeof(void *));
+	// memEnd points past the end of the items memory block.
+	self->memEnd = self->items + size;
+	self->top = self->items;
+	//self->lastMark = self->items;
+	return self;
+}
+
+void Stack_free(Stack *self)
+{
+	io_free(self->items);
+	io_free(self);
+}
+
+Stack *Stack_clone(const Stack *self)
+{
+	Stack *s = (Stack *)cpalloc(self, sizeof(Stack));
+
+	ptrdiff_t nItems = self->top - self->items;
+	ptrdiff_t size = nItems + 1;
+
+	s->items = (void **)cpalloc(self->items, size*sizeof(void *));
+	s->memEnd = s->items + size;
+	s->top = s->items + nItems;
+	return s;
+}
+
+void Stack_copy_(Stack *self, const Stack *other)
+{
+	ptrdiff_t nItems = self->top - self->items;
+	ptrdiff_t size = nItems + 1;
+	ptrdiff_t sizeInBytes = size*sizeof(void *);
+
+	self->items = (void **)io_realloc(self->items, sizeInBytes);
+	memcpy(self->items, other->items, sizeInBytes);
+	self->memEnd = self->items + size;
+	self->top = self->items + nItems;
+}
+
+
+// stack --------------------------------------------------
+
+size_t Stack_memorySize(const Stack *self)
+{
+	return sizeof(Stack) + (self->memEnd - self->items);
+}
+
+void Stack_compact(Stack *self)
+{
+	int oldSize = (1 + self->top - self->items)*sizeof(void *);
+	self->items = (void **)io_realloc(self->items, oldSize);
+}
+
+void Stack_resize(Stack *self)
+{
+	int oldSize = (self->memEnd - self->items)*sizeof(void *);
+	int newSize = oldSize*STACK_RESIZE_FACTOR;
+	int i = self->top - self->items;
+	self->items = (void **)io_realloc(self->items, newSize);
+	self->top = self->items + i;
+	self->memEnd = self->items + (newSize/sizeof(void *));
+}
+
+// sizing ------------------------------------------------
+
+void Stack_do_on_(const Stack *self, StackDoOnCallback *callback, void *target)
+{
+	Stack *stack = Stack_newCopyWithNullMarks(self);
+	int i;
+
+	for(i = 0; i < Stack_count(stack) - 1; i ++)
+	{
+		void *v = Stack_at_(stack, i);
+		if (v) (*callback)(target, v);
+	}
+
+	Stack_free(stack);
+}
+
+void Stack_makeMarksNull(Stack *self)
+{
+	ptrdiff_t mark = self->lastMark;
+
+	while (mark)
+	{
+		ptrdiff_t nextMark = (ptrdiff_t)self->items[mark];
+		self->items[mark] = NULL;
+		mark = nextMark;
+	}
+}
+
+Stack *Stack_newCopyWithNullMarks(const Stack *self)
+{
+	Stack *newStack = Stack_clone(self);
+	Stack_makeMarksNull(newStack);
+	return newStack;
+}
+
+void Stack_popToMark_(Stack *self, intptr_t mark)
+{
+	while (self->lastMark && self->lastMark != mark)
+	{
+		Stack_popMark(self);
+	}
+
+	if (self->lastMark == 0)
+	{
+		printf("Stack error: unable to find mark %p in %p\n", (void *)mark, (void *)self);
+		exit(1);
+	}
+
+	Stack_popMark(self);
+}
+
+List *Stack_asList(const Stack *self) // slow
+{
+	List *list = List_new();
+	Stack_do_on_(self, (StackDoOnCallback *)List_append_, list);
+	return list;
+}
diff --git a/release/src/router/skipdbv2/basekit/Stack.h b/release/src/router/skipdbv2/basekit/Stack.h
new file mode 100644
index 0000000000..faf2725fc0
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Stack.h
@@ -0,0 +1,82 @@
+//metadoc Stack copyright Steve Dekorte 2002
+//metadoc Stack license BSD revised
+/*metadoc Stack description
+	Stack - array of void pointers
+	supports setting marks - when a mark is popped,
+	all stack items above it are popped as well
+
+	Designed to optimize push, pushMark and popMark
+	at the expense of pop (since pop requires a mark check)
+*/
+
+#ifndef STACK_DEFINED
+#define STACK_DEFINED 1
+
+#include "Common.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stddef.h>
+#include "List.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef LOW_MEMORY_SYSTEM
+	#define STACK_START_SIZE 512
+	#define STACK_RESIZE_FACTOR 2
+#else
+	#define STACK_START_SIZE 512
+	#define STACK_RESIZE_FACTOR 2
+#endif
+
+typedef void (StackDoCallback)(void *);
+typedef void (StackDoOnCallback)(void *, void *);
+
+//#define STACK_POP_CALLBACK
+
+#ifdef STACK_POP_CALLBACK
+typedef void (StackPopCallback)(void *);
+#endif
+
+typedef struct
+{
+	void **items;
+	void **memEnd;
+	void **top;
+	intptr_t lastMark;
+
+#ifdef STACK_POP_CALLBACK
+	StackPopCallback *popCallback;
+#endif
+} Stack;
+
+#define Stack_popCallback_(self, callback) self->popCallback = callback;
+
+BASEKIT_API Stack *Stack_new(void);
+BASEKIT_API void Stack_free(Stack *self);
+BASEKIT_API Stack *Stack_clone(const Stack *self);
+BASEKIT_API void Stack_copy_(Stack *self, const Stack *other);
+
+BASEKIT_API size_t Stack_memorySize(const Stack *self);
+BASEKIT_API void Stack_compact(Stack *self);
+
+BASEKIT_API void Stack_resize(Stack *self);
+
+BASEKIT_API void Stack_popToMark_(Stack *self, intptr_t mark);
+
+// not high performance
+
+BASEKIT_API void Stack_makeMarksNull(Stack *self);
+BASEKIT_API Stack *Stack_newCopyWithNullMarks(const Stack *self);
+BASEKIT_API void Stack_do_on_(const Stack *self, StackDoOnCallback *callback, void *target);
+
+BASEKIT_API List *Stack_asList(const Stack *self);
+
+#include "Stack_inline.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/Stack_inline.h b/release/src/router/skipdbv2/basekit/Stack_inline.h
new file mode 100644
index 0000000000..3d21dc2ef4
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/Stack_inline.h
@@ -0,0 +1,162 @@
+//metadoc Stack copyright Steve Dekorte 2002
+//metadoc Stack license BSD revised
+/*metadoc Stack description
+ Stack - array of void pointers
+ supports setting marks - when a mark is popped,
+ all stack items above it are popped as well
+ */
+
+#ifdef STACK_C
+#define IO_IN_C_FILE
+#endif
+#include "Common_inline.h"
+#ifdef IO_DECLARE_INLINES
+
+IOINLINE void Stack_do_(const Stack *self, StackDoCallback *callback)
+{
+	void **itemP = self->top;
+	intptr_t mark = self->lastMark;
+
+	while (itemP > self->items)
+	{
+		if (itemP - self->items == mark)
+		{
+			mark = (intptr_t)(*itemP);
+		}
+		else
+		{
+			(*callback)(*itemP);
+		}
+
+		itemP --;
+	}
+}
+
+IOINLINE void Stack_doUntilMark_(const Stack *self, StackDoCallback *callback)
+{
+	void **itemP = self->top;
+	intptr_t mark = self->lastMark;
+
+	while (itemP > self->items)
+	{
+		if (itemP - self->items == mark)
+		{
+			return;
+		}
+		else
+		{
+			(*callback)(*itemP);
+		}
+
+		itemP --;
+	}
+}
+
+IOINLINE void Stack_clear(Stack *self)
+{
+	self->top = self->items;
+	self->lastMark = 0;
+}
+
+IOINLINE size_t Stack_totalSize(const Stack *self)
+{
+	return (self->top - self->items);
+}
+
+IOINLINE int Stack_count(const Stack *self)
+{
+	return (self->top - self->items);
+}
+
+IOINLINE void Stack_push_(Stack *self, void *item)
+{
+	self->top ++;
+
+	if (self->top == self->memEnd)
+	{
+		Stack_resize(self);
+	}
+
+	*(self->top) = item;
+}
+
+IOINLINE void Stack_pushMark(Stack *self)
+{
+	Stack_push_(self, (void *)self->lastMark);
+	self->lastMark = self->top - self->items;
+}
+
+IOINLINE intptr_t Stack_pushMarkPoint(Stack *self)
+{
+	Stack_push_(self, (void *)self->lastMark);
+	self->lastMark = self->top - self->items;
+	return self->lastMark;
+}
+
+IOINLINE void *Stack_pop(Stack *self)
+{
+	void *top = *(self->top);
+
+	if (self->items != self->top)
+	{
+#ifdef STACK_POP_CALLBACK
+		if(self->popCallback) self->popCallback(*(self->top));
+#endif
+		self->top --;
+	}
+
+	return top;
+}
+
+IOINLINE void Stack_popMark(Stack *self)
+{
+#ifdef STACK_POP_CALLBACK
+	if(self->popCallback) Stack_doUntilMark_(self, self->popCallback);
+#endif
+
+	self->top = self->items + self->lastMark - 1;
+
+	if (self->lastMark)
+	{
+		self->lastMark = (intptr_t)(self->items[self->lastMark]);
+	}
+}
+
+IOINLINE int Stack_popMarkPoint_(Stack *self, intptr_t mark)
+{
+	while (self->lastMark && self->lastMark != mark)
+	{
+		Stack_popMark(self);
+	}
+
+	if (self->lastMark != mark)
+	{
+		return 0;
+	}
+
+	Stack_popMark(self);
+	return 1;
+}
+
+IOINLINE void Stack_clearTop(Stack *self)
+{
+	Stack_popMark(self);
+	Stack_pushMark(self);
+	//self->top = self->items + self->lastMark;
+}
+
+IOINLINE void *Stack_top(const Stack *self)
+{
+	return *(self->top);
+}
+
+IOINLINE void *Stack_at_(const Stack *self, int i)
+{
+	return self->items[i + 1];
+}
+
+
+
+#undef IO_IN_C_FILE
+#endif
+
diff --git a/release/src/router/skipdbv2/basekit/UArray.c b/release/src/router/skipdbv2/basekit/UArray.c
new file mode 100644
index 0000000000..5fd531ad66
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray.c
@@ -0,0 +1,1309 @@
+/*
+copyright: Steve Dekorte, 2006. All rights reserved.
+license: See _BSDLicense.txt.
+*/
+
+#include "Base.h"
+
+#define UArray_C
+#include "UArray.h"
+#undef UArray_C
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <limits.h>
+
+size_t CTYPE_size(CTYPE type)
+{
+	switch (type)
+	{
+		case CTYPE_uint8_t:   return sizeof(uint8_t);
+		case CTYPE_uint16_t:  return sizeof(uint16_t);
+		case CTYPE_uint32_t:  return sizeof(uint32_t);
+		case CTYPE_uint64_t:  return sizeof(uint64_t);
+
+		case CTYPE_int8_t:    return sizeof(int8_t);
+		case CTYPE_int16_t:   return sizeof(int16_t);
+		case CTYPE_int32_t:   return sizeof(int32_t);
+		case CTYPE_int64_t:   return sizeof(int64_t);
+
+		case CTYPE_float32_t: return sizeof(float32_t);
+		case CTYPE_float64_t: return sizeof(float64_t);
+
+		case CTYPE_uintptr_t: return sizeof(uintptr_t);
+	}
+	return 0;
+}
+
+const char *CTYPE_name(CTYPE type)
+{
+	switch (type)
+	{
+		case CTYPE_uint8_t:   return "uint8";
+		case CTYPE_uint16_t:  return "uint16";
+		case CTYPE_uint32_t:  return "uint32";
+		case CTYPE_uint64_t:  return "uint64";
+
+		case CTYPE_int8_t:    return "int8";
+		case CTYPE_int16_t:   return "int16";
+		case CTYPE_int32_t:   return "int32";
+		case CTYPE_int64_t:   return "int64";
+
+		case CTYPE_float32_t: return "float32";
+		case CTYPE_float64_t: return "float64";
+
+		case CTYPE_uintptr_t: return "intptr";
+	}
+	return "unknown";
+}
+
+int CTYPE_forName(const char *name)
+{
+	if(!strcmp(name, "uint8"))   return CTYPE_uint8_t;
+	if(!strcmp(name, "uint16"))  return CTYPE_uint16_t;
+	if(!strcmp(name, "uint32"))  return CTYPE_uint32_t;
+	if(!strcmp(name, "uint64"))  return CTYPE_uint64_t;
+	if(!strcmp(name, "int8"))    return CTYPE_int8_t;
+	if(!strcmp(name, "int16"))   return CTYPE_int16_t;
+	if(!strcmp(name, "int32"))   return CTYPE_int32_t;
+	if(!strcmp(name, "int64"))   return CTYPE_int64_t;
+	if(!strcmp(name, "float32")) return CTYPE_float32_t;
+	if(!strcmp(name, "float64")) return CTYPE_float64_t;
+	return -1;
+}
+
+int CENCODING_forName(const char *name)
+{
+	if(!strcmp(name, "ascii"))  return CENCODING_ASCII;
+	if(!strcmp(name, "utf8"))   return CENCODING_UTF8;
+	if(!strcmp(name, "utf16"))  return CENCODING_UTF16;
+	if(!strcmp(name, "utf32"))  return CENCODING_UTF32;
+	if(!strcmp(name, "number")) return CENCODING_NUMBER;
+	return -1;
+}
+
+const char *CENCODING_name(CENCODING encoding)
+{
+	switch (encoding)
+	{
+		case CENCODING_ASCII:  return "ascii";
+		case CENCODING_UTF8:   return "utf8";
+		case CENCODING_UTF16:  return "utf16";
+		case CENCODING_UTF32:  return "utf32";
+		case CENCODING_NUMBER: return "number";
+	}
+	return "unknown";
+}
+
+// error
+
+void UArray_unsupported_with_(const UArray *self, const char *methodName, const UArray *other)
+{
+	//UArray_error_(self, "Error: '%s' not supported between '%s' and '%s'\n");
+	printf("Error: '%s' not supported between '%s' and '%s'\n",
+		   methodName, CTYPE_name(self->itemType), CTYPE_name(other->itemType));
+	exit(-1);
+}
+
+void UArray_error_(const UArray *self, char *e)
+{
+	printf("%s\n", e);
+	exit(-1);
+}
+
+// new
+
+CTYPE UArray_itemType(const UArray *self)
+{
+	return self->itemType;
+}
+
+size_t UArray_itemSize(const UArray *self)
+{
+	return self->itemSize;
+}
+
+//inline 
+size_t UArray_sizeRequiredToContain_(const UArray *self, const UArray *other)
+{
+	return (UArray_sizeInBytes(other)  + self->itemSize - 1) / self->itemSize;
+}
+
+void UArray_rawSetItemType_(UArray *self, CTYPE type)
+{
+	size_t itemSize = CTYPE_size(type);
+	self->itemType = type;
+	self->itemSize = itemSize;
+}
+
+void UArray_setItemType_(UArray *self, CTYPE type)
+{
+	size_t itemSize = CTYPE_size(type);
+	div_t q = div(UArray_sizeInBytes(self), itemSize);
+
+	if (q.rem != 0)
+	{
+		q.quot += 1;
+		UArray_setSize_(self, (q.quot * itemSize) / self->itemSize);
+	}
+
+	self->itemType = type;
+
+	self->itemSize = itemSize;
+	self->size = q.quot;
+
+	// ensure encoding is sane for type
+
+	if (UArray_isFloatType(self))
+	{
+		self->encoding = CENCODING_NUMBER;
+	}
+	else if (self->encoding == CENCODING_ASCII)
+	{
+		switch(self->itemSize)
+		{
+			case 2: self->encoding = CENCODING_UTF16; break;
+			case 4: self->encoding = CENCODING_UTF32; break;
+			case 8: self->encoding = CENCODING_NUMBER; break;
+		}
+	}
+}
+
+CENCODING UArray_encoding(const UArray *self)
+{
+	return self->encoding;
+}
+
+void UArray_setEncoding_(UArray *self, CENCODING encoding)
+{
+	// ensure that size matches new encoding
+
+	switch(encoding)
+	{
+		case CENCODING_ASCII:
+		case CENCODING_UTF8:
+			UArray_setItemType_(self, CTYPE_uint8_t);
+			break;
+		case CENCODING_UTF16:
+			UArray_setItemType_(self, CTYPE_uint16_t);
+			break;
+		case CENCODING_UTF32:
+			UArray_setItemType_(self, CTYPE_uint32_t);
+			break;
+		case CENCODING_NUMBER:
+			// Don't change itemType when setting raw encoding. Raw encoding
+			// used for vectors and numbers and the item type may have been set
+			// before this call.
+			break;
+	}
+
+	self->encoding = encoding;
+}
+
+void UArray_convertToEncoding_(UArray *self, CENCODING encoding)
+{
+	switch(encoding)
+	{
+		case CENCODING_ASCII:
+		case CENCODING_UTF8:
+			UArray_convertToUTF8(self);
+			break;
+		case CENCODING_UTF16:
+			UArray_convertToUTF16(self);
+			break;
+		case CENCODING_UTF32:
+			UArray_convertToUTF32(self);
+			break;
+		case CENCODING_NUMBER:
+			UArray_setItemType_(self, CTYPE_uint8_t);
+			break;
+	}
+
+	self->encoding = encoding;
+	UArray_changed(self);
+}
+
+UArray *UArray_newWithData_type_encoding_size_copy_(void *bytes, CTYPE type, CENCODING encoding, size_t size, int copy)
+{
+	UArray *self = (UArray *)io_calloc(1, sizeof(UArray));
+	UArray_setData_type_size_copy_(self, bytes, type, size, copy);
+	self->encoding = encoding;
+	return self;
+}
+
+UArray *UArray_newWithData_type_size_copy_(void *bytes, CTYPE type, size_t size, int copy)
+{
+	UArray *self = (UArray *)io_calloc(1, sizeof(UArray));
+	UArray_setData_type_size_copy_(self, bytes, type, size, copy);
+	self->encoding = CENCODING_ASCII;
+	return self;
+}
+
+UArray *UArray_new(void)
+{
+	return UArray_newWithData_type_size_copy_("", CTYPE_uint8_t, 0, 1);
+}
+
+UArray *UArray_clone(const UArray *self)
+{
+	UArray *out = UArray_new();
+	UArray_copy_(out, self);
+	return out;
+}
+
+void UArray_show(const UArray *self)
+{
+	printf("UArray_%p %s\t", (void *)self, CTYPE_name(self->itemType));
+	printf("size: %i ", self->size);
+	printf("itemSize: %i ", self->itemSize);
+	printf("data: ");
+	UArray_print(self);
+	printf("\n");
+}
+
+void UArray_print(const UArray *self)
+{
+	if(self->encoding == CENCODING_ASCII || self->encoding == CENCODING_UTF8)
+	{
+		printf("%s", (char *)self->data);
+	}
+	else if(self->encoding != CENCODING_NUMBER)
+	{
+		UARRAY_FOREACH(self, i, v, printf("%c", (int)v); );
+	}
+	else if(UArray_isFloatType(self))
+	{
+		printf("[");
+		UARRAY_FOREACH(self, i, v,
+					printf("%f", (float)v);
+					if(i != self->size - 1) printf(", ");
+					);
+		printf("]");
+	}
+	else
+	{
+		printf("[");
+		UARRAY_FOREACH(self, i, v,
+					printf("%i", (int)v);
+					if(i != self->size - 1) printf(", ");
+					);
+		printf("]");
+	}
+}
+
+UArray UArray_stackAllocedWithData_type_size_(void *data, CTYPE type, size_t size)
+{
+	UArray self;
+	memset(&self, 0, sizeof(UArray));
+
+#ifdef UARRAY_DEBUG
+	self.stackAllocated = 1;
+#endif
+
+	self.itemType = type;
+	self.itemSize = CTYPE_size(type);
+	self.size = size;
+	self.data = data;
+	return self;
+}
+
+BASEKIT_API UArray UArray_stackAllocedEmptyUArray(void)
+{
+	UArray self;
+	memset(&self, 0, sizeof(UArray));
+
+#ifdef UARRAY_DEBUG
+	self.stackAllocated = 1;
+#endif
+
+	self.itemType = CTYPE_int32_t;
+	self.itemSize = 4;
+	self.size = 0;
+	self.data = 0x0;
+	return self;
+}
+
+UArray *UArray_newWithCString_copy_(char *s, int copy)
+{
+	return UArray_newWithData_type_size_copy_(s, CTYPE_uint8_t, strlen(s), copy);
+}
+
+UArray *UArray_newWithCString_(const char *s)
+{
+	return UArray_newWithData_type_size_copy_((uint8_t *)s, CTYPE_uint8_t, strlen(s), 1);
+}
+
+void UArray_empty(UArray *self)
+{
+	UArray_setSize_(self, 0);
+}
+
+void UArray_setCString_(UArray *self, const char *s)
+{
+	UArray_empty(self);
+	UArray_setItemType_(self, CTYPE_uint8_t);
+	UArray_appendCString_(self, s);
+}
+
+#ifdef UARRAY_DEBUG
+void UArray_checkIfOkToRelloc(UArray *self)
+{
+	if(self->stackAllocated)
+	{
+		printf("UArray debug error: attempt to io_realloc UArray data that this UArray does not own");
+		exit(-1);
+	}
+}
+#endif
+
+void UArray_setData_type_size_copy_(UArray *self, void *data, CTYPE type, size_t size, int copy)
+{
+	size_t sizeInBytes;
+
+	UArray_rawSetItemType_(self, type);
+	self->size = size;
+
+	sizeInBytes = self->size * self->itemSize;
+
+	if (copy)
+	{	
+		#ifdef UARRAY_DEBUG
+		UArray_checkIfOkToRelloc(self);
+		#endif
+
+		self->data = io_realloc(self->data, sizeInBytes + 1);
+		memmove(self->data, data, sizeInBytes);
+		self->data[sizeInBytes] = 0x0;
+	}
+	else
+	{
+		if(self->data) free(self->data);
+		self->data = data;
+	}
+
+}
+
+UArray UArray_stackAllocedWithCString_(char *s)
+{
+	return UArray_stackAllocedWithData_type_size_(s, CTYPE_uint8_t, strlen(s));
+}
+
+const void *UArray_data(const UArray *self)
+{
+	return self->data;
+}
+
+const uint8_t *UArray_bytes(const UArray *self)
+{
+	return self->data;
+}
+
+uint8_t *UArray_mutableBytes(UArray *self)
+{
+	UArray_changed(self);
+	return self->data;
+}
+
+const char *UArray_asCString(const UArray *self)
+{
+	return (const char *)(self->data);
+}
+
+void UArray_stackFree(UArray *self)
+{
+	if(self->data) io_free(self->data);
+}
+
+void UArray_free(UArray *self)
+{
+	if(self->data) io_free(self->data);
+	io_free(self);
+}
+
+// size
+
+void UArray_setSize_(UArray *self, size_t size)
+{
+	if (size != self->size)
+	{
+		size_t oldSizeInBytes = UArray_sizeInBytes(self);
+		size_t newSizeInBytes = self->itemSize * size;
+
+#ifdef UARRAY_DEBUG
+			UArray_checkIfOkToRelloc(self);
+#endif
+		self->data = io_realloc(self->data, newSizeInBytes + 1);
+
+
+		self->data[newSizeInBytes] = 0x0;
+		self->size = size;
+
+		if (newSizeInBytes > oldSizeInBytes)
+		{
+			memset(self->data + oldSizeInBytes, 0, newSizeInBytes - oldSizeInBytes);
+		}
+
+		UArray_changed(self);
+	}
+}
+
+size_t UArray_size(const UArray *self)
+{
+	return self->size;
+}
+
+size_t UArray_sizeInBytes(const UArray *self)
+{
+	return self->size * self->itemSize;
+}
+
+void UArray_sizeTo_(UArray *self, size_t size)
+{
+	UArray_setSize_(self, size);
+}
+
+
+// copy
+
+void UArray_copy_(UArray *self, const UArray *other)
+{
+	UArray_setItemType_(self, UArray_itemType(other));
+	UArray_setEncoding_(self, UArray_encoding(other));
+	UArray_setSize_(self, UArray_size(other));
+	UArray_copyItems_(self, other);
+}
+
+void UArray_copyItems_(UArray *self, const UArray *other)
+{
+	if(self->size != other->size)
+	{
+		printf("UArray_copyItems_ error - arrays not of same size\n");
+		exit(-1);
+	}
+
+	if(self->itemType == other->itemType)
+	{
+		UArray_copyData_(self, other);
+	}
+	else
+	{
+		DUARRAY_OP(UARRAY_BASICOP_TYPES, =, self, other);
+	}
+	UArray_changed(self);
+}
+
+void UArray_copyData_(UArray *self, const UArray *other)
+{
+	UArray_setSize_(self, UArray_sizeRequiredToContain_(self, other));
+	memmove(self->data, other->data, UArray_sizeInBytes(other));
+}
+
+void UArray_convertToItemType_(UArray *self, CTYPE newItemType)
+{
+	if (self->itemType != newItemType)
+	{
+		UArray *tmp = UArray_new();
+		UArray_setItemType_(tmp, newItemType);
+		UArray_setEncoding_(tmp, UArray_encoding(self));
+		UArray_setSize_(tmp, self->size);
+		UArray_copyItems_(tmp, self);
+		UArray_copy_(self, tmp);
+		UArray_free(tmp);
+		UArray_changed(self);
+	}
+}
+
+// slice
+
+UArray UArray_stackRange(const UArray *self, size_t start, size_t size)
+{
+	UArray s;
+
+	memcpy(&s, self, sizeof(UArray));
+	s.hash = 0;
+
+#ifdef UARRAY_DEBUG
+	s.stackAllocated = 1;
+#endif
+
+	if(start < self->size || start == 0)
+	{
+		s.data = self->data + self->itemSize * start;
+	}
+	else
+	{
+		s.data = 0x0;
+	}
+
+	if(start + size <= self->size)
+	{
+		s.size = size;
+	}
+	else
+	{
+		s.size = 0;
+	}
+
+	return s;
+}
+
+UArray *UArray_range(const UArray *self, size_t start, size_t size)
+{
+	UArray out = UArray_stackRange(self, start, size);
+	return UArray_clone(&out);
+}
+
+UArray UArray_stackSlice(const UArray *self, long start, long end)
+{
+	start = UArray_wrapPos_(self, start);
+	end   = UArray_wrapPos_(self, end);
+	if (end < start) end = start;
+	return UArray_stackRange(self, start, end - start);
+}
+
+BASEKIT_API UArray *UArray_slice(const UArray *self, long start, long end)
+{
+	UArray out = UArray_stackSlice(self, start, end);
+	return UArray_clone(&out);
+}
+
+// at, without bounds check
+
+void *UArray_rawPointerAt_(const UArray *self, size_t i)
+{
+	if (self->itemType == CTYPE_uintptr_t)
+	{
+		return ((void **)self->data)[i];
+	}
+
+	UArray_error_(self, "UArray_rawPointerAt_ not supported on this type");
+	return NULL;
+}
+
+long UArray_rawLongAt_(const UArray *self, size_t i)
+{
+	UARRAY_RAWAT_(self, i);
+	UArray_error_(self, "UArray_rawLongAt_ not supported on this type");
+	return 0;
+}
+
+double UArray_rawDoubleAt_(const UArray *self, size_t i)
+{
+	UARRAY_RAWAT_(self, i);
+	UArray_error_(self, "UArray_doubleAt_ not supported on this type");
+	return 0;
+}
+
+// at, with bounds check
+
+void *UArray_pointerAt_(const UArray *self, size_t i)
+{
+	if (i >= self->size) { return NULL; }
+	return UArray_rawPointerAt_(self, i);
+}
+
+long UArray_longAt_(const UArray *self, size_t i)
+{
+	if (i >= self->size) { return 0; }
+	return UArray_rawLongAt_(self, i);
+}
+
+double UArray_doubleAt_(const UArray *self, size_t i)
+{
+	if (i >= self->size) { return 0.0; }
+	return UArray_rawDoubleAt_(self, i);
+}
+
+// at, extras
+
+long UArray_firstLong(const UArray *self)
+{
+	return UArray_rawLongAt_(self, 0);
+}
+
+long UArray_lastLong(const UArray *self)
+{
+	if (!self->size)
+	{
+		return 0;
+	}
+
+	return UArray_rawLongAt_(self, self->size - 1);
+}
+
+// remove
+
+void UArray_removeRange(UArray *self, size_t start, size_t removeSize)
+{
+	if (start < self->size)
+	{
+		if (start + removeSize > self->size)
+		{
+			removeSize = self->size - start;
+		}
+		else if (start + removeSize < self->size)
+		{
+			// need to copy end
+			size_t remainder = start + removeSize;
+			size_t remainderSize = self->size - remainder;
+			memmove(UARRAY_BYTESAT_(self, start), UARRAY_BYTESAT_(self, remainder), self -> itemSize * remainderSize);
+		}
+
+		UArray_setSize_(self, self->size - removeSize);
+	}
+	UArray_changed(self);
+}
+
+void UArray_leave_thenRemove_(UArray *self, size_t itemsToLeave, size_t itemsToRemove)
+{
+	if (itemsToLeave <= 0)
+	{
+		UArray_clear(self);
+		UArray_setSize_(self, 0);
+		return;
+	}
+	
+	if (itemsToRemove <= 0)
+	{
+		return;
+	}
+	
+	{
+		size_t tailChunkSizeInBytes;
+		
+		size_t period = itemsToLeave + itemsToRemove;
+		size_t tailItemCount = UArray_size(self) % period;
+		size_t itemSize = self->itemSize;
+		size_t chunkSizeInBytes = itemSize * itemsToLeave;
+		
+		if (tailItemCount == 0)
+		{
+			tailChunkSizeInBytes = 0;
+		}
+		else if (tailItemCount <= itemsToLeave)
+		{
+			tailChunkSizeInBytes = tailItemCount * itemSize;
+		}
+		else
+		{
+			tailChunkSizeInBytes = chunkSizeInBytes;
+		}
+		
+		{
+			size_t chunkCount = UArray_size(self) / period;
+			size_t newItemCount = chunkCount * itemsToLeave + tailChunkSizeInBytes / itemSize;
+			uint8_t *newData = malloc(newItemCount * itemSize);
+			
+			{
+				size_t chunkPos;
+				
+				for (chunkPos = 0; chunkPos < chunkCount; chunkPos++)
+				{
+					memmove(newData + chunkPos * chunkSizeInBytes, UARRAY_BYTESAT_(self, chunkPos * period), chunkSizeInBytes);
+				}
+
+				if (tailChunkSizeInBytes)
+				{
+					memmove(newData + chunkPos * chunkSizeInBytes, UARRAY_BYTESAT_(self, chunkPos * period), tailChunkSizeInBytes);
+				}
+				
+				UArray_setData_type_size_copy_(self, newData, UArray_itemType(self), newItemCount, 0);
+				UArray_changed(self);
+			}
+		}
+	}
+}
+
+BASEKIT_API void UArray_removeFirst(UArray *self)
+{
+	UArray_removeRange(self, 0, 1);
+}
+
+BASEKIT_API void UArray_removeLast(UArray *self)
+{
+	if (self->size > 0)
+	{
+		UArray_setSize_(self, self->size - 1);
+	}
+}
+
+// insert
+
+#define UARRAY_RAWAT_PUT_(self, pos, v) \
+switch (self->itemType)\
+{\
+	case CTYPE_uint8_t:   ((uint8_t   *)self->data)[pos] = v; return;\
+	case CTYPE_uint16_t:  ((uint16_t  *)self->data)[pos] = v; return;\
+	case CTYPE_uint32_t:  ((uint32_t  *)self->data)[pos] = v; return;\
+	case CTYPE_uint64_t:  ((uint64_t  *)self->data)[pos] = v; return;\
+	case CTYPE_int8_t:    ((int8_t    *)self->data)[pos] = v; return;\
+	case CTYPE_int16_t:   ((int16_t   *)self->data)[pos] = v; return;\
+	case CTYPE_int32_t:   ((int32_t   *)self->data)[pos] = v; return;\
+	case CTYPE_int64_t:   ((int64_t   *)self->data)[pos] = v; return;\
+	case CTYPE_float32_t: ((float32_t *)self->data)[pos] = v; return;\
+	case CTYPE_float64_t: ((float64_t *)self->data)[pos] = v; return;\
+	case CTYPE_uintptr_t: ((uintptr_t *)self->data)[pos] = v; return;\
+}
+
+void UArray_at_putLong_(UArray *self, size_t pos, long v)
+{
+	if(pos >= self->size) UArray_setSize_(self, pos + 1);
+
+	//if(UArray_longAt_(self, pos) != v)
+	{
+		UARRAY_RAWAT_PUT_(self, pos, v);
+		UArray_changed(self);
+	}
+}
+
+void UArray_at_putDouble_(UArray *self, size_t pos, double v)
+{
+	if(pos >= self->size) UArray_setSize_(self, pos + 1);
+
+	//if(UArray_doubleAt_(self, pos) != v)
+	{
+		UARRAY_RAWAT_PUT_(self, pos, v);
+		UArray_changed(self);
+	}
+}
+
+void UArray_at_putPointer_(UArray *self, size_t pos, void *v)
+{
+	if (pos >= self->size) UArray_setSize_(self, pos + 1);
+
+	switch (self->itemType)
+	{
+		case CTYPE_uintptr_t:
+			if(((void **)self->data)[pos] != v)
+			{
+				((void **)self->data)[pos] = v;
+				UArray_changed(self);
+			}
+			return;
+	}
+
+	UArray_error_(self, "UArray_at_putPointer_ not supported with this type");
+}
+
+void UArray_appendLong_(UArray *self, long v)
+{
+	UArray_at_putLong_(self, self->size, v);
+}
+
+void UArray_appendDouble_(UArray *self, double v)
+{
+	UArray_at_putDouble_(self, self->size, v);
+}
+
+void UArray_appendPointer_(UArray *self, void *v)
+{
+	UArray_at_putPointer_(self, self->size, v);
+}
+
+void UArray_appendBytes_size_(UArray *self, const uint8_t *bytes, size_t size)
+{
+	UArray a = UArray_stackAllocedWithData_type_size_((uint8_t *)bytes, CTYPE_uint8_t, size);
+	UArray_append_(self, &a);
+}
+
+/*
+void UArray_appendByte_(UArray *self, uint8_t byte)
+{
+	UArray a = UArray_stackAllocedWithData_type_size_(&byte, CTYPE_uint8_t, 1);
+	UArray_append_(self, &a);	
+}
+*/
+
+void UArray_insert_every_(UArray *self, UArray *other, size_t itemCount)
+{
+	UArray *out = UArray_new();
+	UArray *convertedOther = other;
+	
+	if (itemCount == 0)
+	{
+		UArray_error_(self, "UArray_insert_every_: itemCount must be > 0");
+		return;
+	}
+	
+	if(UArray_itemType(self) != UArray_itemType(other))
+	{
+		UArray *convertedOther = UArray_clone(other);
+		UArray_convertToItemType_(convertedOther, UArray_itemType(self));
+	}
+		
+	{
+		size_t selfSizeInBytes  = UArray_sizeInBytes(self);
+		size_t otherSize = UArray_size(convertedOther);
+		size_t chunkSize  = itemCount * UArray_itemSize(self);
+		size_t i;
+		
+		for(i = 0; i < selfSizeInBytes; i += chunkSize)
+		{
+			if (i + chunkSize > selfSizeInBytes) 
+			{ 
+				UArray_appendBytes_size_(out, self->data + i, selfSizeInBytes - i);
+			}
+			else
+			{
+				UArray_appendBytes_size_(out, self->data + i, chunkSize);
+				UArray_appendBytes_size_(out, convertedOther->data, otherSize);
+			}
+		}
+	}
+	
+	if(UArray_itemType(self) != UArray_itemType(other))
+	{
+		UArray_free(convertedOther);
+	}
+	
+	UArray_copy_(self, out);
+	UArray_free(out);
+}
+
+void UArray_at_putAll_(UArray *self, size_t pos, const UArray *other)
+{
+	if (other->size == 0) return;
+
+	if (pos > self->size)
+	{
+		UArray_setSize_(self, pos);
+	}
+
+	{
+		size_t chunkSize = self->size - pos;
+		size_t originalSelfSize = self->size;
+
+		UArray_setSize_(self, self->size + other->size);
+
+		{
+			UArray oldChunk = UArray_stackRange(self, pos, chunkSize);
+			UArray newChunk = UArray_stackRange(self, pos + other->size, chunkSize);
+			UArray insertChunk = UArray_stackRange(self, pos, other->size);
+
+			if (
+				//(&newChunk)->data == 0x0 ||
+				(&insertChunk)->data == 0x0)
+			{
+				printf("oldChunk.data     %p size %i\n", (void *)(&oldChunk)->data, oldChunk.size);
+				printf("newChunk.data     %p size %i\n", (void *)(&newChunk)->data, newChunk.size);
+				printf("insertChunk.data  %p size %i\n", (void *)(&insertChunk)->data, insertChunk.size);
+				printf("originalSelfSize = %i\n", originalSelfSize);
+				printf("self->size  = %i\n", self->size);
+				printf("other->size = %i\n", other->size);
+				printf("pos = %i\n", pos);
+				//exit(-1);
+
+				oldChunk = UArray_stackRange(self, pos, chunkSize);
+				newChunk = UArray_stackRange(self, pos + other->size, chunkSize);
+				insertChunk = UArray_stackRange(self, pos, other->size);
+				return;
+			}
+
+			if (newChunk.size) //UArray_copy_(&newChunk, &oldChunk); // copy chunk to end
+			UArray_copyItems_(&newChunk, &oldChunk);
+			//UArray_copy_(&insertChunk, other); // insert other
+			UArray_copyItems_(&insertChunk, other);
+		}
+
+		UArray_changed(self);
+	}
+}
+
+// compare
+
+#define UARRAY_COMPARE_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+		TYPE2 v2 = ((TYPE2 *)other->data)[i];\
+		if (v1 > v2) return 1;\
+		if (v1 < v2) return -1;\
+	}\
+	if(self->size != other->size)\
+	{\
+		return self->size < other->size ? -1 : 1;\
+	}\
+	return 0;\
+}
+
+#define UARRAY_EQ_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+		TYPE2 v2 = ((TYPE2 *)other->data)[i];\
+		if (v1 != v2) return 0;\
+	}\
+	return 1;\
+}
+
+#define UARRAY_GT_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+		TYPE2 v2 = ((TYPE2 *)other->data)[i];\
+		if (v1 < v2) return 0;\
+	}\
+	return 1;\
+}
+
+#define UARRAY_LT_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+		TYPE2 v2 = ((TYPE2 *)other->data)[i];\
+		if (v1 > v2) return 0;\
+	}\
+	return 1;\
+}
+
+int UArray_compare_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_COMPARE_TYPES, NULL, self, other);
+	return 0;
+}
+
+int UArray_equals_(const UArray *self, const UArray *other)
+{
+	if (self->size != other->size) return 0;
+	DUARRAY_OP(UARRAY_EQ_TYPES, NULL, self, other);
+	return 0;
+}
+
+int UArray_greaterThan_(const UArray *self, const UArray *other)
+{
+	if(self->encoding == CENCODING_NUMBER)
+	{ DUARRAY_OP(UARRAY_GT_TYPES, NULL, self, other); }
+
+	return UArray_compare_(self, other) > 0;
+}
+
+int UArray_lessThan_(const UArray *self, const UArray *other)
+{
+	if(self->encoding == CENCODING_NUMBER)
+	{ DUARRAY_OP(UARRAY_LT_TYPES, NULL, self, other); }
+
+	return UArray_compare_(self, other) < 0;
+}
+
+int UArray_greaterThanOrEqualTo_(const UArray *self, const UArray *other)
+{
+	if(self->encoding == CENCODING_NUMBER)
+	{
+		if (UArray_greaterThan_(self, other) | UArray_equals_(self, other))
+		{ return 1; } else { return 0; }
+	}
+
+	return UArray_compare_(self, other) >= 0;
+}
+
+int UArray_lessThanOrEqualTo_(const UArray *self, const UArray *other)
+{
+	if(self->encoding == CENCODING_NUMBER)
+	{
+		if (UArray_lessThan_(self, other) | UArray_equals_(self, other))
+		{ return 1; } else { return 0; }
+	}
+
+	return UArray_compare_(self, other) <= 0;
+}
+
+int UArray_isZero(const UArray *self)
+{
+	UARRAY_FOREACH(self, i, v, if (v) return 0;)
+	return 1;
+}
+
+// find
+
+// printf("i %i %c j %i %c\n", i, v1, j, v2);\
+// printf("j%i == %i\n", i, other->size);\
+
+#define UARRAY_FIND_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i;\
+			if(self->size < other->size || self->size == 0) return -1;\
+			for(i = 0; i < self->size - other->size + 1; i ++)\
+			{\
+				size_t j;\
+					int match = 1;\
+					for(j = 0; j < other->size; j ++)\
+					{\
+						TYPE1 v1 = ((TYPE1 *)self->data)[i + j];\
+							TYPE2 v2 = ((TYPE2 *)other->data)[j];\
+								if (v1 != v2) { match = 0; break; }\
+					}\
+					if (match) return i;\
+			}\
+			return -1;\
+}
+
+long UArray_find_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_FIND_TYPES, NULL, self, other);
+	return -1;
+}
+
+int UArray_contains_(const UArray *self, const UArray *other)
+{
+	return UArray_find_(self, other) != -1;
+}
+
+long UArray_find_from_(const UArray *self, const UArray *other, size_t from)
+{
+	UArray s = UArray_stackRange(self, from, self->size - from);
+	long i = UArray_find_(&s, other);
+
+	return i == -1 ? -1 : from + i;
+}
+
+#define UARRAY_FINDANYCASE_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i;\
+		if(self->size < other->size) return -1;\
+			for(i = 0; i < self->size - other->size + 1; i ++)\
+			{\
+				size_t j;\
+				int match = 1;\
+					for(j = 0; j < other->size; j ++)\
+					{\
+						TYPE1 v1 = ((TYPE1 *)self->data)[i + j];\
+						TYPE2 v2 = ((TYPE2 *)other->data)[j];\
+						if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; }\
+					}\
+					if(match) { return i; }\
+			}\
+			return -1;\
+}
+
+long UArray_findAnyCase_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_FINDANYCASE_TYPES, NULL, self, other);
+	return -1;
+}
+
+int UArray_containsAnyCase_(const UArray *self, const UArray *other)
+{
+	long i = UArray_findAnyCase_(self, other);
+	return i != -1;
+}
+
+long UArray_findLongValue_(const UArray *self, long value)
+{
+	UARRAY_FOREACH(self, i, v, if(v == value) return i);
+	return -1;
+}
+
+int UArray_containsLong_(const UArray *self, long value)
+{
+	return UArray_findLongValue_(self, value) != -1;
+}
+
+long UArray_findDoubleValue_(const UArray *self, double value)
+{
+	UARRAY_FOREACH(self, i, v, if(v == value) return i);
+	return -1;
+}
+
+int UArray_containsDouble_(const UArray *self, double value)
+{
+	return UArray_findDoubleValue_(self, value) != -1;
+}
+
+#define UARRAY_RFIND_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	long i, j;\
+		if(self->size < other->size) return -1;\
+			for(i = self->size - other->size + 1; i > -1; i --)\
+			{\
+				int match = 1;\
+				for(j = 0; j < other->size; j ++)\
+				{\
+					TYPE1 v1 = ((TYPE1 *)self->data)[i+j];\
+						TYPE2 v2 = ((TYPE2 *)other->data)[j];\
+							if (v1 != v2) { match = 0; break; }\
+				}\
+				if(match) { return i;}\
+			}\
+			return -1;\
+}
+
+long UArray_rFind_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_RFIND_TYPES, NULL, self, other);
+	return -1;
+}
+
+BASEKIT_API long UArray_rFind_from_(const UArray *self, const UArray *other, size_t from)
+{
+	UArray s = UArray_stackRange(self, 0, from);
+	long i = UArray_rFind_(&s, other);
+	return i;
+}
+
+#define UARRAY_RFINDANYCASE_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	long i, j;\
+		if(self->size < other->size) return -1;\
+			for(i = self->size - other->size + 1; i > -1; i --)\
+			{\
+				int match = 1;\
+				for(j = 0; j < other->size; j ++)\
+				{\
+					int v1 = ((TYPE1 *)self->data)[i+j];\
+						int v2 = ((TYPE2 *)other->data)[j];\
+							if (tolower(v1) != tolower(v2)) { match = 0; break; }\
+				}\
+				if(match) return i;\
+			}\
+			return -1;\
+}
+
+long UArray_rFindAnyCase_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_RFINDANYCASE_TYPES, NULL, self, other);
+	return -1;
+}
+
+#define UARRAY_RFINDANYVALUE_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	long i, j;\
+		if(self->size < other->size) return -1;\
+			for(i = self->size - 1; i > -1; i --)\
+			{\
+				TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+				for(j = 0; j < other->size; j ++)\
+				{\
+					TYPE2 v2 = ((TYPE2 *)other->data)[j];\
+					if (v1 == v2) { return i; }\
+				}\
+			}\
+			return -1;\
+}
+
+long UArray_rFindAnyValue_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_RFINDANYVALUE_TYPES, NULL, self, other);
+	return -1;
+}
+
+// types
+
+int UArray_isFloatType(const UArray *self)
+{
+	return self->itemType == CTYPE_float32_t || self->itemType == CTYPE_float64_t;
+}
+
+int UArray_isSignedType(const UArray *self)
+{
+	switch (self->itemType)
+	{
+		case CTYPE_uint8_t:   return 0;
+		case CTYPE_uint16_t:  return 0;
+		case CTYPE_uint32_t:  return 0;
+		case CTYPE_uint64_t:  return 0;
+		case CTYPE_int8_t:    return 1;
+		case CTYPE_int16_t:   return 1;
+		case CTYPE_int32_t:   return 1;
+		case CTYPE_int64_t:   return 1;
+		case CTYPE_float32_t: return 1;
+		case CTYPE_float64_t: return 1;
+	}
+	return 0;
+}
+
+size_t UArray_wrapPos_(const UArray *self, long pos)
+{
+	long size = self->size;
+
+	if (pos > size - 1)
+	{
+		return size;
+	}
+
+	if (pos < 0)
+	{
+		pos = size + pos;
+
+		if (pos < 0)
+		{
+			pos = 0;
+		}
+	}
+
+	return pos;
+}
+
+int cmp_uint8_t (const uint8_t  *a, const uint8_t *b)     { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_uint16_t(const uint16_t *a, const uint16_t *b)    { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_uint32_t(const uint32_t *a, const uint32_t *b)    { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_uint64_t(const uint64_t *a, const uint64_t *b)    { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+
+int cmp_int8_t (const int8_t  *a, const int8_t  *b)       { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_int16_t(const int16_t *a, const int16_t *b)       { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_int32_t(const int32_t *a, const int32_t *b)       { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_int64_t(const int64_t *a, const int64_t *b)       { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+
+int cmp_float32_t(const float32_t *a, const float32_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_float64_t(const float64_t *a, const float64_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+int cmp_uintptr_t(const uintptr_t *a, const uintptr_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
+
+void UArray_sort(UArray *self)
+{
+	void *base = self->data;
+	size_t size = self->size;
+
+	UArray_changed(self);
+
+	switch(self->itemType)
+	{
+		case CTYPE_uint8_t:   qsort(base, size,  sizeof(uint8_t),  (UArraySortCallback *)cmp_uint8_t);   return;
+		case CTYPE_uint16_t:  qsort(base, size, sizeof(uint16_t),  (UArraySortCallback *)cmp_uint16_t);  return;
+		case CTYPE_uint32_t:  qsort(base, size, sizeof(uint32_t),  (UArraySortCallback *)cmp_uint32_t);  return;
+		case CTYPE_uint64_t:  qsort(base, size, sizeof(uint64_t),  (UArraySortCallback *)cmp_uint64_t);  return;
+
+		case CTYPE_int8_t:    qsort(base, size,  sizeof(int8_t),   (UArraySortCallback *)cmp_int8_t);    return;
+		case CTYPE_int16_t:   qsort(base, size, sizeof(int16_t),   (UArraySortCallback *)cmp_int16_t);   return;
+		case CTYPE_int32_t:   qsort(base, size, sizeof(int32_t),   (UArraySortCallback *)cmp_int32_t);   return;
+		case CTYPE_int64_t:   qsort(base, size, sizeof(int64_t),   (UArraySortCallback *)cmp_int64_t);   return;
+
+		case CTYPE_float32_t: qsort(base, size, sizeof(float32_t), (UArraySortCallback *)cmp_float32_t); return;
+		case CTYPE_float64_t: qsort(base, size, sizeof(float64_t), (UArraySortCallback *)cmp_float64_t); return;
+		case CTYPE_uintptr_t: qsort(base, size, sizeof(uintptr_t), (UArraySortCallback *)cmp_uintptr_t); return;
+	}
+}
+
+void UArray_sortBy_(UArray *self, UArraySortCallback *cmp)
+{
+	void *base = self->data;
+	size_t size = self->size;
+
+	UArray_changed(self);
+
+	switch(self->itemType)
+	{
+		case CTYPE_uint8_t:   qsort(base, size,  sizeof(uint8_t),  cmp); return;
+		case CTYPE_uint16_t:  qsort(base, size, sizeof(uint16_t),  cmp); return;
+		case CTYPE_uint32_t:  qsort(base, size, sizeof(uint32_t),  cmp); return;
+		case CTYPE_uint64_t:  qsort(base, size, sizeof(uint64_t),  cmp); return;
+
+		case CTYPE_int8_t:    qsort(base, size,  sizeof(int8_t),   cmp); return;
+		case CTYPE_int16_t:   qsort(base, size, sizeof(int16_t),   cmp); return;
+		case CTYPE_int32_t:   qsort(base, size, sizeof(int32_t),   cmp); return;
+		case CTYPE_int64_t:   qsort(base, size, sizeof(int64_t),   cmp); return;
+
+		case CTYPE_float32_t: qsort(base, size, sizeof(float32_t), cmp); return;
+		case CTYPE_float64_t: qsort(base, size, sizeof(float64_t), cmp); return;
+		case CTYPE_uintptr_t: qsort(base, size, sizeof(uintptr_t), cmp); return;
+	}
+}
+
+
diff --git a/release/src/router/skipdbv2/basekit/UArray.h b/release/src/router/skipdbv2/basekit/UArray.h
new file mode 100644
index 0000000000..f08f55fb7c
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray.h
@@ -0,0 +1,455 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+	description: A mutable array of same-sized values.
+*/
+
+
+#ifndef UARRAY_DEFINED
+#define UARRAY_DEFINED 1
+
+#include "Common.h"
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !defined(float32_t)
+	typedef float  float32_t;
+	typedef double float64_t;
+#endif
+
+typedef size_t PID_TYPE;
+
+typedef enum
+{
+	CTYPE_uint8_t,
+	CTYPE_uint16_t,
+	CTYPE_uint32_t,
+	CTYPE_uint64_t,
+
+	CTYPE_int8_t,
+	CTYPE_int16_t,
+	CTYPE_int32_t,
+	CTYPE_int64_t,
+
+	CTYPE_float32_t,
+	CTYPE_float64_t,
+
+	CTYPE_uintptr_t
+} CTYPE;
+
+typedef enum
+{
+	CENCODING_ASCII,
+	CENCODING_UTF8,
+	CENCODING_UTF16,
+	CENCODING_UTF32,
+	CENCODING_NUMBER
+} CENCODING;
+
+typedef struct
+{
+	uint8_t   uint8;
+	uint16_t  uint16;
+	uint32_t  uint32;
+	uint64_t  uint64;
+	int8_t    int8;
+	int16_t   int16;
+	int32_t   int32;
+	int64_t   int64;
+	float32_t float32;
+	float64_t float64;
+	uintptr_t uintptr;
+} UArrayValueUnion;
+
+#define UARRAY_DEBUG 1
+
+typedef struct
+{
+	uint8_t *data;  // memory for items
+	size_t size;    // number of items
+	CTYPE itemType;
+	size_t itemSize;
+	uintptr_t hash;
+	uint8_t encoding;
+	#ifdef UARRAY_DEBUG
+	int stackAllocated;
+	#endif
+} UArray;
+
+typedef  UArray CharUArray;
+typedef  UArray PtrUArray;
+typedef  UArray FloatUArray;
+
+BASEKIT_API const void *UArray_data(const UArray *self);
+BASEKIT_API const uint8_t *UArray_bytes(const UArray *self);
+BASEKIT_API uint8_t *UArray_mutableBytes(UArray *self);
+BASEKIT_API const char *UArray_asCString(const UArray *self);
+
+BASEKIT_API size_t UArray_SizeOfCtype(CTYPE type);
+
+BASEKIT_API const char *CTYPE_name(CTYPE type);
+BASEKIT_API int CTYPE_forName(const char *name);
+
+BASEKIT_API const char *CENCODING_name(CENCODING encoding);
+BASEKIT_API int CENCODING_forName(const char *name);
+
+BASEKIT_API void UArray_unsupported_with_(const UArray *self, const char *methodName, const UArray *other);
+BASEKIT_API void UArray_error_(const UArray *self, char *e);
+
+BASEKIT_API UArray *UArray_new(void);
+BASEKIT_API UArray *UArray_newWithData_type_size_copy_(void *data, CTYPE type, size_t size, int copy);
+BASEKIT_API UArray *UArray_newWithData_type_encoding_size_copy_(void *bytes, CTYPE type, CENCODING encoding, size_t size, int copy);
+BASEKIT_API UArray *UArray_newWithCString_copy_(char *s, int copy);
+BASEKIT_API UArray *UArray_newWithCString_(const char *s);
+BASEKIT_API void UArray_setCString_(UArray *self, const char *s);
+BASEKIT_API void UArray_setData_type_size_copy_(UArray *self, void *data, CTYPE type, size_t size, int copy);
+BASEKIT_API UArray *UArray_clone(const UArray *self);
+BASEKIT_API void UArray_show(const UArray *self);
+BASEKIT_API void UArray_print(const UArray *self);
+
+BASEKIT_API UArray UArray_stackAllocedWithData_type_size_(void *data, CTYPE type, size_t size);
+BASEKIT_API UArray UArray_stackAllocedWithCString_(char *s);
+BASEKIT_API UArray UArray_stackAllocedEmptyUArray(void);
+
+BASEKIT_API void UArray_stackFree(UArray *self);
+BASEKIT_API void UArray_free(UArray *self);
+
+BASEKIT_API CTYPE UArray_itemType(const UArray *self);
+BASEKIT_API size_t UArray_itemSize(const UArray *self);
+BASEKIT_API void UArray_setItemType_(UArray *self, CTYPE type);
+BASEKIT_API CENCODING UArray_encoding(const UArray *self);
+BASEKIT_API void UArray_setEncoding_(UArray *self, CENCODING encoding);
+BASEKIT_API void UArray_convertToEncoding_(UArray *self, CENCODING encoding);
+
+// copy
+
+BASEKIT_API void UArray_copyItems_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_copy_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_copyData_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_convertToItemType_(UArray *self, CTYPE newItemType);
+
+// size
+
+#define UArray_minSizeWith_(self, other) self->size < other->size ? self->size : other->size
+#define UArray_minSizeInBytesWith_(self, other) self->size * self->itemSize < other->size  * other->itemSize ? self->size * self->itemSize : other->size  * other->itemSize
+
+BASEKIT_API void UArray_setSize_(UArray *self, size_t size);
+BASEKIT_API size_t UArray_size(const UArray *self);
+BASEKIT_API size_t UArray_sizeInBytes(const UArray *self);
+
+BASEKIT_API void UArray_sizeTo_(UArray *self, size_t size);
+
+// slice
+
+BASEKIT_API UArray UArray_stackRange(const UArray *self, size_t start, size_t size);
+BASEKIT_API UArray *UArray_range(const UArray *self, size_t start, size_t size);
+BASEKIT_API UArray UArray_stackSlice(const UArray *self, long start, long end);
+BASEKIT_API UArray *UArray_slice(const UArray *self, long start, long end);
+
+// compare
+
+BASEKIT_API int UArray_compare_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_equals_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_greaterThan_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_lessThan_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_greaterThanOrEqualTo_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_lessThanOrEqualTo_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_isZero(const UArray *self);
+
+// contains
+
+BASEKIT_API int UArray_contains_(const UArray *self, const UArray *other);
+BASEKIT_API int UArray_containsAnyCase_(const UArray *self, const UArray *other);
+
+// find
+
+BASEKIT_API long UArray_find_(const UArray *self, const UArray *other);
+BASEKIT_API long UArray_find_from_(const UArray *self, const UArray *other, size_t from);
+BASEKIT_API long UArray_rFind_from_(const UArray *self, const UArray *other, size_t from);
+BASEKIT_API long UArray_rFind_(const UArray *self, const UArray *other);
+BASEKIT_API long UArray_rFindAnyCase_(const UArray *self, const UArray *other);
+BASEKIT_API long UArray_rFindAnyValue_(const UArray *self, const UArray *other);
+
+// insert
+
+BASEKIT_API void UArray_at_putLong_(UArray *self, size_t pos, long v);
+BASEKIT_API void UArray_at_putDouble_(UArray *self, size_t pos, double v);
+BASEKIT_API void UArray_at_putPointer_(UArray *self, size_t pos, void *v);
+BASEKIT_API void UArray_at_putAll_(UArray *self, size_t pos, const UArray *other);
+
+BASEKIT_API void UArray_appendLong_(UArray *self, long v);
+BASEKIT_API void UArray_appendDouble_(UArray *self, double v);
+BASEKIT_API void UArray_appendPointer_(UArray *self, void *v);
+
+BASEKIT_API void UArray_appendBytes_size_(UArray *self, const uint8_t *bytes, size_t size);
+//BASEKIT_API void UArray_appendByte_(UArray *self, uint8_t byte);
+
+BASEKIT_API void UArray_insert_every_(UArray *self, UArray *other, size_t itemCount);
+
+// remove
+
+BASEKIT_API void UArray_removeRange(UArray *self, size_t start, size_t size);
+BASEKIT_API void UArray_leave_thenRemove_(UArray *self, size_t itemsToLeave, size_t itemsToRemove);
+BASEKIT_API void UArray_removeFirst(UArray *self);
+BASEKIT_API void UArray_removeLast(UArray *self);
+
+// at
+
+#define UARRAY_RAWAT_(self, i) \
+	switch (self->itemType)\
+	{\
+		case CTYPE_uint8_t:   return ((uint8_t   *)self->data)[i];\
+		case CTYPE_uint16_t:  return ((uint16_t  *)self->data)[i];\
+		case CTYPE_uint32_t:  return ((uint32_t  *)self->data)[i];\
+		case CTYPE_uint64_t:  return ((uint64_t  *)self->data)[i];\
+		case CTYPE_int8_t:    return ((int8_t    *)self->data)[i];\
+		case CTYPE_int16_t:   return ((int16_t   *)self->data)[i];\
+		case CTYPE_int32_t:   return ((int32_t   *)self->data)[i];\
+		case CTYPE_int64_t:   return ((int64_t   *)self->data)[i];\
+		case CTYPE_float32_t: return ((float32_t *)self->data)[i];\
+		case CTYPE_float64_t: return ((float64_t *)self->data)[i];\
+		case CTYPE_uintptr_t: return ((uintptr_t *)self->data)[i];\
+	}
+
+// at, without bounds check
+
+BASEKIT_API void *UArray_rawPointerAt_(const UArray *self, size_t i);
+BASEKIT_API long UArray_rawLongAt_(const UArray *self, size_t i);
+BASEKIT_API double UArray_rawDoubleAt_(const UArray *self, size_t i);
+
+// at, with bounds check
+
+BASEKIT_API void *UArray_pointerAt_(const UArray *self, size_t i);
+BASEKIT_API long UArray_longAt_(const UArray *self, size_t i);
+BASEKIT_API double UArray_doubleAt_(const UArray *self, size_t i);
+
+// at, extras
+
+BASEKIT_API long UArray_lastLong(const UArray *self);
+BASEKIT_API long UArray_firstLong(const UArray *self);
+
+// types
+
+BASEKIT_API int UArray_isFloatType(const UArray *self);
+BASEKIT_API int UArray_isSignedType(const UArray *self);
+
+BASEKIT_API size_t UArray_wrapPos_(const UArray *self, long pos);
+
+// sort
+
+BASEKIT_API void UArray_sort(UArray *self);
+
+typedef int (UArraySortCallback)(const void *, const void *);
+
+BASEKIT_API void UArray_sortBy_(UArray *self, UArraySortCallback *cmp);
+
+// accessing
+
+#define UARRAY_BYTEPOSAT_(self, n) (self->itemSize * n)
+#define UARRAY_BYTESAT_(self, n) (self->data + (self->itemSize * n))
+
+// macros
+
+#define DUARRAY_INTOTHER(MACRO, OP, TYPE1, self, other) \
+	switch (other->itemType)\
+	{\
+		case CTYPE_uint8_t:  MACRO(OP, TYPE1, self, uint8_t,  other); break;\
+		case CTYPE_uint16_t: MACRO(OP, TYPE1, self, uint16_t, other); break;\
+		case CTYPE_uint32_t: MACRO(OP, TYPE1, self, uint32_t, other); break;\
+		case CTYPE_int8_t:   MACRO(OP, TYPE1, self, int8_t,   other); break;\
+		case CTYPE_int16_t:  MACRO(OP, TYPE1, self, int16_t,  other); break;\
+		case CTYPE_int32_t:  MACRO(OP, TYPE1, self, int32_t,  other); break;\
+		case CTYPE_uintptr_t: MACRO(OP, TYPE1, self, uintptr_t, other); break;\
+	}
+
+#define DUARRAY_OTHER(MACRO, OP, TYPE1, self, other) \
+	switch (other->itemType)\
+	{\
+		case CTYPE_uint8_t:   MACRO(OP, TYPE1, self, uint8_t,   other); break;\
+		case CTYPE_uint16_t:  MACRO(OP, TYPE1, self, uint16_t,  other); break;\
+		case CTYPE_uint32_t:  MACRO(OP, TYPE1, self, uint32_t,  other); break;\
+		case CTYPE_uint64_t:  MACRO(OP, TYPE1, self, uint64_t,  other); break;\
+		case CTYPE_int8_t:    MACRO(OP, TYPE1, self, int8_t,    other); break;\
+		case CTYPE_int16_t:   MACRO(OP, TYPE1, self, int16_t,   other); break;\
+		case CTYPE_int32_t:   MACRO(OP, TYPE1, self, int32_t,   other); break;\
+		case CTYPE_int64_t:   MACRO(OP, TYPE1, self, int64_t,   other); break;\
+		case CTYPE_float32_t: MACRO(OP, TYPE1, self, float32_t, other); break;\
+		case CTYPE_float64_t: MACRO(OP, TYPE1, self, float64_t, other); break;\
+		case CTYPE_uintptr_t: MACRO(OP, TYPE1, self, uintptr_t, other); break;\
+	}
+
+#define DUARRAY_INTSELF(MACRO, OP, self, other) \
+	switch (self->itemType)\
+	{\
+		case CTYPE_uint8_t:  DUARRAY_INTOTHER(MACRO, OP, uint8_t,  self, other);\
+		case CTYPE_uint16_t: DUARRAY_INTOTHER(MACRO, OP, uint16_t, self, other);\
+		case CTYPE_uint32_t: DUARRAY_INTOTHER(MACRO, OP, uint32_t, self, other);\
+		case CTYPE_int8_t:   DUARRAY_INTOTHER(MACRO, OP, int8_t,   self, other);\
+		case CTYPE_int16_t:  DUARRAY_INTOTHER(MACRO, OP, int16_t,  self, other);\
+		case CTYPE_int32_t:  DUARRAY_INTOTHER(MACRO, OP, uint32_t, self, other);\
+	}
+
+#define DUARRAY_SELF(MACRO, OP, self, other) \
+	switch (self->itemType)\
+	{\
+		case CTYPE_uint8_t:   DUARRAY_OTHER(MACRO, OP, uint8_t,   self, other);\
+		case CTYPE_uint16_t:  DUARRAY_OTHER(MACRO, OP, uint16_t,  self, other);\
+		case CTYPE_uint32_t:  DUARRAY_OTHER(MACRO, OP, uint32_t,  self, other);\
+		case CTYPE_uint64_t:  DUARRAY_OTHER(MACRO, OP, uint64_t,  self, other);\
+		case CTYPE_int8_t:    DUARRAY_OTHER(MACRO, OP, int8_t,    self, other);\
+		case CTYPE_int16_t:   DUARRAY_OTHER(MACRO, OP, int16_t,   self, other);\
+		case CTYPE_int32_t:   DUARRAY_OTHER(MACRO, OP, uint32_t,  self, other);\
+		case CTYPE_int64_t:   DUARRAY_OTHER(MACRO, OP, uint64_t,  self, other);\
+		case CTYPE_float32_t: DUARRAY_OTHER(MACRO, OP, float32_t, self, other);\
+		case CTYPE_float64_t: DUARRAY_OTHER(MACRO, OP, float64_t, self, other);\
+		case CTYPE_uintptr_t: DUARRAY_OTHER(MACRO, OP, uintptr_t, self, other);\
+	}
+
+#define DUARRAY_OP(MACRO, OP, self, other)\
+	DUARRAY_SELF(MACRO, OP, self, other);\
+	UArray_unsupported_with_(self, #OP, other);
+
+#define DUARRAY_INTOP(MACRO, OP, self, other)\
+	DUARRAY_INTSELF(MACRO, OP, self, other);\
+	UArray_unsupported_with_(self, #OP, other);
+
+// two array primitive ops
+
+#define UARRAY_BASICOP_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		((TYPE1 *)self->data)[i] OP2 ((TYPE2 *)other->data)[i];\
+	}\
+	return; \
+}
+
+//printf("%i: " #TYPE1 " %f " #OP2 " " #TYPE2 " %i\n", i, ((TYPE1 *)self->data)[i], ((TYPE2 *)other->data)[i]);
+
+// single array ops
+
+// foreach --------------------------
+
+#define UARRAY_FOREACHTYPE(self, i, v, code, TYPE)\
+	{\
+		size_t i;\
+		for(i = 0; i < self->size; i ++)\
+		{\
+			TYPE v = ((TYPE *)self->data)[i];\
+			code;\
+		}\
+	}
+
+#define UARRAY_FOREACH_CASETYPE_(self, i, v, code, TYPE)\
+		case CTYPE_ ## TYPE: UARRAY_FOREACHTYPE(self, i, v, code, TYPE); break;
+
+#define UARRAY_FOREACH(self, i, v, code)\
+	switch(self->itemType)\
+	{\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint8_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint16_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int8_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int16_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, float32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, float64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uintptr_t);\
+	}
+
+#define UARRAY_INTFOREACH(self, i, v, code)\
+	switch(self->itemType)\
+	{\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint8_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint16_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uint64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int8_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int16_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, int64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, float32_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, float64_t);\
+		UARRAY_FOREACH_CASETYPE_(self, i, v, code, uintptr_t);\
+	}
+
+// rforeach --------------------------
+
+#define UARRAY_RFOREACHTYPE(self, i, v, code, TYPE)\
+	{\
+	long i;\
+	for(i = self->size - 1; i > -1; i --)\
+	{\
+		TYPE v = ((TYPE *)self->data)[i];\
+		code;\
+	}\
+	}
+
+#define UARRAY_RFOREACH_CASETYPE_(self, i, v, code, TYPE)\
+		case CTYPE_ ## TYPE: UARRAY_RFOREACHTYPE(self, i, v, code, TYPE); break;
+
+#define UARRAY_RFOREACH(self, i, v, code)\
+	switch(self->itemType)\
+	{\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, uint8_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, uint16_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, uint32_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, uint64_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, int8_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, int16_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, int32_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, int64_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, float32_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, float64_t);\
+		UARRAY_RFOREACH_CASETYPE_(self, i, v, code, uintptr_t);\
+	}
+
+// foreach assign --------------------------
+
+#define UARRAY_FOREACHTYPEASSIGN(self, i, v, code, TYPE)\
+	{\
+		size_t i;\
+		for(i = 0; i < self->size; i ++)\
+		{\
+			TYPE v = ((TYPE *)self->data)[i];\
+			((TYPE *)self->data)[i] = code;\
+		}\
+	}
+
+#define UARRAY_FOREACHASSIGN(self, i, v, code)\
+	switch(self->itemType)\
+	{\
+		case CTYPE_uint8_t:   UARRAY_FOREACHTYPEASSIGN(self, i, v, code, uint8_t);   break;\
+		case CTYPE_uint16_t:  UARRAY_FOREACHTYPEASSIGN(self, i, v, code, uint16_t);  break;\
+		case CTYPE_uint32_t:  UARRAY_FOREACHTYPEASSIGN(self, i, v, code, uint32_t);  break;\
+		case CTYPE_uint64_t:  UARRAY_FOREACHTYPEASSIGN(self, i, v, code, uint64_t);  break;\
+		case CTYPE_int8_t:    UARRAY_FOREACHTYPEASSIGN(self, i, v, code, int8_t);    break;\
+		case CTYPE_int16_t:   UARRAY_FOREACHTYPEASSIGN(self, i, v, code, int16_t);   break;\
+		case CTYPE_int32_t:   UARRAY_FOREACHTYPEASSIGN(self, i, v, code, int32_t);   break;\
+		case CTYPE_int64_t:   UARRAY_FOREACHTYPEASSIGN(self, i, v, code, int64_t);   break;\
+		case CTYPE_float32_t: UARRAY_FOREACHTYPEASSIGN(self, i, v, code, float32_t); break;\
+		case CTYPE_float64_t: UARRAY_FOREACHTYPEASSIGN(self, i, v, code, float64_t); break;\
+	}
+
+// ----------------------------
+
+#include "UArray_character.h"
+#include "UArray_format.h"
+#include "UArray_math.h"
+#include "UArray_path.h"
+#include "UArray_stream.h"
+#include "UArray_string.h"
+#include "UArray_utf.h"
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/basekit/UArray_character.c b/release/src/router/skipdbv2/basekit/UArray_character.c
new file mode 100644
index 0000000000..f35749370b
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_character.c
@@ -0,0 +1,39 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <math.h>
+
+// set
+
+#define UARRAY_IOP(OP) \
+void UArray_ ## OP (UArray *self) { UARRAY_FOREACHASSIGN(self, i, v, OP((int)v)); }
+
+UARRAY_IOP(isalnum);
+UARRAY_IOP(isalpha);
+UARRAY_IOP(iscntrl);
+UARRAY_IOP(isdigit);
+UARRAY_IOP(isgraph);
+UARRAY_IOP(islower);
+UARRAY_IOP(isprint);
+UARRAY_IOP(ispunct);
+UARRAY_IOP(isspace);
+UARRAY_IOP(isupper);
+UARRAY_IOP(isxdigit);
+
+UARRAY_IOP(tolower);
+UARRAY_IOP(toupper);
+
+BASEKIT_API int UArray_isLowercase(UArray *self)
+{
+	UARRAY_INTFOREACH(self, i, v, if(v != tolower(v)) return 0);
+	return 1;
+}
+
+BASEKIT_API int UArray_isUppercase(UArray *self)
+{
+	UARRAY_INTFOREACH(self, i, v, if(v != toupper(v)) return 0);
+	return 1;
+}
diff --git a/release/src/router/skipdbv2/basekit/UArray_character.h b/release/src/router/skipdbv2/basekit/UArray_character.h
new file mode 100644
index 0000000000..38b8dcc705
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_character.h
@@ -0,0 +1,21 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+BASEKIT_API void UArray_isalnum(UArray *self);
+BASEKIT_API void UArray_isalpha(UArray *self);
+BASEKIT_API void UArray_iscntrl(UArray *self);
+BASEKIT_API void UArray_isdigit(UArray *self);
+BASEKIT_API void UArray_isgraph(UArray *self);
+BASEKIT_API void UArray_islower(UArray *self);
+BASEKIT_API void UArray_isprint(UArray *self);
+BASEKIT_API void UArray_ispunct(UArray *self);
+BASEKIT_API void UArray_isspace(UArray *self);
+BASEKIT_API void UArray_isupper(UArray *self);
+BASEKIT_API void UArray_isxdigit(UArray *self);
+BASEKIT_API void UArray_tolower(UArray *self);
+BASEKIT_API void UArray_toupper(UArray *self);
+
+BASEKIT_API int UArray_isLowercase(UArray *self);
+BASEKIT_API int UArray_isUppercase(UArray *self);
diff --git a/release/src/router/skipdbv2/basekit/UArray_format.c b/release/src/router/skipdbv2/basekit/UArray_format.c
new file mode 100644
index 0000000000..fc2c7e8170
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_format.c
@@ -0,0 +1,122 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+UArray *UArray_newWithFormat_(const char *format, ...)
+{
+	UArray *self;
+	va_list ap;
+	va_start(ap, format);
+	self = UArray_newWithVargs_(format, ap);
+	va_end(ap);
+	return self;
+}
+
+UArray *UArray_newWithVargs_(const char *format, va_list ap)
+{
+	UArray *self = UArray_new();
+	UArray_fromVargs_(self, format,ap);
+	return self;
+}
+
+UArray *UArray_fromFormat_(UArray *self, const char *format, ...)
+{
+	va_list ap;
+	va_start(ap, format);
+	UArray_fromVargs_(self, format, ap);
+	va_end(ap);
+	return self;
+}
+
+void UArray_fromVargs_(UArray *self, const char *format, va_list ap)
+{
+	while (*format)
+	{
+		if (*format == '%')
+		{
+			format ++;
+
+			if (*format == 's')
+			{
+				char *s = va_arg(ap, char *);
+				if (!s) { printf("UArray_fromVargs_ missing param"); return; }
+				UArray_appendCString_(self, s);
+			}
+			else if (*format == 'i' || *format == 'd')
+			{
+				int i = va_arg(ap, int);
+				char s[100];
+
+				snprintf(s, 100, "%i", i);
+				UArray_appendCString_(self, s);
+			}
+			else if (*format == 'f')
+			{
+				double d = va_arg(ap, double);
+				char s[100];
+
+				snprintf(s, 100, "%f", d);
+				UArray_appendCString_(self, s);
+			}
+			else if (*format == 'p')
+			{
+				void *p = va_arg(ap, void *);
+				char s[100];
+
+				snprintf(s, 100, "%p", p);
+				UArray_appendCString_(self, s);
+			}
+			// new format command for a given number adding spaces
+			else if (*format == '#')
+			{
+				int n, i = va_arg(ap, int);
+				char *s = " ";
+
+				for (n = 0; n < i; n ++)
+				{
+					UArray_appendCString_(self, s);
+				}
+			}
+		}
+		else
+		{
+			char s[2];
+
+			snprintf(s, 2, "%c", *format);
+			UArray_appendCString_(self, s);
+		}
+
+		format ++;
+	}
+}
+
+UArray *UArray_asNewHexStringUArray(UArray *self)
+{
+	size_t i, newSize = self->size * 2;
+	UArray *ba = UArray_new();
+	UArray_setSize_(ba, newSize);
+
+	for(i = 0; i < self->size; i ++)
+	{
+		int v = UArray_longAt_(self, i);
+		char *s = (char *)(ba->data + i * 2);
+
+		if (v < 16)
+		{
+			snprintf(s, newSize, "0%x", (int)v);
+		}
+		else
+		{
+			snprintf(s, newSize, "%x", (int)v);
+		}
+	}
+
+	return ba;
+}
diff --git a/release/src/router/skipdbv2/basekit/UArray_format.h b/release/src/router/skipdbv2/basekit/UArray_format.h
new file mode 100644
index 0000000000..4184771661
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_format.h
@@ -0,0 +1,11 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+BASEKIT_API UArray *UArray_newWithFormat_(const char *format, ...);
+BASEKIT_API UArray *UArray_newWithVargs_(const char *format, va_list ap);
+BASEKIT_API UArray *UArray_fromFormat_(UArray *self, const char *format, ...);
+BASEKIT_API void UArray_fromVargs_(UArray *self, const char *format, va_list ap);
+
+BASEKIT_API UArray *UArray_asNewHexStringUArray(UArray *self);
diff --git a/release/src/router/skipdbv2/basekit/UArray_math.c b/release/src/router/skipdbv2/basekit/UArray_math.c
new file mode 100644
index 0000000000..baf106a895
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_math.c
@@ -0,0 +1,677 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <math.h>
+#include <float.h>
+
+#warning Uncomment the IO_USE_SIMD define to turn on SIMD acceleration
+//#define IO_USE_SIMD 1
+
+#ifdef IO_USE_SIMD
+#include "simd_cp.h"
+#else
+#define __UNK__EMU__
+#include "simd_cp_emu.h"
+#endif
+
+#define VEC_SIZE 4
+
+#define LLVEC_DUALARG_OP(VNAME, COP, TYPE) \
+void v ## TYPE ## _ ## VNAME(TYPE ##_t *aa, TYPE ##_t *bb, size_t size)\
+{\
+	size_t i = 0;\
+	simd_m128 *a = (simd_m128 *)aa;\
+	simd_m128 *b = (simd_m128 *)bb;\
+	size_t max = (size / VEC_SIZE);\
+	for(i = 0; i < max; i ++) { simd_4f_ ## VNAME (a[i], b[i], a[i]); }\
+	i = i * VEC_SIZE;\
+	while (i < size) { aa[i] COP bb[i]; i ++; }\
+}
+
+LLVEC_DUALARG_OP(add,  +=, float32);
+LLVEC_DUALARG_OP(sub,  -=, float32);
+LLVEC_DUALARG_OP(mult, *=, float32);
+LLVEC_DUALARG_OP(div,  /=, float32);
+
+// set
+
+void UArray_round(UArray *self)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, floor((double)(v+.5)));
+}
+
+void UArray_clear(UArray *self)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, 0);
+}
+
+void UArray_setItemsToLong_(UArray *self, long x)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, x);
+}
+
+void UArray_setItemsToDouble_(UArray *self, double x)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, x);
+}
+
+void UArray_rangeFill(UArray *self)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, i);
+}
+
+void UArray_negate(const UArray *self)
+{
+	if(UArray_isSignedType(self))
+	{
+		UARRAY_FOREACHASSIGN(self, i, v, -v);
+	}
+	else
+	{
+		UArray_error_(self, "UArray_negate not supported on this type");
+	}
+}
+
+// basic vector math
+
+void UArray_add_(UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t && other->itemType == CTYPE_float32_t)
+	{
+		vfloat32_add((float32_t *)self->data, (float32_t *)other->data, UArray_minSizeWith_(self, other));
+		return;
+	}
+
+	DUARRAY_OP(UARRAY_BASICOP_TYPES, +=, self, other);
+}
+
+void UArray_subtract_(UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t && other->itemType == CTYPE_float32_t)
+	{
+		vfloat32_sub((float32_t *)self->data, (float32_t *)other->data, UArray_minSizeWith_(self, other));
+		return;
+	}
+
+	DUARRAY_OP(UARRAY_BASICOP_TYPES, -=, self, other);
+}
+
+void UArray_multiply_(UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t && other->itemType == CTYPE_float32_t)
+	{
+		vfloat32_mult((float32_t *)self->data, (float32_t *)other->data, UArray_minSizeWith_(self, other));
+		return;
+	}
+
+	DUARRAY_OP(UARRAY_BASICOP_TYPES, *=, self, other);
+}
+
+void UArray_divide_(UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t && other->itemType == CTYPE_float32_t)
+	{
+		vfloat32_div((float32_t *)self->data, (float32_t *)other->data, UArray_minSizeWith_(self, other));
+		return;
+	}
+
+	DUARRAY_OP(UARRAY_BASICOP_TYPES, /=, self, other);
+}
+
+#define UARRAY_DOT(OP2, TYPE1, self, TYPE2, other)\
+{\
+	double p = 0;\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{ p += ((TYPE1 *)self->data)[i] * ((TYPE2 *)other->data)[i]; }\
+	return p; \
+}
+
+
+double UArray_dotProduct_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_DOT, NULL, self, other);
+}
+
+// basic scalar math
+
+void UArray_addScalarDouble_(UArray *self, double value)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, v + value);
+}
+
+void UArray_subtractScalarDouble_(UArray *self, double value)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, v - value);
+}
+
+void UArray_multiplyScalarDouble_(UArray *self, double value)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, v * value);
+}
+
+void UArray_divideScalarDouble_(UArray *self, double value)
+{
+	UARRAY_FOREACHASSIGN(self, i, v, v / value);
+}
+
+// bitwise
+
+void UArray_bitwiseOr_(UArray *self, const UArray *other)
+{
+	size_t i, max = UArray_minSizeInBytesWith_(self, other);
+	uint8_t *d1 = self->data;
+	uint8_t *d2 = other->data;
+	for (i = 0; i < max; i ++) { d1[i] |= d2[i]; }
+}
+
+void UArray_bitwiseAnd_(UArray *self, const UArray *other)
+{
+	size_t i, max = UArray_minSizeInBytesWith_(self, other);
+	uint8_t *d1 = self->data;
+	uint8_t *d2 = other->data;
+	for (i = 0; i < max; i ++) { d1[i] &= d2[i]; }
+}
+
+void UArray_bitwiseXor_(UArray *self, const UArray *other)
+{
+	size_t i, max = UArray_minSizeInBytesWith_(self, other);
+	uint8_t *d1 = self->data;
+	uint8_t *d2 = other->data;
+	for (i = 0; i < max; i ++) { d1[i] ^= d2[i]; }
+}
+
+void UArray_bitwiseNot(UArray *self)
+{
+	size_t i, max = UArray_sizeInBytes(self);
+	uint8_t *data = self->data;
+	for (i = 0; i < max; i ++) { data[i] = ~(data[i]); }
+}
+
+// bitwise ops
+
+void UArray_setAllBitsTo_(UArray *self, uint8_t aBool)
+{
+	size_t i, max = UArray_sizeInBytes(self);
+	uint8_t *data = self->data;
+	uint8_t bits = aBool ? ~0 : 0;
+	for (i = 0; i < max; i ++) { data[i] = bits; }
+}
+
+// adjust for endianess?
+
+int UArray_bitAt_(UArray *self, size_t i)
+{
+	size_t bytePos = i / 8;
+	size_t bitPos  = i - bytePos;
+	if (bytePos >= UArray_sizeInBytes(self)) return 0;
+	return self->data[bytePos] = (self->data[bytePos] >> bitPos) & 0x1;
+}
+
+uint8_t UArray_byteAt_(UArray *self, size_t i)
+{
+	if (i < self->size) return self->data[i];
+	return 0;
+}
+
+void UArray_setBit_at_(UArray *self, int aBool, size_t i)
+{
+	size_t bytePos = i / 8;
+	size_t bitPos  = i - bytePos;
+	uint8_t n = 0x1 << bitPos;
+	uint8_t b;
+	if (bytePos >= UArray_sizeInBytes(self)) return;
+	b = self->data[bytePos];
+	b ^= n;
+	if (aBool) b |= (0x1 << bitPos);
+	self->data[bytePos] = b;
+}
+
+UArray *UArray_asBits(const UArray *self)
+{
+	UArray *out = UArray_new();
+	size_t i, max = UArray_sizeInBytes(self);
+	uint8_t *data = self->data;
+
+	for (i = 0; i < max; i ++)
+	{
+		uint8_t b = data[i];
+		int j;
+
+		for (j = 0; j < 8; j ++)
+		{
+			int v = (b >> j) & 0x1;
+			UArray_appendCString_(out, v ? "1" : "0");
+		}
+	}
+
+	return out;
+}
+
+size_t UArray_bitCount(UArray *self)
+{
+	const unsigned char map[] =
+	{
+		0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+		1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+		2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+		3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+		4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+	};
+
+	size_t i, max = UArray_sizeInBytes(self);
+	uint8_t *data = self->data;
+	size_t total = 0;
+
+	for (i = 0; i < max; i ++) { total += map[data[i]]; }
+
+	return total;
+}
+
+// logic
+
+#define UARRAY_LOGICOP_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	size_t i, minSize = self->size < other->size ? self->size : other->size;\
+		for(i = 0; i < minSize; i ++)\
+		{\
+			((TYPE1 *)self->data)[i] = ((TYPE1 *)self->data)[i] OP2 ((TYPE2 *)other->data)[i];\
+		}\
+}
+
+void UArray_logicalOr_(UArray *self, const UArray *other)
+{
+	DUARRAY_INTOP(UARRAY_LOGICOP_TYPES, ||, self, other);
+}
+
+void UArray_logicalAnd_(UArray *self, const UArray *other)
+{
+	DUARRAY_INTOP(UARRAY_LOGICOP_TYPES, &&, self, other);
+}
+
+// trigonometry
+
+#define UARRAY_DOP(OP) \
+void UArray_ ## OP (UArray *self) { UARRAY_FOREACHASSIGN(self, i, v, OP((double)v)); }
+
+UARRAY_DOP(sin);
+UARRAY_DOP(cos);
+UARRAY_DOP(tan);
+UARRAY_DOP(asin);
+UARRAY_DOP(acos);
+UARRAY_DOP(atan);
+UARRAY_DOP(sinh);
+UARRAY_DOP(cosh);
+UARRAY_DOP(tanh);
+UARRAY_DOP(exp);
+UARRAY_DOP(log);
+UARRAY_DOP(log10);
+
+UARRAY_DOP(sqrt);
+UARRAY_DOP(ceil);
+UARRAY_DOP(floor);
+UARRAY_DOP(fabs);
+
+void UArray_abs(UArray *self)
+{
+	UArray_fabs(self);
+}
+
+void UArray_square(UArray *self)
+{
+	UArray_multiply_(self, self);
+}
+
+// extras
+
+double UArray_sumAsDouble(const UArray *self)
+{
+	double sum = 0;
+	UARRAY_FOREACH(self, i, v, sum += v);
+	return sum;
+}
+
+double UArray_productAsDouble(const UArray *self)
+{
+	double p = 1;
+	UARRAY_FOREACH(self, i, v, p *= v);
+	return p;
+}
+
+double UArray_arithmeticMeanAsDouble(const UArray *self)
+{
+	return UArray_sumAsDouble(self) / ((double)self->size);
+}
+
+double UArray_arithmeticMeanSquareAsDouble(const UArray *self)
+{
+	double r;
+	UArray *s = UArray_clone(self);
+	UArray_square(s);
+	r = UArray_arithmeticMeanAsDouble(s);
+	UArray_free(s);
+	return r;
+}
+
+double UArray_maxAsDouble(const UArray *self)
+{
+	if(self->size > 0)
+	{
+		double max = DBL_MIN;
+		UARRAY_FOREACH(self, i, v, if(v > max) { max = v; });
+		return max;
+	}
+
+	return 0;
+}
+
+double UArray_minAsDouble(const UArray *self)
+{
+	if(self->size > 0)
+	{
+		double max = DBL_MAX;
+		UARRAY_FOREACH(self, i, v, if(v < max) { max = v; });
+		return max;
+	}
+
+	return 0;
+}
+
+BASEKIT_API void UArray_Max(UArray *self, const UArray *other)
+{
+	size_t i, minSize = self->size < other->size ? self->size : other->size;
+
+	for(i = 0; i < minSize; i ++)
+	{
+		double v1 = UArray_rawDoubleAt_(self, i);
+		double v2 = UArray_rawDoubleAt_(other, i);
+		double m = v1 > v2 ? v1 : v2;
+		UArray_at_putDouble_(self, i, m);
+	}
+}
+
+BASEKIT_API void UArray_Min(UArray *self, const UArray *other)
+{
+	size_t i, minSize = self->size < other->size ? self->size : other->size;
+
+	for(i = 0; i < minSize; i ++)
+	{
+		double v1 = UArray_rawDoubleAt_(self, i);
+		double v2 = UArray_rawDoubleAt_(other, i);
+		double m = v1 < v2 ? v1 : v2;
+		UArray_at_putDouble_(self, i, m);
+	}
+}
+
+
+void UArray_normalize(UArray *self)
+{
+	double a;
+	UArray *s = UArray_clone(self);
+	UArray_square(s);
+	a = UArray_sumAsDouble(s);
+	UArray_free(s);
+	a = sqrt(a);
+	UArray_divideScalarDouble_(self, a);
+}
+
+void UArray_crossProduct_(UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t &&
+		other->itemType == CTYPE_float32_t &&
+		self->size > 2 && other->size > 2)
+	{
+		float32_t *a = (float32_t *)self->data;
+		float32_t *b = (float32_t *)other->data;
+
+		float32_t i = (a[1]*b[2]) - (a[2]*b[1]);
+		float32_t j = (a[2]*b[0]) - (a[0]*b[2]);
+		float32_t k = (a[0]*b[1]) - (a[1]*b[0]);
+
+		a[0] = i;
+		a[1] = j;
+		a[2] = k;
+
+		UArray_changed(self);
+
+		return;
+	}
+}
+
+double UArray_distanceTo_(const UArray *self, const UArray *other)
+{
+	if (self->itemType == CTYPE_float32_t &&
+		other->itemType == CTYPE_float32_t)
+	{
+		float32_t *a = (float32_t *)self->data;
+		float32_t *b = (float32_t *)other->data;
+		size_t max = self->size > other->size ? self->size : other->size;
+		double sum = 0;
+
+		if (self->size == other->size)
+		{
+			size_t i;
+
+			for (i = 0; i < max; i ++)
+			{
+				float32_t d = a[i] - b[i];
+				sum += d * d;
+			}
+		}
+
+		return (double)sqrt((double)sum);
+	}
+	else if (self->itemType == CTYPE_float64_t &&
+		other->itemType == CTYPE_float64_t)
+	{
+		float64_t *a = (float64_t *)self->data;
+		float64_t *b = (float64_t *)other->data;
+		size_t max = self->size > other->size ? self->size : other->size;
+		double sum = 0;
+
+		if (self->size == other->size)
+		{
+			size_t i;
+
+			for (i = 0; i < max; i ++)
+			{
+				float32_t d = a[i] - b[i];
+				sum += d * d;
+			}
+		}
+
+		return (double)sqrt((double)sum);
+	}
+
+	return 0;
+}
+
+// hash
+
+void UArray_changed(UArray *self)
+{
+	self->hash = 0;
+}
+
+uintptr_t UArray_calcHash(UArray *self)
+{
+	uintptr_t h = 5381;
+
+	int i, max = UArray_sizeInBytes(self);
+	uint8_t *data = self->data;
+
+	for(i = 0; i < max; i ++)
+	{
+		h += (h << 5);
+		h ^= data[i];
+	}
+
+	//printf("UArray_%p %i %s\n", self, h, (char *)self->data);
+
+/*
+	// I *think* this should hash to the same value for ASCII, UTF16 and UTF32 types, but not UTF8
+
+	UARRAY_FOREACH(self, i, v,
+		h += (h << 5);
+		h ^= (uintptr_t)v;
+	);
+*/
+
+	return h;
+}
+
+uintptr_t UArray_hash(UArray *self)
+{
+	if (!self->hash)
+	{
+		self->hash = UArray_calcHash(self);
+		if(self->hash == 0x0) self->hash = 0x1;
+	}
+
+	return self->hash;
+}
+
+int UArray_equalsWithHashCheck_(UArray *self, UArray *other)
+{
+	if (self == other)
+	{
+		return 1;
+	}
+	else
+	{
+		uintptr_t h1 = UArray_hash(self);
+		uintptr_t h2 = UArray_hash(other);
+
+		if (h1 != h2)
+		{
+			return 0;
+		}
+
+		/*
+		if(strcmp(self->data, other->data) != 0)
+		{
+			printf("[%s] %i == %i [%s]\n", self->data, h1, h2, other->data);
+		}
+		*/
+	}
+
+	return UArray_equals_(self, other);
+}
+
+// indexes
+
+BASEKIT_API void UArray_duplicateIndexes(UArray *self)
+{
+	size_t size = self->size;
+	int itemSize = self->itemSize;
+
+	if (size)
+	{
+		size_t si = size - 1;
+		size_t di = (size * 2) - 1;
+		uint8_t *b;
+
+		UArray_setSize_(self, self->size * 2);
+
+		b = self->data;
+
+		for (;;)
+		{
+			uint8_t *src  = b + si * itemSize;
+			uint8_t *dest = b + di * itemSize;
+
+			memcpy(dest, src, itemSize);
+			memcpy(dest - itemSize, src, itemSize);
+
+			if (si == 0) break;
+			di = di - 2;
+			si --;
+		}
+	}
+}
+
+void UArray_removeOddIndexes(UArray *self)
+{
+	size_t itemSize = self->itemSize;
+	size_t di = 1;
+	size_t si = 2;
+	size_t max = self->size;
+	uint8_t *b = self->data;
+
+	if (max == 0)
+	{
+		return;
+	}
+
+	while (si < max)
+	{
+		uint8_t *src  = b + (si * itemSize);
+		uint8_t *dest = b + (di * itemSize);
+		memcpy(dest, src, itemSize);
+		si = si + 2;
+		di = di + 1;
+	}
+
+	UArray_setSize_(self, di);
+}
+
+void UArray_removeEvenIndexes(UArray *self)
+{
+	size_t itemSize = self->itemSize;
+	size_t di = 0;
+	size_t si = 1;
+	size_t max = self->size;
+	uint8_t *b = self->data;
+
+	while (si < max)
+	{
+		uint8_t *src  = b + (si * itemSize);
+		uint8_t *dest = b + (di * itemSize);
+		memcpy(dest, src, itemSize);
+		si = si + 2;
+		di = di + 1;
+	}
+
+	UArray_setSize_(self, di);
+}
+
+void UArray_reverseItemByteOrders(UArray *self)
+{
+	size_t itemSize = self->itemSize;
+
+	if (itemSize > 1)
+	{
+		size_t i, max = self->size;
+		uint8_t *d = self->data;
+
+		for(i = 0; i < max; i ++)
+		{
+			size_t j;
+
+			for(j = 0; j < itemSize; j ++)
+			{
+				size_t i1 = i + j;
+				size_t i2 = i + itemSize - j;
+				uint8_t v = d[i1];
+				d[i1] = d[i2];
+				d[i2] = v;
+			}
+		}
+
+		UArray_changed(self);
+	}
+}
diff --git a/release/src/router/skipdbv2/basekit/UArray_math.h b/release/src/router/skipdbv2/basekit/UArray_math.h
new file mode 100644
index 0000000000..1f6aee9ae1
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_math.h
@@ -0,0 +1,112 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+// set
+
+BASEKIT_API void UArray_clear(UArray *self);
+BASEKIT_API void UArray_setItemsToLong_(UArray *self, long x);
+BASEKIT_API void UArray_setItemsToDouble_(UArray *self, double x);
+BASEKIT_API void UArray_rangeFill(UArray *self);
+BASEKIT_API void UArray_negate(const UArray *self);
+
+// basic vector math
+
+BASEKIT_API void UArray_add_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_subtract_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_multiply_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_divide_(UArray *self, const UArray *other);
+BASEKIT_API double UArray_dotProduct_(const UArray *self, const UArray *other);
+
+// basic scalar math
+
+BASEKIT_API void UArray_addScalarDouble_(UArray *self, double v);
+BASEKIT_API void UArray_subtractScalarDouble_(UArray *self, double v);
+BASEKIT_API void UArray_multiplyScalarDouble_(UArray *self, double v);
+BASEKIT_API void UArray_divideScalarDouble_(UArray *self, double v);
+
+// bitwise logic
+
+BASEKIT_API void UArray_bitwiseOr_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_bitwiseAnd_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_bitwiseXor_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_bitwiseNot(UArray *self);
+
+// bitwise ops
+
+BASEKIT_API void UArray_setAllBitsTo_(UArray *self, uint8_t aBool);
+BASEKIT_API uint8_t UArray_byteAt_(UArray *self, size_t i);
+BASEKIT_API int UArray_bitAt_(UArray *self, size_t i);
+BASEKIT_API void UArray_setBit_at_(UArray *self, int b, size_t i);
+BASEKIT_API UArray * UArray_asBits(const UArray *self);
+BASEKIT_API size_t UArray_bitCount(UArray *self);
+
+// boolean logic
+
+BASEKIT_API void UArray_logicalOr_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_logicalAnd_(UArray *self, const UArray *other);
+
+// trigonometry
+
+BASEKIT_API void UArray_sin(UArray *self);
+BASEKIT_API void UArray_cos(UArray *self);
+BASEKIT_API void UArray_tan(UArray *self);
+
+BASEKIT_API void UArray_asin(UArray *self);
+BASEKIT_API void UArray_acos(UArray *self);
+BASEKIT_API void UArray_atan(UArray *self);
+
+//void UArray_atan2(UArray *self, const UArray *other);
+
+BASEKIT_API void UArray_sinh(UArray *self);
+BASEKIT_API void UArray_cosh(UArray *self);
+BASEKIT_API void UArray_tanh(UArray *self);
+
+BASEKIT_API void UArray_exp(UArray *self);
+BASEKIT_API void UArray_log(UArray *self);
+BASEKIT_API void UArray_log10(UArray *self);
+
+//void UArray_pow(UArray *self, const UArray *other);
+
+BASEKIT_API void UArray_sqrt(UArray *self);
+BASEKIT_API void UArray_ceil(UArray *self);
+BASEKIT_API void UArray_floor(UArray *self);
+BASEKIT_API void UArray_abs(UArray *self);
+BASEKIT_API void UArray_round(UArray *self);
+
+//void UArray_ldexp(UArray *self, const UArray *other);
+//void UArray_fmod(UArray *self, const UArray *other);
+
+BASEKIT_API void UArray_square(UArray *self);
+BASEKIT_API void UArray_normalize(UArray *self);
+
+BASEKIT_API void UArray_crossProduct_(UArray *self, const UArray *other);
+BASEKIT_API double UArray_distanceTo_(const UArray *self, const UArray *other);
+
+// extras
+
+BASEKIT_API double UArray_sumAsDouble(const UArray *self);
+BASEKIT_API double UArray_productAsDouble(const UArray *self);
+BASEKIT_API double UArray_arithmeticMeanAsDouble(const UArray *self);
+BASEKIT_API double UArray_arithmeticMeanSquareAsDouble(const UArray *self);
+BASEKIT_API double UArray_maxAsDouble(const UArray *self);
+BASEKIT_API double UArray_minAsDouble(const UArray *self);
+BASEKIT_API void UArray_Max(UArray *self, const UArray *other);
+BASEKIT_API void UArray_Min(UArray *self, const UArray *other);
+
+// hash
+
+BASEKIT_API void UArray_changed(UArray *self);
+BASEKIT_API uintptr_t UArray_calcHash(UArray *self);
+BASEKIT_API uintptr_t UArray_hash(UArray *self);
+BASEKIT_API int UArray_equalsWithHashCheck_(UArray *self, UArray *other);
+
+// indexes
+
+BASEKIT_API void UArray_duplicateIndexes(UArray *self);
+BASEKIT_API void UArray_removeOddIndexes(UArray *self);
+BASEKIT_API void UArray_removeEvenIndexes(UArray *self);
+
+BASEKIT_API void UArray_reverseItemByteOrders(UArray *self);
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_path.c b/release/src/router/skipdbv2/basekit/UArray_path.c
new file mode 100644
index 0000000000..69c00d5644
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_path.c
@@ -0,0 +1,138 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+void UArray_appendPath_(UArray *self, const UArray *path)
+{
+	const UArray sep = UArray_stackAllocedWithCString_(IO_PATH_SEPARATOR);
+
+	int selfEndsWithSep   = IS_PATH_SEPERATOR(UArray_lastLong(self));
+	int pathStartsWithSep = IS_PATH_SEPERATOR(UArray_firstLong(path));
+
+	if (!selfEndsWithSep && !pathStartsWithSep)
+	{
+		if(self->size != 0) UArray_append_(self, &sep);
+		UArray_append_(self, path);
+	}
+	else if (selfEndsWithSep && pathStartsWithSep)
+	{
+		const UArray pathPart = UArray_stackRange(path, 1, path->size - 1);
+		UArray_append_(self, &pathPart);
+	}
+	else
+	{
+		UArray_append_(self, path);
+	}
+}
+
+void UArray_removeLastPathComponent(UArray *self)
+{
+	UArray seps = UArray_stackAllocedWithCString_(IO_PATH_SEPARATORS);
+	long pos = UArray_findLastPathComponent(self);
+	if (pos) pos --;
+	UArray_setSize_(self, pos);
+}
+
+void UArray_clipBeforeLastPathComponent(UArray *self)
+{
+	long pos = UArray_findLastPathComponent(self);
+
+	if (pos != -1)
+	{
+		UArray_removeRange(self, 0, pos);
+	}
+}
+
+long UArray_findLastPathComponent(const UArray *self)
+{
+	if (self->size)
+	{
+		UArray seps = UArray_stackAllocedWithCString_(IO_PATH_SEPARATORS);
+		UArray s = UArray_stackRange(self, 0, self->size);
+		long pos = 0;
+
+		while (s.size && (pos = UArray_rFindAnyValue_(&s, &seps)) == s.size - 1)
+		{
+			s.size = pos;
+		}
+
+		if (pos == -1) { pos = 0; } else { pos ++; }
+		return pos;
+	}
+
+	return 0;
+}
+
+UArray *UArray_lastPathComponent(const UArray *self)
+{
+	long pos = UArray_findLastPathComponent(self);
+	return UArray_range(self, pos, self->size - pos);
+}
+
+long UArray_findPathExtension(UArray *self)
+{
+	UArray dot = UArray_stackAllocedWithCString_(IO_PATH_SEPARATOR_DOT);
+	return UArray_rFind_(self, &dot);
+}
+
+void UArray_removePathExtension(UArray *self)
+{
+	long pos = UArray_findPathExtension(self);
+
+	if (pos != -1)
+	{
+		UArray_setSize_(self, pos);
+	}
+}
+
+UArray *UArray_pathExtension(UArray *self)
+{
+	long pos = UArray_findPathExtension(self);
+
+	if (pos == -1 || pos == self->size - 1)
+	{
+		return UArray_newWithCString_copy_("", 1);
+	}
+
+	return UArray_range(self, pos + 1, self->size - pos - 1);
+}
+
+UArray *UArray_fileName(UArray *self)
+{
+	long extPos = UArray_findLastPathComponent(self);
+	long dotPos = UArray_findPathExtension(self);
+
+	//if (extPos == -1) { extPos = 0; } else { extPos ++; }
+	if (dotPos == -1) dotPos = self->size;
+
+	return UArray_range(self, extPos, dotPos - extPos);
+}
+
+// to/from os path - always returns a copy
+
+int UArray_OSPathSeparatorIsUnixSeparator(void)
+{
+	return strcmp(OS_PATH_SEPARATOR, "/") == 0;
+}
+
+UArray *UArray_asOSPath(UArray *self)
+{
+	UArray *a = UArray_clone(self);
+	UArray_replaceCString_withCString_(a, IO_PATH_SEPARATOR, OS_PATH_SEPARATOR);
+	return a;
+}
+
+UArray *UArray_asUnixPath(UArray *self)
+{
+	UArray *a = UArray_clone(self);
+	UArray_replaceCString_withCString_(a, OS_PATH_SEPARATOR, IO_PATH_SEPARATOR);
+	return a;
+}
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_path.h b/release/src/router/skipdbv2/basekit/UArray_path.h
new file mode 100644
index 0000000000..5dd819a529
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_path.h
@@ -0,0 +1,51 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+// internally, Io always uses a forward slash "/" for path separators,
+// but on Windows, back slashes are also tolerated as path separators.
+#if defined(DOS) || defined(ON_WINDOWS)
+#define OS_PATH_SEPARATOR     "\\"
+#define IO_PATH_SEPARATORS    "\\/"
+#else
+#define OS_PATH_SEPARATOR     "/"
+#define IO_PATH_SEPARATORS    "/"
+#endif
+
+#define IO_PATH_SEPARATOR     "/"
+#define IO_PATH_SEPARATOR_DOT "."
+
+
+#ifdef ON_WINDOWS
+#define IS_PATH_SEPERATOR(ch) ((ch == '/') || (ch == '\\'))
+#else
+#define IS_PATH_SEPERATOR(ch) (ch == '/')
+#endif
+
+
+BASEKIT_API void UArray_appendPath_(UArray *self, const UArray *path);
+
+// last component
+
+BASEKIT_API void UArray_removeLastPathComponent(UArray *self);
+BASEKIT_API void UArray_clipBeforeLastPathComponent(UArray *self);
+BASEKIT_API long UArray_findLastPathComponent(const UArray *self);
+BASEKIT_API UArray *UArray_lastPathComponent(const UArray *self);
+
+// extension
+
+BASEKIT_API long UArray_findPathExtension(UArray *self);
+BASEKIT_API void UArray_removePathExtension(UArray *self);
+BASEKIT_API UArray *UArray_pathExtension(UArray *self);
+
+// fileName
+
+BASEKIT_API UArray *UArray_fileName(UArray *self);
+
+// to/from os path - always returns a copy
+
+BASEKIT_API int UArray_OSPathSeparatorIsUnixSeparator(void);
+BASEKIT_API UArray *UArray_asOSPath(UArray *self);
+BASEKIT_API UArray *UArray_asUnixPath(UArray *self);
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_stream.c b/release/src/router/skipdbv2/basekit/UArray_stream.c
new file mode 100644
index 0000000000..605f2a0b54
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_stream.c
@@ -0,0 +1,146 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+// read ------------------------------------------------------
+
+size_t UArray_fread_(UArray *self, FILE *fp)
+{
+	size_t itemsRead = fread(self->data, self->itemSize, self->size, fp);
+	UArray_setSize_(self, itemsRead);
+	return itemsRead;
+}
+
+long UArray_readFromCStream_(UArray *self, FILE *fp)
+{
+	long totalItemsRead = 0;
+	long itemsPerBuffer =  4096 / self->itemSize;
+	UArray *buffer = UArray_new();
+	UArray_setItemType_(buffer, self->itemType);
+	UArray_setSize_(buffer, itemsPerBuffer);
+
+	if (!fp) { perror("UArray_readFromCStream_"); return -1; }
+
+	while(!feof(fp) && !ferror(fp))
+	{
+		size_t itemsRead;
+		UArray_setSize_(buffer, itemsPerBuffer);
+		itemsRead = UArray_fread_(buffer, fp);
+
+		totalItemsRead += itemsRead;
+		UArray_append_(self, buffer);
+		if (itemsRead != itemsPerBuffer) break;
+	}
+
+	if (ferror(fp)) { perror("UArray_readFromCStream_"); return -1; }
+
+	UArray_free(buffer);
+	return totalItemsRead;
+}
+
+long UArray_readNumberOfItems_fromCStream_(UArray *self, size_t size, FILE *stream)
+{
+	size_t itemsRead;
+	UArray *buffer = UArray_new();
+	UArray_setItemType_(buffer, self->itemType);
+	UArray_setSize_(buffer, size);
+
+	itemsRead = UArray_fread_(buffer, stream);
+	UArray_append_(self, buffer);
+
+	UArray_free(buffer);
+	return itemsRead;
+}
+
+long UArray_readFromFilePath_(UArray *self, const UArray *path)
+{
+	FILE *stream;
+	long itemsRead;
+	UArray *sysPath = (UArray_itemSize(path) == 1) ? (UArray *)path : UArray_asUTF8(path);
+	const char *p = UArray_asCString(sysPath);
+
+	//printf("UArray_readFromFilePath_(\"%s\")\n", p);
+
+	stream = fopen(p, "rb");
+	if (!stream) return -1;
+	itemsRead = UArray_readFromCStream_(self, stream);
+	fclose(stream);
+
+	if(sysPath != path) UArray_free(sysPath);
+	return itemsRead;
+}
+
+
+#define CHUNK_SIZE 4096
+
+int UArray_readLineFromCStream_(UArray *self, FILE *stream)
+{
+	int readSomething = 0;
+
+	if(self->itemSize == 1)
+	{
+		char *s = (char *)io_calloc(1, CHUNK_SIZE);
+
+		while (fgets(s, CHUNK_SIZE, stream) != NULL)
+		{
+			char *eol1 = strchr(s, '\n');
+			char *eol2 = strchr(s, '\r');
+
+			readSomething = 1;
+
+			if (eol1) { *eol1 = 0; } // remove the \n return character
+			if (eol2) { *eol2 = 0; } // remove the \r return character
+
+			if (*s)
+			{
+				UArray_appendCString_(self, s);
+			}
+
+			if (eol1 || eol2)
+			{
+				break;
+			}
+		}
+
+		io_free(s);
+	}
+
+	return readSomething;
+}
+
+// write ------------------------------------------------------
+
+size_t UArray_fwrite_(const UArray *self, size_t size, FILE *fp)
+{
+	return fwrite(self->data, 1, self->itemSize * size, fp);
+}
+
+long UArray_writeToCStream_(const UArray *self, FILE *stream)
+{
+	size_t totalItemsRead = UArray_fwrite_(self, self->size, stream);
+	if (ferror(stream)) { perror("UArray_readFromCStream_"); return -1; }
+	return totalItemsRead;
+}
+
+long UArray_writeToFilePath_(const UArray *self, const UArray *path)
+{
+	UArray *sysPath = (UArray_itemSize(path) == 1) ? (UArray *)path : UArray_asUTF8(path);
+	FILE *fp = fopen(UArray_asCString(sysPath), "w");
+	long itemsWritten = -1;
+
+	if (fp)
+	{
+		itemsWritten = UArray_writeToCStream_(self, fp);
+		fclose(fp);
+	}
+
+	return itemsWritten;
+}
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_stream.h b/release/src/router/skipdbv2/basekit/UArray_stream.h
new file mode 100644
index 0000000000..b2c47c3c71
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_stream.h
@@ -0,0 +1,20 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+// these return item read/written count or -1 on error
+
+// read
+
+BASEKIT_API size_t UArray_fread_(UArray *self, FILE *fp);
+BASEKIT_API long UArray_readFromCStream_(UArray *self, FILE *stream);
+BASEKIT_API long UArray_readFromFilePath_(UArray *self, const UArray *path);
+BASEKIT_API long UArray_readNumberOfItems_fromCStream_(UArray *self, size_t size, FILE *stream);
+BASEKIT_API int UArray_readLineFromCStream_(UArray *self, FILE *stream);
+
+// write
+
+BASEKIT_API size_t UArray_fwrite_(const UArray *self, size_t size, FILE *stream);
+BASEKIT_API long UArray_writeToCStream_(const UArray *self, FILE *stream);
+BASEKIT_API long UArray_writeToFilePath_(const UArray *self, const UArray *path);
diff --git a/release/src/router/skipdbv2/basekit/UArray_string.c b/release/src/router/skipdbv2/basekit/UArray_string.c
new file mode 100644
index 0000000000..250c88cc3c
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_string.c
@@ -0,0 +1,506 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+void UArray_append_(UArray *self, const UArray *other)
+{
+	UArray_at_putAll_(self, self->size, other);
+}
+
+void UArray_appendCString_(UArray *self, const char *s)
+{
+	while (*s)
+	{
+		UArray_appendLong_(self, *s);
+		s ++;
+	}
+}
+
+void UArray_prepend_(UArray *self, const UArray *other)
+{
+	UArray_at_putAll_(self, 0, other);
+}
+
+int UArray_equalsAnyCase_(const UArray *self, const UArray *other)
+{
+	if (self->size == other->size)
+	{
+		return UArray_findAnyCase_(self, other) == 0;
+	}
+
+	return 0;
+}
+
+void UArray_replace_with_(UArray *self, const UArray *a1, const UArray *a2)
+{
+	long i;
+	size_t start = 0;
+	UArray visible = UArray_stackRange(self, start, self->size);
+
+	while ((i = UArray_find_(&visible, a1)) != -1)
+	{
+		size_t index = start + i;
+		UArray_removeRange(self, index, a1->size);
+		UArray_at_putAll_(self, index, a2);
+		start = index + a2->size;
+		visible = UArray_stackRange(self, start, self->size - start);
+	}
+	UArray_changed(self);
+}
+
+BASEKIT_API void UArray_replaceCString_withCString_(UArray *self, const char *s1, const char *s2)
+{
+	UArray a1 = UArray_stackAllocedWithCString_((char *)s1);
+	UArray a2 = UArray_stackAllocedWithCString_((char *)s2);
+	UArray_replace_with_(self, &a1, &a2);
+}
+
+void UArray_replaceAnyCase_with_(UArray *self, const UArray *a1, const UArray *a2)
+{
+	long i;
+	size_t start = 0;
+	UArray visible = UArray_stackRange(self, start, self->size);
+
+	while ((i = UArray_findAnyCase_(&visible, a1)) != -1)
+	{
+		size_t index = start + i;
+		UArray_removeRange(self, index, a1->size);
+		UArray_at_putAll_(self, index, a2);
+		start = index + a2->size;
+		visible = UArray_stackRange(self, start, self->size - start);
+	}
+
+	UArray_changed(self);
+}
+
+BASEKIT_API void UArray_remove_(UArray *self, const UArray *a1)
+{
+	UArray blank = UArray_stackAllocedEmptyUArray();
+	UArray_replace_with_(self, a1, &blank);
+}
+
+BASEKIT_API void UArray_removeAnyCase_(UArray *self, const UArray *a1)
+{
+	UArray blank = UArray_stackAllocedEmptyUArray();
+	UArray_replaceAnyCase_with_(self, a1, &blank);
+}
+
+// clipping
+
+BASEKIT_API int UArray_clipBefore_(UArray *self, const UArray *other)
+{
+	long index = UArray_find_(self, other);
+
+	if (index > -1)
+	{
+		UArray_removeRange(self, 0, index);
+		return 1;
+	}
+
+	return 0;
+}
+
+BASEKIT_API int UArray_clipBeforeEndOf_(UArray *self, const UArray *other)
+{
+	long index = UArray_find_(self, other);
+
+	if (index > -1)
+	{
+		UArray_removeRange(self, 0, index + other->size);
+		return 1;
+	}
+
+	return 0;
+}
+
+BASEKIT_API int UArray_clipAfter_(UArray *self, const UArray *other)
+{
+	long index = UArray_find_(self, other);
+
+	if (index > -1)
+	{
+		UArray_removeRange(self, index + other->size, self->size);
+		return 1;
+	}
+
+	return 0;
+}
+
+BASEKIT_API int UArray_clipAfterStartOf_(UArray *self, const UArray *other)
+{
+	long index = UArray_find_(self, other);
+
+	if (index > -1)
+	{
+		UArray_removeRange(self, index, self->size);
+		return 1;
+	}
+
+	return 0;
+}
+
+// strip
+
+void UArray_lstrip_(UArray *self, const UArray *other)
+{
+	size_t amount = 0;
+
+	if (UArray_isFloatType(self))
+	{
+		UARRAY_FOREACH(self, i, v,
+			amount = i+1;
+			if (!UArray_containsDouble_(other, v))
+			{
+				amount --;
+				break;
+			}
+		)
+	}
+	else
+	{
+		UARRAY_FOREACH(self, i, v,
+			amount = i+1;
+			if (!UArray_containsLong_(other, v))
+			{
+				amount --;
+				break;
+			}
+		)
+	}
+
+	UArray_removeRange(self, 0, amount);
+}
+
+void UArray_rstrip_(UArray *self, const UArray *other)
+{
+	size_t index = 0; // initial value is only needed when FOREACHes don't work
+
+	if (UArray_isFloatType(self))
+	{
+		UARRAY_RFOREACH(self, i, v,
+			index = i;
+			if (!UArray_containsDouble_(other, v)) { index++; break; }
+		)
+	}
+	else
+	{
+		UARRAY_RFOREACH(self, i, v,
+			index = i;
+			if (!UArray_containsLong_(other, v)) { index++; break; }
+		)
+	}
+
+	UArray_removeRange(self, index, self->size);
+}
+
+BASEKIT_API void UArray_strip_(UArray *self, const UArray *other)
+{
+	UArray_lstrip_(self, other);
+	UArray_rstrip_(self, other);
+}
+
+// swap
+
+BASEKIT_API void UArray_swapIndex_withIndex_(UArray *self, size_t i, size_t j)
+{
+	int itemSize = self->itemSize;
+	uint8_t *data = self->data;
+	void *ip = data + i * itemSize;
+	void *jp = data + j * itemSize;
+	UArrayValueUnion b;
+
+	memcpy(&b, ip, sizeof(UArray));
+	memcpy(ip, jp, sizeof(UArray));
+	memcpy(jp, &b, sizeof(UArray));
+	UArray_changed(self);
+}
+
+// reverse
+
+BASEKIT_API void UArray_reverse(UArray *self)
+{
+	long i = 0;
+	long j = self->size - 1;
+	UArrayValueUnion b;
+	int itemSize = self->itemSize;
+	uint8_t *data = self->data;
+
+	while (j > i)
+	{
+		void *ip = data + i * itemSize;
+		void *jp = data + j * itemSize;
+
+		memcpy(&b, ip, itemSize);
+		memcpy(ip, jp, itemSize);
+		memcpy(jp, &b, itemSize);
+
+		j --;
+		i ++;
+	}
+
+	UArray_changed(self);
+}
+
+/*
+#define UARRAY_MATCHPREFIXLENGTH_TYPES(OP2, TYPE1, self, TYPE2, other)\
+{\
+	long i, minSize = (self->size < other->size) ? self->size : other->size;\
+	for(i = 0; i < minSize; i ++)\
+	{\
+		TYPE1 v1 = ((TYPE1 *)self->data)[i];\
+		TYPE2 v2 = ((TYPE2 *)other->data)[i];\
+		if (v1 != v2) break;\
+	}\
+	return i;\
+}
+
+BASEKIT_API size_t UArray_matchingPrefixSizeWith_(const UArray *self, const UArray *other)
+{
+	DUARRAY_OP(UARRAY_MATCHPREFIXLENGTH_TYPES, NULL, self, other);
+}
+*/
+
+// split
+
+PtrUArray *UArray_split_(const UArray *self, const PtrUArray *delims)
+{
+	PtrUArray *results = UArray_new();
+	size_t i, last = 0;
+	UArray_setItemType_(results, CTYPE_uintptr_t);
+
+	for (i = 0; i < self->size; i ++)
+	{
+		UArray slice = UArray_stackRange(self, i, self->size - i);
+		size_t j;
+
+		for (j = 0; j < delims->size; j ++)
+		{
+			UArray *delim = UArray_rawPointerAt_(delims, j);
+
+			if (UArray_beginsWith_(&slice, delim))
+			{
+				UArray_appendPointer_(results, UArray_range(self, last, i - last));
+
+				last = i + delim->size;
+				i = last - 1; // since for() will increment it
+				break;
+			}
+		}
+	}
+
+	if (last != self->size)
+	{
+		UArray_appendPointer_(results, UArray_range(self, last, self->size - last));
+	}
+
+	return results;
+}
+
+size_t UArray_splitCount_(const UArray *self, const PtrUArray *delims)
+{
+	PtrUArray *r = UArray_split_(self, delims);
+	size_t count = UArray_size(r);
+	UArray_free(r);
+	return count;
+}
+
+// find
+
+BASEKIT_API int UArray_beginsWith_(UArray *self, const UArray *other)
+{
+	if (self->size >= other->size)
+	{
+		UArray tmp = UArray_stackRange(self, 0, other->size);
+		return UArray_find_(&tmp, other) != -1;
+	}
+
+	return 0;
+}
+
+BASEKIT_API int UArray_endsWith_(UArray *self, const UArray *other)
+{
+	if (self->size >= other->size)
+	{
+		UArray tmp = UArray_stackRange(self, self->size - other->size, other->size);
+		return UArray_find_(&tmp, other) != -1;
+	}
+
+	return 0;
+}
+
+// escape and quote
+
+void UArray_swapWith_(UArray *self, UArray *other)
+{
+	UArray b;
+	memcpy(&b, other, sizeof(UArray));
+	memcpy(other, self, sizeof(UArray));
+	memcpy(self, &b, sizeof(UArray));
+	UArray_changed(self);
+}
+
+void UArray_escape(UArray *self)
+{
+	UArray *out = UArray_new();
+	out->itemType = self->itemType;
+
+	UARRAY_FOREACH(self, i, v,
+		switch ((int)v)
+		{
+			case '"':  UArray_appendCString_(out, "\\\""); break;
+			case '\a': UArray_appendCString_(out, "\\a"); break;
+			case '\b': UArray_appendCString_(out, "\\b"); break;
+			case '\f': UArray_appendCString_(out, "\\f"); break;
+			case '\n': UArray_appendCString_(out, "\\n"); break;
+			case '\r': UArray_appendCString_(out, "\\r"); break;
+			case '\t': UArray_appendCString_(out, "\\t"); break;
+			case '\v': UArray_appendCString_(out, "\\v"); break;
+			case '\\': UArray_appendCString_(out, "\\\\"); break;
+			default:   UArray_appendLong_(out, v);
+		}
+	);
+
+	UArray_swapWith_(self, out);
+	UArray_free(out);
+	UArray_changed(self);
+}
+
+void UArray_unescape(UArray *self)
+{
+	size_t getIndex = 0;
+	size_t putIndex = 0;
+
+	while (getIndex < self->size)
+	{
+		long c = UArray_longAt_(self, getIndex);
+		long nextChar = UArray_longAt_(self, getIndex + 1);
+
+		if (c != '\\')
+		{
+			if (getIndex != putIndex)
+			{
+				UArray_at_putLong_(self, putIndex, c);
+			}
+
+			putIndex ++;
+		}
+		else
+		{
+			c = nextChar;
+
+			switch (c)
+			{
+				case  'a': c = '\a'; break;
+				case  'b': c = '\b'; break;
+				case  'f': c = '\f'; break;
+				case  'n': c = '\n'; break;
+				case  'r': c = '\r'; break;
+				case  't': c = '\t'; break;
+				case  'v': c = '\v'; break;
+				case '\0': c = '\\'; break;
+				default:
+					if (isdigit(c))
+					{
+						c -= 48;
+					}
+			}
+
+			UArray_at_putLong_(self, putIndex, c);
+			getIndex ++;
+			putIndex ++;
+		}
+
+		getIndex ++;
+	}
+
+	UArray_setSize_(self, putIndex);
+	UArray_changed(self);
+}
+
+void UArray_quote(UArray *self)
+{
+	UArray q = UArray_stackAllocedWithCString_("\"");
+	UArray_prepend_(self, &q);
+	UArray_append_(self, &q);
+	UArray_changed(self);
+}
+
+void UArray_unquote(UArray *self)
+{
+	UArray q = UArray_stackAllocedWithCString_("\"");
+
+	if(UArray_beginsWith_(self, &q) && UArray_endsWith_(self, &q))
+	{
+		UArray_removeFirst(self);
+		UArray_removeLast(self);
+		UArray_changed(self);
+	}
+}
+
+void UArray_translate(UArray *self, UArray *fromChars, UArray *toChars)
+{
+	size_t max = 4096;
+	long fromMax = UArray_maxAsDouble(fromChars);
+	long toMax   = UArray_maxAsDouble(toChars);
+
+	if (UArray_size(fromChars) != UArray_size(toChars))
+	{
+		printf("UArray_translate: translation strings must be of the same length");
+		return;
+	}
+
+	if ((0 < fromMax && fromMax < max) && (0 < toMax && toMax < 256))
+	{
+		size_t i;
+		uint8_t *map = io_calloc(1, fromMax);
+		memset(map, 0x0, fromMax);
+
+		for(i = 0; i < UArray_size(fromChars); i ++)
+		{
+			map[UArray_longAt_(fromChars, i)] = UArray_longAt_(toChars, i);
+		}
+
+		for(i = 0; i < UArray_size(self); i ++)
+		{
+			self->data[i] = map[self->data[i]];
+		}
+
+		io_free(map);
+		return;
+	}
+
+	/*
+	 UARRAY_FOREACH(self, i, currChar,
+				 UARRAY_FOREACH(fromChars, j, fromChar,
+							 if(currChar == fromChar)
+							 {
+								 UARRAY_RAWAT_PUT_(self, i, UARRAY_RAWAT_(toChars, j));
+								 break;
+							 }
+							 );
+				 );
+	 */
+
+	UArray_error_(self, "UArray_translate unimplemented for this type");
+}
+
+size_t UArray_count_(const UArray *self, const UArray *other)
+{
+	long i = 0;
+	size_t count = 0;
+
+	while ((i = UArray_find_from_(self, other, i)) != -1)
+	{
+		i += UArray_size(other);
+		count ++;
+	}
+
+	return count;
+}
diff --git a/release/src/router/skipdbv2/basekit/UArray_string.h b/release/src/router/skipdbv2/basekit/UArray_string.h
new file mode 100644
index 0000000000..48ad68eecd
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_string.h
@@ -0,0 +1,72 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+BASEKIT_API void UArray_append_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_appendCString_(UArray *self, const char *s);
+BASEKIT_API void UArray_prepend_(UArray *self, const UArray *other);
+
+BASEKIT_API int UArray_equalsAnyCase_(const UArray *self, const UArray *other);
+BASEKIT_API void UArray_replace_with_(UArray *self, const UArray *a1, const UArray *a2);
+BASEKIT_API void UArray_replaceAnyCase_with_(UArray *self, const UArray *a1, const UArray *a2);
+BASEKIT_API void UArray_replaceCString_withCString_(UArray *self, const char *s1, const char *s2);
+BASEKIT_API void UArray_remove_(UArray *self, const UArray *a1);
+BASEKIT_API void UArray_removeAnyCase_(UArray *self, const UArray *a1);
+
+// clipping
+
+BASEKIT_API int UArray_clipBefore_(UArray *self, const UArray *other);
+BASEKIT_API int UArray_clipBeforeEndOf_(UArray *self, const UArray *other);
+BASEKIT_API int UArray_clipAfter_(UArray *self, const UArray *other);
+BASEKIT_API int UArray_clipAfterStartOf_(UArray *self, const UArray *other);
+
+// strip
+
+BASEKIT_API void UArray_lstrip_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_rstrip_(UArray *self, const UArray *other);
+BASEKIT_API void UArray_strip_(UArray *self, const UArray *other);
+
+// swap
+
+BASEKIT_API void UArray_swapIndex_withIndex_(UArray *self, size_t i, size_t j);
+
+// reverse
+
+BASEKIT_API void UArray_reverse(UArray *self);
+
+//BASEKIT_API size_t UArray_matchingPrefixSizeWith_(const UArray *self, const UArray *other);
+
+// split
+
+BASEKIT_API PtrUArray *UArray_split_(const UArray *self, const PtrUArray *delims);
+BASEKIT_API size_t UArray_splitCount_(const UArray *self, const PtrUArray *delims);
+
+// find
+
+BASEKIT_API int UArray_beginsWith_(UArray *self, const UArray *other);
+BASEKIT_API int UArray_endsWith_(UArray *self, const UArray *other);
+
+// escape and quote
+
+BASEKIT_API void UArray_swapWith_(UArray *self, UArray *other);
+
+BASEKIT_API void UArray_escape(UArray *self);
+BASEKIT_API void UArray_unescape(UArray *self);
+
+BASEKIT_API void UArray_quote(UArray *self);
+BASEKIT_API void UArray_unquote(UArray *self);
+
+BASEKIT_API void UArray_translate(UArray *self, UArray *fromChars, UArray *toChars);
+BASEKIT_API size_t UArray_count_(const UArray *self, const UArray *other);
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_utf.c b/release/src/router/skipdbv2/basekit/UArray_utf.c
new file mode 100644
index 0000000000..fdd38e8034
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_utf.c
@@ -0,0 +1,310 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+#include "UArray.h"
+#include "ConvertUTF.h"
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stddef.h>
+
+int UArray_MachineIsLittleEndian(void)
+{
+	unsigned int i = 0x1;
+	return ((unsigned char *)(&i))[0] == 1;
+}
+
+static int UArray_SizeOfUTFChar(const uint8_t *s)
+{
+	uint8_t c = *s;
+
+	if (c & 0x80)
+	{
+		if((c & 0xE0) == 0xC0) return 2;
+		if((c & 0xF0) == 0xE0) return 3;
+		if((c & 0xF8) == 0xF0) return 4;
+		if((c & 0xFC) == 0xF8) return 5;
+		if((c & 0xFE) == 0xFC) return 6;
+		return -1;
+	}
+
+	return 1;
+}
+
+int UArray_maxCharSize(const UArray *self)
+{
+	if (self->encoding == CENCODING_UTF8)
+	{
+		int maxCharSize = 1;
+		size_t i = 0;
+
+		while (i < self->size)
+		{
+			int charSize = UArray_SizeOfUTFChar(self->data + i);
+			if (charSize > maxCharSize)  maxCharSize = charSize;
+			if (charSize == -1) return -1;
+			i += charSize;
+		}
+
+		return maxCharSize;
+	}
+
+	return self->itemSize;
+}
+
+void UArray_truncateAfterConvertToEncoding_(UArray *self){
+	if(self->encoding == CENCODING_NUMBER)
+	{
+		return;
+	}
+
+	{
+		UArray tmp = UArray_stackAllocedWithData_type_size_("\0", CTYPE_uint8_t, 1);
+		long newSize = UArray_find_(self, &tmp);
+		if(newSize != -1)
+		{
+			UArray_setSize_(self, newSize);
+		}
+	}
+}
+
+int UArray_convertToFixedSizeType(UArray *self)
+{
+	if (self->encoding == CENCODING_UTF8)
+	{
+		int maxCharSize = UArray_maxCharSize(self);
+
+		if(maxCharSize == 1)
+		{
+			self->encoding = CENCODING_ASCII;
+		}
+		else if(maxCharSize == 2)
+		{
+			UArray_convertToUTF16(self);
+		}
+		else
+		{
+			UArray_convertToUTF32(self);
+		}
+
+		return 1;
+	}
+
+	return 0;
+}
+
+int UArray_isMultibyte(const UArray *self)
+{
+	if (self->encoding == CENCODING_UTF8)
+	{
+		UARRAY_INTFOREACH(self, i, v, if (ismbchar((int)v)) return 1; );
+	}
+
+	return 0;
+}
+
+int UArray_isLegalUTF8(const UArray *self)
+{
+	void *sourceStart = self->data;
+	void *sourceEnd   = self->data + self->size * self->itemSize;
+
+	return isLegalUTF8Sequence(sourceStart, sourceEnd);
+}
+
+UArray *UArray_asNumberArrayString(const UArray *self)
+{
+	UArray *out = UArray_new();
+	UArray_setEncoding_(out, CENCODING_ASCII);
+
+	UARRAY_INTFOREACH(self, i, v,
+		char s[128];
+
+		if(UArray_isFloatType(self))
+		{
+			sprintf(s, "%f", v);
+		}
+		else
+		{
+			sprintf(s, "%i", v);
+		}
+
+		if(i != UArray_size(self) -1 ) strcat(s, ", ");
+		UArray_appendBytes_size_(out, (unsigned char *)s, strlen(s));
+	);
+
+	return out;
+}
+
+
+UArray *UArray_asUTF8(const UArray *self)
+{
+	UArray *out = UArray_new();
+	UArray_setItemType_(out, CTYPE_uint8_t);
+	UArray_setEncoding_(out, CENCODING_UTF8);
+	UArray_setSize_(out, self->size * 4);
+
+	{
+		ConversionResult r = conversionOK;
+		ConversionFlags options = lenientConversion;
+		void *sourceStart = self->data;
+		void *sourceEnd   = self->data + self->size * self->itemSize;
+		UTF8 *targetStart = out->data;
+		UTF8 *targetEnd   = out->data + out->size * out->itemSize;
+		size_t outSize;
+
+		switch(self->encoding)
+		{
+			case CENCODING_ASCII:
+				UArray_copy_(out, self);
+				break;
+			case CENCODING_UTF8:
+				UArray_copy_(out, self);
+				break;
+			case CENCODING_UTF16:
+				r = ConvertUTF16toUTF8((const UTF16 **)&sourceStart, (const UTF16 *)sourceEnd, &targetStart, targetEnd, options);
+				//outSize = (targetStart - out->data) / out->itemSize;
+				break;
+			case CENCODING_UTF32:
+				r = ConvertUTF32toUTF8((const UTF32 **)&sourceStart, (const UTF32 *)sourceEnd, &targetStart, targetEnd, options);
+				//outSize = (targetStart - out->data) / out->itemSize;
+				break;
+			case CENCODING_NUMBER:
+				{
+					UArray *nas = UArray_asNumberArrayString(self);
+					UArray_free(out);
+					out = UArray_asUTF8(nas);
+					UArray_free(nas);
+					break;
+				}
+			default:
+				printf("UArray_asUTF8 - unknown source encoding\n");
+		}
+	}
+
+
+	UArray_setSize_(out, strlen((char *)out->data));
+
+	return out;
+}
+
+UArray *UArray_asUTF16(const UArray *self)
+{
+	UArray *out = UArray_new();
+	UArray_setItemType_(out, CTYPE_uint16_t);
+	UArray_setEncoding_(out, CENCODING_UTF16);
+	UArray_setSize_(out, self->size);
+
+	{
+		ConversionResult r = conversionOK;
+		ConversionFlags options = lenientConversion;
+		void *sourceStart = self->data;
+		void *sourceEnd   = self->data + self->size * self->itemSize;
+		UTF16 *targetStart = (UTF16 *)out->data;
+		UTF16 *targetEnd   = (UTF16 *)(out->data + out->size * out->itemSize);
+
+		switch(self->encoding)
+		{
+			case CENCODING_ASCII:
+				r = ConvertUTF8toUTF16((const UTF8 **)&sourceStart, (const UTF8 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_UTF8:
+				r = ConvertUTF8toUTF16((const UTF8 **)&sourceStart, (const UTF8 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_UTF16:
+				UArray_copy_(out, self);
+				break;
+			case CENCODING_UTF32:
+				r = ConvertUTF32toUTF16((const UTF32 **)&sourceStart, (const UTF32 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_NUMBER:
+				{
+					UArray *nas = UArray_asNumberArrayString(self);
+					UArray_free(out);
+					out = UArray_asUTF16(nas);
+					UArray_free(nas);
+					break;
+				}
+			default:
+				printf("UArray_asUTF16 - unknown source encoding\n");
+		}
+	}
+
+	UArray_truncateAfterConvertToEncoding_(out);
+
+	return out;
+}
+
+UArray *UArray_asUTF32(const UArray *self)
+{
+	UArray *out = UArray_new();
+	UArray_setItemType_(out, CTYPE_uint32_t);
+	UArray_setEncoding_(out, CENCODING_UTF32);
+	UArray_setSize_(out, self->size);
+
+	{
+		ConversionResult r = conversionOK;
+		ConversionFlags options = lenientConversion;
+		void *sourceStart = self->data;
+		void *sourceEnd   = self->data + self->size * self->itemSize;
+		UTF32 *targetStart = (UTF32 *)out->data;
+		UTF32 *targetEnd   = (UTF32 *)(out->data + out->size * out->itemSize);
+
+		switch(self->encoding)
+		{
+			case CENCODING_ASCII:
+				r = ConvertUTF8toUTF32((const UTF8 **)&sourceStart, (const UTF8 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_UTF8:
+				r = ConvertUTF8toUTF32((const UTF8 **)&sourceStart, (const UTF8 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_UTF16:
+				r = ConvertUTF16toUTF32((const UTF16 **)&sourceStart, (const UTF16 *)sourceEnd, &targetStart, targetEnd, options);
+				break;
+			case CENCODING_UTF32:
+				UArray_copy_(out, self);
+				break;
+			case CENCODING_NUMBER:
+				{
+					UArray *nas = UArray_asNumberArrayString(self);
+					UArray_free(out);
+					out = UArray_asUTF32(nas);
+					UArray_free(nas);
+					break;
+				}
+			default:
+				printf("UArray_asUTF32 - unknown source encoding\n");
+		}
+	}
+
+	UArray_truncateAfterConvertToEncoding_(out);
+
+	return out;
+}
+
+void UArray_convertToUTF8(UArray *self)
+{
+	UArray *a = UArray_asUTF8(self);
+	UArray_swapWith_(self, a);
+	UArray_free(a);
+}
+
+void UArray_convertToUTF16(UArray *self)
+{
+	UArray *a = UArray_asUTF16(self);
+	UArray_swapWith_(self, a);
+	UArray_free(a);
+}
+
+void UArray_convertToUTF32(UArray *self)
+{
+	UArray *a = UArray_asUTF32(self);
+	UArray_swapWith_(self, a);
+	UArray_free(a);
+}
+
+
+// ----------------------------------------------------
+
+
diff --git a/release/src/router/skipdbv2/basekit/UArray_utf.h b/release/src/router/skipdbv2/basekit/UArray_utf.h
new file mode 100644
index 0000000000..a065aff104
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/UArray_utf.h
@@ -0,0 +1,18 @@
+/*
+	copyright: Steve Dekorte, 2006. All rights reserved.
+	license: See _BSDLicense.txt.
+*/
+
+BASEKIT_API int UArray_convertToFixedSizeType(UArray *self);
+
+BASEKIT_API int UArray_maxCharSize(const UArray *self);
+BASEKIT_API int UArray_isMultibyte(const UArray *self);
+BASEKIT_API int UArray_isLegalUTF8(const UArray *self);
+
+BASEKIT_API UArray *UArray_asUTF8(const UArray *self);
+BASEKIT_API UArray *UArray_asUTF16(const UArray *self);
+BASEKIT_API UArray *UArray_asUTF32(const UArray *self);
+
+BASEKIT_API void UArray_convertToUTF8(UArray *self);
+BASEKIT_API void UArray_convertToUTF16(UArray *self);
+BASEKIT_API void UArray_convertToUTF32(UArray *self);
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/LICENSE.txt b/release/src/router/skipdbv2/basekit/simd_cph/LICENSE.txt
new file mode 100644
index 0000000000..e53c6fc03e
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/LICENSE.txt
@@ -0,0 +1,28 @@
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/docs/LICENSE.txt b/release/src/router/skipdbv2/basekit/simd_cph/docs/LICENSE.txt
new file mode 100644
index 0000000000..e53c6fc03e
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/docs/LICENSE.txt
@@ -0,0 +1,28 @@
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp.h b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp.h
new file mode 100644
index 0000000000..56cbf6ab6b
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp.h
@@ -0,0 +1,134 @@
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
+
+
+/*****************************************************
+
+   Cross-platform SIMD intrinsics header file
+
+      This is the main file and the only one an application should
+   include.  It will find the correct (hopefully) SIMD_CPH
+   dialect file to include.
+   
+
+*/
+
+#ifndef __SIMD_CPHD_h
+
+
+/* Defines */
+/* Defines */
+/* Defines */
+#define __SIMD_CPHD_h
+
+
+/* Figure out what compiler and CPU we have */
+
+#if defined (__SIMD_NO_SIMD__)  || defined (__SIMD_EMU__)
+#else /* broken pre-processor */
+
+#ifdef __GNUC__  /* gcc compiler */
+
+  /* x86 compiler */
+   #ifdef __i386__
+      #define __GNUC__X86__
+      #define __FOUND
+   #endif
+   
+  /* PowerPC Compiler */
+   #ifdef __ALTIVEC__
+      #define __GNUC__RS6__
+      #define __FOUND
+      #define __SIMD_NO_SIMD /* No PPC intrinsics file right now */
+   #endif
+   
+   #ifdef __XSCALE__
+      #define __GNUC__ARM_IWMMX__
+      #define __FOUND
+   #endif
+       
+#endif /* __GNUC__ */
+
+
+
+#ifdef _MSC_VER  /* Microsoft VC Compiler */
+
+   #ifdef _M_IX86  /* MSVC for X86 CPU  (same as GNUC?)*/
+      #define __MSVC__X86__
+      #define __FOUND
+   #endif
+
+   #ifdef _M_ALPHA /* for Compaq Alpha CPU */
+      #define __MSVC__AXP__ 
+      #define __FOUND
+      #define __SIMD_NO_SIMD__
+   #endif
+   
+#endif /* _WIN32 */
+
+
+
+#ifndef __FOUND
+  #define __SIMD_EMU__
+  //#warning simd_cp.h does not support or could not figure out your compiler and/or CPU.
+#endif
+
+#endif /* SIMD_NO_SIMD and SIMD_EMU */
+
+
+/* Include the correct SIMD file */
+
+#if defined(__SIMD_NO_SIMD__) || defined(__SIMD_EMU__)
+   #warning Including Emulated SIMD support...
+   #define __UNK__EMU__
+   #include <simd_cp_emu.h>
+#endif
+
+#if defined( __GNUC__X86__ ) || defined(__MSVC__X86__)
+        /* gcc x86 compiler or msvc x86 */
+   #include <simd_cp_x86.h>
+#endif /* __GNUC__X86__ */
+
+#ifdef __GNUC__ARM_IWMMX /* gcc ARM compiler with XSCALE SIMD */
+   #include <simd_cp_arm-iwmmx.h>
+#endif
+
+
+/* Generic Helper commands */
+/* Generic Helper commands */
+/* Generic Helper commands */
+
+   /* print a simd_m128 variable:  l=label to print, a=simd_m128 variable */
+   #define simd_print4Floats(l,a) printf("%s: %f  %f  %f  %f\n",l,a.f[0],a.f[1],a.f[2],a.f[3])
+   #define simd_print4Ints(l,a)   printf("%s: %d  %d  %d  %d\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+   #define simd_print4UInts(l,a)  printf("%s: %d  %d  %d  %d\n",l,(unsigned int)a.i[0],(unsigned int)a.i[1],(unsigned int)a.i[2],(unsigned int)a.i[3])
+   #define simd_print4Hex(l,a)    printf("%s: 0x%08x  0x%08x  0x%08x  0x%08x\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+
+
+#endif /* CP_SIMD_h */
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_arm-iwmmx.h b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_arm-iwmmx.h
new file mode 100644
index 0000000000..0c0bb1b0f4
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_arm-iwmmx.h
@@ -0,0 +1,281 @@
+/*****************************************************
+
+  SIMD_CP XSCALE instrinsics for ARM (IWMMX)
+
+***************************************************/
+
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
+
+
+
+
+/* Include the correct SIMD file */
+
+
+
+/* Includes */
+/* Includes */
+/* Includes */
+
+   #include <xmmintrin.h>
+
+
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+
+/* simd_m128 is a multi-use 128bit variable containing 4 ints or 4 floats */
+/* ALL SIMD ops in this header use this variable type */
+
+   typedef union {
+	__m128 v   ;  /* the packed SIMD data (vector) */
+	float  f[4];  /* signed float access */
+	int    i[4];  /* int access */
+	short  s[8];  /* short access */
+	char   c[16]; /* char access */
+	__m64  m[2];  /* need for MMX commands - sse has no integer */
+   } simd_m128 ;
+
+
+
+
+
+
+/* Helper commands */
+/* Helper commands */
+/* Helper commands */
+
+   #define simd_load4Floats(v,a,b,c,d) v.f[0]=a;v.f[1]=b;v.f[2]=c;v.f[3]=d
+   #define simd_load4Ints(v,a,b,c,d)   v.i[0]=a;v.i[1]=b;v.i[2]=c;v.i[3]=d
+
+   /* print a simd_m128 variable:  l=label to print, a=simd_m128 variable */
+   #define simd_print4Floats(l,a) printf("%s: %f  %f  %f  %f\n",l,a.f[0],a.f[1],a.f[2],a.f[3])
+   #define simd_print4Ints(l,a)   printf("%s: %d  %d  %d  %d\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+   #define simd_print4UInts(l,a)  printf("%s: %d  %d  %d  %d\n",l,(unsigned int)a.i[0],(unsigned int)a.i[1],(unsigned int)a.i[2],(unsigned int)a.i[3])
+   #define simd_print4Hex(l,a)    printf("%s: 0x%08x  0x%08x  0x%08x  0x%08x\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+
+   /* v0 = v1 {mask} v2, where mask controlls which packed values are copied */
+   
+   /* EMULATED */
+   #define simd_copy(v1,v2,m,v0)  v0.i[0]=( m & 0x01 ? v2.i[0] : v1.i[0] ); \
+   				  v0.i[1]=( m & 0x02 ? v2.i[1] : v1.i[1] ); \
+   				  v0.i[2]=( m & 0x04 ? v2.i[2] : v1.i[2] ); \
+				  v0.i[3]=( m & 0x08 ? v2.i[3] : v1.i[3] )
+
+
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+
+
+   /* Signed ints (4 packed ints) */
+
+   /* v0 = 4 ints in v1 added to 4 ints in v2 */
+   #define simd_4i_add(v1,v2,v0)  v0.m[0]=_mm_add_pi32(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi32(v1.m[1],v2.m[1])
+
+   /* v0 = 4 ints in v1 subracted from 4 ints in v2 */
+   #define simd_4i_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi32(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi32(v1.m[1],v2.m[1])
+
+   /* no integer SIMD mult on IWMMX */
+   /* v0 = 4 ints in v1 multiplied by 4 ints in v2 */
+   #define simd_4i_mult(v1,v2,v0) v0.i[0]=v1.i[0]*v2.i[0]; v0.i[1]=v1.i[1]*v2.i[1]; v0.i[2]=v1.i[2]*v2.i[2]; v0.i[3]=v1.i[3]*v2.i[3]
+
+   /* no integer SIMD div on IWMMX */
+   /* v0 = 4 ints in v1 divided by 4 ints in v2 */
+   #define simd_4i_div(v1,v2,v0) v0.i[0]=v1.i[0]/v2.i[0]; v0.i[1]=v1.i[1]/v2.i[1]; v0.i[2]=v1.i[2]/v2.i[2]; v0.i[3]=v1.i[3]/v2.i[3]
+
+   /* ints logical/bitwise */
+   
+   /* IN GCC IWMMX DO BITWISE AS MMX 64-BIT INSTRUCTIONS */
+   
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_band(v1,v2,v0) v0.m[0]=_mm_and_si64(v1.m[0],v2.m[0]);v0.m[1]=_mm_and_si64(v1.m[1],v2.m[1])
+
+   /* v0 = 4 ints in v1 | 4 ints in v2 */
+   #define simd_4i_bor(v1,v2,v0)  v0.m[0]=_mm_or_si64(v1.m[0],v2.m[0]);v0.m[1]=_mm_or_si64(v1.m[1],v2.m[1])
+
+   /* v0 = 4 ints in v1 ^ 4 ints in v2 */
+   #define simd_4i_bxor(v1,v2,v0) v0.m[0]=_mm_xor_si64(v1.m[0],v2.m[0]);v0.m[1]=_mm_xor_si64(v1.m[1],v2.m[1])
+   
+   /* V0 = 4 ints in V1, each shifted left  (<<) X bits */
+   #define simd_4i_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi32(v1.m[0],x);v0.m[1]=_mm_sll_pi32(v1.m[1],x)
+
+   /* V0 = 4 ints in V1, each shifted right (>>) X bits */
+   #define simd_4i_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi32(v1.m[0],x);v0.m[1]=_mm_srl_pi32(v1.m[1],x)
+
+
+   
+   /* Signed shorts (8 packed shorts) */
+
+   /* v0 = 8 shorts in v1 added to 8 shorts in v2 */
+   #define simd_4s_add(v1,v2,v0)  v0.m[0]=_mm_add_pi16(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi16(v1.m[1],v2.m[1])
+
+   /* v0 = 8 shorts in v1 subracted from 8 shorts in v2 */
+   #define simd_4s_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi16(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi16(v1.m[1],v2.m[1])
+
+   /* V0 = 8 shorts in V1, each shifted left  (<<) X bits */
+   #define simd_4s_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi16(v1.m[0],x);v0.m[1]=_mm_sll_pi16(v1.m[1],x)
+
+   /* V0 = 8 shorts in V1, each shifted right (>>) X bits */
+   #define simd_4s_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi16(v1.m[0],x);v0.m[1]=_mm_srl_pi16(v1.m[1],x)
+   
+
+   
+   /* Signed chars (16 packed chars) */
+
+   /* v0 = 16 chars in v1 added to 16 chars in v2 */
+   #define simd_4c_add(v1,v2,v0)  v0.m[0]=_mm_add_pi8(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi8(v1.m[1],v2.m[1])
+
+   /* v0 = 16 chars in v1 subracted from 16 chars in v2 */
+   #define simd_4c_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi8(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi8(v1.m[1],v2.m[1])
+
+   /* V0 = 16 chars in V1, each shifted left  (<<) X bits */
+   #define simd_4c_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi8(v1.m[0],x);v0.m[1]=_mm_sll_pi8(v1.m[1],x)
+
+   /* V0 = 16 chars in V1, each shifted right (>>) X bits */
+   #define simd_4c_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi8(v1.m[0],x);v0.m[1]=_mm_srl_pi8(v1.m[1],x)
+
+
+
+
+
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+
+  /* GCC ARM is ALL EMULATED FP SIMD, ARM VFP IS NOT SUPPORTED */
+  
+  /* math */
+
+   /* v0 = 4 floats in v1 added to 4 floats in v2 */
+   #define simd_4f_add(v1,v2,v0)  v0.f[0]=v1.f[0]+v2.f[0]; v0.f[1]=v1.f[1]+v2.f[1]; v0.f[2]=v1.f[2]+v2.f[2]; v0.f[3]=v1.f[3]+v2.f[3]
+
+   /* v0 = 4 floats in v1 subtracted from 4 floats in v2 */
+   #define simd_4f_sub(v1,v2,v0)  v0.f[0]=v1.f[0]-v2.f[0]; v0.f[1]=v1.f[1]-v2.f[1]; v0.f[2]=v1.f[2]-v2.f[2]; v0.f[3]=v1.f[3]-v2.f[3]
+
+   /* v0 = 4 floats in v1 multiplied by 4 floats in v2 */
+   #define simd_4f_mult(v1,v2,v0) v0.f[0]=v1.f[0]*v2.f[0]; v0.f[1]=v1.f[1]*v2.f[1]; v0.f[2]=v1.f[2]*v2.f[2]; v0.f[3]=v1.f[3]*v2.f[3]
+
+   /* v0 = 4 floats in v1 divided by 4 floats in v2 */
+   #define simd_4f_div(v1,v2,v0)  v0.f[0]=v1.f[0]/v2.f[0]; v0.f[1]=v1.f[1]/v2.f[1]; v0.f[2]=v1.f[2]/v2.f[2]; v0.f[3]=v1.f[3]/v2.f[3]
+
+   /* v0 = 4 floats in v1 sqrt */
+   #define simd_4f_sqrt(v1,v0)   v0.f[0]=sqrtf(v1.f[0]);v0.f[1]=sqrtf(v1.f[1]);v0.f[2]=sqrtf(v1.f[2]);v0.f[3]=sqrtf(v1.f[3])
+   
+   /* v0 = 1/(4 floats in v1) */
+   #define simd_4f_recp(v1,v0)   v0.f[0]=1/v1.f[0]; v0.f[1]=1/v1.f[1]; v0.f[2]=1/v1.f[2]; v0.f[3]=1/v1.f[3]
+   
+   /* compares */
+   
+   /* v0 = 4 floats min(v1,v2) */
+   #define simd_4f_min(v1,v2,v0)  v0.f[0]=( v2.f[0] <= v1.f[0] ? v2.f[0] : v1.f[0] ); \
+   				  v0.f[1]=( v2.f[1] <= v1.f[1] ? v2.f[1] : v1.f[1] ); \
+   				  v0.f[2]=( v2.f[2] <= v1.f[2] ? v2.f[2] : v1.f[2] ); \
+				  v0.f[3]=( v2.f[3] <= v1.f[3] ? v2.f[3] : v1.f[3] )
+   
+   /* v0 = 4 floats max(v1,v2) */
+   #define simd_4f_max(v1,v2,v0)  v0.f[0]=( v2.f[0] >= v1.f[0] ? v2.f[0] : v1.f[0] ); \
+   				  v0.f[1]=( v2.f[1] >= v1.f[1] ? v2.f[1] : v1.f[1] ); \
+   				  v0.f[2]=( v2.f[2] >= v1.f[2] ? v2.f[2] : v1.f[2] ); \
+				  v0.f[3]=( v2.f[3] >= v1.f[3] ? v2.f[3] : v1.f[3] )
+
+   /* compare masks */
+   
+   /* v0 = (4 floats in v1 == 4 floats in v1) */
+   #define simd_4f_meq(v1,v2,v0)  v0.i[0]=( v1.f[0] == v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] == v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] == v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] == v2.f[3] ? 0xFFFFFFFF : 0x00 )
+   
+   /* v0 = (4 floats in v1 != 4 floats in v1) */
+   #define simd_4f_mneq(v1,v2,v0) v0.i[0]=( v1.f[0] != v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] != v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] != v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] != v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 < 4 floats in v1) */
+   #define simd_4f_mlt(v1,v2,v0)  v0.i[0]=( v1.f[0] < v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] < v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] < v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] < v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 > 4 floats in v1) */
+   #define simd_4f_mgt(v1,v2,v0)  v0.i[0]=( v1.f[0] > v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] > v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] > v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] > v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 <= 4 floats in v1) */
+   #define simd_4f_mle(v1,v2,v0)  v0.i[0]=( v1.f[0] <= v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] <= v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] <= v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] <= v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 >= 4 floats in v1) */
+   #define simd_4f_mge(v1,v2,v0)  v0.i[0]=( v1.f[0] >= v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] >= v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] >= v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] >= v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+
+
+
+
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+
+/********************************
+
+  These functions that optional.  If they
+  are not available on an architecture, they
+  are defined out, and won't hurt anything.  If they
+  are available, they will only help.
+*/
+
+   /* Tell the MMU you'll soon be accessing some memory from
+      the address "p".  On x86, one cache line is loaded.  There
+      are three flavors for x86, on other procs they'll probably
+      all be defined out or all set to the same type */
+
+
+/* NOT SUPPORTED ON ARM IWMMX */
+   
+   /* This is for data which will be accessed once
+      OTU = One Time Use */
+   #define simd_ut_prefetchOTU(p)
+
+   /* Fetch into the L2 and pass to the L1 cache */
+   #define simd_ut_prefetchL1(p)
+
+   /* Fetch into the L2 cache only */
+   #define simd_ut_prefetchL2(p)
+
+
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_emu.h b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_emu.h
new file mode 100644
index 0000000000..9eab040dfe
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_emu.h
@@ -0,0 +1,324 @@
+
+/*
+
+  Non SIMD or Unknown System/Emulation - Don't use SIMD, and hope the
+  compiler can vectorize if the CPU and compiler support SIMD.
+  
+*/
+
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
+
+
+
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+
+/* simd_m128 is a multi-use 128bit variable containing 4 ints or 4 floats */
+/* ALL SIMD ops in this header use this variable type */
+
+#ifdef __UNK__EMU__  /* Unknown System/Emulation/Emulation */
+   typedef union {
+	float  f[4];  /* signed float access */
+	int    i[4];  /* int access */
+	short  s[8];  /* short access */
+	char   c[16]; /* char access */
+   } simd_m128 ;
+   
+   
+#endif /* __UNK__EMU__ */
+
+
+
+
+
+
+/* Helper commands */
+/* Helper commands */
+/* Helper commands */
+
+   #define simd_load4Floats(v,a,b,c,d) v.f[0]=a;v.f[1]=b;v.f[2]=c;v.f[3]=d
+   #define simd_load4Ints(v,a,b,c,d)   v.i[0]=a;v.i[1]=b;v.i[2]=c;v.i[3]=d
+
+   /* print a simd_m128 variable:  l=label to print, a=simd_m128 variable */
+   #define simd_print4Floats(l,a) printf("%s: %f  %f  %f  %f\n",l,a.f[0],a.f[1],a.f[2],a.f[3])
+   #define simd_print4Ints(l,a)   printf("%s: %d  %d  %d  %d\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+   #define simd_print4UInts(l,a)  printf("%s: %d  %d  %d  %d\n",l,(unsigned int)a.i[0],(unsigned int)a.i[1],(unsigned int)a.i[2],(unsigned int)a.i[3])
+   #define simd_print4Hex(l,a)    printf("%s: 0x%08x  0x%08x  0x%08x  0x%08x\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+
+#ifdef __UNK__EMU__  /* Unknown System/Emulation */
+
+#warning "using SIMD Emulation"
+
+   /* v0 = v1 {mask} v2, where mask controlls which packed values are copied */
+   #define simd_copy(v1,v2,m,v0)  v0.i[0]=( m & 0x01 ? v2.i[0] : v1.i[0] ); \
+   				  v0.i[1]=( m & 0x02 ? v2.i[1] : v1.i[1] ); \
+   				  v0.i[2]=( m & 0x04 ? v2.i[2] : v1.i[2] ); \
+				  v0.i[3]=( m & 0x08 ? v2.i[3] : v1.i[3] )
+
+#endif /* __UNK__EMU__ */
+
+
+
+
+
+
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+
+#ifdef __UNK__EMU__  /* Unknown System/Emulation */
+
+   /* Signed ints (4 packed ints) */
+
+   /* v0 = 4 ints in v1 added to 4 ints in v2 */
+   #define simd_4i_add(v1,v2,v0)  v0.i[0]=v1.i[0]+v2.i[0]; v0.i[1]=v1.i[1]+v2.i[1]; v0.i[2]=v1.i[2]+v2.i[2]; v0.i[3]=v1.i[3]+v2.i[3]
+
+   /* v0 = 4 ints in v1 subracted from 4 ints in v2 */
+   #define simd_4i_sub(v1,v2,v0)  v0.i[0]=v1.i[0]-v2.i[0]; v0.i[1]=v1.i[1]-v2.i[1]; v0.i[2]=v1.i[2]-v2.i[2]; v0.i[3]=v1.i[3]-v2.i[3]
+
+   /* no integer SIMD mult on x86? */
+   /* v0 = 4 ints in v1 multiplied by 4 ints in v2 */
+   #define simd_4i_mult(v1,v2,v0) v0.i[0]=v1.i[0]*v2.i[0]; v0.i[1]=v1.i[1]*v2.i[1]; v0.i[2]=v1.i[2]*v2.i[2]; v0.i[3]=v1.i[3]*v2.i[3]
+
+   /* no integer SIMD div on x86? */
+   /* v0 = 4 ints in v1 divided by 4 ints in v2 */
+   #define simd_4i_div(v1,v2,v0)  v0.i[0]=v1.i[0]/v2.i[0]; v0.i[1]=v1.i[1]/v2.i[1]; v0.i[2]=v1.i[2]/v2.i[2]; v0.i[3]=v1.i[3]/v2.i[3]
+
+   /* ints logical/bitwise */
+   
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_band(v1,v2,v0) v0.i[0]=v1.i[0]&v2.i[0]; v0.i[1]=v1.i[1]&v2.i[1]; v0.i[2]=v1.i[2]&v2.i[2]; v0.i[3]=v1.i[3]&v2.i[3]
+
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_bor(v1,v2,v0)  v0.i[0]=v1.i[0]|v2.i[0]; v0.i[1]=v1.i[1]|v2.i[1]; v0.i[2]=v1.i[2]|v2.i[2]; v0.i[3]=v1.i[3]|v2.i[3]
+
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_bxor(v1,v2,v0) v0.i[0]=v1.i[0]^v2.i[0]; v0.i[1]=v1.i[1]^v2.i[1]; v0.i[2]=v1.i[2]^v2.i[2]; v0.i[3]=v1.i[3]^v2.i[3]
+   
+   /* V0 = 4 ints in V1, each shifted left  (<<) X bits */
+   #define simd_4i_shftl(v1,x,v0) v0.i[0]=v1.i[0]<<x; v0.i[1]=v1.i[1]<<x; v0.i[2]=v1.i[2]<<x; v0.i[3]=v1.i[3]<<x
+
+   /* V0 = 4 ints in V1, each shifted right (>>) X bits */
+   #define simd_4i_shftr(v1,x,v0) v0.i[0]=v1.i[0]>>x; v0.i[1]=v1.i[1]>>x; v0.i[2]=v1.i[2]>>x; v0.i[3]=v1.i[3]>>x
+
+
+   
+   /* Signed shorts (8 packed shorts) */
+
+   /* v0 = 8 shorts in v1 added to 8 shorts in v2 */
+   #define simd_4s_add(v1,v2,v0)  v0.s[0]=v1.s[0]+v2.s[0];v0.s[1]=v1.s[1]+v2.s[1]; \
+                                  v0.s[2]=v1.s[2]+v2.s[2];v0.s[3]=v1.s[3]+v2.s[3]; \
+				  v0.s[4]=v1.s[4]+v2.s[4];v0.s[5]=v1.s[5]+v2.s[5]; \
+				  v0.s[6]=v1.s[6]+v2.s[6];v0.s[7]=v1.s[7]+v2.s[7]
+
+   /* v0 = 8 shorts in v1 subracted from 8 shorts in v2 */
+   #define simd_4s_sub(v1,v2,v0)  v0.s[0]=v1.s[0]-v2.s[0];v0.s[1]=v1.s[1]-v2.s[1]; \
+                                  v0.s[2]=v1.s[2]-v2.s[2];v0.s[3]=v1.s[3]-v2.s[3]; \
+				  v0.s[4]=v1.s[4]-v2.s[4];v0.s[5]=v1.s[5]-v2.s[5]; \
+				  v0.s[6]=v1.s[6]-v2.s[6];v0.s[7]=v1.s[7]-v2.s[7]
+
+   /* V0 = 8 shorts in V1, each shifted left  (<<) X bits */
+   #define simd_4s_shftl(v1,x,v0) v0.s[0]=v1.s[0]<<x;v0.s[1]=v1.s[1]<<x; \
+                                  v0.s[2]=v1.s[2]<<x;v0.s[3]=v1.s[3]<<x; \
+				  v0.s[4]=v1.s[4]<<x;v0.s[5]=v1.s[5]<<x; \
+				  v0.s[6]=v1.s[6]<<x;v0.s[7]=v1.s[7]<<x
+
+   /* V0 = 8 shorts in V1, each shifted right (>>) X bits */
+   #define simd_4s_shftr(v1,x,v0) v0.s[0]=v1.s[0]>>x;v0.s[1]=v1.s[1]>>x; \
+                                  v0.s[2]=v1.s[2]>>x;v0.s[3]=v1.s[3]>>x; \
+				  v0.s[4]=v1.s[4]>>x;v0.s[5]=v1.s[5]>>x; \
+				  v0.s[6]=v1.s[6]>>x;v0.s[7]=v1.s[7]>>x
+
+   
+   /* Signed chars (16 packed chars) */
+
+   /* v0 = 16 chars in v1 added to 16 chars in v2 */
+   #define simd_4c_add(v1,v2,v0)  v0.c[0]=v1.c[0]+v2.c[0];v0.c[1]=v1.c[1]+v2.c[1]; \
+                                  v0.c[2]=v1.c[2]+v2.c[2];v0.c[3]=v1.c[3]+v2.c[3]; \
+				  v0.c[4]=v1.c[4]+v2.c[4];v0.c[5]=v1.c[5]+v2.c[5]; \
+				  v0.c[6]=v1.c[6]+v2.c[6];v0.c[7]=v1.c[7]+v2.c[7]; \
+                                  v0.c[8]=v1.c[8]+v2.c[8];v0.c[9]=v1.c[9]+v2.c[9]; \
+                                  v0.c[10]=v1.c[10]+v2.c[10];v0.c[11]=v1.c[11]+v2.c[11]; \
+				  v0.c[12]=v1.c[12]+v2.c[12];v0.c[13]=v1.c[13]+v2.c[13]; \
+				  v0.c[14]=v1.c[14]+v2.c[14];v0.c[15]=v1.c[15]+v2.c[15]
+
+   /* v0 = 16 chars in v1 subracted from 16 chars in v2 */
+   #define simd_4c_sub(v1,v2,v0)  v0.c[0]=v1.c[0]-v2.c[0];v0.c[1]=v1.c[1]-v2.c[1]; \
+                                  v0.c[2]=v1.c[2]-v2.c[2];v0.c[3]=v1.c[3]-v2.c[3]; \
+				  v0.c[4]=v1.c[4]-v2.c[4];v0.c[5]=v1.c[5]-v2.c[5]; \
+				  v0.c[6]=v1.c[6]-v2.c[6];v0.c[7]=v1.c[7]-v2.c[7]; \
+                                  v0.c[8]=v1.c[8]-v2.c[8];v0.c[9]=v1.c[9]-v2.c[9]; \
+                                  v0.c[10]=v1.c[10]-v2.c[10];v0.c[11]=v1.c[11]-v2.c[11]; \
+				  v0.c[12]=v1.c[12]-v2.c[12];v0.c[13]=v1.c[13]-v2.c[13]; \
+				  v0.c[14]=v1.c[14]-v2.c[14];v0.c[15]=v1.c[15]-v2.c[15]
+				  
+   /* V0 = 16 chars in V1, each shifted left  (<<) X bits */
+   #define simd_4c_shftl(v1,x,v0) v0.c[0]=v1.c[0]<<x;v0.c[1]=v1.c[1]<<x; \
+                                  v0.c[2]=v1.c[2]<<x;v0.c[3]=v1.c[3]<<x; \
+				  v0.c[4]=v1.c[4]<<x;v0.c[5]=v1.c[5]<<x; \
+				  v0.c[6]=v1.c[6]<<x;v0.c[7]=v1.c[7]<<x; \
+				  v0.c[8]=v1.c[8]<<x;v0.c[9]=v1.c[9]<<x; \
+                                  v0.c[10]=v1.c[10]<<x;v0.c[11]=v1.c[11]<<x; \
+				  v0.c[12]=v1.c[12]<<x;v0.c[13]=v1.c[13]<<x; \
+				  v0.c[14]=v1.c[14]<<x;v0.c[15]=v1.c[15]<<x
+
+   /* V0 = 16 chars in V1, each shifted right (>>) X bits */
+   #define simd_4c_shftr(v1,x,v0) v0.c[0]=v1.c[0]>>x;v0.c[1]=v1.c[1]>>x; \
+                                  v0.c[2]=v1.c[2]>>x;v0.c[3]=v1.c[3]>>x; \
+				  v0.c[4]=v1.c[4]>>x;v0.c[5]=v1.c[5]>>x; \
+				  v0.c[6]=v1.c[6]>>x;v0.c[7]=v1.c[7]>>x; \
+				  v0.c[8]=v1.c[8]>>x;v0.c[9]=v1.c[9]>>x; \
+                                  v0.c[10]=v1.c[10]>>x;v0.c[11]=v1.c[11]>>x; \
+				  v0.c[12]=v1.c[12]>>x;v0.c[13]=v1.c[13]>>x; \
+				  v0.c[14]=v1.c[14]>>x;v0.c[15]=v1.c[15]>>x
+
+
+#endif /* __UNK__EMU__ */
+
+
+
+
+
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+
+#ifdef __UNK__EMU__  /* Unknown System/Emulation */
+
+   /* math */
+
+   /* v0 = 4 floats in v1 added to 4 floats in v2 */
+   #define simd_4f_add(v1,v2,v0)  v0.f[0]=v1.f[0]+v2.f[0]; v0.f[1]=v1.f[1]+v2.f[1]; v0.f[2]=v1.f[2]+v2.f[2]; v0.f[3]=v1.f[3]+v2.f[3]
+
+   /* v0 = 4 floats in v1 subtracted from 4 floats in v2 */
+   #define simd_4f_sub(v1,v2,v0)  v0.f[0]=v1.f[0]-v2.f[0]; v0.f[1]=v1.f[1]-v2.f[1]; v0.f[2]=v1.f[2]-v2.f[2]; v0.f[3]=v1.f[3]-v2.f[3]
+
+   /* v0 = 4 floats in v1 multiplied by 4 floats in v2 */
+   #define simd_4f_mult(v1,v2,v0) v0.f[0]=v1.f[0]*v2.f[0]; v0.f[1]=v1.f[1]*v2.f[1]; v0.f[2]=v1.f[2]*v2.f[2]; v0.f[3]=v1.f[3]*v2.f[3]
+
+   /* v0 = 4 floats in v1 divided by 4 floats in v2 */
+   #define simd_4f_div(v1,v2,v0)  v0.f[0]=v1.f[0]/v2.f[0]; v0.f[1]=v1.f[1]/v2.f[1]; v0.f[2]=v1.f[2]/v2.f[2]; v0.f[3]=v1.f[3]/v2.f[3]
+
+   /* v0 = 4 floats in v1 sqrt */
+   #define simd_4f_sqrt(v1,v0)   v0.f[0]=sqrtf(v1.f[0]);v0.f[1]=sqrtf(v1.f[1]);v0.f[2]=sqrtf(v1.f[2]);v0.f[3]=sqrtf(v1.f[3])
+   
+   /* v0 = 1/(4 floats in v1) */
+   #define simd_4f_recp(v1,v0)   v0.f[0]=1/v1.f[0]; v0.f[1]=1/v1.f[1]; v0.f[2]=1/v1.f[2]; v0.f[3]=1/v1.f[3]
+   
+   /* compares */
+   
+   /* v0 = 4 floats min(v1,v2) */
+   #define simd_4f_min(v1,v2,v0)  v0.f[0]=( v2.f[0] <= v1.f[0] ? v2.f[0] : v1.f[0] ); \
+   				  v0.f[1]=( v2.f[1] <= v1.f[1] ? v2.f[1] : v1.f[1] ); \
+   				  v0.f[2]=( v2.f[2] <= v1.f[2] ? v2.f[2] : v1.f[2] ); \
+				  v0.f[3]=( v2.f[3] <= v1.f[3] ? v2.f[3] : v1.f[3] )
+   
+   /* v0 = 4 floats max(v1,v2) */
+   #define simd_4f_max(v1,v2,v0)  v0.f[0]=( v2.f[0] >= v1.f[0] ? v2.f[0] : v1.f[0] ); \
+   				  v0.f[1]=( v2.f[1] >= v1.f[1] ? v2.f[1] : v1.f[1] ); \
+   				  v0.f[2]=( v2.f[2] >= v1.f[2] ? v2.f[2] : v1.f[2] ); \
+				  v0.f[3]=( v2.f[3] >= v1.f[3] ? v2.f[3] : v1.f[3] )
+
+   /* compare masks */
+   
+   /* v0 = (4 floats in v1 == 4 floats in v1) */
+   #define simd_4f_meq(v1,v2,v0)  v0.i[0]=( v1.f[0] == v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] == v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] == v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] == v2.f[3] ? 0xFFFFFFFF : 0x00 )
+   
+   /* v0 = (4 floats in v1 != 4 floats in v1) */
+   #define simd_4f_mneq(v1,v2,v0) v0.i[0]=( v1.f[0] != v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] != v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] != v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] != v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 < 4 floats in v1) */
+   #define simd_4f_mlt(v1,v2,v0)  v0.i[0]=( v1.f[0] < v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] < v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] < v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] < v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 > 4 floats in v1) */
+   #define simd_4f_mgt(v1,v2,v0)  v0.i[0]=( v1.f[0] > v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] > v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] > v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] > v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 <= 4 floats in v1) */
+   #define simd_4f_mle(v1,v2,v0)  v0.i[0]=( v1.f[0] <= v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] <= v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] <= v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] <= v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+   /* v0 = (4 floats in v1 >= 4 floats in v1) */
+   #define simd_4f_mge(v1,v2,v0)  v0.i[0]=( v1.f[0] >= v2.f[0] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[1]=( v1.f[1] >= v2.f[1] ? 0xFFFFFFFF : 0x00 ); \
+   				  v0.i[2]=( v1.f[2] >= v2.f[2] ? 0xFFFFFFFF : 0x00 ); \
+				  v0.i[3]=( v1.f[3] >= v2.f[3] ? 0xFFFFFFFF : 0x00 )
+
+#endif /* __UNK__EMU__ */
+
+
+
+
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+
+/*
+
+  These functions that optional.  If they
+  are not available on an architecture, they
+  are defined out, and won't hurt anything.
+  If they are available, they will only help.
+  
+*/
+
+#ifdef __UNK__EMU__  /* Unknown System/Emulation (defined out) */
+
+   /* Tell the MMU you'll soon be accessing some memory from
+      the address "p".  On x86, one cache line is loaded.  There
+      are three flavors for x86, on other procs they'll probably
+      all be defined out or all set to the same type */
+   
+   /* This is for data which will be accessed once
+      (OTU = One Time Use */
+   #define simd_ut_prefetchOTU(p)
+
+   /* Fetch into the L2 and pass to the L1 cache */
+   #define simd_ut_prefetchL1(p)
+
+   /* Fetch into the L2 cache only */
+   #define simd_ut_prefetchL2(p)
+   
+#endif /* __UNK__EMU__ */
+
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_x86.h b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_x86.h
new file mode 100644
index 0000000000..ed0ccd5ba1
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/include/simd_cp_x86.h
@@ -0,0 +1,246 @@
+/*****************************************************
+
+  SIMD_CP instrinsics for X86 with SSE and MMX
+
+***************************************************/
+
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
+
+
+
+
+/* Include the correct SIMD file */
+
+
+
+/* Includes */
+/* Includes */
+/* Includes */
+
+   #include <xmmintrin.h>
+
+
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+/* Register/Variable typedefs */
+
+/* simd_m128 is a multi-use 128bit variable containing 4 ints or 4 floats */
+/* ALL SIMD ops in this header use this variable type */
+
+   typedef union {
+	__m128 v   ;  /* the packed SIMD data (vector) */
+	float  f[4];  /* signed float access */
+	int    i[4];  /* int access */
+	short  s[8];  /* short access */
+	char   c[16]; /* char access */
+	__m64  m[2];  /* x86 needs for MMX commands - sse has no integer */
+   } simd_m128 ;
+
+
+
+
+
+
+/* Helper commands */
+/* Helper commands */
+/* Helper commands */
+
+   #define simd_load4Floats(v,a,b,c,d) v.f[0]=a;v.f[1]=b;v.f[2]=c;v.f[3]=d
+   #define simd_load4Ints(v,a,b,c,d)   v.i[0]=a;v.i[1]=b;v.i[2]=c;v.i[3]=d
+
+   /* print a simd_m128 variable:  l=label to print, a=simd_m128 variable */
+   #define simd_print4Floats(l,a) printf("%s: %f  %f  %f  %f\n",l,a.f[0],a.f[1],a.f[2],a.f[3])
+   #define simd_print4Ints(l,a)   printf("%s: %d  %d  %d  %d\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+   #define simd_print4UInts(l,a)  printf("%s: %d  %d  %d  %d\n",l,(unsigned int)a.i[0],(unsigned int)a.i[1],(unsigned int)a.i[2],(unsigned int)a.i[3])
+   #define simd_print4Hex(l,a)    printf("%s: 0x%08x  0x%08x  0x%08x  0x%08x\n",l,a.i[0],a.i[1],a.i[2],a.i[3])
+
+   /* v0 = v1 {mask} v2, where mask controlls which packed values are copied */
+   #define simd_copy(v1,v2,m,v0)  v0.v=_mm_suffle_ps(v1.v,v2.v,m)
+
+
+
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+/* Integer SIMD intrinsics */
+
+
+   /* Signed ints (4 packed ints) */
+
+   /* v0 = 4 ints in v1 added to 4 ints in v2 */
+   #define simd_4i_add(v1,v2,v0)  v0.m[0]=_mm_add_pi32(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi32(v1.m[1],v2.m[1])
+
+   /* v0 = 4 ints in v1 subracted from 4 ints in v2 */
+   #define simd_4i_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi32(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi32(v1.m[1],v2.m[1])
+
+   /* no integer SIMD mult on x86? */
+   /* v0 = 4 ints in v1 multiplied by 4 ints in v2 */
+   #define simd_4i_mult(v1,v2,v0) v0.i[0]=v1.i[0]*v2.i[0]; v0.i[1]=v1.i[1]*v2.i[1]; v0.i[2]=v1.i[2]*v2.i[2]; v0.i[3]=v1.i[3]*v2.i[3]
+
+   /* no integer SIMD div on x86? */
+   /* v0 = 4 ints in v1 divided by 4 ints in v2 */
+   #define simd_4i_div(v1,v2,v0) v0.i[0]=v1.i[0]/v2.i[0]; v0.i[1]=v1.i[1]/v2.i[1]; v0.i[2]=v1.i[2]/v2.i[2]; v0.i[3]=v1.i[3]/v2.i[3]
+
+   /* ints logical/bitwise */
+   
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_band(v1,v2,v0) v0.v=_mm_and_ps(v1.v,v2.v)
+
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_bor(v1,v2,v0)  v0.v=_mm_or_ps(v1.v,v2.v)
+
+   /* v0 = 4 ints in v1 & 4 ints in v2 */
+   #define simd_4i_bxor(v1,v2,v0) v0.v=_mm_xor_ps(v1.v,v2.v)
+   
+   /* V0 = 4 ints in V1, each shifted left  (<<) X bits */
+   #define simd_4i_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi32(v1.m[0],x);v0.m[1]=_mm_sll_pi32(v1.m[1],x)
+
+   /* V0 = 4 ints in V1, each shifted right (>>) X bits */
+   #define simd_4i_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi32(v1.m[0],x);v0.m[1]=_mm_srl_pi32(v1.m[1],x)
+
+
+   
+   /* Signed shorts (8 packed shorts) */
+
+   /* v0 = 8 shorts in v1 added to 8 shorts in v2 */
+   #define simd_4s_add(v1,v2,v0)  v0.m[0]=_mm_add_pi16(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi16(v1.m[1],v2.m[1])
+
+   /* v0 = 8 shorts in v1 subracted from 8 shorts in v2 */
+   #define simd_4s_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi16(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi16(v1.m[1],v2.m[1])
+
+   /* V0 = 8 shorts in V1, each shifted left  (<<) X bits */
+   #define simd_4s_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi16(v1.m[0],x);v0.m[1]=_mm_sll_pi16(v1.m[1],x)
+
+   /* V0 = 8 shorts in V1, each shifted right (>>) X bits */
+   #define simd_4s_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi16(v1.m[0],x);v0.m[1]=_mm_srl_pi16(v1.m[1],x)
+   
+
+   
+   /* Signed chars (16 packed chars) */
+
+   /* v0 = 16 chars in v1 added to 16 chars in v2 */
+   #define simd_4c_add(v1,v2,v0)  v0.m[0]=_mm_add_pi8(v1.m[0],v2.m[0]);v0.m[1]=_mm_add_pi8(v1.m[1],v2.m[1])
+
+   /* v0 = 16 chars in v1 subracted from 16 chars in v2 */
+   #define simd_4c_sub(v1,v2,v0)  v0.m[0]=_mm_sub_pi8(v1.m[0],v2.m[0]);v0.m[1]=_mm_sub_pi8(v1.m[1],v2.m[1])
+
+   /* V0 = 16 chars in V1, each shifted left  (<<) X bits */
+   #define simd_4c_shftl(v1,x,v0)  v0.m[0]=_mm_sll_pi8(v1.m[0],x);v0.m[1]=_mm_sll_pi8(v1.m[1],x)
+
+   /* V0 = 16 chars in V1, each shifted right (>>) X bits */
+   #define simd_4c_shftr(v1,x,v0)  v0.m[0]=_mm_srl_pi8(v1.m[0],x);v0.m[1]=_mm_srl_pi8(v1.m[1],x)
+
+
+
+
+
+
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+/* Floating SIMD intrinsics */
+
+
+   /* math */
+
+   /* v0 = 4 floats in v1 added to 4 floats in v2 */
+   #define simd_4f_add(v1,v2,v0)  v0.v=_mm_add_ps(v1.v,v2.v)
+
+   /* v0 = 4 floats in v1 subtracted from 4 floats in v2 */
+   #define simd_4f_sub(v1,v2,v0)  v0.v=_mm_sub_ps(v1.v,v2.v)
+
+   /* v0 = 4 floats in v1 multiplied by 4 floats in v2 */
+   #define simd_4f_mult(v1,v2,v0) v0.v=_mm_mul_ps(v1.v,v2.v)
+
+   /* v0 = 4 floats in v1 divided by 4 floats in v2 */
+   #define simd_4f_div(v1,v2,v0)  v0.v=_mm_div_ps(v1.v,v2.v)
+
+   /* v0 = 4 floats in v1 sqrt */
+   #define simd_4f_sqrt(v1,v0)    v0.v=_mm_sqrt_ps(v1.v)
+   
+   /* v0 = 1/(4 floats in v1) */
+   #define simd_4f_recp(v1,v0)    v0.v=_mm_rcp_ps(v1.v)
+   
+   /* compares */
+   
+   /* v0 = 4 floats min(v1,v2) */
+   #define simd_4f_min(v1,v2,v0)  v0.v=_mm_min_ps(v1.v,v2.v)
+   
+   /* v0 = 4 floats max(v1,v2) */
+   #define simd_4f_max(v1,v2,v0)  v0.v=_mm_max_ps(v1.v,v2.v)
+
+   /* compare masks */
+   
+   /* v0 = (4 floats in v1 == 4 floats in v1) */
+   #define simd_4f_meq(v1,v2,v0)  v0.v=_mm_cmpeq_ps(v1.v,v2.v)
+   
+   /* v0 = (4 floats in v1 != 4 floats in v1) */
+   #define simd_4f_mneq(v1,v2,v0)  v0.v=_mm_cmpneq_ps(v1.v,v2.v)
+
+   /* v0 = (4 floats in v1 < 4 floats in v1) */
+   #define simd_4f_mlt(v1,v2,v0)  v0.v=_mm_cmplt_ps(v1.v,v2.v)
+
+   /* v0 = (4 floats in v1 > 4 floats in v1) */
+   #define simd_4f_mgt(v1,v2,v0)  v0.v=_mm_cmpgt_ps(v1.v,v2.v)
+
+   /* v0 = (4 floats in v1 <= 4 floats in v1) */
+   #define simd_4f_mle(v1,v2,v0)  v0.v=_mm_cmple_ps(v1.v,v2.v)
+
+   /* v0 = (4 floats in v1 >= 4 floats in v1) */
+   #define simd_4f_mge(v1,v2,v0)  v0.v=_mm_cmpge_ps(v1.v,v2.v)
+
+
+
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+/* Utility Functions and non-SIMD */
+
+/********************************
+
+  These functions that optional.  If they
+  are not available on an architecture, they
+  are defined out, and won't hurt anything.  If they
+  are available, they will only help.
+*/
+
+   /* Tell the MMU you'll soon be accessing some memory from
+      the address "p".  On x86, one cache line is loaded.  There
+      are three flavors for x86, on other procs they'll probably
+      all be defined out or all set to the same type */
+   
+   /* This is for data which will be accessed once
+      (OTU = One Time Use */
+   #define simd_ut_prefetchOTU(p) _mm_prefetch(p,_MM_HINT_NTA)
+
+   /* Fetch into the L2 and pass to the L1 cache */
+   #define simd_ut_prefetchL1(p) _mm_prefetch(p,_MM_HINT_NTA)
+
+   /* Fetch into the L2 cache only */
+   #define simd_ut_prefetchL2(p) _mm_prefetch(p,_MM_HINT_NTA)
+
+
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/simd_cph.readme b/release/src/router/skipdbv2/basekit/simd_cph/simd_cph.readme
new file mode 100644
index 0000000000..2ca2899c65
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/simd_cph.readme
@@ -0,0 +1,111 @@
+/*****************************************************
+
+   Cross-platform SIMD intrinsics header file
+
+   VERSION: 2004.10.26 (alpha)
+   
+   Created by Patrick Roberts
+   
+   This is an on-going project.  Please add functions and
+   typedefs as needed, but try to follow the guideline
+   below:
+   
+   The goal of this file is to stay cross-platform.
+   Only intrinsics or #defines that mimic another system's
+   SIMD instruction should be included, with the only exception
+   being instructions that, if non existant, are not
+   needed (see bottom)
+      
+   Currently, the goal is to base support around 128-bit SIMD.
+   (Only the Gekko and x86-MMX are 64-bit)
+   
+   Changelog:
+   
+   2004.05.09  [Patrick Roberts]
+   	*) Created file with some i386, GCC dialect
+   2004.10.22  [Patrick Roberts]
+        *) Created emulated SIMD
+   2004.10.25  [Patrick Roberts]
+   	*) Created arm-iwmmx GCC dialect
+	*) Fixed sqrt bug in emu dialect
+	*) Organized directories
+	*) Makefile for test app
+	
+
+   To Do:
+   
+   *( Docs
+   *( Add new intrinsics to test app
+   *( MinGW x86 dialect (same as GCC on Linux?)
+   *( Does 3DNOW buy us anything?
+   *( Intel ICC x86 dialect
+   *( MSVC .NET x86 dialect
+   *( Support for ARM ARM6, VFP and NEON SIMD?  What compilers use these?
+   *( PowerPC AltiVec/Velocity/VMX components
+   *( MIPS-MMI / PS2-VU components
+   *( See if SSE2 buys us anything beyond what the compiler does already
+   *( Compaq Alpha components
+   
+*/
+
+/***************************************************
+
+  Platform Notes:
+  
+  
+     General
+     -------
+     
+        NOTE: Code must be 16-byte aligned. Align to 16 when allocating memory.
+	
+	X86/XSCALE (Intel) vs. PowerPC/MIPS
+	
+	While the PowerPC and MIPS SIMD instructions take 2 source vectors
+	and a destination vector, the Intel platforms only take a source and
+	destination.  Example:
+	
+	   PPC/MIPS can do:
+	   
+	      C = A + B
+	      
+	   X86 can only do:
+	   
+	     A = A + B   (or A+=B)
+	     
+	 Code written either way will work on the X86, and still be faster than
+	 387 math, but preserving the registers takes significant overhead.
+	 (Disassemble the test program for an example.  The prints preserve, the
+	 'disassembly test' does not.)   For the fastest code between systems, write
+	 your SIMD math as the X86 expects, manually preserving SIMD variables.
+	 At least GCC for PPC doesn't seem to have any issues figuring out how to
+	 deal with a source and destination memory address being the same.
+  
+  
+     GCC x86
+     -------
+         
+        You must compile with -msse and -mmmx.  I try to avoid mmx as mmx is slower on
+	the P4 than on the P3 and XP, but sse doesn't have integer math.
+	 
+	 You may want to set -msse2 if you have a P4 CPU (-msse2 is set by default
+	 for x86-64 CPUS), as some of the simd functions not supported on x86
+	 can be sped up by gcc using sse2 commands rather than standard pipeline
+	 commands.
+	
+     
+     GCC PowerPC
+     -----------
+     
+        You must compile with the switch -maltivec
+
+
+     GCC ARM (Xscale only)
+     ----------------
+        
+	GCC ARM only seems to support Intel Wirekess MMX (XSCALE), not ARMv6,
+	Neon, or VFP? (Are these all the same beast?)
+
+        You must compile with +iwmmxt 
+
+	
+*/
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/test/Makefile b/release/src/router/skipdbv2/basekit/simd_cph/test/Makefile
new file mode 100644
index 0000000000..8f9d3c47bc
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/test/Makefile
@@ -0,0 +1,25 @@
+
+CC = gcc
+
+# X86
+#COPTS = -I../include -g -O2 -mmmx -msse
+#PLATFORM = X86
+DIS = objdump -d -S
+
+# EMULATED
+COPTS = -I../include -D__SIMD_EMU__ -g -O2
+PLATFORM = emu
+
+default: test_simd.c emulated
+	${CC} ${COPTS} -o test_simd_${PLATFORM} test_simd.c
+
+emulated: test_simd.c
+	${CC} ${COPTS} -D__SIMD_EMU__ -o test_simd_emu test_simd.c
+
+xdiff: default emulated
+	${DIS} test_simd_${PLATFORM} > test_simd_${PLATFORM}.dis
+	${DIS} test_simd_emu > test_simd_emu.dis
+	xdiff test_simd_emu.dis test_simd_${PLATFORM}.dis
+
+clean:
+	rm test_simd_${PLATFORM} test_simd_emu *.dis
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/test/test_simd.c b/release/src/router/skipdbv2/basekit/simd_cph/test/test_simd.c
new file mode 100644
index 0000000000..8d7f88d666
--- /dev/null
+++ b/release/src/router/skipdbv2/basekit/simd_cph/test/test_simd.c
@@ -0,0 +1,109 @@
+/*
+Copyright (c) 2004 Patrick Roberts
+
+This software is provided 'as-is', without any express
+or implied warranty. In no event will the authors be held
+liable for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it
+and redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented;
+you must not claim that you wrote the original software.
+If you use this software in a product, an acknowledgment in
+the product documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such,
+and must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source distribution.
+
+4. THIS LICENSE MAY NOT BE CHANGED, ASSIGNED, OR MIGRATED WITHOUT
+THE AUTHOR'S WRITTEN PERMISSION, WITH THE FOLLOWING EXCEPTIONS:
+
+   a.  This file may be included with GPL/LGPL licensed
+  software, but you may not change the license this file
+  is released under.
+*/
+
+
+/* uncomment the line below to force SIMD emulation C code */  
+/*#define __SIMD_EMU__  */
+
+#include <simd_cp.h>
+#include <stdio.h>
+
+int main(void) {
+
+  simd_m128 v0,v1,v2;
+  
+  simd_load4Floats(v1,2.0,2.0,2.0,2.0);
+  simd_load4Floats(v2,10.0,20.0,30.0,40.0);
+  
+  printf("\nChecking 4f commands\n");
+
+  simd_print4Floats("v1 ",v1);
+  simd_print4Floats("v2 ",v2);
+  puts("");
+  
+  /*  v0 = v1 + v2  */
+  simd_4f_add(v1,v2,v0);
+  simd_print4Floats("4f_add ",v0);
+
+  /*  v0 = v1 - v2  */
+  simd_4f_sub(v1,v2,v0);
+  simd_print4Floats("4f_sub ",v0);
+
+  /*  v0 = v1 * v2  */
+  simd_4f_mult(v1,v2,v0);
+  simd_print4Floats("4f_mult",v0);
+
+  /*  v0 = v1 / v2  */
+  simd_4f_div(v1,v2,v0);
+  simd_print4Floats("4f_div",v0);
+  
+  /*
+   * If you look at the disassembly of this section on an X86 processor, it will be
+   * very tight, as X86 SSE/MMX only handles 2 regs- i.e. A+=B, instead of C=A+B.
+   * For the best cross-platform performance, cater to the lowest demoninator and
+   * write your code like this.
+   */
+   
+  printf("\ndisassembly test\n");
+  simd_4f_add(v1,v2,v1);
+  simd_4f_mult(v1,v2,v1);
+  simd_4f_sub(v1,v2,v1);
+  simd_4f_div(v1,v2,v1);
+  
+
+
+  printf("\nChecking 4i commands\n");
+
+  simd_load4Ints(v1,20,30,40,50);
+  simd_load4Ints(v2,2,3,4,5);
+  
+  simd_print4Ints("v1 ",v1);
+  simd_print4Ints("v2 ",v2);
+  puts("");
+
+  
+  /*  v0 = v1 + v2  */
+  simd_4i_add(v1,v2,v0);
+  simd_print4Ints("4i_add ",v0);
+
+  /*  v0 = v1 - v2  */
+  simd_4i_sub(v1,v2,v0);
+  simd_print4Ints("4i_sub ",v0);
+
+  /*  v0 = v1 * v2  */
+  simd_4i_mult(v1,v2,v0);
+  simd_print4Ints("4i_mult",v0);
+
+  /*  v0 = v1 / v2  */
+  simd_4i_div(v1,v2,v0);
+  simd_print4Ints("4i_div ",v0);
+  
+
+  return 0;
+}
diff --git a/release/src/router/skipdbv2/basekit/simd_cph/test/test_simd_emu b/release/src/router/skipdbv2/basekit/simd_cph/test/test_simd_emu
new file mode 100644
index 0000000000000000000000000000000000000000..cff73755c852303ae8a5806fbf478eda1a969fb2
GIT binary patch
literal 16756
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
J`w6c+`foS9!{z`0

literal 0
HcmV?d00001

diff --git a/release/src/router/skipdbv2/client/skbus.c b/release/src/router/skipdbv2/client/skbus.c
new file mode 100644
index 0000000000..d539a43e41
--- /dev/null
+++ b/release/src/router/skipdbv2/client/skbus.c
@@ -0,0 +1,167 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h> // fcntl
+#include <unistd.h> // close
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <ev.h>
+
+#define MAGIC "magicv1 "
+#define MAGIC_LEN 8
+#define HEADER_LEN 8
+#define HEADER_PREFIX (MAGIC_LEN + HEADER_LEN)
+
+// TODO
+// disconnect and reconnect on each newline
+
+// Nasty globals for now
+// feel free to fork this example and clean it up
+EV_P;
+ev_io stdin_watcher;
+ev_io remote_w;
+ev_io send_w;
+int remote_fd;
+char* line = NULL;
+size_t len = 0;
+
+static void send_cb (EV_P_ ev_io *w, int revents)
+{
+  char *p;
+
+  if (revents & EV_WRITE)
+  {
+    puts ("remote ready for writing...");
+
+    p = malloc(HEADER_PREFIX + len + 1);
+    sprintf(p, "%s%07d %s", MAGIC, len, line);
+    puts(p);
+    if (-1 == send(remote_fd, p, len + HEADER_PREFIX, 0)) {
+      perror("echo send");
+      exit(EXIT_FAILURE);
+    }
+    free(p);
+
+    // once the data is sent, stop notifications that
+    // data can be sent until there is actually more
+    // data to send
+    ev_io_stop(EV_A_ &send_w);
+    ev_io_set(&send_w, remote_fd, EV_READ);
+    ev_io_start(EV_A_ &send_w);
+  }
+  else if (revents & EV_READ)
+  {
+    int n;
+    char str[100] = ".\0";
+
+    printf("[r,remote]");
+    n = recv(remote_fd, str, 100, 0);
+    if (n <= 0) {
+      if (0 == n) {
+        // an orderly disconnect
+        puts("orderly disconnect");
+        ev_io_stop(EV_A_ &send_w);
+        close(remote_fd);
+      }  else if (EAGAIN == errno) {
+        puts("should never get in this state with libev");
+      } else {
+        perror("recv");
+      }
+      return;
+    }
+    printf("socket client said: %s", str);
+
+  }
+}
+
+static void stdin_cb (EV_P_ ev_io *w, int revents)
+{
+  int len2; // not sure if this is at all useful
+
+  puts ("stdin written to, reading...");
+  len2 = getline(&line, &len, stdin);
+  len = len2;
+  //fprintf(stderr, "line=%s len2=%d len=%d\n", line, len2, len);
+  ev_io_stop(EV_A_ &send_w);
+  ev_io_set (&send_w, remote_fd, EV_READ | EV_WRITE);
+  ev_io_start(EV_A_ &send_w);
+}
+
+static void remote_cb (EV_P_ ev_io *w, int revents)
+{
+  puts ("connected, now watching stdin");
+  // Once the connection is established, listen to stdin
+  ev_io_start(EV_A_ &stdin_watcher);
+  // Once we're connected, that's the end of that
+  ev_io_stop(EV_A_ &remote_w);
+}
+
+
+// Simply adds O_NONBLOCK to the file descriptor of choice
+int setnonblock(int fd)
+{
+  int flags;
+
+  flags = fcntl(fd, F_GETFL);
+  flags |= O_NONBLOCK;
+  return fcntl(fd, F_SETFL, flags);
+}
+
+static void connection_new(EV_P_ char* sock_path) {
+  int len, opt = 0;
+  struct sockaddr_un remote;
+
+  if (-1 == (remote_fd = socket(AF_UNIX, SOCK_STREAM, 0))) {
+      perror("socket");
+      exit(1);
+  }
+
+  //setsockopt(remote_fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+
+  // Set it non-blocking
+  if (-1 == setnonblock(remote_fd)) {
+    perror("echo client socket nonblock");
+    exit(EXIT_FAILURE);
+  }
+
+  // this should be initialized before the connect() so
+  // that no packets are dropped when initially sent?
+  // http://cr.yp.to/docs/connect.html
+
+  // initialize the connect callback so that it starts the stdin asap
+  ev_io_init (&remote_w, remote_cb, remote_fd, EV_WRITE);
+  ev_io_start(EV_A_ &remote_w);
+  // initialize the send callback, but wait to start until there is data to write
+  ev_io_init(&send_w, send_cb, remote_fd, EV_READ);
+  ev_io_start(EV_A_ &send_w);
+
+  remote.sun_family = AF_UNIX;
+  strcpy(remote.sun_path, sock_path);
+  len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+
+  if (-1 == connect(remote_fd, (struct sockaddr *)&remote, len)) {
+      perror("connect");
+      //exit(1);
+  }
+}
+
+int main (void)
+{
+  loop = EV_DEFAULT;
+  // initialise an io watcher, then start it
+  // this one will watch for stdin to become readable
+  setnonblock(0);
+  ev_io_init(&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
+
+  connection_new(EV_A_ "/tmp/.skipd_server_sock");
+
+  // now wait for events to arrive
+  ev_loop(EV_A_ 0);
+
+  // unloop was called, so exit
+  return 0;
+}
diff --git a/release/src/router/skipdbv2/debug.txt b/release/src/router/skipdbv2/debug.txt
new file mode 100644
index 0000000000..e6a63edda6
--- /dev/null
+++ b/release/src/router/skipdbv2/debug.txt
@@ -0,0 +1,2 @@
+set args -d ./db/a
+b main
diff --git a/release/src/router/skipdbv2/jfile/JFile.c b/release/src/router/skipdbv2/jfile/JFile.c
new file mode 100644
index 0000000000..abe106b181
--- /dev/null
+++ b/release/src/router/skipdbv2/jfile/JFile.c
@@ -0,0 +1,529 @@
+/*#io
+JFile ioDoc(
+		  docCopyright("Steve Dekorte", 2004)
+		  docLicense("BSD revised")
+		  docObject("JFile")
+		  docDescription("A journaled file.")
+		  log file is currently endian dependent
+*/
+
+#include "JFile.h"
+#include "Common.h"	// for Win32 snprintf
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include "PortableTruncate.h"
+
+// See: http://lists.apple.com/archives/darwin-dev/2005/Feb/msg00072.html
+
+#include <fcntl.h>
+
+#define JFILE_END_TRANSACTION_ITEM 1
+#define JFILE_END_TRANSACTION 2
+
+void JFile_clipLog(JFile *self);
+void JFile_writeLogToFile(JFile *self);
+void JFile_flushLog(JFile *self);
+void JFile_flushFile(JFile *self);
+
+JFile *JFile_new(void)
+{
+	JFile *self = (JFile *)calloc(1, sizeof(JFile));
+	//JFile_setPath_(self, "default");
+	JFile_setJournalingOn_(self, 1);
+	self->logHighWaterMark = 1024*1024*8;
+	self->fullSync = 1;
+	return self;
+}
+
+void JFile_setJournalingOn_(JFile *self, int aBool)
+{
+	self->journalingOn = aBool;
+}
+
+void JFile_free(JFile *self)
+{
+	JFile_close(self);
+	if (self->path) free(self->path);
+	if (self->logPath) free(self->logPath);
+	if (self->buf) free(self->buf);
+	free(self);
+}
+
+void JFile_setPath_(JFile *self, const char *path)
+{
+	self->path    = strcpy((char *)realloc(self->path,    strlen(path)+1), path);
+	self->logPath = strcpy((char *)realloc(self->logPath, strlen(path)+5), path);
+	strcat(self->logPath,  ".log");
+}
+
+char *JFile_fileName(JFile *self)
+{
+#ifdef __WIN32__
+	char *fileName = strrchr(self->path, '\\');
+#else
+	char *fileName = strrchr(self->path, '/');
+#endif
+	return  fileName ? fileName : self->path;
+}
+
+void JFile_setLogPath_(JFile *self, const char *path)
+{
+	char *fileName = JFile_fileName(self);
+	self->logPath = strcpy((char *)realloc(self->logPath, strlen(path) + strlen(fileName)+10), path);
+	if (self->logPath[strlen(self->logPath)-1] != '/') strcat(self->logPath, "/");
+	strcat(self->logPath, fileName);
+	strcat(self->logPath,  ".log");
+}
+
+void JFile_setPath_withExtension_(JFile *self, const char *path, const char *ext)
+{
+	size_t length = strlen(path) + 1 + strlen(ext) + 1;
+	char *s = (char *)calloc(1, length);
+	strcat(s, path);
+	strcat(s, ".");
+	strcat(s, ext);
+	JFile_setPath_(self, s);
+	free(s);
+}
+
+char *JFile_path(JFile *self)
+{
+	return self->path;
+}
+
+void JFile_remove(JFile *self)
+{
+	JFile_close(self);
+	remove(self->path);
+	remove(self->logPath);
+}
+
+void JFile_open(JFile *self)
+{
+	self->file = fopen(self->path, "r+");
+
+	if (!self->file)
+	{
+		// if it doesn't exist, create file
+		self->file = fopen(self->path, "w");
+		fclose(self->file);
+		self->file = fopen(self->path, "r+");
+	}
+
+	self->pos = 0;
+	fseek(self->file, 0, SEEK_END);
+	self->maxPos = ftell(self->file);
+
+	self->log = fopen(self->logPath, "r+");
+
+	if (!self->log)
+	{
+		// if log doesn't exist, create it
+		self->log = fopen(self->logPath, "w");
+		fclose(self->log);
+		self->log = fopen(self->logPath, "r+");
+		#ifdef F_PREALLOCATE
+			// OSX
+			fcntl(fileno(self->log), F_PREALLOCATE, self->logHighWaterMark);
+		#else
+			// FIXME by jannson Linux
+			//posix_fallocate(fileno(self->log), -1, self->logHighWaterMark);
+		#endif
+	}
+	else
+	{
+		// if log exists, write any completed transactions to file
+		JFile_clipLogToLastCompletedTransaction(self);
+		JFile_writeLogToFile(self);
+	}
+}
+
+void JFile_close(JFile *self)
+{
+	if (self->file)
+	{
+		fclose(self->file);
+		self->file = NULL;
+	}
+
+	if (self->log)
+	{
+		fclose(self->log);
+		self->log = NULL;
+	}
+}
+
+void JFile_delete(JFile *self)
+{
+	JFile_close(self);
+	remove(self->path);
+	remove(self->logPath);
+}
+
+size_t JFile_fwrite(JFile *self, void *buf, size_t size, size_t nobjs)
+{
+	size_t total = size * nobjs;
+	size_t nobjsWritten;
+
+	if (self->journalingOn)
+	{
+		fwrite(&(self->pos), sizeof(long), 1, self->log);
+		fwrite(&total, sizeof(size_t), 1, self->log);
+		nobjsWritten = fwrite(buf, size, nobjs, self->log);
+		fputc(JFILE_END_TRANSACTION_ITEM, self->log); // commit byte
+		self->pos += total;
+	}
+	else
+	{
+		fseek(self->file, self->pos, SEEK_SET);
+		nobjsWritten = fwrite(buf, size, nobjs, self->file);
+		self->pos = ftell(self->file);
+	}
+
+	if (nobjs != nobjsWritten)
+	{
+		printf("Error: JFile_fwrite nobjs != nobjsWritten\n");
+	}
+
+	if (self->pos > self->maxPos) self->maxPos = self->pos;
+
+	return nobjsWritten;
+}
+
+size_t JFile_fread(JFile *self, void *buf, size_t size, size_t nobjs)
+{
+	size_t nobjsRead;
+
+	fseek(self->file, self->pos, SEEK_SET);
+	nobjsRead = fread(buf, size, nobjs, self->file);
+	self->pos = ftell(self->file);
+
+	return nobjsRead;
+}
+
+int JFile_fputc(JFile *self, int i)
+{
+	unsigned char c = i;
+	JFile_fwrite(self, &c, 1, 1);
+	return i;
+}
+
+int JFile_fgetc(JFile *self)
+{
+	char *v;
+	JFile_fread(self, &v, 1, 1);
+	return (int)v;
+}
+
+void JFile_writeInt_(JFile *self, int v)
+{
+	JFile_fwrite(self, &v, sizeof(int), 1);
+}
+
+int JFile_readInt(JFile *self)
+{
+	int v;
+	JFile_fread(self, &v, sizeof(int), 1);
+	return v;
+}
+
+void JFile_setPosition_(JFile *self, long pos)
+{
+	self->pos = pos;
+}
+
+void JFile_fseek(JFile *self, long offset, int whence)
+{
+	switch (whence)
+	{
+		case SEEK_CUR:
+			self->pos += offset;
+			break;
+		case SEEK_SET:
+			self->pos = offset;
+			break;
+		case SEEK_END:
+			self->pos = self->maxPos + offset;
+			break;
+	}
+}
+
+long JFile_position(JFile *self)
+{
+	return self->pos;
+}
+
+long JFile_setPositionToEnd(JFile *self)
+{
+	self->pos = self->maxPos;
+	return self->pos;
+}
+
+void JFile_hardSyncFileDescriptor_(JFile *self, int fd)
+{
+	#ifdef F_FULLFSYNC
+		fcntl(fd, F_FULLFSYNC, NULL);
+	#else
+		#warning Linux cant ensure data sync to physical media
+		fsync(fd);
+	#endif
+}
+
+void JFile_syncFileWritesToDisk(JFile *self)
+{
+	//printf("f"); fflush(stdout);
+	fflush(self->file);
+
+	if(self->fullSync)
+	{
+		JFile_hardSyncFileDescriptor_(self, fileno(self->file));
+	}
+}
+
+void JFile_syncLogWritesToDisk(JFile *self)
+{
+	//printf("j"); fflush(stdout);
+	fflush(self->log);
+	if (self->fullSync)
+	{
+			JFile_hardSyncFileDescriptor_(self, fileno(self->log));
+	}
+
+	fseek(self->log, -1, SEEK_END);
+
+	fputc(JFILE_END_TRANSACTION, self->log);
+
+	fflush(self->log);
+	if (self->fullSync)
+	{
+			JFile_hardSyncFileDescriptor_(self, fileno(self->log));
+	}
+}
+
+void JFile_writeLogToFileIfNeeded(JFile *self)
+{
+	if (ftell(self->log))
+	{
+		JFile_writeLogToFile(self);
+	}
+}
+
+void JFile_writeLogToFile(JFile *self)
+{
+	size_t writeCount = 0;
+	int logNotEmpty = 0;
+	int lastTerminator = 0;
+	fseek(self->log, 0, SEEK_SET);
+
+	while (1)
+	{
+		long pos;
+		size_t total;
+
+		if (fread(&pos, sizeof(long), 1, self->log) != 1)
+		{
+			if (feof(self->log)) break;
+			printf("JFile: error reading pos\n");
+			goto fatalError;
+		}
+
+		if (fread(&total, sizeof(size_t), 1, self->log) != 1)
+		{
+			printf("JFile: error reading total\n");
+			goto fatalError;
+		}
+
+                //by janson, TODO better
+                if (0 == total) {
+                    return;
+                }
+
+		self->buf = realloc(self->buf, total);
+
+		if (fread(self->buf, total, 1, self->log) != 1)
+		{
+			printf("JFile: error reading buf %d\n", total);
+			goto fatalError;
+		}
+
+		lastTerminator = fgetc(self->log);
+
+		if (lastTerminator != JFILE_END_TRANSACTION_ITEM &&
+			lastTerminator != JFILE_END_TRANSACTION)
+		{
+			printf("JFile: invalid log terminator\n");
+			goto fatalError;
+		}
+
+		fseek(self->file, pos, SEEK_SET);
+		fwrite(self->buf, total, 1, self->file);
+		writeCount ++;
+		logNotEmpty = 1;
+	}
+
+	if (logNotEmpty)
+	{
+		//printf("writing log\n");
+		JFile_syncFileWritesToDisk(self);
+		JFile_clipLog(self);
+	}
+
+	return;
+
+	fatalError:
+		printf("JFile: FATAL ERROR: invalid log file '%s' - may result in inconsistency\n", self->logPath);
+
+}
+
+
+void JFile_begin(JFile *self)
+{
+	// begin is implicit unless we need to mark a rollback point
+}
+
+void JFile_commitToFile(JFile *self)
+{
+	JFile_commitToLog(self);
+	/*
+	if (!JFile_verifyLog(self))
+	{
+		printf("log '%s' not valid\n", self->logPath);
+		exit(-1);
+	}
+	*/
+	JFile_writeLogToFile(self);
+}
+
+void JFile_commitToLog(JFile *self)
+{
+	if (self->journalingOn)
+	{
+		if (ftell(self->log))
+		{
+			JFile_syncLogWritesToDisk(self);
+		}
+	}
+	else
+	{
+		JFile_syncFileWritesToDisk(self);
+	}
+}
+
+#include <unistd.h>
+
+void JFile_clipLog(JFile *self)
+{
+	if (!self->log)
+	{
+		self->log = fopen(self->logPath, "r+");
+
+		if (self->log)
+		{
+			ftruncate(fileno(self->log), 0);
+			fseek(self->log, 0, SEEK_SET);
+		}
+	}
+	else
+	{
+		ftruncate(fileno(self->log), 0);
+		fseek(self->log, 0, SEEK_SET);
+	}
+}
+
+void JFile_truncate_(JFile *self, off_t size)
+{
+	JFile_commitToLog(self);
+	JFile_commitToFile(self);
+	ftruncate(fileno(self->file), size);
+}
+
+int JFile_needsSync(JFile *self)
+{
+	return JFile_logSize(self) != 0;
+}
+
+size_t JFile_logSize(JFile *self)
+{
+	// this only valid when not in the middle of a commit
+	return ftell(self->log);
+}
+
+long JFile_lastCommitPosition(JFile *self)
+{
+	long lastCommitPosition = 0;
+	long end;
+	fseek(self->log, 0, SEEK_END);
+	end = ftell(self->log);
+	fseek(self->log, 0, SEEK_SET);
+
+	while (1)
+	{
+		long pos;
+		size_t total;
+		int r;
+
+		r = fread(&pos, sizeof(long), 1, self->log);
+		if (r != 1)
+		{
+			if (feof(self->log)) break;
+
+			//printf("log broken at pos");
+			break;
+		}
+
+		r = fread(&total, sizeof(size_t), 1, self->log);
+		if (r != 1)
+		{
+			//printf("log broken at size");
+			break;
+		}
+
+		if(fseek(self->log, total, SEEK_CUR) != 0)
+		{
+			//printf("log broken at data");
+			break;
+		}
+
+		switch (fgetc(self->log))
+		{
+			case JFILE_END_TRANSACTION_ITEM:
+				//printf("JFILE_END_TRANSACTION_ITEM at %i\n", ftell(self->log));
+				continue;
+			case JFILE_END_TRANSACTION:
+				//printf("JFILE_END_TRANSACTION at %i\n", ftell(self->log));
+				lastCommitPosition = ftell(self->log);
+				continue;
+			default:
+				break;
+		}
+	}
+
+	fseek(self->log, 0, SEEK_END);
+	return lastCommitPosition;
+}
+
+int JFile_verifyLog(JFile *self)
+{
+	long lastCommitPosition = JFile_lastCommitPosition(self);
+
+	fseek(self->log, 0, SEEK_END);
+
+	return lastCommitPosition == ftell(self->log);
+}
+
+void JFile_clipLogToLastCompletedTransaction(JFile *self)
+{
+	long lastCommitPosition = JFile_lastCommitPosition(self);
+
+	fseek(self->log, 0, SEEK_END);
+
+	if (lastCommitPosition != ftell(self->log))
+	{
+		printf("JFile: incomplete transaction found in '%s' - discarding\n", self->logPath);
+		ftruncate(fileno(self->log), lastCommitPosition);
+		fseek(self->log, 0, SEEK_END);
+	}
+}
+
diff --git a/release/src/router/skipdbv2/jfile/JFile.h b/release/src/router/skipdbv2/jfile/JFile.h
new file mode 100644
index 0000000000..b20f4cdaf4
--- /dev/null
+++ b/release/src/router/skipdbv2/jfile/JFile.h
@@ -0,0 +1,105 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("JFile")    
+docDescription("""
+  JFile - a journaled file
+ 
+  How it works:
+    1. writes are made to a log file (file.log) 
+    2. when commit is called, a JFILE_COMMITTED value and the length of the log is written to the log header
+       2.1 then the log writes are performed on output file 
+       2.2 then log file header is set to JFILE_UNCOMMITTED
+    3. when JFile is opened, if it finds:
+       3.1 JFILE_UNCOMMITTED set in the log header
+          it assumes the log is incomplete and overwrites it
+       3.2 JFILE_COMMITTED set in the log header
+          it goes to step 2.1
+	  
+  In this way, the output file is assured to be kept in a consistent state.
+""")
+*/
+
+#ifndef JFILE_DEFINED
+#define JFILE_DEFINED 1
+
+#include <stdio.h>
+#include <sys/types.h> 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+// expiremental
+#define JFILE_SUPPORTS_MMAP 1
+*/
+
+#define JFILE_UNCOMMITTED 0
+#define JFILE_COMMITTED   1
+
+typedef struct
+{    
+    char *path;
+    FILE *file;
+
+    char *logPath;
+    FILE *log;
+	
+	long pos;
+	long maxPos;
+ 
+    unsigned char *buf;
+	int journalingOn;
+	int fullSync;
+	size_t logHighWaterMark;
+} JFile;
+
+JFile *JFile_new(void);
+void JFile_free(JFile *self);
+
+void JFile_setJournalingOn_(JFile *self, int aBool);
+
+void JFile_setPath_(JFile *self, const char *path);
+void JFile_setLogPath_(JFile *self, const char *path);
+void JFile_setPath_withExtension_(JFile *self, const char *path, const char *ext);
+char *JFile_path(JFile *self);
+
+void JFile_open(JFile *self);
+void JFile_close(JFile *self);
+void JFile_delete(JFile *self);
+
+size_t JFile_fwrite(JFile *self, void *buf, size_t size, size_t nobjs);
+size_t JFile_fread(JFile *self, void *buf, size_t size, size_t nobjs);
+
+int JFile_fputc(JFile *self, int c);
+int JFile_fgetc(JFile *self);
+
+void JFile_writeInt_(JFile *self, int v);
+int JFile_readInt(JFile *self);
+
+void JFile_setPosition_(JFile *self, long pos);
+long JFile_setPositionToEnd(JFile *self);
+void JFile_fseek(JFile *self, long offset, int whence);
+long JFile_position(JFile *self);
+
+void JFile_begin(JFile *self);
+void JFile_commitToLog(JFile *self); // makes sure log is on disk
+void JFile_commitToFile(JFile *self);   // writes log to file and makes sure changes are on disk
+void JFile_remove(JFile *self);
+
+void JFile_truncate_(JFile *self, off_t size);
+
+void JFile_setTrueFlush_(JFile *self, int aBool);
+size_t JFile_logSize(JFile *self);
+int JFile_needsSync(JFile *self);
+long JFile_lastCommitPosition(JFile *self);
+void JFile_clipLogToLastCompletedTransaction(JFile *self);
+void JFile_clipLog(JFile *self);
+//int JFile_hasUnfinishedCommits(JFile *self);
+int JFile_verifyLog(JFile *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/libev/ev++.h b/release/src/router/skipdbv2/libev/ev++.h
new file mode 100644
index 0000000000..4f0a36ab02
--- /dev/null
+++ b/release/src/router/skipdbv2/libev/ev++.h
@@ -0,0 +1,816 @@
+/*
+ * libev simple C++ wrapper classes
+ *
+ * Copyright (c) 2007,2008,2010 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef EVPP_H__
+#define EVPP_H__
+
+#ifdef EV_H
+# include EV_H
+#else
+# include "ev.h"
+#endif
+
+#ifndef EV_USE_STDEXCEPT
+# define EV_USE_STDEXCEPT 1
+#endif
+
+#if EV_USE_STDEXCEPT
+# include <stdexcept>
+#endif
+
+namespace ev {
+
+  typedef ev_tstamp tstamp;
+
+  enum {
+    UNDEF    = EV_UNDEF,
+    NONE     = EV_NONE,
+    READ     = EV_READ,
+    WRITE    = EV_WRITE,
+#if EV_COMPAT3
+    TIMEOUT  = EV_TIMEOUT,
+#endif
+    TIMER    = EV_TIMER,
+    PERIODIC = EV_PERIODIC,
+    SIGNAL   = EV_SIGNAL,
+    CHILD    = EV_CHILD,
+    STAT     = EV_STAT,
+    IDLE     = EV_IDLE,
+    CHECK    = EV_CHECK,
+    PREPARE  = EV_PREPARE,
+    FORK     = EV_FORK,
+    ASYNC    = EV_ASYNC,
+    EMBED    = EV_EMBED,
+#   undef ERROR // some systems stupidly #define ERROR
+    ERROR    = EV_ERROR
+  };
+
+  enum
+  {
+    AUTO      = EVFLAG_AUTO,
+    NOENV     = EVFLAG_NOENV,
+    FORKCHECK = EVFLAG_FORKCHECK,
+
+    SELECT    = EVBACKEND_SELECT,
+    POLL      = EVBACKEND_POLL,
+    EPOLL     = EVBACKEND_EPOLL,
+    KQUEUE    = EVBACKEND_KQUEUE,
+    DEVPOLL   = EVBACKEND_DEVPOLL,
+    PORT      = EVBACKEND_PORT
+  };
+
+  enum
+  {
+#if EV_COMPAT3
+    NONBLOCK = EVLOOP_NONBLOCK,
+    ONESHOT  = EVLOOP_ONESHOT,
+#endif
+    NOWAIT   = EVRUN_NOWAIT,
+    ONCE     = EVRUN_ONCE
+  };
+
+  enum how_t
+  {
+    ONE = EVBREAK_ONE,
+    ALL = EVBREAK_ALL
+  };
+
+  struct bad_loop
+#if EV_USE_STDEXCEPT
+  : std::runtime_error
+#endif
+  {
+#if EV_USE_STDEXCEPT
+    bad_loop ()
+    : std::runtime_error ("libev event loop cannot be initialized, bad value of LIBEV_FLAGS?")
+    {
+    }
+#endif
+  };
+
+#ifdef EV_AX
+#  undef EV_AX
+#endif
+
+#ifdef EV_AX_
+#  undef EV_AX_
+#endif
+
+#if EV_MULTIPLICITY
+#  define EV_AX  raw_loop
+#  define EV_AX_ raw_loop,
+#else
+#  define EV_AX
+#  define EV_AX_
+#endif
+
+  struct loop_ref
+  {
+    loop_ref (EV_P) throw ()
+#if EV_MULTIPLICITY
+    : EV_AX (EV_A)
+#endif
+    {
+    }
+
+    bool operator == (const loop_ref &other) const throw ()
+    {
+#if EV_MULTIPLICITY
+      return EV_AX == other.EV_AX;
+#else
+      return true;
+#endif
+    }
+
+    bool operator != (const loop_ref &other) const throw ()
+    {
+#if EV_MULTIPLICITY
+      return ! (*this == other);
+#else
+      return false;
+#endif
+    }
+
+#if EV_MULTIPLICITY
+    bool operator == (const EV_P) const throw ()
+    {
+      return this->EV_AX == EV_A;
+    }
+
+    bool operator != (const EV_P) const throw ()
+    {
+      return (*this == EV_A);
+    }
+
+    operator struct ev_loop * () const throw ()
+    {
+      return EV_AX;
+    }
+
+    operator const struct ev_loop * () const throw ()
+    {
+      return EV_AX;
+    }
+
+    bool is_default () const throw ()
+    {
+      return EV_AX == ev_default_loop (0);
+    }
+#endif
+
+#if EV_COMPAT3
+    void loop (int flags = 0)
+    {
+      ev_run (EV_AX_ flags);
+    }
+
+    void unloop (how_t how = ONE) throw ()
+    {
+      ev_break (EV_AX_ how);
+    }
+#endif
+
+    void run (int flags = 0)
+    {
+      ev_run (EV_AX_ flags);
+    }
+
+    void break_loop (how_t how = ONE) throw ()
+    {
+      ev_break (EV_AX_ how);
+    }
+
+    void post_fork () throw ()
+    {
+      ev_loop_fork (EV_AX);
+    }
+
+    unsigned int backend () const throw ()
+    {
+      return ev_backend (EV_AX);
+    }
+
+    tstamp now () const throw ()
+    {
+      return ev_now (EV_AX);
+    }
+
+    void ref () throw ()
+    {
+      ev_ref (EV_AX);
+    }
+
+    void unref () throw ()
+    {
+      ev_unref (EV_AX);
+    }
+
+#if EV_FEATURE_API
+    unsigned int iteration () const throw ()
+    {
+      return ev_iteration (EV_AX);
+    }
+
+    unsigned int depth () const throw ()
+    {
+      return ev_depth (EV_AX);
+    }
+
+    void set_io_collect_interval (tstamp interval) throw ()
+    {
+      ev_set_io_collect_interval (EV_AX_ interval);
+    }
+
+    void set_timeout_collect_interval (tstamp interval) throw ()
+    {
+      ev_set_timeout_collect_interval (EV_AX_ interval);
+    }
+#endif
+
+    // function callback
+    void once (int fd, int events, tstamp timeout, void (*cb)(int, void *), void *arg = 0) throw ()
+    {
+      ev_once (EV_AX_ fd, events, timeout, cb, arg);
+    }
+
+    // method callback
+    template<class K, void (K::*method)(int)>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_thunk<K, method>, object);
+    }
+
+    // default method == operator ()
+    template<class K>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_thunk<K, &K::operator ()>, object);
+    }
+
+    template<class K, void (K::*method)(int)>
+    static void method_thunk (int revents, void *arg)
+    {
+      (static_cast<K *>(arg)->*method)
+        (revents);
+    }
+
+    // no-argument method callback
+    template<class K, void (K::*method)()>
+    void once (int fd, int events, tstamp timeout, K *object) throw ()
+    {
+      once (fd, events, timeout, method_noargs_thunk<K, method>, object);
+    }
+
+    template<class K, void (K::*method)()>
+    static void method_noargs_thunk (int revents, void *arg)
+    {
+      (static_cast<K *>(arg)->*method)
+        ();
+    }
+
+    // simpler function callback
+    template<void (*cb)(int)>
+    void once (int fd, int events, tstamp timeout) throw ()
+    {
+      once (fd, events, timeout, simpler_func_thunk<cb>);
+    }
+
+    template<void (*cb)(int)>
+    static void simpler_func_thunk (int revents, void *arg)
+    {
+      (*cb)
+        (revents);
+    }
+
+    // simplest function callback
+    template<void (*cb)()>
+    void once (int fd, int events, tstamp timeout) throw ()
+    {
+      once (fd, events, timeout, simplest_func_thunk<cb>);
+    }
+
+    template<void (*cb)()>
+    static void simplest_func_thunk (int revents, void *arg)
+    {
+      (*cb)
+        ();
+    }
+
+    void feed_fd_event (int fd, int revents) throw ()
+    {
+      ev_feed_fd_event (EV_AX_ fd, revents);
+    }
+
+    void feed_signal_event (int signum) throw ()
+    {
+      ev_feed_signal_event (EV_AX_ signum);
+    }
+
+#if EV_MULTIPLICITY
+    struct ev_loop* EV_AX;
+#endif
+
+  };
+
+#if EV_MULTIPLICITY
+  struct dynamic_loop : loop_ref
+  {
+
+    dynamic_loop (unsigned int flags = AUTO) throw (bad_loop)
+    : loop_ref (ev_loop_new (flags))
+    {
+      if (!EV_AX)
+        throw bad_loop ();
+    }
+
+    ~dynamic_loop () throw ()
+    {
+      ev_loop_destroy (EV_AX);
+      EV_AX = 0;
+    }
+
+  private:
+
+    dynamic_loop (const dynamic_loop &);
+
+    dynamic_loop & operator= (const dynamic_loop &);
+
+  };
+#endif
+
+  struct default_loop : loop_ref
+  {
+    default_loop (unsigned int flags = AUTO) throw (bad_loop)
+#if EV_MULTIPLICITY
+    : loop_ref (ev_default_loop (flags))
+#endif
+    {
+      if (
+#if EV_MULTIPLICITY
+          !EV_AX
+#else
+          !ev_default_loop (flags)
+#endif
+      )
+        throw bad_loop ();
+    }
+
+  private:
+    default_loop (const default_loop &);
+    default_loop &operator = (const default_loop &);
+  };
+
+  inline loop_ref get_default_loop () throw ()
+  {
+#if EV_MULTIPLICITY
+    return ev_default_loop (0);
+#else
+    return loop_ref ();
+#endif
+  }
+
+#undef EV_AX
+#undef EV_AX_
+
+#undef EV_PX
+#undef EV_PX_
+#if EV_MULTIPLICITY
+#  define EV_PX  loop_ref EV_A
+#  define EV_PX_ loop_ref EV_A_
+#else
+#  define EV_PX
+#  define EV_PX_
+#endif
+
+  template<class ev_watcher, class watcher>
+  struct base : ev_watcher
+  {
+    #if EV_MULTIPLICITY
+      EV_PX;
+
+      // loop set
+      void set (EV_P) throw ()
+      {
+        this->EV_A = EV_A;
+      }
+    #endif
+
+    base (EV_PX) throw ()
+    #if EV_MULTIPLICITY
+      : EV_A (EV_A)
+    #endif
+    {
+      ev_init (this, 0);
+    }
+
+    void set_ (const void *data, void (*cb)(EV_P_ ev_watcher *w, int revents)) throw ()
+    {
+      this->data = (void *)data;
+      ev_set_cb (static_cast<ev_watcher *>(this), cb);
+    }
+
+    // function callback
+    template<void (*function)(watcher &w, int)>
+    void set (void *data = 0) throw ()
+    {
+      set_ (data, function_thunk<function>);
+    }
+
+    template<void (*function)(watcher &w, int)>
+    static void function_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      function
+        (*static_cast<watcher *>(w), revents);
+    }
+
+    // method callback
+    template<class K, void (K::*method)(watcher &w, int)>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_thunk<K, method>);
+    }
+
+    // default method == operator ()
+    template<class K>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_thunk<K, &K::operator ()>);
+    }
+
+    template<class K, void (K::*method)(watcher &w, int)>
+    static void method_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      (static_cast<K *>(w->data)->*method)
+        (*static_cast<watcher *>(w), revents);
+    }
+
+    // no-argument callback
+    template<class K, void (K::*method)()>
+    void set (K *object) throw ()
+    {
+      set_ (object, method_noargs_thunk<K, method>);
+    }
+
+    template<class K, void (K::*method)()>
+    static void method_noargs_thunk (EV_P_ ev_watcher *w, int revents)
+    {
+      (static_cast<K *>(w->data)->*method)
+        ();
+    }
+
+    void operator ()(int events = EV_UNDEF)
+    {
+      return
+        ev_cb (static_cast<ev_watcher *>(this))
+          (static_cast<ev_watcher *>(this), events);
+    }
+
+    bool is_active () const throw ()
+    {
+      return ev_is_active (static_cast<const ev_watcher *>(this));
+    }
+
+    bool is_pending () const throw ()
+    {
+      return ev_is_pending (static_cast<const ev_watcher *>(this));
+    }
+
+    void feed_event (int revents) throw ()
+    {
+      ev_feed_event (EV_A_ static_cast<ev_watcher *>(this), revents);
+    }
+  };
+
+  inline tstamp now (EV_P) throw ()
+  {
+    return ev_now (EV_A);
+  }
+
+  inline void delay (tstamp interval) throw ()
+  {
+    ev_sleep (interval);
+  }
+
+  inline int version_major () throw ()
+  {
+    return ev_version_major ();
+  }
+
+  inline int version_minor () throw ()
+  {
+    return ev_version_minor ();
+  }
+
+  inline unsigned int supported_backends () throw ()
+  {
+    return ev_supported_backends ();
+  }
+
+  inline unsigned int recommended_backends () throw ()
+  {
+    return ev_recommended_backends ();
+  }
+
+  inline unsigned int embeddable_backends () throw ()
+  {
+    return ev_embeddable_backends ();
+  }
+
+  inline void set_allocator (void *(*cb)(void *ptr, long size) throw ()) throw ()
+  {
+    ev_set_allocator (cb);
+  }
+
+  inline void set_syserr_cb (void (*cb)(const char *msg) throw ()) throw ()
+  {
+    ev_set_syserr_cb (cb);
+  }
+
+  #if EV_MULTIPLICITY
+    #define EV_CONSTRUCT(cppstem,cstem)	                                                \
+      (EV_PX = get_default_loop ()) throw ()                                            \
+        : base<ev_ ## cstem, cppstem> (EV_A)                                            \
+      {                                                                                 \
+      }
+  #else
+    #define EV_CONSTRUCT(cppstem,cstem)                                                 \
+      () throw ()                                                                       \
+      {                                                                                 \
+      }
+  #endif
+
+  /* using a template here would require quite a few more lines,
+   * so a macro solution was chosen */
+  #define EV_BEGIN_WATCHER(cppstem,cstem)	                                        \
+                                                                                        \
+  struct cppstem : base<ev_ ## cstem, cppstem>                                          \
+  {                                                                                     \
+    void start () throw ()                                                              \
+    {                                                                                   \
+      ev_ ## cstem ## _start (EV_A_ static_cast<ev_ ## cstem *>(this));                 \
+    }                                                                                   \
+                                                                                        \
+    void stop () throw ()                                                               \
+    {                                                                                   \
+      ev_ ## cstem ## _stop (EV_A_ static_cast<ev_ ## cstem *>(this));                  \
+    }                                                                                   \
+                                                                                        \
+    cppstem EV_CONSTRUCT(cppstem,cstem)                                                 \
+                                                                                        \
+    ~cppstem () throw ()                                                                \
+    {                                                                                   \
+      stop ();                                                                          \
+    }                                                                                   \
+                                                                                        \
+    using base<ev_ ## cstem, cppstem>::set;                                             \
+                                                                                        \
+  private:                                                                              \
+                                                                                        \
+    cppstem (const cppstem &o);                                                         \
+                                                                                        \
+    cppstem &operator =(const cppstem &o);                                              \
+                                                                                        \
+  public:
+
+  #define EV_END_WATCHER(cppstem,cstem)	                                                \
+  };
+
+  EV_BEGIN_WATCHER (io, io)
+    void set (int fd, int events) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_io_set (static_cast<ev_io *>(this), fd, events);
+      if (active) start ();
+    }
+
+    void set (int events) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_io_set (static_cast<ev_io *>(this), fd, events);
+      if (active) start ();
+    }
+
+    void start (int fd, int events) throw ()
+    {
+      set (fd, events);
+      start ();
+    }
+  EV_END_WATCHER (io, io)
+
+  EV_BEGIN_WATCHER (timer, timer)
+    void set (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_timer_set (static_cast<ev_timer *>(this), after, repeat);
+      if (active) start ();
+    }
+
+    void start (ev_tstamp after, ev_tstamp repeat = 0.) throw ()
+    {
+      set (after, repeat);
+      start ();
+    }
+
+    void again () throw ()
+    {
+      ev_timer_again (EV_A_ static_cast<ev_timer *>(this));
+    }
+
+    ev_tstamp remaining ()
+    {
+      return ev_timer_remaining (EV_A_ static_cast<ev_timer *>(this));
+    }
+  EV_END_WATCHER (timer, timer)
+
+  #if EV_PERIODIC_ENABLE
+  EV_BEGIN_WATCHER (periodic, periodic)
+    void set (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_periodic_set (static_cast<ev_periodic *>(this), at, interval, 0);
+      if (active) start ();
+    }
+
+    void start (ev_tstamp at, ev_tstamp interval = 0.) throw ()
+    {
+      set (at, interval);
+      start ();
+    }
+
+    void again () throw ()
+    {
+      ev_periodic_again (EV_A_ static_cast<ev_periodic *>(this));
+    }
+  EV_END_WATCHER (periodic, periodic)
+  #endif
+
+  #if EV_SIGNAL_ENABLE
+  EV_BEGIN_WATCHER (sig, signal)
+    void set (int signum) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_signal_set (static_cast<ev_signal *>(this), signum);
+      if (active) start ();
+    }
+
+    void start (int signum) throw ()
+    {
+      set (signum);
+      start ();
+    }
+  EV_END_WATCHER (sig, signal)
+  #endif
+
+  #if EV_CHILD_ENABLE
+  EV_BEGIN_WATCHER (child, child)
+    void set (int pid, int trace = 0) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_child_set (static_cast<ev_child *>(this), pid, trace);
+      if (active) start ();
+    }
+
+    void start (int pid, int trace = 0) throw ()
+    {
+      set (pid, trace);
+      start ();
+    }
+  EV_END_WATCHER (child, child)
+  #endif
+
+  #if EV_STAT_ENABLE
+  EV_BEGIN_WATCHER (stat, stat)
+    void set (const char *path, ev_tstamp interval = 0.) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_stat_set (static_cast<ev_stat *>(this), path, interval);
+      if (active) start ();
+    }
+
+    void start (const char *path, ev_tstamp interval = 0.) throw ()
+    {
+      stop ();
+      set (path, interval);
+      start ();
+    }
+
+    void update () throw ()
+    {
+      ev_stat_stat (EV_A_ static_cast<ev_stat *>(this));
+    }
+  EV_END_WATCHER (stat, stat)
+  #endif
+
+  #if EV_IDLE_ENABLE
+  EV_BEGIN_WATCHER (idle, idle)
+    void set () throw () { }
+  EV_END_WATCHER (idle, idle)
+  #endif
+
+  #if EV_PREPARE_ENABLE
+  EV_BEGIN_WATCHER (prepare, prepare)
+    void set () throw () { }
+  EV_END_WATCHER (prepare, prepare)
+  #endif
+
+  #if EV_CHECK_ENABLE
+  EV_BEGIN_WATCHER (check, check)
+    void set () throw () { }
+  EV_END_WATCHER (check, check)
+  #endif
+
+  #if EV_EMBED_ENABLE
+  EV_BEGIN_WATCHER (embed, embed)
+    void set_embed (struct ev_loop *embedded_loop) throw ()
+    {
+      int active = is_active ();
+      if (active) stop ();
+      ev_embed_set (static_cast<ev_embed *>(this), embedded_loop);
+      if (active) start ();
+    }
+
+    void start (struct ev_loop *embedded_loop) throw ()
+    {
+      set (embedded_loop);
+      start ();
+    }
+
+    void sweep ()
+    {
+      ev_embed_sweep (EV_A_ static_cast<ev_embed *>(this));
+    }
+  EV_END_WATCHER (embed, embed)
+  #endif
+
+  #if EV_FORK_ENABLE
+  EV_BEGIN_WATCHER (fork, fork)
+    void set () throw () { }
+  EV_END_WATCHER (fork, fork)
+  #endif
+
+  #if EV_ASYNC_ENABLE
+  EV_BEGIN_WATCHER (async, async)
+    void send () throw ()
+    {
+      ev_async_send (EV_A_ static_cast<ev_async *>(this));
+    }
+
+    bool async_pending () throw ()
+    {
+      return ev_async_pending (static_cast<ev_async *>(this));
+    }
+  EV_END_WATCHER (async, async)
+  #endif
+
+  #undef EV_PX
+  #undef EV_PX_
+  #undef EV_CONSTRUCT
+  #undef EV_BEGIN_WATCHER
+  #undef EV_END_WATCHER
+}
+
+#endif
+
diff --git a/release/src/router/skipdbv2/libev/ev.h b/release/src/router/skipdbv2/libev/ev.h
new file mode 100644
index 0000000000..38f62d82ef
--- /dev/null
+++ b/release/src/router/skipdbv2/libev/ev.h
@@ -0,0 +1,854 @@
+/*
+ * libev native API header
+ *
+ * Copyright (c) 2007,2008,2009,2010,2011,2012,2015 Marc Alexander Lehmann <libev@schmorp.de>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modifica-
+ * tion, are permitted provided that the following conditions are met:
+ *
+ *   1.  Redistributions of source code must retain the above copyright notice,
+ *       this list of conditions and the following disclaimer.
+ *
+ *   2.  Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MER-
+ * CHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPE-
+ * CIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTH-
+ * ERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * the GNU General Public License ("GPL") version 2 or any later version,
+ * in which case the provisions of the GPL are applicable instead of
+ * the above. If you wish to allow the use of your version of this file
+ * only under the terms of the GPL and not to allow others to use your
+ * version of this file under the BSD license, indicate your decision
+ * by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL. If you do not delete the
+ * provisions above, a recipient may use your version of this file under
+ * either the BSD or the GPL.
+ */
+
+#ifndef EV_H_
+#define EV_H_
+
+#ifdef __cplusplus
+# define EV_CPP(x) x
+# if __cplusplus >= 201103L
+#  define EV_THROW noexcept
+# else
+#  define EV_THROW throw ()
+# endif
+#else
+# define EV_CPP(x)
+# define EV_THROW
+#endif
+
+EV_CPP(extern "C" {)
+
+/*****************************************************************************/
+
+/* pre-4.0 compatibility */
+#ifndef EV_COMPAT3
+# define EV_COMPAT3 1
+#endif
+
+#ifndef EV_FEATURES
+# if defined __OPTIMIZE_SIZE__
+#  define EV_FEATURES 0x7c
+# else
+#  define EV_FEATURES 0x7f
+# endif
+#endif
+
+#define EV_FEATURE_CODE     ((EV_FEATURES) &  1)
+#define EV_FEATURE_DATA     ((EV_FEATURES) &  2)
+#define EV_FEATURE_CONFIG   ((EV_FEATURES) &  4)
+#define EV_FEATURE_API      ((EV_FEATURES) &  8)
+#define EV_FEATURE_WATCHERS ((EV_FEATURES) & 16)
+#define EV_FEATURE_BACKENDS ((EV_FEATURES) & 32)
+#define EV_FEATURE_OS       ((EV_FEATURES) & 64)
+
+/* these priorities are inclusive, higher priorities will be invoked earlier */
+#ifndef EV_MINPRI
+# define EV_MINPRI (EV_FEATURE_CONFIG ? -2 : 0)
+#endif
+#ifndef EV_MAXPRI
+# define EV_MAXPRI (EV_FEATURE_CONFIG ? +2 : 0)
+#endif
+
+#ifndef EV_MULTIPLICITY
+# define EV_MULTIPLICITY EV_FEATURE_CONFIG
+#endif
+
+#ifndef EV_PERIODIC_ENABLE
+# define EV_PERIODIC_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_STAT_ENABLE
+# define EV_STAT_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_PREPARE_ENABLE
+# define EV_PREPARE_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CHECK_ENABLE
+# define EV_CHECK_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_IDLE_ENABLE
+# define EV_IDLE_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_FORK_ENABLE
+# define EV_FORK_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CLEANUP_ENABLE
+# define EV_CLEANUP_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_SIGNAL_ENABLE
+# define EV_SIGNAL_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_CHILD_ENABLE
+# ifdef _WIN32
+#  define EV_CHILD_ENABLE 0
+# else
+#  define EV_CHILD_ENABLE EV_FEATURE_WATCHERS
+#endif
+#endif
+
+#ifndef EV_ASYNC_ENABLE
+# define EV_ASYNC_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_EMBED_ENABLE
+# define EV_EMBED_ENABLE EV_FEATURE_WATCHERS
+#endif
+
+#ifndef EV_WALK_ENABLE
+# define EV_WALK_ENABLE 0 /* not yet */
+#endif
+
+/*****************************************************************************/
+
+#if EV_CHILD_ENABLE && !EV_SIGNAL_ENABLE
+# undef EV_SIGNAL_ENABLE
+# define EV_SIGNAL_ENABLE 1
+#endif
+
+/*****************************************************************************/
+
+typedef double ev_tstamp;
+
+#include <string.h> /* for memmove */
+
+#ifndef EV_ATOMIC_T
+# include <signal.h>
+# define EV_ATOMIC_T sig_atomic_t volatile
+#endif
+
+#if EV_STAT_ENABLE
+# ifdef _WIN32
+#  include <time.h>
+#  include <sys/types.h>
+# endif
+# include <sys/stat.h>
+#endif
+
+/* support multiple event loops? */
+#if EV_MULTIPLICITY
+struct ev_loop;
+# define EV_P  struct ev_loop *loop               /* a loop as sole parameter in a declaration */
+# define EV_P_ EV_P,                              /* a loop as first of multiple parameters */
+# define EV_A  loop                               /* a loop as sole argument to a function call */
+# define EV_A_ EV_A,                              /* a loop as first of multiple arguments */
+# define EV_DEFAULT_UC  ev_default_loop_uc_ ()    /* the default loop, if initialised, as sole arg */
+# define EV_DEFAULT_UC_ EV_DEFAULT_UC,            /* the default loop as first of multiple arguments */
+# define EV_DEFAULT  ev_default_loop (0)          /* the default loop as sole arg */
+# define EV_DEFAULT_ EV_DEFAULT,                  /* the default loop as first of multiple arguments */
+#else
+# define EV_P void
+# define EV_P_
+# define EV_A
+# define EV_A_
+# define EV_DEFAULT
+# define EV_DEFAULT_
+# define EV_DEFAULT_UC
+# define EV_DEFAULT_UC_
+# undef EV_EMBED_ENABLE
+#endif
+
+/* EV_INLINE is used for functions in header files */
+#if __STDC_VERSION__ >= 199901L || __GNUC__ >= 3
+# define EV_INLINE static inline
+#else
+# define EV_INLINE static
+#endif
+
+#ifdef EV_API_STATIC
+# define EV_API_DECL static
+#else
+# define EV_API_DECL extern
+#endif
+
+/* EV_PROTOTYPES can be used to switch of prototype declarations */
+#ifndef EV_PROTOTYPES
+# define EV_PROTOTYPES 1
+#endif
+
+/*****************************************************************************/
+
+#define EV_VERSION_MAJOR 4
+#define EV_VERSION_MINOR 22
+
+/* eventmask, revents, events... */
+enum {
+  EV_UNDEF    = (int)0xFFFFFFFF, /* guaranteed to be invalid */
+  EV_NONE     =            0x00, /* no events */
+  EV_READ     =            0x01, /* ev_io detected read will not block */
+  EV_WRITE    =            0x02, /* ev_io detected write will not block */
+  EV__IOFDSET =            0x80, /* internal use only */
+  EV_IO       =         EV_READ, /* alias for type-detection */
+  EV_TIMER    =      0x00000100, /* timer timed out */
+#if EV_COMPAT3
+  EV_TIMEOUT  =        EV_TIMER, /* pre 4.0 API compatibility */
+#endif
+  EV_PERIODIC =      0x00000200, /* periodic timer timed out */
+  EV_SIGNAL   =      0x00000400, /* signal was received */
+  EV_CHILD    =      0x00000800, /* child/pid had status change */
+  EV_STAT     =      0x00001000, /* stat data changed */
+  EV_IDLE     =      0x00002000, /* event loop is idling */
+  EV_PREPARE  =      0x00004000, /* event loop about to poll */
+  EV_CHECK    =      0x00008000, /* event loop finished poll */
+  EV_EMBED    =      0x00010000, /* embedded event loop needs sweep */
+  EV_FORK     =      0x00020000, /* event loop resumed in child */
+  EV_CLEANUP  =      0x00040000, /* event loop resumed in child */
+  EV_ASYNC    =      0x00080000, /* async intra-loop signal */
+  EV_CUSTOM   =      0x01000000, /* for use by user code */
+  EV_ERROR    = (int)0x80000000  /* sent when an error occurs */
+};
+
+/* can be used to add custom fields to all watchers, while losing binary compatibility */
+#ifndef EV_COMMON
+# define EV_COMMON void *data;
+#endif
+
+#ifndef EV_CB_DECLARE
+# define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents);
+#endif
+#ifndef EV_CB_INVOKE
+# define EV_CB_INVOKE(watcher,revents) (watcher)->cb (EV_A_ (watcher), (revents))
+#endif
+
+/* not official, do not use */
+#define EV_CB(type,name) void name (EV_P_ struct ev_ ## type *w, int revents)
+
+/*
+ * struct member types:
+ * private: you may look at them, but not change them,
+ *          and they might not mean anything to you.
+ * ro: can be read anytime, but only changed when the watcher isn't active.
+ * rw: can be read and modified anytime, even when the watcher is active.
+ *
+ * some internal details that might be helpful for debugging:
+ *
+ * active is either 0, which means the watcher is not active,
+ *           or the array index of the watcher (periodics, timers)
+ *           or the array index + 1 (most other watchers)
+ *           or simply 1 for watchers that aren't in some array.
+ * pending is either 0, in which case the watcher isn't,
+ *           or the array index + 1 in the pendings array.
+ */
+
+#if EV_MINPRI == EV_MAXPRI
+# define EV_DECL_PRIORITY
+#elif !defined (EV_DECL_PRIORITY)
+# define EV_DECL_PRIORITY int priority;
+#endif
+
+/* shared by all watchers */
+#define EV_WATCHER(type)			\
+  int active; /* private */			\
+  int pending; /* private */			\
+  EV_DECL_PRIORITY /* private */		\
+  EV_COMMON /* rw */				\
+  EV_CB_DECLARE (type) /* private */
+
+#define EV_WATCHER_LIST(type)			\
+  EV_WATCHER (type)				\
+  struct ev_watcher_list *next; /* private */
+
+#define EV_WATCHER_TIME(type)			\
+  EV_WATCHER (type)				\
+  ev_tstamp at;     /* private */
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher
+{
+  EV_WATCHER (ev_watcher)
+} ev_watcher;
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher_list
+{
+  EV_WATCHER_LIST (ev_watcher_list)
+} ev_watcher_list;
+
+/* base class, nothing to see here unless you subclass */
+typedef struct ev_watcher_time
+{
+  EV_WATCHER_TIME (ev_watcher_time)
+} ev_watcher_time;
+
+/* invoked when fd is either EV_READable or EV_WRITEable */
+/* revent EV_READ, EV_WRITE */
+typedef struct ev_io
+{
+  EV_WATCHER_LIST (ev_io)
+
+  int fd;     /* ro */
+  int events; /* ro */
+} ev_io;
+
+/* invoked after a specific time, repeatable (based on monotonic clock) */
+/* revent EV_TIMEOUT */
+typedef struct ev_timer
+{
+  EV_WATCHER_TIME (ev_timer)
+
+  ev_tstamp repeat; /* rw */
+} ev_timer;
+
+/* invoked at some specific time, possibly repeating at regular intervals (based on UTC) */
+/* revent EV_PERIODIC */
+typedef struct ev_periodic
+{
+  EV_WATCHER_TIME (ev_periodic)
+
+  ev_tstamp offset; /* rw */
+  ev_tstamp interval; /* rw */
+  ev_tstamp (*reschedule_cb)(struct ev_periodic *w, ev_tstamp now) EV_THROW; /* rw */
+} ev_periodic;
+
+/* invoked when the given signal has been received */
+/* revent EV_SIGNAL */
+typedef struct ev_signal
+{
+  EV_WATCHER_LIST (ev_signal)
+
+  int signum; /* ro */
+} ev_signal;
+
+/* invoked when sigchld is received and waitpid indicates the given pid */
+/* revent EV_CHILD */
+/* does not support priorities */
+typedef struct ev_child
+{
+  EV_WATCHER_LIST (ev_child)
+
+  int flags;   /* private */
+  int pid;     /* ro */
+  int rpid;    /* rw, holds the received pid */
+  int rstatus; /* rw, holds the exit status, use the macros from sys/wait.h */
+} ev_child;
+
+#if EV_STAT_ENABLE
+/* st_nlink = 0 means missing file or other error */
+# ifdef _WIN32
+typedef struct _stati64 ev_statdata;
+# else
+typedef struct stat ev_statdata;
+# endif
+
+/* invoked each time the stat data changes for a given path */
+/* revent EV_STAT */
+typedef struct ev_stat
+{
+  EV_WATCHER_LIST (ev_stat)
+
+  ev_timer timer;     /* private */
+  ev_tstamp interval; /* ro */
+  const char *path;   /* ro */
+  ev_statdata prev;   /* ro */
+  ev_statdata attr;   /* ro */
+
+  int wd; /* wd for inotify, fd for kqueue */
+} ev_stat;
+#endif
+
+#if EV_IDLE_ENABLE
+/* invoked when the nothing else needs to be done, keeps the process from blocking */
+/* revent EV_IDLE */
+typedef struct ev_idle
+{
+  EV_WATCHER (ev_idle)
+} ev_idle;
+#endif
+
+/* invoked for each run of the mainloop, just before the blocking call */
+/* you can still change events in any way you like */
+/* revent EV_PREPARE */
+typedef struct ev_prepare
+{
+  EV_WATCHER (ev_prepare)
+} ev_prepare;
+
+/* invoked for each run of the mainloop, just after the blocking call */
+/* revent EV_CHECK */
+typedef struct ev_check
+{
+  EV_WATCHER (ev_check)
+} ev_check;
+
+#if EV_FORK_ENABLE
+/* the callback gets invoked before check in the child process when a fork was detected */
+/* revent EV_FORK */
+typedef struct ev_fork
+{
+  EV_WATCHER (ev_fork)
+} ev_fork;
+#endif
+
+#if EV_CLEANUP_ENABLE
+/* is invoked just before the loop gets destroyed */
+/* revent EV_CLEANUP */
+typedef struct ev_cleanup
+{
+  EV_WATCHER (ev_cleanup)
+} ev_cleanup;
+#endif
+
+#if EV_EMBED_ENABLE
+/* used to embed an event loop inside another */
+/* the callback gets invoked when the event loop has handled events, and can be 0 */
+typedef struct ev_embed
+{
+  EV_WATCHER (ev_embed)
+
+  struct ev_loop *other; /* ro */
+  ev_io io;              /* private */
+  ev_prepare prepare;    /* private */
+  ev_check check;        /* unused */
+  ev_timer timer;        /* unused */
+  ev_periodic periodic;  /* unused */
+  ev_idle idle;          /* unused */
+  ev_fork fork;          /* private */
+#if EV_CLEANUP_ENABLE
+  ev_cleanup cleanup;    /* unused */
+#endif
+} ev_embed;
+#endif
+
+#if EV_ASYNC_ENABLE
+/* invoked when somebody calls ev_async_send on the watcher */
+/* revent EV_ASYNC */
+typedef struct ev_async
+{
+  EV_WATCHER (ev_async)
+
+  EV_ATOMIC_T sent; /* private */
+} ev_async;
+
+# define ev_async_pending(w) (+(w)->sent)
+#endif
+
+/* the presence of this union forces similar struct layout */
+union ev_any_watcher
+{
+  struct ev_watcher w;
+  struct ev_watcher_list wl;
+
+  struct ev_io io;
+  struct ev_timer timer;
+  struct ev_periodic periodic;
+  struct ev_signal signal;
+  struct ev_child child;
+#if EV_STAT_ENABLE
+  struct ev_stat stat;
+#endif
+#if EV_IDLE_ENABLE
+  struct ev_idle idle;
+#endif
+  struct ev_prepare prepare;
+  struct ev_check check;
+#if EV_FORK_ENABLE
+  struct ev_fork fork;
+#endif
+#if EV_CLEANUP_ENABLE
+  struct ev_cleanup cleanup;
+#endif
+#if EV_EMBED_ENABLE
+  struct ev_embed embed;
+#endif
+#if EV_ASYNC_ENABLE
+  struct ev_async async;
+#endif
+};
+
+/* flag bits for ev_default_loop and ev_loop_new */
+enum {
+  /* the default */
+  EVFLAG_AUTO      = 0x00000000U, /* not quite a mask */
+  /* flag bits */
+  EVFLAG_NOENV     = 0x01000000U, /* do NOT consult environment */
+  EVFLAG_FORKCHECK = 0x02000000U, /* check for a fork in each iteration */
+  /* debugging/feature disable */
+  EVFLAG_NOINOTIFY = 0x00100000U, /* do not attempt to use inotify */
+#if EV_COMPAT3
+  EVFLAG_NOSIGFD   = 0, /* compatibility to pre-3.9 */
+#endif
+  EVFLAG_SIGNALFD  = 0x00200000U, /* attempt to use signalfd */
+  EVFLAG_NOSIGMASK = 0x00400000U  /* avoid modifying the signal mask */
+};
+
+/* method bits to be ored together */
+enum {
+  EVBACKEND_SELECT  = 0x00000001U, /* about anywhere */
+  EVBACKEND_POLL    = 0x00000002U, /* !win */
+  EVBACKEND_EPOLL   = 0x00000004U, /* linux */
+  EVBACKEND_KQUEUE  = 0x00000008U, /* bsd */
+  EVBACKEND_DEVPOLL = 0x00000010U, /* solaris 8 */ /* NYI */
+  EVBACKEND_PORT    = 0x00000020U, /* solaris 10 */
+  EVBACKEND_ALL     = 0x0000003FU, /* all known backends */
+  EVBACKEND_MASK    = 0x0000FFFFU  /* all future backends */
+};
+
+#if EV_PROTOTYPES
+EV_API_DECL int ev_version_major (void) EV_THROW;
+EV_API_DECL int ev_version_minor (void) EV_THROW;
+
+EV_API_DECL unsigned int ev_supported_backends (void) EV_THROW;
+EV_API_DECL unsigned int ev_recommended_backends (void) EV_THROW;
+EV_API_DECL unsigned int ev_embeddable_backends (void) EV_THROW;
+
+EV_API_DECL ev_tstamp ev_time (void) EV_THROW;
+EV_API_DECL void ev_sleep (ev_tstamp delay) EV_THROW; /* sleep for a while */
+
+/* Sets the allocation function to use, works like realloc.
+ * It is used to allocate and free memory.
+ * If it returns zero when memory needs to be allocated, the library might abort
+ * or take some potentially destructive action.
+ * The default is your system realloc function.
+ */
+EV_API_DECL void ev_set_allocator (void *(*cb)(void *ptr, long size) EV_THROW) EV_THROW;
+
+/* set the callback function to call on a
+ * retryable syscall error
+ * (such as failed select, poll, epoll_wait)
+ */
+EV_API_DECL void ev_set_syserr_cb (void (*cb)(const char *msg) EV_THROW) EV_THROW;
+
+#if EV_MULTIPLICITY
+
+/* the default loop is the only one that handles signals and child watchers */
+/* you can call this as often as you like */
+EV_API_DECL struct ev_loop *ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW;
+
+#ifdef EV_API_STATIC
+EV_API_DECL struct ev_loop *ev_default_loop_ptr;
+#endif
+
+EV_INLINE struct ev_loop *
+ev_default_loop_uc_ (void) EV_THROW
+{
+  extern struct ev_loop *ev_default_loop_ptr;
+
+  return ev_default_loop_ptr;
+}
+
+EV_INLINE int
+ev_is_default_loop (EV_P) EV_THROW
+{
+  return EV_A == EV_DEFAULT_UC;
+}
+
+/* create and destroy alternative loops that don't handle signals */
+EV_API_DECL struct ev_loop *ev_loop_new (unsigned int flags EV_CPP (= 0)) EV_THROW;
+
+EV_API_DECL ev_tstamp ev_now (EV_P) EV_THROW; /* time w.r.t. timers and the eventloop, updated after each poll */
+
+#else
+
+EV_API_DECL int ev_default_loop (unsigned int flags EV_CPP (= 0)) EV_THROW; /* returns true when successful */
+
+EV_API_DECL ev_tstamp ev_rt_now;
+
+EV_INLINE ev_tstamp
+ev_now (void) EV_THROW
+{
+  return ev_rt_now;
+}
+
+/* looks weird, but ev_is_default_loop (EV_A) still works if this exists */
+EV_INLINE int
+ev_is_default_loop (void) EV_THROW
+{
+  return 1;
+}
+
+#endif /* multiplicity */
+
+/* destroy event loops, also works for the default loop */
+EV_API_DECL void ev_loop_destroy (EV_P);
+
+/* this needs to be called after fork, to duplicate the loop */
+/* when you want to re-use it in the child */
+/* you can call it in either the parent or the child */
+/* you can actually call it at any time, anywhere :) */
+EV_API_DECL void ev_loop_fork (EV_P) EV_THROW;
+
+EV_API_DECL unsigned int ev_backend (EV_P) EV_THROW; /* backend in use by loop */
+
+EV_API_DECL void ev_now_update (EV_P) EV_THROW; /* update event loop time */
+
+#if EV_WALK_ENABLE
+/* walk (almost) all watchers in the loop of a given type, invoking the */
+/* callback on every such watcher. The callback might stop the watcher, */
+/* but do nothing else with the loop */
+EV_API_DECL void ev_walk (EV_P_ int types, void (*cb)(EV_P_ int type, void *w)) EV_THROW;
+#endif
+
+#endif /* prototypes */
+
+/* ev_run flags values */
+enum {
+  EVRUN_NOWAIT = 1, /* do not block/wait */
+  EVRUN_ONCE   = 2  /* block *once* only */
+};
+
+/* ev_break how values */
+enum {
+  EVBREAK_CANCEL = 0, /* undo unloop */
+  EVBREAK_ONE    = 1, /* unloop once */
+  EVBREAK_ALL    = 2  /* unloop all loops */
+};
+
+#if EV_PROTOTYPES
+EV_API_DECL int  ev_run (EV_P_ int flags EV_CPP (= 0));
+EV_API_DECL void ev_break (EV_P_ int how EV_CPP (= EVBREAK_ONE)) EV_THROW; /* break out of the loop */
+
+/*
+ * ref/unref can be used to add or remove a refcount on the mainloop. every watcher
+ * keeps one reference. if you have a long-running watcher you never unregister that
+ * should not keep ev_loop from running, unref() after starting, and ref() before stopping.
+ */
+EV_API_DECL void ev_ref   (EV_P) EV_THROW;
+EV_API_DECL void ev_unref (EV_P) EV_THROW;
+
+/*
+ * convenience function, wait for a single event, without registering an event watcher
+ * if timeout is < 0, do wait indefinitely
+ */
+EV_API_DECL void ev_once (EV_P_ int fd, int events, ev_tstamp timeout, void (*cb)(int revents, void *arg), void *arg) EV_THROW;
+
+# if EV_FEATURE_API
+EV_API_DECL unsigned int ev_iteration (EV_P) EV_THROW; /* number of loop iterations */
+EV_API_DECL unsigned int ev_depth     (EV_P) EV_THROW; /* #ev_loop enters - #ev_loop leaves */
+EV_API_DECL void         ev_verify    (EV_P) EV_THROW; /* abort if loop data corrupted */
+
+EV_API_DECL void ev_set_io_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
+EV_API_DECL void ev_set_timeout_collect_interval (EV_P_ ev_tstamp interval) EV_THROW; /* sleep at least this time, default 0 */
+
+/* advanced stuff for threading etc. support, see docs */
+EV_API_DECL void ev_set_userdata (EV_P_ void *data) EV_THROW;
+EV_API_DECL void *ev_userdata (EV_P) EV_THROW;
+typedef void (*ev_loop_callback)(EV_P);
+EV_API_DECL void ev_set_invoke_pending_cb (EV_P_ ev_loop_callback invoke_pending_cb) EV_THROW;
+/* C++ doesn't allow the use of the ev_loop_callback typedef here, so we need to spell it out */
+EV_API_DECL void ev_set_loop_release_cb (EV_P_ void (*release)(EV_P) EV_THROW, void (*acquire)(EV_P) EV_THROW) EV_THROW;
+
+EV_API_DECL unsigned int ev_pending_count (EV_P) EV_THROW; /* number of pending events, if any */
+EV_API_DECL void ev_invoke_pending (EV_P); /* invoke all pending watchers */
+
+/*
+ * stop/start the timer handling.
+ */
+EV_API_DECL void ev_suspend (EV_P) EV_THROW;
+EV_API_DECL void ev_resume  (EV_P) EV_THROW;
+#endif
+
+#endif
+
+/* these may evaluate ev multiple times, and the other arguments at most once */
+/* either use ev_init + ev_TYPE_set, or the ev_TYPE_init macro, below, to first initialise a watcher */
+#define ev_init(ev,cb_) do {			\
+  ((ev_watcher *)(void *)(ev))->active  =	\
+  ((ev_watcher *)(void *)(ev))->pending = 0;	\
+  ev_set_priority ((ev), 0);			\
+  ev_set_cb ((ev), cb_);			\
+} while (0)
+
+#define ev_io_set(ev,fd_,events_)            do { (ev)->fd = (fd_); (ev)->events = (events_) | EV__IOFDSET; } while (0)
+#define ev_timer_set(ev,after_,repeat_)      do { ((ev_watcher_time *)(ev))->at = (after_); (ev)->repeat = (repeat_); } while (0)
+#define ev_periodic_set(ev,ofs_,ival_,rcb_)  do { (ev)->offset = (ofs_); (ev)->interval = (ival_); (ev)->reschedule_cb = (rcb_); } while (0)
+#define ev_signal_set(ev,signum_)            do { (ev)->signum = (signum_); } while (0)
+#define ev_child_set(ev,pid_,trace_)         do { (ev)->pid = (pid_); (ev)->flags = !!(trace_); } while (0)
+#define ev_stat_set(ev,path_,interval_)      do { (ev)->path = (path_); (ev)->interval = (interval_); (ev)->wd = -2; } while (0)
+#define ev_idle_set(ev)                      /* nop, yes, this is a serious in-joke */
+#define ev_prepare_set(ev)                   /* nop, yes, this is a serious in-joke */
+#define ev_check_set(ev)                     /* nop, yes, this is a serious in-joke */
+#define ev_embed_set(ev,other_)              do { (ev)->other = (other_); } while (0)
+#define ev_fork_set(ev)                      /* nop, yes, this is a serious in-joke */
+#define ev_cleanup_set(ev)                   /* nop, yes, this is a serious in-joke */
+#define ev_async_set(ev)                     /* nop, yes, this is a serious in-joke */
+
+#define ev_io_init(ev,cb,fd,events)          do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)
+#define ev_timer_init(ev,cb,after,repeat)    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)
+#define ev_periodic_init(ev,cb,ofs,ival,rcb) do { ev_init ((ev), (cb)); ev_periodic_set ((ev),(ofs),(ival),(rcb)); } while (0)
+#define ev_signal_init(ev,cb,signum)         do { ev_init ((ev), (cb)); ev_signal_set ((ev), (signum)); } while (0)
+#define ev_child_init(ev,cb,pid,trace)       do { ev_init ((ev), (cb)); ev_child_set ((ev),(pid),(trace)); } while (0)
+#define ev_stat_init(ev,cb,path,interval)    do { ev_init ((ev), (cb)); ev_stat_set ((ev),(path),(interval)); } while (0)
+#define ev_idle_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_idle_set ((ev)); } while (0)
+#define ev_prepare_init(ev,cb)               do { ev_init ((ev), (cb)); ev_prepare_set ((ev)); } while (0)
+#define ev_check_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_check_set ((ev)); } while (0)
+#define ev_embed_init(ev,cb,other)           do { ev_init ((ev), (cb)); ev_embed_set ((ev),(other)); } while (0)
+#define ev_fork_init(ev,cb)                  do { ev_init ((ev), (cb)); ev_fork_set ((ev)); } while (0)
+#define ev_cleanup_init(ev,cb)               do { ev_init ((ev), (cb)); ev_cleanup_set ((ev)); } while (0)
+#define ev_async_init(ev,cb)                 do { ev_init ((ev), (cb)); ev_async_set ((ev)); } while (0)
+
+#define ev_is_pending(ev)                    (0 + ((ev_watcher *)(void *)(ev))->pending) /* ro, true when watcher is waiting for callback invocation */
+#define ev_is_active(ev)                     (0 + ((ev_watcher *)(void *)(ev))->active) /* ro, true when the watcher has been started */
+
+#define ev_cb_(ev)                           (ev)->cb /* rw */
+#define ev_cb(ev)                            (memmove (&ev_cb_ (ev), &((ev_watcher *)(ev))->cb, sizeof (ev_cb_ (ev))), (ev)->cb)
+
+#if EV_MINPRI == EV_MAXPRI
+# define ev_priority(ev)                     ((ev), EV_MINPRI)
+# define ev_set_priority(ev,pri)             ((ev), (pri))
+#else
+# define ev_priority(ev)                     (+(((ev_watcher *)(void *)(ev))->priority))
+# define ev_set_priority(ev,pri)             (   (ev_watcher *)(void *)(ev))->priority = (pri)
+#endif
+
+#define ev_periodic_at(ev)                   (+((ev_watcher_time *)(ev))->at)
+
+#ifndef ev_set_cb
+# define ev_set_cb(ev,cb_)                   (ev_cb_ (ev) = (cb_), memmove (&((ev_watcher *)(ev))->cb, &ev_cb_ (ev), sizeof (ev_cb_ (ev))))
+#endif
+
+/* stopping (enabling, adding) a watcher does nothing if it is already running */
+/* stopping (disabling, deleting) a watcher does nothing unless it's already running */
+#if EV_PROTOTYPES
+
+/* feeds an event into a watcher as if the event actually occurred */
+/* accepts any ev_watcher type */
+EV_API_DECL void ev_feed_event     (EV_P_ void *w, int revents) EV_THROW;
+EV_API_DECL void ev_feed_fd_event  (EV_P_ int fd, int revents) EV_THROW;
+#if EV_SIGNAL_ENABLE
+EV_API_DECL void ev_feed_signal    (int signum) EV_THROW;
+EV_API_DECL void ev_feed_signal_event (EV_P_ int signum) EV_THROW;
+#endif
+EV_API_DECL void ev_invoke         (EV_P_ void *w, int revents);
+EV_API_DECL int  ev_clear_pending  (EV_P_ void *w) EV_THROW;
+
+EV_API_DECL void ev_io_start       (EV_P_ ev_io *w) EV_THROW;
+EV_API_DECL void ev_io_stop        (EV_P_ ev_io *w) EV_THROW;
+
+EV_API_DECL void ev_timer_start    (EV_P_ ev_timer *w) EV_THROW;
+EV_API_DECL void ev_timer_stop     (EV_P_ ev_timer *w) EV_THROW;
+/* stops if active and no repeat, restarts if active and repeating, starts if inactive and repeating */
+EV_API_DECL void ev_timer_again    (EV_P_ ev_timer *w) EV_THROW;
+/* return remaining time */
+EV_API_DECL ev_tstamp ev_timer_remaining (EV_P_ ev_timer *w) EV_THROW;
+
+#if EV_PERIODIC_ENABLE
+EV_API_DECL void ev_periodic_start (EV_P_ ev_periodic *w) EV_THROW;
+EV_API_DECL void ev_periodic_stop  (EV_P_ ev_periodic *w) EV_THROW;
+EV_API_DECL void ev_periodic_again (EV_P_ ev_periodic *w) EV_THROW;
+#endif
+
+/* only supported in the default loop */
+#if EV_SIGNAL_ENABLE
+EV_API_DECL void ev_signal_start   (EV_P_ ev_signal *w) EV_THROW;
+EV_API_DECL void ev_signal_stop    (EV_P_ ev_signal *w) EV_THROW;
+#endif
+
+/* only supported in the default loop */
+# if EV_CHILD_ENABLE
+EV_API_DECL void ev_child_start    (EV_P_ ev_child *w) EV_THROW;
+EV_API_DECL void ev_child_stop     (EV_P_ ev_child *w) EV_THROW;
+# endif
+
+# if EV_STAT_ENABLE
+EV_API_DECL void ev_stat_start     (EV_P_ ev_stat *w) EV_THROW;
+EV_API_DECL void ev_stat_stop      (EV_P_ ev_stat *w) EV_THROW;
+EV_API_DECL void ev_stat_stat      (EV_P_ ev_stat *w) EV_THROW;
+# endif
+
+# if EV_IDLE_ENABLE
+EV_API_DECL void ev_idle_start     (EV_P_ ev_idle *w) EV_THROW;
+EV_API_DECL void ev_idle_stop      (EV_P_ ev_idle *w) EV_THROW;
+# endif
+
+#if EV_PREPARE_ENABLE
+EV_API_DECL void ev_prepare_start  (EV_P_ ev_prepare *w) EV_THROW;
+EV_API_DECL void ev_prepare_stop   (EV_P_ ev_prepare *w) EV_THROW;
+#endif
+
+#if EV_CHECK_ENABLE
+EV_API_DECL void ev_check_start    (EV_P_ ev_check *w) EV_THROW;
+EV_API_DECL void ev_check_stop     (EV_P_ ev_check *w) EV_THROW;
+#endif
+
+# if EV_FORK_ENABLE
+EV_API_DECL void ev_fork_start     (EV_P_ ev_fork *w) EV_THROW;
+EV_API_DECL void ev_fork_stop      (EV_P_ ev_fork *w) EV_THROW;
+# endif
+
+# if EV_CLEANUP_ENABLE
+EV_API_DECL void ev_cleanup_start  (EV_P_ ev_cleanup *w) EV_THROW;
+EV_API_DECL void ev_cleanup_stop   (EV_P_ ev_cleanup *w) EV_THROW;
+# endif
+
+# if EV_EMBED_ENABLE
+/* only supported when loop to be embedded is in fact embeddable */
+EV_API_DECL void ev_embed_start    (EV_P_ ev_embed *w) EV_THROW;
+EV_API_DECL void ev_embed_stop     (EV_P_ ev_embed *w) EV_THROW;
+EV_API_DECL void ev_embed_sweep    (EV_P_ ev_embed *w) EV_THROW;
+# endif
+
+# if EV_ASYNC_ENABLE
+EV_API_DECL void ev_async_start    (EV_P_ ev_async *w) EV_THROW;
+EV_API_DECL void ev_async_stop     (EV_P_ ev_async *w) EV_THROW;
+EV_API_DECL void ev_async_send     (EV_P_ ev_async *w) EV_THROW;
+# endif
+
+#if EV_COMPAT3
+  #define EVLOOP_NONBLOCK EVRUN_NOWAIT
+  #define EVLOOP_ONESHOT  EVRUN_ONCE
+  #define EVUNLOOP_CANCEL EVBREAK_CANCEL
+  #define EVUNLOOP_ONE    EVBREAK_ONE
+  #define EVUNLOOP_ALL    EVBREAK_ALL
+  #if EV_PROTOTYPES
+    EV_INLINE void ev_loop   (EV_P_ int flags) { ev_run   (EV_A_ flags); }
+    EV_INLINE void ev_unloop (EV_P_ int how  ) { ev_break (EV_A_ how  ); }
+    EV_INLINE void ev_default_destroy (void) { ev_loop_destroy (EV_DEFAULT); }
+    EV_INLINE void ev_default_fork    (void) { ev_loop_fork    (EV_DEFAULT); }
+    #if EV_FEATURE_API
+      EV_INLINE unsigned int ev_loop_count  (EV_P) { return ev_iteration  (EV_A); }
+      EV_INLINE unsigned int ev_loop_depth  (EV_P) { return ev_depth      (EV_A); }
+      EV_INLINE void         ev_loop_verify (EV_P) {        ev_verify     (EV_A); }
+    #endif
+  #endif
+#else
+  typedef struct ev_loop ev_loop;
+#endif
+
+#endif
+
+EV_CPP(})
+
+#endif
+
diff --git a/release/src/router/skipdbv2/mgr/array-heap.c b/release/src/router/skipdbv2/mgr/array-heap.c
new file mode 100644
index 0000000000..951e4448f7
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/array-heap.c
@@ -0,0 +1,49 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "array-heap.h"
+
+int array_init(array* arr, int size) {
+  arr->data = realloc(NULL, sizeof(void*) * size);
+  if (0 == (size_t)arr->data) {
+    return -1;
+  }
+  arr->length = size;
+  arr->index = 0;
+  return 0;
+}
+
+int array_push(array* arr, void* data) {
+  ((size_t*)arr->data)[arr->index] = (size_t)data;
+  arr->index += 1;
+  if (arr->index >= arr->length) {
+    if (-1 == array_grow(arr, arr->length * 2))
+    {
+      return -1;
+    }
+  }
+  return arr->index - 1;
+}
+
+int array_grow(array* arr, int size) {
+  if (size <= arr->length) {
+    return -1;
+  }
+  arr->data = realloc(arr->data, sizeof(void*) * size);
+  if (-1 == (size_t)arr->data) {
+    return -1;
+  }
+  arr->length = size;
+  return 0;
+}
+
+void array_free(array* arr, void (*free_element)(void*)) {
+  int i;
+  for (i = 0; i < arr->index; i += 1) {
+    free_element((void*)((size_t*)arr->data)[i]);
+  }
+  free(arr->data);
+  arr->index = -1;
+  arr->length = 0;
+  arr->data = NULL;
+}
diff --git a/release/src/router/skipdbv2/mgr/array-heap.h b/release/src/router/skipdbv2/mgr/array-heap.h
new file mode 100644
index 0000000000..d134ee6158
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/array-heap.h
@@ -0,0 +1,16 @@
+#ifndef __ARRAY_HEAP_H__
+#define __ARRAY_HEAP_H__
+
+typedef struct {
+  void* data;
+  int index;
+  int length;
+} array;
+
+int array_init(array* arr, int size);
+int array_push(array* arr, void* data);
+int array_grow(array* arr, int size);
+void array_free(array* arr, void (*free_element)(void*));
+
+#endif
+
diff --git a/release/src/router/skipdbv2/mgr/coroutine.h b/release/src/router/skipdbv2/mgr/coroutine.h
new file mode 100644
index 0000000000..4b30eabe56
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/coroutine.h
@@ -0,0 +1,39 @@
+/*
+ * 协程实现，最开始见于putty软件的实现，文件头部有介绍。
+ * 此版本有修改，不使用动态内存申请，内存由外部函数申请好。
+ */
+
+#ifndef COROUTINE_H
+#define COROUTINE_H
+
+#include <stdlib.h>
+
+#define COROUTINE_CONTEXT_LEN 	64
+
+struct ccrContextTag {
+    int ccrLine;
+    /* 协程中用于临时内存交换 */
+    unsigned char stack_buf[COROUTINE_CONTEXT_LEN]; 
+};
+
+ /* assert(sizeof(struct _stack_##__FUNCTION__) < COROUTINE_CONTEXT_LEN)
+ * 未实现assert函数 */
+#define TOKENPASTE(x, y) 	x ## y
+#define TOKENPASTE2(x, y) 	TOKENPASTE(x, y)
+#define TYPE_UNIQUE 			TOKENPASTE2(_statck_, __LINE__)
+#define ccrBeginContext  typedef struct TYPE_UNIQUE {
+#define ccrEndContext(x) } TYPE_UNIQUE; TYPE_UNIQUE *CS; do { CS = (TYPE_UNIQUE*)(&((x)->stack_buf[0]));} while(0)
+
+#define ccrBegin(x)      if (x){ 			\
+                         switch((x)->ccrLine) { case 0:;
+#define ccrFinish(x,z)     }} do { (x)->ccrLine = 0; return (z); } while(0)
+
+#define ccrReturn(x,z)     \
+        do {\
+            (x)->ccrLine=__LINE__;\
+            return (z); case __LINE__:;\
+        } while (0)
+
+#define ccrStop(x,z)       do{ (x)->ccrLine = 0; return (z); }while(0)
+
+#endif /* COROUTINE_H */
diff --git a/release/src/router/skipdbv2/mgr/daemonize.c b/release/src/router/skipdbv2/mgr/daemonize.c
new file mode 100644
index 0000000000..8bb269aba4
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/daemonize.c
@@ -0,0 +1,91 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <string.h>
+#include <signal.h>
+#include <assert.h>
+#include <time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/un.h>
+#include <syslog.h>
+#include <ev.h>
+
+void skipd_daemonize(char * path)
+{
+#ifndef __MINGW32__
+    /* Our process ID and Session ID */
+    pid_t pid, sid;
+
+    /* Fork off the parent process */
+    pid = fork();
+    if (pid < 0) {
+        exit(EXIT_FAILURE);
+    }
+
+    /* If we got a good PID, then
+       we can exit the parent process. */
+    if (pid > 0) {
+        FILE *file = fopen(path, "w");
+        if (file == NULL) {
+            fprintf(stderr, "Invalid pid file\n");
+        }
+
+        fprintf(file, "%d", pid);
+        fclose(file);
+        exit(EXIT_SUCCESS);
+    }
+
+
+    /* Cancel certain signals */
+    signal(SIGCHLD, SIG_DFL); /* A child process dies */
+    signal(SIGTSTP, SIG_IGN); /* Various TTY signals */
+    signal(SIGTTOU, SIG_IGN);
+    signal(SIGTTIN, SIG_IGN);
+    signal(SIGHUP, SIG_IGN); /* Ignore hangup signal */
+
+    /* Change the file mode mask */
+    umask(0);
+
+    /* Open any logs here */
+
+    /* Create a new SID for the child process */
+    sid = setsid();
+    if (sid < 0) {
+        /* Log the failure */
+        exit(EXIT_FAILURE);
+    }
+
+    /* Change the current working directory */
+    if ((chdir("/")) < 0) {
+        /* Log the failure */
+        exit(EXIT_FAILURE);
+    }
+
+    /* Redirect standard files to /dev/null */
+    if (!freopen("/dev/null", "r", stdin)) {
+        fprintf(stderr, "unable to freopen() stdin, code %d (%s)",
+                                                   errno, strerror(errno));
+    }
+
+    if (!freopen("/dev/null", "w", stdout)) {
+        fprintf(stderr, "unable to freopen() stdout, code %d (%s)",
+                                                   errno, strerror(errno));
+    }
+
+    if (!freopen("/dev/null", "w", stderr)) {
+        fprintf(stderr, "unable to freopen() stderr, code %d (%s)",
+                                                   errno, strerror(errno));
+    }
+
+    /* Close out the standard file descriptors */
+    /* close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO); */
+#endif
+}
diff --git a/release/src/router/skipdbv2/mgr/dbapi.c b/release/src/router/skipdbv2/mgr/dbapi.c
new file mode 100644
index 0000000000..47c4c965b7
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/dbapi.c
@@ -0,0 +1,323 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h> // fcntl
+#include <unistd.h> // close
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/time.h>
+#include <time.h>
+#include <limits.h> // [LONG|INT][MIN|MAX]
+#include <errno.h>  // errno
+#include <unistd.h>
+#include "skipd.h"
+
+//"list "
+#define LIST_LEN 5
+
+typedef struct _dbclient {
+    int remote_fd;
+
+    char* buf;
+    int buf_max;
+    int buf_len;
+    int buf_pos;
+} dbclient;
+
+typedef int (*fn_db_parse)(dbclient* client, void* o, char* prefix, char* key, char* value);
+static int ignore_result(dbclient *client);
+
+static int write_util(dbclient* client, int len, unsigned int delay) {
+    int n, writed_len = 0;
+    unsigned int now, timeout;
+    struct timeval tv, tv2;
+
+    gettimeofday(&tv2, NULL);
+    timeout = (tv2.tv_sec*1000) + (tv2.tv_usec/1000) + delay;
+    while(writed_len < len) {
+        n = write(client->remote_fd, client->buf + writed_len, len - writed_len);
+        if(n < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                gettimeofday(&tv, NULL);
+                now = (tv.tv_sec*1000) + (tv.tv_usec/1000);
+                if(now > timeout) {
+                    break;
+                }
+
+                usleep(50);
+            }
+        }
+
+        writed_len += n;
+    }
+
+    if(writed_len != len) {
+        return -1;
+    }
+
+    return 0;
+}
+
+//TODO better for code reused
+static int create_client_fd(char* sock_path) {
+    int len, remote_fd;
+    struct sockaddr_un remote;
+
+    if(-1 == (remote_fd = socket(PF_UNIX, SOCK_STREAM, 0))) {
+        //perror("socket");
+        return -1;
+    }
+
+    remote.sun_family = AF_UNIX;
+    strcpy(remote.sun_path, sock_path);
+    len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+    if(-1 == connect(remote_fd, (struct sockaddr*)&remote, len)) {
+        //perror("connect");
+        close(remote_fd);
+        return -1;
+    }
+
+    return remote_fd;
+}
+
+static void check_buf(dbclient* client, int len) {
+    int clen = _max(len, BUF_MAX);
+
+    if((NULL != client->buf) && (client->buf_max < clen)) {
+        free(client->buf);
+        client->buf = NULL;
+    }
+
+    if(NULL == client->buf) {
+        client->buf = (char*)malloc(clen+1);
+        client->buf_max = clen;
+    }
+}
+
+static int setnonblock(int fd) {
+    int flags;
+
+    flags = fcntl(fd, F_GETFL);
+    flags |= O_NONBLOCK;
+    return fcntl(fd, F_SETFL, flags);
+}
+
+int dbclient_start(dbclient* client) {
+    char* socket_path = "/tmp/.skipd_server_sock";
+
+    memset(client, 0, sizeof(dbclient));
+
+    client->remote_fd = create_client_fd(socket_path);
+    if(-1 == client->remote_fd) {
+        system("service start_skipd >/dev/null 2>&1 &");
+        sleep(1);
+
+        client->remote_fd = create_client_fd(socket_path);
+        if(-1 == client->remote_fd) {
+            return -1;
+        }
+    }
+
+    setnonblock(client->remote_fd);
+    return 0;
+}
+
+int dbclient_bulk(dbclient* client, char* command, char* key, char* value) {
+    int n1,n2,nc,nk,nv;
+
+    nc = strlen(command);
+    nk = strlen(key);
+    nv = strlen(value);
+
+    n1 = nc + nk + nv + 3;// replace key value\n
+    check_buf(client, n1 + HEADER_PREFIX);
+    n2 = sprintf(client->buf, "%s%07d %s %s %s\n", MAGIC, n1, command, key, value);
+
+    if(0 == write_util(client, n1 + HEADER_PREFIX, 200)) {
+        ignore_result(client);
+        return 0;
+    }
+
+    return -1;
+}
+
+static int read_util(dbclient* client, int len, unsigned int delay) {
+    int clen, n;
+    unsigned int now, timeout;
+    struct timeval tv,  tv2;
+
+    check_buf(client, len);
+    gettimeofday(&tv2, NULL);
+    timeout = (tv2.tv_sec * 1000) + (tv2.tv_usec / 1000) + delay;
+    client->buf_pos = 0;
+
+    for(;;) {
+        clen = len - client->buf_pos;
+        n = recv(client->remote_fd, client->buf + client->buf_pos, clen, 0);
+        if(n < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                gettimeofday(&tv, NULL);
+                now = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+                if(now > timeout) {
+                    break;
+                }
+
+                usleep(50);
+                continue;
+            }
+            //timeout
+            return -2;
+        } else if(n == 0) {
+            //socket closed
+            return -1;
+        } else {
+            client->buf_pos += n;
+            if(client->buf_pos == len) {
+                //read ok
+                return 0;
+            }
+        }
+    }
+
+    //unkown error
+    return -3;
+}
+
+static int ignore_result(dbclient *client) {
+    int n1, n2;
+    char* magic = MAGIC;
+
+    do {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+    } while(0);
+
+    return 0;
+}
+
+static int parse_list_result(dbclient *client, char* prefix, void* o, fn_db_parse fn) {
+    int n1, n2;
+    char *p1, *p2, *magic = MAGIC;
+
+    for(;;) {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 510);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        client->buf[n2] = '\0';
+
+        if(NULL != strstr(client->buf, "__end__")) {
+            break;
+        }
+
+        p1 = client->buf + LIST_LEN;
+        p2 = strstr(p1, " ");
+        *p2 = '\0';
+        p2++;
+        if(client->buf[n2-1] == '\n') {
+            client->buf[n2-1] = '\0';
+        }
+        if(0 != (*fn)(client, o, prefix, p1, p2)) {
+            break;
+        }
+    }
+
+    return 0;
+}
+
+int dbclient_list(dbclient* client, char* prefix, void* o, fn_db_parse fn) {
+    int n1, n2;
+
+    n1 = strlen("list") + strlen(prefix) + 2;//list prefix\n
+    check_buf(client, n1 + HEADER_PREFIX);
+    n2 = sprintf(client->buf, "%s%07d list %s\n", MAGIC, n1, prefix);
+    if(0 != write_util(client, n1 + HEADER_PREFIX, 100)) {
+        return -1;
+    }
+
+    return parse_list_result(client, prefix, o, fn);
+}
+
+int dbclient_end(dbclient* client) {
+    if(NULL != client->buf) {
+        free(client->buf);
+    }
+    if((-1 != client->remote_fd) && (0 != client->remote_fd)) {
+        close(client->remote_fd);
+    }
+
+    return 0;
+}
+
+static int myprint(dbclient* client, void* o, char* prefix, char* key, char* value) {
+    printf("%s=%s\n", key, value);
+    return 0;
+}
+
+static int print_json(dbclient* client, void* o, char* prefix, char* key, char* value) {
+    printf("o['%s']='%s';\n", key, value);
+    return 0;
+}
+
+int dbclient_json(dbclient* client, char* prefix) {
+    printf("var %s=(function() ({\nvar o={};\n", prefix);
+    dbclient_list(client, prefix, NULL, print_json);
+    printf("return o;\n})();\n");
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    dbclient client;
+    dbclient_start(&client);
+    dbclient_bulk(&client, "set", "hello1", "value-new-value");
+    dbclient_bulk(&client, "set", "hello11", "value-new-value");
+    dbclient_bulk(&client, "set", "hello111", "value-new-value");
+    dbclient_bulk(&client, "set", "hello1112", "value-new-value");
+    dbclient_bulk(&client, "set", "hello13", "value-new-value");
+    dbclient_bulk(&client, "set", "hello15", "value-new-value");
+
+    //dbclient_list(&client, "hello1", NULL, myprint);
+    dbclient_json(&client, "hello1");
+    dbclient_end(&client);
+    return 0;
+}
diff --git a/release/src/router/skipdbv2/mgr/dbus.c b/release/src/router/skipdbv2/mgr/dbus.c
new file mode 100644
index 0000000000..1817650de4
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/dbus.c
@@ -0,0 +1,656 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h> // fcntl
+#include <unistd.h> // close
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/time.h>
+#include <time.h>
+#include <limits.h> // [LONG|INT][MIN|MAX]
+#include <errno.h>  // errno
+#include <unistd.h>
+#include "skipd.h"
+
+//"list "
+#define LIST_LEN 5
+
+typedef struct _dbclient {
+    int remote_fd;
+    char command[DELAY_KEY_LEN+1];
+    char key[DELAY_KEY_LEN+1];
+    //unsigned int timeout;
+
+    char* buf;
+    int buf_max;
+    int buf_len;
+    int buf_pos;
+} dbclient;
+
+#if 0
+static void print_time(char* prefix)
+{
+    struct timeval tv;
+    unsigned int ms;
+
+    gettimeofday (&tv, NULL);
+    ms = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+    fprintf(stderr, "%s: %03u\n", prefix, ms);
+}
+#endif
+
+static int create_client_fd(char* sock_path) {
+    int len, remote_fd;
+    struct sockaddr_un remote;
+
+    if(-1 == (remote_fd = socket(PF_UNIX, SOCK_STREAM, 0))) {
+        //perror("socket");
+        return -1;
+    }
+
+    remote.sun_family = AF_UNIX;
+    strcpy(remote.sun_path, sock_path);
+    len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+    if(-1 == connect(remote_fd, (struct sockaddr*)&remote, len)) {
+        //perror("connect");
+        close(remote_fd);
+        return -1;
+    }
+
+    return remote_fd;
+}
+
+int setnonblock(int fd) {
+    int flags;
+
+    flags = fcntl(fd, F_GETFL);
+    flags |= O_NONBLOCK;
+    return fcntl(fd, F_SETFL, flags);
+}
+
+static void check_buf(dbclient* client, int len) {
+    int clen = _max(len, BUF_MAX);
+
+    if((NULL != client->buf) && (client->buf_max < clen)) {
+        free(client->buf);
+        client->buf = NULL;
+    }
+
+    if(NULL == client->buf) {
+        client->buf = (char*)malloc(clen+1);
+        client->buf_max = clen;
+    }
+}
+
+static int read_util(dbclient* client, int len, unsigned int delay) {
+    int clen, n;
+    unsigned int now, timeout;
+    struct timeval tv,  tv2;
+
+    check_buf(client, len);
+    gettimeofday(&tv2, NULL);
+    timeout = (tv2.tv_sec * 1000) + (tv2.tv_usec / 1000) + delay;
+    client->buf_pos = 0;
+
+    for(;;) {
+        clen = len - client->buf_pos;
+        n = recv(client->remote_fd, client->buf + client->buf_pos, clen, 0);
+        if(n < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                gettimeofday(&tv, NULL);
+                now = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+                if(now > timeout) {
+                    break;
+                }
+
+                usleep(50);
+                continue;
+            }
+            //timeout
+            return -2;
+        } else if(n == 0) {
+            //socket closed
+            return -1;
+        } else {
+            client->buf_pos += n;
+            if(client->buf_pos == len) {
+                //read ok
+                return 0;
+            }
+        }
+    }
+
+    //unkown error
+    return -3;
+}
+
+int parse_common_result(dbclient *client) {
+    int n1, n2;
+    char* magic = MAGIC;
+
+    do {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        client->buf[n2] = '\0';
+
+        if(client->buf[n2-1] != '\n') {
+            //TODO fix hear
+            printf("%s\n", client->buf);
+        } else {
+            printf("%s", client->buf);
+        }
+    } while(0);
+
+    return 0;
+}
+
+int parse_get_result(dbclient *client) {
+    int n1, n2;
+    char *p1, *p2, *magic = MAGIC;
+
+    do {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 510);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        client->buf[n2] = '\0';
+        p1 = strstr(client->buf, " ");
+        if(NULL == p1) {
+            break;
+        }
+        p2 = strstr(p1+1, " ");
+        if(NULL == p2) {
+            break;
+        }
+        n2 -= (p2-client->buf);
+        if(!strcmp(p2+1, "none\n")) {
+            break;
+        }
+        if(p2[n2-1] != '\n') {
+            printf("%s\n", p2+1);
+        } else {
+            printf("%s", p2+1);
+        }
+        return 0;
+    } while(0);
+
+    printf("\n");
+    return 0;
+}
+
+int parse_list_result(dbclient *client) {
+    int n1, n2;
+    char *p1, *p2, *magic = MAGIC;
+
+    for(;;) {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 510);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        client->buf[n2] = '\0';
+
+        if(NULL != strstr(client->buf, "__end__")) {
+            break;
+        }
+
+        p2 = client->buf;
+        p1 = strstr(p2, " ");
+        p2 = p1+1;
+        p1 = strstr(p2, " ");
+        *p1 = '=';
+
+        if(p2[n2-1] != '\n') {
+            printf("%s\n", p2);
+        } else {
+            printf("%s", p2);
+        }
+    }
+
+    return 0;
+}
+
+int parse_script_result(dbclient *client) {
+    int n1, n2;
+    char *p1, *p2;
+    char* magic = MAGIC;
+
+    for(;;) {
+        n1 = read_util(client, HEADER_PREFIX, 110);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        if(0 != memcmp(client->buf, magic, MAGIC_LEN)) {
+            //message error
+            return -3;
+        }
+
+        client->buf[HEADER_PREFIX-1] = '\0';
+        if(S2ISUCCESS != str2int(&n2, client->buf+MAGIC_LEN, 10)) {
+            //message error
+            return -4;
+        }
+
+        n1 = read_util(client, n2, 510);
+        if(n1 < 0) {
+            return n1;
+        }
+
+        client->buf[n2] = '\0';
+        if(NULL != strstr(client->buf, "__end__")) {
+            break;
+        }
+
+        p1 = client->buf + LIST_LEN;
+        p2 = strstr(p1, " ");
+        *p2 = '\0';
+        p2++;
+        if(client->buf[n2-1] == '\n') {
+            client->buf[n2-1] = '\0';
+        }
+        printf("export %s=\"%s\";", p1, p2);
+    }
+
+    return 0;
+}
+
+static void write_util(dbclient* client, int len) {
+    int n, writed_len = 0;
+    unsigned int now, timeout;
+    struct timeval tv,  tv2;
+
+    gettimeofday(&tv2, NULL);
+    timeout = (tv2.tv_sec * 1000) + (tv2.tv_usec / 1000) + 20;
+
+    while(writed_len < len) {
+        n = write(client->remote_fd, client->buf + writed_len, len-writed_len);
+        if(n < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                gettimeofday(&tv, NULL);
+                now = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+                fprintf(stderr, "timeout\n");
+                if(now > timeout) {
+                    break;
+                }
+
+                usleep(5);
+                continue;
+            }
+        }
+        writed_len += n;
+    }
+
+    if(writed_len != len) {
+        fprintf(stderr, "write error\n");
+        exit(1);
+    }
+}
+
+static void bulk_key(dbclient* client, char* command, char* prefix, char* envp[]) {
+    char** env;
+    char *p1, *p2;
+    int n1, n2, nenv, nc, nkey, np = strlen(prefix);
+
+    //print_time("begin writing");
+    strcpy(client->command, command);
+    nc = strlen(client->command);
+    for (env = envp; *env != 0; env++) {
+        p1 = *env;
+        if(strncmp(p1, prefix, np)) {
+            continue;
+        }
+
+        nenv = strlen(p1);
+        n1 = nc + nenv + 2;
+        check_buf(client, n1 + HEADER_PREFIX);
+
+        n2 = sprintf(client->buf, "%s%07d %s ", MAGIC, n1, client->command);
+
+        p2 = strstr(p1, "=");
+        nkey = (p2-p1);
+        memcpy(client->buf+n2, p1, nkey);
+        p2++;
+        client->buf[n2+nkey] = ' ';
+        strcpy(client->buf+n2+nkey+1, p2);
+
+        client->buf[n1+HEADER_PREFIX] = '\0';
+        client->buf[n1+HEADER_PREFIX-1] = '\n';
+        //print_time("writing");
+        //write(client->remote_fd, client->buf, n1 + HEADER_PREFIX);
+        write_util(client,  n1 + HEADER_PREFIX);
+        //print_time("writed");
+    }
+}
+
+static void help(void) {
+    printf("help:\n");
+    printf("dbus set key=value\n");
+    printf("dbus ram key=value\n");
+    printf("dbus replace key=value\n");
+    printf("dbus get key\n");
+    printf("dbus list key\n");
+    printf("dbus remove key\n");
+    printf("dbus export key\n");
+    printf("dbus update key\n");
+    printf("dbus delay key tick path_of_shell.sh\n");
+    printf("dbus time key H:M:S path_of_shell.sh\n");
+    printf("dbus fire key\n");
+    printf("dbus event key path_of_shell.sh\n");
+    printf("dbus inc key=value\n");
+    printf("dbus desc key=value\n");
+}
+
+static int prefix_set_command(dbclient* client, int argc, char **argv)
+{
+    int i, n1, n2;
+    char* p;
+    n1 = strlen(client->command) + argc - 1;
+    for(i = 2; i < argc; i++) {
+        n1 += strlen(argv[i]);
+    }
+    //n1 = strlen(client->command) + strlen(argv[2]) + strlen(argv[3]) + 3;
+    check_buf(client, n1 + HEADER_PREFIX);
+    //n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s %s\n", MAGIC, n1, client->command, argv[2], argv[3]);
+    n2 = snprintf(client->buf, client->buf_max, "%s%07d %s ", MAGIC, n1, client->command);
+    for(i = 2; i < argc; i++) {
+        strcpy(client->buf+n2, argv[i]);
+        n2 += strlen(argv[i]);
+        if(i == (argc-1)) {
+            client->buf[n2] = '\n';
+        } else {
+            client->buf[n2] = ' ';
+        }
+        n2++;
+    }
+    p = strstr(client->buf, "=");
+    //assert(NULL != p);
+    *p = ' ';
+
+    return n2;
+}
+
+dbclient* gclient;
+int main(int argc, char **argv, char * envp[])
+{
+    int n1, n2, err = 0;
+    struct tm tm1;
+    dbclient* client;
+    int remote_fd;
+
+    //print_time("start");
+
+    remote_fd = create_client_fd("/tmp/.skipd_server_sock");
+    if(-1 == remote_fd) {
+#if 0
+        //Try to restart skipd
+        system("service start_skipd >/dev/null 2>&1 &");
+        sleep(1);
+        remote_fd = create_client_fd("/tmp/.skipd_server_sock");
+        if(-1 == remote_fd) {
+            perror("connect to skipd error");
+            return -1;
+        }
+#else
+        perror("connect to skipd error");
+        return -1;
+#endif
+    }
+    gclient = (dbclient*)calloc(1, sizeof(dbclient));
+    gclient->remote_fd = remote_fd;
+    client = gclient;
+
+    do {
+        if(argc < 2) {
+            err = -11;
+            break;
+        }
+        if(!strcmp("list", argv[1])) {
+            if(argc < 3) {
+                err = -12;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n1 = strlen(argv[2]) + 2 + strlen(client->command);
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s\n", MAGIC, n1, client->command, argv[2]);
+            write(remote_fd, client->buf, n2);
+
+            setnonblock(remote_fd);
+            n1 = parse_list_result(gclient);
+        } else if(!strcmp("export", argv[1])) {
+            strcpy(client->command, "list");
+            n1 = strlen(argv[2]) + 2 + strlen(client->command);
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s\n", MAGIC, n1, client->command, argv[2]);
+            write(remote_fd, client->buf, n2);
+
+            setnonblock(remote_fd);
+            n1 = parse_script_result(gclient);
+        } else if(!strcmp("update", argv[1])) {
+            if(argc < 3) {
+                err = -13;
+                break;
+            }
+            bulk_key(gclient, "replace", argv[2], envp);
+        } else if(!strcmp("save", argv[1])) {
+            if(argc < 3) {
+                err = -13;
+                break;
+            }
+            bulk_key(gclient, "set", argv[2], envp);
+        } else if(!strcmp("get", argv[1])) {
+            if(argc < 3) {
+                err = -13;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n1 = strlen(argv[2]) + 2 + strlen(client->command);
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s\n", MAGIC, n1, client->command, argv[2]);
+            write(remote_fd, client->buf, n2);
+
+            setnonblock(remote_fd);
+            n1 = parse_get_result(gclient);
+        } else if(!strcmp("remove", argv[1])) {
+            if(argc < 3) {
+                err = -14;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n1 = strlen(argv[2]) + 2 + strlen(client->command);
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s\n", MAGIC, n1, client->command, argv[2]);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(gclient);
+        } else if(!strcmp("fire", argv[1])) {
+            if(argc < 3) {
+                err = -15;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n1 = strlen(argv[2]) + 2 + strlen(client->command);
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s\n", MAGIC, n1, client->command, argv[2]);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(gclient);
+        } else if(!strcmp("set", argv[1])) {
+            if((argc < 3) || (NULL == strstr(argv[2], "="))) {
+                err = -16;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n2 = prefix_set_command(client, argc, argv);
+            //print_time("started");
+            write(remote_fd, client->buf, n2);
+            //print_time("end");
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        } else if(!strcmp("inc", argv[1])) {
+            if((argc < 3) || (NULL == strstr(argv[2], "="))) {
+                err = -16;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n2 = prefix_set_command(client, argc, argv);
+            write(remote_fd, client->buf, n2);
+
+            setnonblock(remote_fd);
+            n1 = parse_get_result(gclient);
+        } else if(!strcmp("desc", argv[1])) {
+            if((argc < 3) || (NULL == strstr(argv[2], "="))) {
+                err = -16;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n2 = prefix_set_command(client, argc, argv);
+            write(remote_fd, client->buf, n2);
+
+            setnonblock(remote_fd);
+            n1 = parse_get_result(gclient);
+        } else if(!strcmp("ram", argv[1])) {
+            if((argc < 3) || (NULL == strstr(argv[2], "="))) {
+                err = -16;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n2 = prefix_set_command(client, argc, argv);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        } else if(!strcmp("replace", argv[1])) {
+            if((argc < 3) || (NULL == strstr(argv[2], "="))) {
+                err = -16;
+                break;
+            }
+            strcpy(client->command, argv[1]);
+            n2 = prefix_set_command(client, argc, argv);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        } else if(!strcmp("event", argv[1])) {
+            if(argc < 4) {
+                err = -18;
+                break;
+            }
+            strcpy(client->command, "set");
+            n1 = strlen(client->command) + strlen(argv[2]) + strlen(argv[3]) + 3 + 9;
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s __event__%s %s\n", MAGIC, n1, client->command, argv[2], argv[3]);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        } else if(!strcmp("delay", argv[1])) {
+            if(argc < 5) {
+                err = -19;
+                break;
+            }
+            if(S2ISUCCESS != str2int(&n2, argv[3], 10)) {
+                err = -20;
+                break;
+            }
+
+            strcpy(client->command, argv[1]);
+            n1 = strlen(client->command) + strlen(argv[2]) + strlen(argv[3]) + strlen(argv[4]) + 4;
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s %s %s\n", MAGIC, n1, client->command, argv[2], argv[3], argv[4]);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        } else if(!strcmp("time", argv[1])) {
+            if(argc < 5) {
+                err = -21;
+                break;
+            }
+
+            if(NULL == strptime(argv[3], "%H:%M:%S", &tm1)) {
+                err = -22;
+                break;
+            }
+
+            strcpy(client->command, argv[1]);
+            n1 = strlen(client->command) + strlen(argv[2]) + strlen(argv[3]) + strlen(argv[4]) + 4;
+            check_buf(client, n1 + HEADER_PREFIX);
+            n2 = snprintf(client->buf, client->buf_max, "%s%07d %s %s %s %s\n", MAGIC, n1, client->command, argv[2], argv[3], argv[4]);
+            write(remote_fd, client->buf, n2);
+
+            //setnonblock(remote_fd);
+            //n1 = parse_common_result(client);
+        }
+    } while(0);
+    if(err < 0) {
+        help();
+    }
+
+    close(remote_fd);
+    if(NULL != gclient->buf) {
+        free(gclient->buf);
+    }
+    return 0;
+}
+
diff --git a/release/src/router/skipdbv2/mgr/skipd.c b/release/src/router/skipdbv2/mgr/skipd.c
new file mode 100644
index 0000000000..616c4c335c
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/skipd.c
@@ -0,0 +1,1506 @@
+#define _XOPEN_SOURCE
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <getopt.h>
+#include <limits.h> // [LONG|INT][MIN|MAX]
+#include <errno.h>  // errno
+#include <string.h>
+#include <signal.h>
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <sys/time.h>
+#include <time.h>
+#include <sys/un.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <ev.h>
+
+#include "coroutine.h"
+#include "SkipDB.h"
+#include "skipd.h"
+
+typedef struct _skipd_server {
+    ev_io io;
+    int fd;
+    struct sockaddr_un socket;
+    int socket_len;
+
+    ev_timer watcher;
+    int to_commit;
+
+    SkipDB *db;
+    int curr_db;
+    int switch_mark;
+    int in_doing;
+
+    int daemon;
+    char db_path[SK_PATH_MAX];
+    char sock_path[SK_PATH_MAX];
+    char pid_path[SK_PATH_MAX];
+} skipd_server;
+
+/* enum skipd_client_state {
+    client_state_read = 0,
+    client_state_write,
+    client_state_closing
+}; */
+
+enum ccr_break_state {
+    ccr_break_continue = 0,
+    ccr_break_curr,
+    ccr_break_all,
+    ccr_break_killed
+};
+
+enum ccr_error_code {
+    ccr_error_err1 = -1,
+    ccr_error_err2 = -2,
+    ccr_error_err3 = -3,
+    ccr_error_ok = 0, /* 此命令暂时中断，需等待再次执行 */
+    ccr_error_ok1 = 1, /* 此命令成功结束执行 */
+    ccr_error_ok2 = 2
+};
+
+typedef struct _skipd_client {
+    ev_io io_read;
+    ev_io io_write;
+
+    struct ccrContextTag ccr_read;
+    struct ccrContextTag ccr_write;
+    struct ccrContextTag ccr_process;
+    struct ccrContextTag ccr_runcmd;
+    int break_level;
+
+    int fd;
+
+    char* command;
+    char* key;
+    int data_len;
+
+    char* origin;
+    int origin_len;
+    int read_len;
+    int read_pos;
+
+    char* send;
+    int send_max;
+    int send_len;
+    int send_pos;
+
+    skipd_server* server;
+} skipd_client;
+
+typedef struct _delay_cmd {
+    ev_timer watcher;
+    char key[DELAY_KEY_LEN + DELAY_PREFIX_LEN];
+    int tick;
+
+    skipd_server* server;
+} delay_cmd;
+
+typedef struct _time_cmd {
+    ev_timer watcher;
+    char key[DELAY_KEY_LEN + DELAY_PREFIX_LEN];
+
+    skipd_server* server;
+} time_cmd;
+
+/* declare */
+extern int SkipDB_maxPos(SkipDB* self);
+extern SkipDBRecord* SkipDB_list_first(SkipDB* self, Datum k, SkipDBCursor** pcur);
+extern SkipDBRecord* SkipDB_list_next(SkipDB* self, Datum k, SkipDBCursor* cursor);
+static void server_sync(EV_P_ skipd_server* server);
+static void server_switch(skipd_server* server);
+
+void skipd_daemonize(char * path);
+static int setnonblock(int fd);
+static int client_ccr_process(EV_P_ skipd_client* client);
+static int client_ccr_write(EV_P_ skipd_client* client);
+
+char* global_magic = MAGIC;
+skipd_server* global_server;
+ev_signal signal_watcher;
+ev_signal signal_watcher2;
+
+#define STATIC_BUF_LEN 511
+char static_buffer[STATIC_BUF_LEN+1];
+
+#if 0
+static void print_time(char* prefix)
+{
+    struct timeval tv;
+    unsigned int ms;
+
+    gettimeofday (&tv, NULL);
+    ms = (tv.tv_sec * 1000) + (tv.tv_usec / 1000);
+    printf("%s: %03u\n", prefix, ms);
+}
+#endif
+
+static void sigint_cb (EV_P_ ev_signal *w, int revents) {
+    ev_signal_stop (EV_A_ w);
+    ev_break(EV_A_ EVBREAK_ALL);
+}
+
+void sys_script(char *cmd) {
+    if(NULL == cmd) {
+        return;
+    }
+
+    snprintf(static_buffer, STATIC_BUF_LEN, "%s > /tmp/skipd.log 2>&1 &\n", cmd);
+    system(static_buffer);
+    strcpy(static_buffer, ""); // Ensure we don't re-execute it again
+}
+
+int log_level = LOG_ERR;
+void emit_log(int level, char* line) {
+    //TODO for level
+    int syslog_level = LOG_ERR;
+    syslog(syslog_level, "%s", line);
+    //printf("%s", line);
+}
+
+void _skipd_logv(int filter, const char *format, va_list vl)
+{
+	char buf[256];
+
+        //TODO for log_evel
+	/* if (!(log_level & filter)) {
+	    return;
+        } */
+
+	vsnprintf(buf, sizeof(buf), format, vl);
+	buf[sizeof(buf) - 1] = '\0';
+
+	emit_log(filter, buf);
+}
+
+void skipd_log(int filter, const char *format, ...)
+{
+	va_list ap;
+
+	va_start(ap, format);
+	_skipd_logv(filter, format, ap);
+	va_end(ap);
+}
+
+static void client_release(EV_P_ skipd_client* client) {
+    //skipd_log(SKIPD_DEBUG, "closing client\n");
+
+    ev_io_stop(EV_A_ &client->io_read);
+    ev_io_stop(EV_A_ &client->io_write);
+    close(client->fd);
+
+    if(NULL != client->send) {
+        free(client->send);
+    }
+
+    if(NULL != client->origin) {
+        free(client->origin);
+    }
+
+    free(client);
+}
+
+static void client_read_inner(EV_P_ skipd_client* client, int revents) {
+    int rt;
+
+    //process command
+    assert(client->break_level == 0);
+
+    rt = client_ccr_process(EV_A_ client);
+    //skipd_log(SKIPD_DEBUG, "process:%d\n", rt);
+    if(ccr_error_err1 == rt) {
+        //Close it directly
+        client_release(EV_A_ client);
+    } else if(ccr_error_ok == rt) {
+        //Just continue
+        client->break_level = 0;
+    } else if(rt < 0) {
+        if(ccr_break_killed == client->break_level) {
+            //wait for waiting completely
+            if(0 == client->send_len) {
+                //close it
+                client_release(EV_A_ client);
+            } else {
+                memset(&client->ccr_process, 0, sizeof(struct ccrContextTag));
+            }
+        }
+    } else if(rt > 0) {
+        //OK and than reset
+        memset(&client->ccr_process, 0, sizeof(struct ccrContextTag));
+        client->break_level = 0;
+    }
+}
+
+// This callback is called when client data is available
+static void client_read(EV_P_ ev_io *w, int revents) {
+    skipd_client* client = container_of(w, skipd_client, io_read);
+    client_read_inner(EV_A_ client, revents);
+}
+
+static void client_write(EV_P_ ev_io *w, int revents) {
+    skipd_client* client = container_of(w, skipd_client, io_write);
+    int rt;
+
+    //skipd_log(SKIPD_DEBUG, "begin for writing\n");
+
+    rt = client_ccr_write(EV_A_ client);
+    if(ccr_break_killed == client->break_level) {
+        client_release(EV_A_ client);
+    } else {
+            // rt > 0, So reset it
+            memset(&client->ccr_write, 0, sizeof(struct ccrContextTag));
+            client->break_level = 0;
+
+            //change to read state directly,
+            //如果read过程还有资源未释放，跳回read进行资源释放
+            //event_active(&client->io_read, EV_READ, 0);
+            client_read_inner(EV_A_ client, 0);
+    }
+
+    //TODO void event_active (struct event *ev, int res, short ncalls)
+}
+
+static void delay_cmd_cb(EV_P_ ev_timer* watcher, int revents) {
+    char* p1;
+    int tmpi;
+    delay_cmd* delay_obj = container_of(watcher, delay_cmd, watcher);
+    Datum dkey = Datum_FromCString_(delay_obj->key);
+    Datum dvalue = SkipDB_at_(delay_obj->server->db, dkey);
+    do {
+        if(NULL == dvalue.data) {
+            skipd_log(SKIPD_DEBUG, "delay cmd:%s, dvalue.data is null\n", dkey.data);
+            break;
+        }
+
+        p1 = strstr((char*)dvalue.data, " ");
+        if(NULL == p1) {
+            skipd_log(SKIPD_DEBUG, "delay cmd:%s, dvalue.data error\n", dkey.data);
+            break;
+        }
+
+        tmpi = (unsigned char*)p1 - dvalue.data;
+        if(tmpi > STATIC_BUF_LEN) {
+            skipd_log(SKIPD_DEBUG, "delay cmd:%s, dvalue.data error\n", dkey.data);
+            break;
+        }
+        memcpy(static_buffer, dvalue.data, tmpi);
+        static_buffer[tmpi] = '\0';
+        if(S2ISUCCESS != str2int(&tmpi, static_buffer, 10)) {
+            skipd_log(SKIPD_DEBUG, "delay cmd:%s, str2int error\n", dkey.data);
+            break;
+        }
+
+        p1++;
+        sys_script(p1);
+        if(0 == tmpi) {
+            skipd_log(SKIPD_DEBUG, "delay cmd:%s, delay delete, tmpi = 0\n", dkey.data);
+            break;
+        }
+
+        delay_obj->tick = tmpi;
+        watcher->repeat = tmpi;
+        ev_timer_again(EV_A_ watcher);
+        return;
+
+    } while(0);
+
+    ev_timer_stop(EV_A_ watcher);
+    free(delay_obj);
+}
+
+static void time_cmd_cb(EV_P_ ev_timer* watcher, int revents) {
+    char* p1;
+    time_cmd* time_obj = container_of(watcher, time_cmd, watcher);
+    Datum dkey = Datum_FromCString_(time_obj->key);
+    Datum dvalue = SkipDB_at_(time_obj->server->db, dkey);
+    do {
+        if(NULL == dvalue.data) {
+            skipd_log(SKIPD_DEBUG, "time %s not found\n", dkey.data);
+            ev_timer_stop(EV_A_ watcher);
+            free(time_obj);
+            break;
+        }
+
+        p1 = strstr((char*)dvalue.data, " ");
+        if(NULL == p1) {
+            skipd_log(SKIPD_DEBUG, "time %s value error\n", dkey.data);
+            ev_timer_stop(EV_A_ watcher);
+            free(time_obj);
+            break;
+        }
+        p1++;
+
+        sys_script(p1);
+        ev_timer_again(EV_A_ watcher);
+    } while(0);
+
+}
+
+static int client_send_key(EV_P_ skipd_client* client, char* cmd, char* key, char* buf, int len) {
+    char pref_buf[HEADER_PREFIX+1];
+    int n, resp_len = (len + 2);
+
+    memcpy(pref_buf, global_magic, MAGIC_LEN);
+
+    resp_len += strlen(cmd);
+    resp_len += strlen(key);
+
+    sprintf(pref_buf + MAGIC_LEN, "%07d ", resp_len);
+    resp_len += HEADER_PREFIX;
+
+    if(NULL == client->send) {
+        client->send = (char*)malloc(BUF_MAX+1);
+        client->send_max = BUF_MAX;
+        client->send_len = 0;
+    }
+
+    if(resp_len > client->send_max) {
+        free(client->send);
+        client->send = (char*)malloc(resp_len);
+        client->send_max = resp_len;
+        client->send_len = 0;
+    }
+
+    memcpy(client->send, pref_buf, HEADER_PREFIX);
+    n = sprintf(client->send + HEADER_PREFIX, "%s %s ", cmd, key);
+    memcpy(client->send + HEADER_PREFIX + n, buf, len);
+    client->send[resp_len] = '\0';
+    client->send_len = resp_len;
+    client->send_pos = 0;
+
+    //switch to read state
+    memset(&client->ccr_write, 0, sizeof(struct ccrContextTag));
+    ev_io_stop(EV_A_ &client->io_read);
+    ev_io_start(EV_A_ &client->io_write);
+
+    return 0;
+}
+
+static int client_send(EV_P_ skipd_client* client, char* buf, int len) {
+    return client_send_key(EV_A_ client
+            , (NULL == client->command ? "errcmd": client->command)
+            , (NULL == client->key ? "errkey": client->key)
+            , buf, len);
+}
+
+static int client_ccr_write(EV_P_ skipd_client* client) {
+    struct ccrContextTag* ctx = &client->ccr_write;
+
+    //stack
+    ccrBeginContext
+    int n;
+    ccrEndContext(ctx);
+
+    ccrBegin(ctx);
+    while(client->send_pos < client->send_len) {
+        //use send instead of write
+        CS->n = write(client->fd, client->send + client->send_pos, client->send_len - client->send_pos);
+        //CS->n = send(client->fd, client->send + client->send_pos, client->send_len - client->send_pos, 0);
+        if(CS->n <= 0) {
+            if(errno == EINTR || errno == EAGAIN) {
+                ccrReturn(ctx, ccr_error_ok);
+            } else {
+                //TODO fixme
+                client->send_len = 0;
+                client->send_pos = 0;
+                ev_io_stop(EV_A_ &client->io_write);
+                ev_io_start(EV_A_ &client->io_read);
+
+                ccrStop(ctx, ccr_error_err1);
+            }
+        }
+
+        if((client->send_len -= CS->n) > 0) {
+            //write again
+            client->send_pos += CS->n;
+            ccrReturn(ctx, ccr_error_ok);
+        } else {
+            //Finished write
+            client->send_len = 0;
+            client->send_pos = 0;
+            ev_io_stop(EV_A_ &client->io_write);
+            ev_io_start(EV_A_ &client->io_read);
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+    }
+    ccrFinish(ctx, ccr_error_ok1);
+}
+
+/* static void client_read_fix(skipd_client* client) {
+    if(client->read_len > client->read_pos) {
+        memmove(client->origin, client->origin + client->read_pos + 1, client->read_len - client->read_pos - 1);
+    }
+    client->read_len -= client->read_pos + 1;
+    client->read_pos = 0;
+} */
+
+static int client_ccr_read_util(skipd_client* client, int step_len) {
+    int buf_len;
+    struct ccrContextTag* ctx = &client->ccr_read;
+
+    //stack
+    ccrBeginContext
+    int n;
+    int left;
+    ccrEndContext(ctx);
+
+    ccrBegin(ctx);
+
+    if(step_len > READ_MAX) {
+        ccrReturn(ctx, ccr_error_err2);
+    }
+
+    buf_len = _max(step_len, BUF_MAX);
+    if(buf_len > client->origin_len) {
+        if(NULL != client->origin) {
+            free(client->origin);
+        }
+        client->origin = (char*)malloc(buf_len + 1);
+        client->origin_len = buf_len;
+        client->origin[client->origin_len] = '\0';
+    }
+    client->read_pos = 0;
+    client->read_len = 0;
+
+    for(;;) {
+        CS->left = step_len - client->read_len;
+        assert(0 != CS->left);
+
+        CS->n = recv(client->fd, client->origin + client->read_len, CS->left, 0);
+        if (0 == CS->n) {
+            //client closed
+            ccrReturn(ctx, ccr_error_err1);
+        } else if(CS->n < 0) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                client->break_level = ccr_break_all;
+                ccrReturn(ctx, ccr_error_ok);
+            } else {
+                ccrReturn(ctx, ccr_error_err1);
+            }
+        } else {
+            client->read_len += CS->n;
+            if(client->read_len == step_len) {
+                break;
+            }
+        }
+    }
+    ccrFinish(ctx, ccr_error_ok1);
+}
+
+static int client_run_command(EV_P_ skipd_client* client)
+{
+    char *p1, *p2;
+    time_t t1, t2, epoch;
+    int tmpi, tmp2;
+    struct tm tm1, tm2, *tnow;
+    Datum dkey, dvalue;
+    delay_cmd* delay_obj;
+    time_cmd* time_obj;
+    struct ccrContextTag* ctx = &client->ccr_read;
+
+    //stack
+    ccrBeginContext
+    int n;
+    SkipDBCursor* cursor;
+    SkipDBRecord* record;
+    Datum skey;
+    ccrEndContext(ctx);
+
+    ccrBegin(ctx);
+
+    p1 = client->origin;
+    p2 = strstr(p1, " ");
+    if(NULL == p2) {
+        ccrStop(ctx, ccr_error_err2);
+    }
+    *p2 = '\0';
+    client->command = p1;
+
+    if(!strcmp(client->command, "set")) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+        dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+
+        //OK a little hack hear
+        //print_time("beginset");
+        SkipDB_beginTransaction(client->server->db);
+        SkipDB_at_put_(client->server->db, dkey, dvalue);
+        //SkipDB_commitTransaction(client->server->db);
+	    //SkipDB_sync(client->server->db);
+        server_sync(EV_A_ client->server);
+        //print_time("endset");
+
+        p1 = "ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "ram")) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+        dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+        SkipDB_at_put_(client->server->db, dkey, dvalue);
+
+        p1 = "ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "get")) {
+        p1 = p2+1;
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+        dvalue = SkipDB_at_(client->server->db, dkey);
+        if(NULL == dvalue.data) {
+            p1 = "none\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+        } else {
+            client_send(EV_A_ client, (char*)dvalue.data, dvalue.size);
+        }
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "replace")) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+        /* dvalue = SkipDB_at_(client->server->db, dkey);
+        if(NULL == dvalue.data) {
+            p1 = "none\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+        } else {
+            //exists replace it
+            client_send(EV_A_ client, (char*)dvalue.data, dvalue.size);
+            dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+            SkipDB_beginTransaction(client->server->db);
+            SkipDB_at_put_(client->server->db, dkey, dvalue);
+            //SkipDB_commitTransaction(client->server->db);
+            server_sync(EV_A_ client->server);
+        } */
+        dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+        SkipDB_beginTransaction(client->server->db);
+        if(SkipDB_replace_put_(client->server->db, dkey, dvalue)) {
+            //exists
+            client_send(EV_A_ client, (char*)dvalue.data, dvalue.size);
+        } else {
+            p1 = "none\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+        }
+        server_sync(EV_A_ client->server);
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "list")) {
+        p1 = p2+1;
+        client->key = p1;
+        p1 = p2+1;
+
+        client->server->in_doing++;
+        CS->skey = Datum_FromCString_(client->key);
+        CS->record = SkipDB_list_first(client->server->db, CS->skey, &CS->cursor);
+        while(NULL != CS->record) {
+            dkey = SkipDBRecord_keyDatum(CS->record);
+            dvalue = SkipDBRecord_valueDatum(CS->record);
+            client_send_key(EV_A_ client, client->command, (char*)dkey.data, (char*)dvalue.data, dvalue.size);
+            ccrReturn(ctx, ccr_error_ok);
+
+            CS->record = SkipDB_list_next(client->server->db, CS->skey, CS->cursor);
+        }
+
+        //send end
+        p1 = "__end__\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok);
+
+        if(NULL != CS->cursor) {
+            SkipDBCursor_release(CS->cursor);
+        }
+        client->server->in_doing--;
+
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "remove")) {
+        p1 = p2+1;
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+
+        SkipDB_beginTransaction(client->server->db);
+        SkipDB_removeAt_(client->server->db, dkey);
+        //SkipDB_commitTransaction(client->server->db);
+        server_sync(EV_A_ client->server);
+        p1 = "ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "delay")) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        if(strlen(client->key) >= DELAY_KEY_LEN) {
+            p1 = "key too big\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+        //dvalue.data[dvalue.size-1] = '\0';
+        //FIXEM hard code hear
+        if(strlen((char*)dvalue.data) >= 300) {
+            p1 = "value too big\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        p2  = strstr(p1, " ");
+        if(NULL == p2) {
+            p1 = "value param error\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+        tmpi = (int)(p2 - p1);
+        memcpy(static_buffer, p1, tmpi);
+        static_buffer[tmpi] = '\0';
+        if(S2ISUCCESS != str2int(&tmpi, static_buffer, 10)) {
+            p1 = "delay tick error\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        //All ok, we create a delay object
+        delay_obj = calloc(1, sizeof(delay_cmd));
+        sprintf(delay_obj->key, "__delay__%s", client->key);
+        client->key = delay_obj->key;
+        delay_obj->tick = tmpi;
+        delay_obj->server = client->server;
+
+        dkey = Datum_FromCString_(client->key);
+        /* if(SkipDB_exists(client->server->db, dkey)) {
+            p1 = "exists\n";
+            free(delay_obj);
+            client_send(EV_A_ client, p1, strlen(p1));
+
+            //Just replace the old
+            SkipDB_beginTransaction(client->server->db);
+            SkipDB_at_put_(client->server->db, dkey, dvalue);
+            //SkipDB_commitTransaction(client->server->db);
+            server_sync(EV_A_ client->server);
+            ccrReturn(ctx, ccr_error_ok1);
+        } */
+
+        SkipDB_beginTransaction(client->server->db);
+        if(SkipDB_at_put_(client->server->db, dkey, dvalue)) {
+            p1 = "exists\n";
+            free(delay_obj);
+            client_send(EV_A_ client, p1, strlen(p1));
+
+            server_sync(EV_A_ client->server);
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+        //SkipDB_commitTransaction(client->server->db);
+        server_sync(EV_A_ client->server);
+
+        ev_timer_init(&delay_obj->watcher, delay_cmd_cb, delay_obj->tick, delay_obj->tick);
+        ev_timer_start(EV_A_ &delay_obj->watcher);
+
+        p1 = "delay_ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if(!strcmp(client->command, "time")) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        if(strlen(client->key) >= DELAY_KEY_LEN) {
+            p1 = "key too big\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            p1 = "value error\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+        tmpi = (int)(p2 - p1);
+        memcpy(static_buffer, p1, tmpi);
+        static_buffer[tmpi] = '\0';
+
+        if (strptime(static_buffer, "%H:%M:%S", &tm1) != NULL) {
+            epoch = mktime(&tm1);
+        } else {
+            p1 = "time error\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        dvalue = Datum_FromData_length_((unsigned char*)p1, client->data_len - (p1 - client->origin));
+        //dvalue.data[dvalue.size-1] = '\0';
+        //FIXEM hard code hear
+        if(strlen((char*)dvalue.data) >= 300) {
+            p1 = "value too big\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+
+        time_obj = calloc(1, sizeof(time_cmd));
+        sprintf(time_obj->key, "__time__%s", client->key);
+        //TODO time_obj will be free?
+        client->key = time_obj->key;
+        dkey = Datum_FromCString_(client->key);
+        /*if(SkipDB_exists(client->server->db, dkey)) {
+            p1 = "exists\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            free(time_obj);
+            ccrReturn(ctx, ccr_error_ok1);
+        }*/
+
+        SkipDB_beginTransaction(client->server->db);
+        if(SkipDB_at_put_(client->server->db, dkey, dvalue)) {
+            p1 = "exists\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            free(time_obj);
+
+            server_sync(EV_A_ client->server);
+            ccrReturn(ctx, ccr_error_ok1);
+        }
+        //SkipDB_commitTransaction(client->server->db);
+        server_sync(EV_A_ client->server);
+
+        t1 = time(NULL);
+        tnow = localtime(&t1);
+        tm2 = *tnow;
+        tm2.tm_sec = tm1.tm_sec;
+        tm2.tm_min = tm1.tm_min;
+        tm2.tm_hour = tm1.tm_hour;
+        t2 = mktime(&tm2);
+        time_obj->server = client->server;
+        if(t2 <= t1) {
+            ev_timer_init(&time_obj->watcher, time_cmd_cb, (t1-t2+24*3600), 24*3600);
+            ev_timer_start(EV_A_ &time_obj->watcher);
+        } else {
+            ev_timer_init(&time_obj->watcher, time_cmd_cb, (t2-t1), 24*3600);
+            ev_timer_start(EV_A_ &time_obj->watcher);
+        }
+        p1 = "ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok1);
+
+    } else if(!strcmp(client->command, "fire")) {
+        p1 = p2+1;
+        //TODO check length hear
+        client->key = (char*)malloc(DELAY_KEY_LEN*2);
+        sprintf(client->key, "/usr/bin/%s.sh", p1);
+        if(-1 != access(client->key, F_OK)) {
+            //file exist, than run script
+            sys_script(client->key);
+
+            //send end
+            p1 = "ok\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            free(client->key);
+            ccrReturn(ctx, ccr_error_ok1);
+        } else {
+            sprintf(client->key, "/jffs/scripts/%s.sh", p1);
+            if(-1 != access(client->key, F_OK)) {
+                //file exist, than run script
+                sys_script(client->key);
+
+                //send end
+                p1 = "ok\n";
+                client_send(EV_A_ client, p1, strlen(p1));
+                free(client->key);
+                ccrReturn(ctx, ccr_error_ok1);
+            }
+        }
+
+        sprintf(client->key, "__event__%s", p1);
+        p1 = p2+1;
+
+        CS->n = 0;
+        CS->skey = Datum_FromCString_(client->key);
+        client->server->in_doing++;
+        CS->record = SkipDB_list_first(client->server->db, CS->skey, &CS->cursor);
+        while(NULL != CS->record) {
+            dkey = SkipDBRecord_keyDatum(CS->record);
+            dvalue = SkipDBRecord_valueDatum(CS->record);
+            sys_script((char*)dvalue.data);
+
+            CS->record = SkipDB_list_next(client->server->db, CS->skey, CS->cursor);
+            CS->n++;
+        }
+
+        //send end
+        p1 = "ok\n";
+        client_send(EV_A_ client, p1, strlen(p1));
+        ccrReturn(ctx, ccr_error_ok);
+
+        client->server->in_doing--;
+        if(NULL != CS->cursor) {
+            SkipDBCursor_release(CS->cursor);
+        }
+        free(client->key);
+
+        ccrReturn(ctx, ccr_error_ok1);
+    } else if((!strcmp(client->command, "inc")) || (!strcmp(client->command, "desc"))) {
+        p1 = p2+1;
+        p2 = strstr(p1, " ");
+        if(NULL == p2) {
+            ccrStop(ctx, ccr_error_err2);
+        }
+        *p2 = '\0';
+        client->key = p1;
+        p1 = p2+1;
+
+        dkey = Datum_FromCString_(client->key);
+
+        if(S2ISUCCESS != str2int(&tmpi, p1, 10)) {
+            p1 = "error\n";
+            client_send(EV_A_ client, p1, strlen(p1));
+            client->break_level = ccr_break_killed;
+            ccrStop(ctx, ccr_error_err2);
+        }
+
+        dvalue = SkipDB_at_(client->server->db, dkey);
+        if(NULL == dvalue.data) {
+            tmp2 = 0;
+        } else {
+            if(S2ISUCCESS != str2int(&tmp2, (char*)dvalue.data, 10)) {
+                p1 = "error\n";
+                client_send(EV_A_ client, p1, strlen(p1));
+                ccrReturn(ctx, ccr_error_ok1);
+            }
+        }
+
+        //TODO remote \n from data?
+        if(!strcmp(client->command, "inc")) {
+            sprintf(static_buffer, "%d", tmp2+tmpi);
+        } else {
+            sprintf(static_buffer, "%d", tmp2-tmpi);
+        }
+        dvalue = Datum_FromCString_(static_buffer);
+        SkipDB_at_put_(client->server->db, dkey, dvalue);
+        client_send(EV_A_ client, (char*)dvalue.data, dvalue.size);;
+        ccrReturn(ctx, ccr_error_ok1);
+    }
+
+    ccrFinish(ctx, ccr_error_err2);
+}
+
+static int client_ccr_process(EV_P_ skipd_client* client)
+{
+    char* p;
+    struct ccrContextTag* ctx = &client->ccr_process;
+
+    //stack
+    ccrBeginContext
+    int rt;
+    int n;
+    int left;
+    ccrEndContext(ctx);
+
+    ccrBegin(ctx);
+
+    for(;;) {
+
+        /* Sub routine */
+        memset(&client->ccr_read, 0, sizeof(struct ccrContextTag));
+        for(;;) {
+            CS->rt = client_ccr_read_util(client, HEADER_PREFIX);
+            if((ccr_error_err1 != CS->rt) && (CS->rt < 0)) {
+                /* socket not closed but has some other error*/
+                p = "command no found\n";
+                client_send(EV_A_ client, p, strlen(p));
+                client->break_level = ccr_break_killed;
+                ccrStop(ctx, CS->rt);
+            }
+
+            /* TODO if(client->break_level >= ccr_break_all) {
+                ccrReturn(ctx, CS->rt);
+            } else if(ccr_break_curr == client->break_level) {
+                client->break_level = ccr_break_continue;
+                ccrReturn(ctx, CS->rt);
+            } */
+
+            /* OK */
+            if(CS->rt > 0) {
+                break;
+            }
+            ccrReturn(ctx, CS->rt);
+        }
+
+        assert(CS->rt > 0);
+        if(0 != memcmp(client->origin, global_magic, MAGIC_LEN)) {
+            p = "magic not found\n";
+            client_send(EV_A_ client, p, strlen(p));
+            client->break_level = ccr_break_killed;
+            ccrStop(ctx, ccr_error_err2);
+        }
+
+        if(client->origin[HEADER_PREFIX-1] != ' ') {
+            p = "header prefix error\n";
+            client_send(EV_A_ client, p, strlen(p));
+            client->break_level = ccr_break_killed;
+            ccrStop(ctx, ccr_error_err2);
+        }
+        client->origin[HEADER_PREFIX-1] = '\0';
+
+        if(S2ISUCCESS != str2int(&client->data_len, client->origin+MAGIC_LEN, 10)) {
+            p = "data len error\n";
+            client_send(EV_A_ client, p, strlen(p));
+            client->break_level = ccr_break_killed;
+            ccrStop(ctx, ccr_error_err2);
+        }
+
+        /* Sub routine */
+        memset(&client->ccr_read, 0, sizeof(struct ccrContextTag));
+        for(;;) {
+            CS->rt = client_ccr_read_util(client, client->data_len);
+            if((ccr_error_err1 != CS->rt) && (CS->rt < 0)) {
+                p = "read data error\n";
+                client_send(EV_A_ client, p, strlen(p));
+                client->break_level = ccr_break_killed;
+                ccrStop(ctx, CS->rt);
+            }
+
+            if(CS->rt > 0) {
+                break;
+            }
+            ccrReturn(ctx, CS->rt);
+        }
+
+        assert(CS->rt > 0);
+        client->origin[client->data_len] = '\0';
+        //TODO must end with \n ?
+        if('\n' != client->origin[client->data_len-1]) {
+            p = "value error\n";
+            client_send(EV_A_ client, p, strlen(p));
+            client->break_level = ccr_break_killed;
+            ccrReturn(ctx, ccr_error_err2);
+        }
+        client->origin[client->data_len-1] = '\0';
+
+        // Command subroutine
+        memset(&client->ccr_runcmd, 0, sizeof(struct ccrContextTag));
+        for(;;) {
+            CS->rt = client_run_command(EV_A_ client);
+            if(CS->rt < 0) {
+                p = "run command error\n";
+                client_send(EV_A_ client, p, strlen(p));
+                client->break_level = ccr_break_killed;
+                ccrReturn(ctx, CS->rt);
+            }
+            if(CS->rt > 0) {
+                break;
+            }
+            ccrReturn(ctx, CS->rt);
+        }
+
+        /* Reset the read_len */
+        client->command = NULL;
+        client->key = NULL;
+        if(client->origin_len > BUF_MAX) {
+            free(client->origin);
+            client->origin = NULL;
+            client->origin_len = 0;
+        }
+    }
+    ccrFinish(ctx, ccr_error_ok1);
+}
+
+static skipd_client* client_new(int fd) {
+    //int opt = 0;
+    skipd_client* client = (skipd_client*)calloc(1, sizeof(skipd_client));
+    client->fd = fd;
+    client->send = NULL;
+    client->origin = NULL;
+
+    //setsockopt(client->fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+    setnonblock(client->fd);
+    ev_io_init(&client->io_read, client_read, client->fd, EV_READ);
+    ev_io_init(&client->io_write, client_write, client->fd, EV_WRITE);
+
+    return client;
+}
+
+// This callback is called when data is readable on the unix socket.
+static void server_cb(EV_P_ ev_io *w, int revents) {
+    int client_fd;
+    skipd_client* client;
+
+    skipd_server* server = container_of(w, skipd_server, io);
+
+    while (1) {
+        client_fd = accept(server->fd, NULL, NULL);
+        if( client_fd == -1 ) {
+            if( errno != EAGAIN && errno != EWOULDBLOCK ) {
+                skipd_log(SKIPD_DEBUG, "accept() failed errno=%i (%s)",  errno, strerror(errno));
+                exit(EXIT_FAILURE);
+            }
+            break;
+        }
+
+        //print_time("newclient");
+        client = client_new(client_fd);
+        client->server = server;
+        ev_io_start(EV_A_ &client->io_read);
+    }
+}
+
+// Simply adds O_NONBLOCK to the file descriptor of choice
+int setnonblock(int fd) {
+    int flags;
+
+    flags = fcntl(fd, F_GETFL);
+    flags |= O_NONBLOCK;
+    return fcntl(fd, F_SETFL, flags);
+}
+
+int unix_socket_init(struct sockaddr_un* socket_un, char* sock_path, int max_queue) {
+    int fd;
+    //int opt = 0;
+
+    unlink(sock_path);
+
+    // Setup a unix socket listener.
+    fd = socket(PF_UNIX, SOCK_STREAM, 0);
+    //fd = socketpair(AF_UNIX, SOCK_STREAM, 0);
+    if (-1 == fd) {
+        perror("echo server socket");
+        exit(EXIT_FAILURE);
+    }
+
+    //SOL_TCP
+    //setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt));
+    //opt = 1;
+    //setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, (void *)&opt, sizeof(int));
+
+    // Set it non-blocking
+    if (-1 == setnonblock(fd)) {
+        perror("echo server socket nonblock");
+        exit(EXIT_FAILURE);
+    }
+
+    // Set it as unix socket
+    socket_un->sun_family = AF_UNIX;
+    strcpy(socket_un->sun_path, sock_path);
+
+    return fd;
+}
+
+static void server_open(skipd_server* server) {
+    char real_path[SK_PATH_MAX];
+    char nbuf[10];
+    int n, sf;
+#if 0
+    sprintf(real_path, "%s/switch", server->db_path);
+    sf = open(real_path, O_RDONLY);
+    if(sf > 0) {
+        n = read(sf, nbuf, sizeof(nbuf));
+        close(sf);
+        if (n) {
+            n = atoi(nbuf);
+        }
+        server->curr_db = n;
+		skipd_log(SKIPD_DEBUG, "debug:read db:%s",nbuf);
+    }
+	if((server->curr_db != 0) && (server->curr_db != 1)){
+		skipd_log(SKIPD_DEBUG, "db:%d is wrong,reset to 0",server->curr_db);
+		server->curr_db = 0;
+	}
+    sf = open(real_path, O_TRUNC | O_RDWR | O_CREAT, 0640);
+    if (sf < 0) {
+        skipd_log(SKIPD_DEBUG, "cannot write swich file");
+        exit(1);
+    }
+    n = sprintf(nbuf, "%d", server->curr_db);
+    write(sf, nbuf, n);
+    close(sf);
+    skipd_log(SKIPD_DEBUG, "use path:%s db:%d",server->db_path,server->curr_db);
+#endif
+	server->curr_db = 0;
+    sprintf(real_path, "%s/%d", server->db_path, server->curr_db);
+    server->db = SkipDB_new();
+    SkipDB_setPath_(server->db, real_path);
+    //syslog(LOG_PERROR, "LOG HEAR:%s\n", server->db_path);
+    SkipDB_open(server->db);
+}
+
+static void server_switch(skipd_server* server) {
+    char real_path[SK_PATH_MAX];
+    char nbuf[10];
+    int n1, n2, sf;
+    SkipDB *tmp, *other = SkipDB_new();
+    n2 = 1 - server->curr_db;
+    sprintf(real_path, "%s/%d", server->db_path, n2);
+    SkipDB_setPath_(other, real_path);
+    SkipDB_delete(other);
+    SkipDB_open(other);
+
+    SkipDB_mergeInto_(server->db, other);
+    SkipDB_beginTransaction(other);
+    SkipDB_commitTransaction(other);
+
+    tmp = server->db;
+    sprintf(real_path, "%s/switch", server->db_path);
+    sf = open(real_path, O_TRUNC | O_RDWR | O_CREAT, 0640);
+    if (sf < 0) {
+        skipd_log(SKIPD_DEBUG, "cannot write swich file");
+        exit(1);
+    }
+    n1 = sprintf(nbuf, "%d", n2);
+    write(sf, nbuf, n1);
+    close(sf);
+
+    server->db = other;
+    server->curr_db = n2;
+    SkipDB_delete(tmp);
+    SkipDB_free(tmp);
+}
+
+int server_init(skipd_server* server, int max_queue) {
+    int count;
+
+    server->switch_mark = 8*1024*1024;//default 8M
+    server_open(server);
+
+    count = SkipDB_count(server->db);
+    skipd_log(SKIPD_DEBUG, "Load count=%d maxPos=%d\n", count, SkipDB_maxPos(server->db));
+
+    server->fd = unix_socket_init(&server->socket, server->sock_path, max_queue);
+    server->socket_len = sizeof(server->socket.sun_family) + strlen(server->socket.sun_path);
+
+    if (-1 == bind(server->fd, (struct sockaddr*) &server->socket, server->socket_len)) {
+        perror("echo server bind");
+        exit(EXIT_FAILURE);
+    }
+
+    if (-1 == listen(server->fd, max_queue)) {
+        perror("listen");
+        exit(EXIT_FAILURE);
+    }
+    return 0;
+}
+
+static struct option options[] = {
+    { "help",	no_argument,		NULL, 'h' },
+    { "db_path", required_argument,	NULL, 'd' },
+    { "sock_path", required_argument,	NULL, 's' },
+    { "daemon", 	required_argument,	NULL, 'D' },
+    { NULL, 0, 0, 0 }
+};
+
+/* static void not_blocked(EV_P_ ev_periodic *w, int revents) {
+    puts(".");
+} */
+
+static void server_init_delay(EV_P_ skipd_server *server) {
+    int n1;
+    char *p1;
+    Datum skey, dkey, dvalue;
+    SkipDBCursor* cursor = NULL;
+    SkipDBRecord* record;
+    delay_cmd* delay_obj;
+
+    //Init hear
+    skey = Datum_FromCString_("__delay__");
+    record = SkipDB_list_first(server->db, skey, &cursor);
+    while(NULL != record) {
+        dkey = SkipDBRecord_keyDatum(record);
+        dvalue = SkipDBRecord_valueDatum(record);
+
+        p1 = strstr((char*)dvalue.data, " ");
+        if(NULL != p1) {
+            n1 = (p1 - (char*)dvalue.data);
+            if(n1 > STATIC_BUF_LEN || dkey.size > DELAY_KEY_LEN) {
+                skipd_log(SKIPD_DEBUG, "delay read key error: %s\n", dkey.data);
+                continue;
+            }
+            memcpy(static_buffer, dvalue.data, n1);
+            static_buffer[n1] = '\0';
+            if(S2ISUCCESS == str2int(&n1, static_buffer, 10)) {
+                delay_obj = (delay_cmd*)malloc(sizeof(delay_cmd));
+                if(NULL == delay_obj) {
+                    skipd_log(SKIPD_DEBUG, "delay out of memory\n");
+                    break;
+                }
+                memcpy(delay_obj->key, dkey.data, dkey.size);
+                delay_obj->key[dkey.size] = '\0';
+                delay_obj->tick = n1;
+                delay_obj->server = server;
+
+                ev_timer_init(&delay_obj->watcher, delay_cmd_cb, delay_obj->tick, delay_obj->tick);
+                ev_timer_start(EV_A_ &delay_obj->watcher);
+            }
+        }
+
+        record = SkipDB_list_next(server->db, skey, cursor);
+    }
+
+    if(NULL != cursor) {
+        SkipDBCursor_release(cursor);
+    }
+}
+
+static void server_init_time(EV_P_ skipd_server *server) {
+    int n1;
+    char *p1;
+    Datum skey, dkey, dvalue;
+    SkipDBCursor* cursor = NULL;
+    SkipDBRecord* record;
+    time_cmd* time_obj;
+    time_t t1, t2;
+    struct tm tm1, tm2, *tnow;
+
+    //Init hear
+    skey = Datum_FromCString_("__time__");
+    record = SkipDB_list_first(server->db, skey, &cursor);
+    while(NULL != record) {
+        dkey = SkipDBRecord_keyDatum(record);
+        dvalue = SkipDBRecord_valueDatum(record);
+
+        p1 = strstr((char*)dvalue.data, " ");
+        if(NULL != p1) {
+            n1 = (p1 - (char*)dvalue.data);
+            if(n1 > STATIC_BUF_LEN || dkey.size > DELAY_KEY_LEN) {
+                skipd_log(SKIPD_DEBUG, "read time error, key=%s\n", dkey.data);
+                break;
+            }
+
+            memcpy(static_buffer, dvalue.data, n1);
+            static_buffer[n1] = '\0';
+
+            if (strptime(static_buffer, "%H:%M:%S", &tm1) != NULL) {
+                t1 = time(NULL);
+                tnow = localtime(&t1);
+                if(NULL == tnow) {
+                    skipd_log(SKIPD_DEBUG, "localtime error\n");
+                    break;
+                }
+                tm2 = *tnow;
+                tm2.tm_sec = tm1.tm_sec;
+                tm2.tm_min = tm1.tm_min;
+                tm2.tm_hour = tm1.tm_hour;
+                t2 = mktime(&tm2);
+
+                if(t2 > t1) {
+                    time_obj = (time_cmd*)malloc(sizeof(time_cmd));
+                    if(NULL == time_obj) {
+                        skipd_log(SKIPD_DEBUG, "out of memory\n");
+                        break;
+                    }
+                    memcpy(time_obj->key, dkey.data, dkey.size);
+                    time_obj->key[dkey.size] = '\0';
+                    time_obj->server = server;
+
+                    ev_timer_init(&time_obj->watcher, time_cmd_cb, (t2-t1), 24*3600);
+                    ev_timer_start(EV_A_ &time_obj->watcher);
+                } else {
+                    ev_timer_init(&time_obj->watcher, time_cmd_cb, (t1-t2+24*3600), 24*3600);
+                    ev_timer_start(EV_A_ &time_obj->watcher);
+                }
+            }
+        }
+
+        record = SkipDB_list_next(server->db, skey, cursor);
+    }
+
+    if(NULL != cursor) {
+        SkipDBCursor_release(cursor);
+    }
+}
+
+static void server_cmd_init(EV_P_ ev_timer *w, int revents) {
+    skipd_server *server = global_server;
+
+    //Stop first
+    ev_timer_stop(EV_A_ w);
+
+    server_init_delay(EV_A_ server);
+    server_init_time(EV_A_ server);
+}
+
+static void server_sync(EV_P_ skipd_server* server) {
+    ev_timer_again(EV_A_ &server->watcher);
+
+    server->to_commit = 1;
+    SkipDB_sync(server->db);
+}
+
+static void server_sync_tick(EV_P_ ev_timer *w, int revents) {
+    skipd_server *server = global_server;
+
+    if(server->to_commit) {
+        server->to_commit = 0;
+        ev_timer_stop(EV_A_ w);
+        skipd_log(SKIPD_DEBUG, "sync tick\n");
+
+        //Do transaction
+        SkipDB_beginTransaction(server->db);
+        SkipDB_commitTransaction(server->db);
+    }
+
+    if((0 == server->in_doing) && (SkipDB_maxPos(server->db) > server->switch_mark)) {
+        server_switch(server);
+    }
+}
+
+static int check_dbpath(skipd_server* server)
+{
+    struct stat s;
+    int err, n = strlen(server->db_path);
+
+    if('/' == server->db_path[n]) {
+        server->db_path[n] = '\0';
+    }
+    err = stat(server->db_path, &s);
+    if(-1 == err) {
+        if(ENOENT == errno) {
+            mkdir(server->db_path, 0700);
+        } else {
+            return -1;
+        }
+    } else {
+        if(!S_ISDIR(s.st_mode)) {
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+int main(int argc, char **argv)
+{
+    int n = 0, daemon = 0, max_queue = 64;
+    int syslog_options = LOG_PID | LOG_PERROR | LOG_DEBUG;
+    skipd_server *server;
+    //struct ev_periodic every_few_seconds;
+    ev_timer init_watcher = {0};
+    EV_P  = ev_default_loop(0);
+
+    global_server = (skipd_server*)calloc(1, sizeof(skipd_server));
+    server = global_server;
+
+    strcpy(server->sock_path, "/tmp/.skipd_server_sock");
+
+#if 1
+    strcpy(server->pid_path, "/tmp/.skipd_pid");
+    strcpy(server->db_path, "/jffs/db");
+    daemon = 1;
+#endif
+
+    while (n >= 0) {
+            n = getopt_long(argc, argv, "hd:D:s:", options, NULL);
+            if (n < 0)
+                    continue;
+            switch (n) {
+            case 'D':
+                //TODO fix me if optarg is bigger than PATH_MAX
+                //strcpy(server->pid_path, optarg);
+                daemon = 0;
+                break;
+            case 'd':
+                strcpy(server->db_path, optarg);
+                break;
+            case 's':
+                strcpy(server->sock_path, optarg);
+                break;
+            case 'h':
+                fprintf(stderr, "Usage: skipd xxx todo\n");
+                exit(1);
+                break;
+            }
+    }
+
+    if(0 == strlen(server->db_path) || (0 != check_dbpath(server))) {
+        //syslog not initialize hear
+        fprintf(stderr, "Database path error\n");
+        return 1;
+    }
+
+    if(daemon) {
+        skipd_daemonize(server->pid_path);
+    }
+
+    //if(!daemon) {
+    //    skipd_savepid(server->pid_path);
+    //}
+
+    setlogmask(LOG_UPTO (LOG_DEBUG));
+    openlog("skipd", syslog_options, LOG_DAEMON);
+
+    //kill -SIGUSR2 22459
+    signal(SIGPIPE, SIG_IGN);
+    signal(SIGABRT, SIG_IGN);
+    ev_signal_init (&signal_watcher, sigint_cb, SIGINT);
+    ev_signal_start (EV_A_ &signal_watcher);
+    ev_signal_init (&signal_watcher2, sigint_cb, SIGTERM);
+    ev_signal_start (EV_A_ &signal_watcher2);
+
+    // Create unix socket in non-blocking fashion
+    server_init(server, max_queue);
+
+    // Get notified whenever the socket is ready to read
+    ev_io_init(&server->io, server_cb, server->fd, EV_READ);
+    ev_io_start(EV_A_ &server->io);
+
+    // To be sure that we aren't actually blocking
+    //ev_periodic_init(&every_few_seconds, not_blocked, 0, 5, 0);
+    //ev_periodic_start(EV_A_ &every_few_seconds);
+    ev_timer_init(EV_A_ &init_watcher, server_cmd_init, 5.0, 0.0);
+    ev_timer_start(EV_A_ &init_watcher);
+    //update at 2s after write
+    ev_timer_init(EV_A_ &server->watcher, server_sync_tick, 0.0, 2.0);
+    //ev_timer_start(EV_A_ &server->watcher);
+
+    // Run our loop, ostensibly forever
+    ev_loop(EV_A_ 0);
+
+    //sync at exit
+    SkipDB_beginTransaction(server->db);
+    SkipDB_commitTransaction(server->db);
+	
+    SkipDB_close(server->db);
+    skipd_log(SKIPD_DEBUG, "exit..\n");
+    // This point is only ever reached if the loop is manually exited
+    close(server->fd);
+    return EXIT_SUCCESS;
+}
+
diff --git a/release/src/router/skipdbv2/mgr/skipd.h b/release/src/router/skipdbv2/mgr/skipd.h
new file mode 100644
index 0000000000..5eb0508d32
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/skipd.h
@@ -0,0 +1,60 @@
+#ifndef __SKIPD_H_
+#define  __SKIPD_H_
+
+#define offsetof2(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
+#define container_of(ptr, type, member) ({                      \
+        const typeof( ((type *)0)->member ) *__mptr = (const typeof( ((type *)0)->member )*)(ptr);    \
+        (type *)( (char *)__mptr - offsetof2(type,member) );})
+
+#define MAGIC "magicv1 "
+#define MAGIC_LEN 8
+#define HEADER_LEN 8
+#define HEADER_PREFIX (MAGIC_LEN + HEADER_LEN)
+#define SK_PATH_MAX 128
+#define BUF_MAX 2048
+#define READ_MAX 65536
+
+#define DELAY_PREFIX "__delay__"
+#define DELAY_PREFIX_LEN 9
+#define DELAY_KEY_LEN 128
+
+#define SKIPD_DEBUG 3
+
+#define _min(a,b) \
+   ({ __typeof__ (a) _a = (a); \
+       __typeof__ (b) _b = (b); \
+     _a > _b ? _b : _a; })
+
+#define _max(a,b) \
+   ({ __typeof__ (a) _a = (a); \
+       __typeof__ (b) _b = (b); \
+     _a > _b ? _a : _b; })
+
+typedef enum {
+    S2ISUCCESS = 0,
+    S2IOVERFLOW,
+    S2IUNDERFLOW,
+    S2IINCONVERTIBLE
+} STR2INT_ERROR;
+
+static STR2INT_ERROR str2int(int *i, char *s, int base) {
+  char *end;
+  long  l;
+  errno = 0;
+  l = strtol(s, &end, base);
+
+  if ((errno == ERANGE && l == LONG_MAX) || l > INT_MAX) {
+    return S2IOVERFLOW;
+  }
+  if ((errno == ERANGE && l == LONG_MIN) || l < INT_MIN) {
+    return S2IUNDERFLOW;
+  }
+  if (*s == '\0' || *end != '\0') {
+    return S2IINCONVERTIBLE;
+  }
+  *i = l;
+  return S2ISUCCESS;
+}
+
+#endif
+
diff --git a/release/src/router/skipdbv2/mgr/unix-echo-client.c b/release/src/router/skipdbv2/mgr/unix-echo-client.c
new file mode 100644
index 0000000000..d4e3e2ea75
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/unix-echo-client.c
@@ -0,0 +1,148 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <ev.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/fcntl.h> // fcntl
+#include <unistd.h> // close
+
+// TODO
+// disconnect and reconnect on each newline
+
+// Nasty globals for now
+// feel free to fork this example and clean it up
+EV_P;
+ev_io stdin_watcher;
+ev_io remote_w;
+ev_io send_w;
+int remote_fd;
+char* line = NULL;
+size_t len = 0;
+
+static void send_cb (EV_P_ ev_io *w, int revents)
+{
+  if (revents & EV_WRITE)
+  {
+    puts ("remote ready for writing...");
+
+    if (-1 == send(remote_fd, line, len, 0)) {
+      perror("echo send");
+      exit(EXIT_FAILURE);
+    }
+    // once the data is sent, stop notifications that
+    // data can be sent until there is actually more 
+    // data to send
+    ev_io_stop(EV_A_ &send_w);
+    ev_io_set(&send_w, remote_fd, EV_READ);
+    ev_io_start(EV_A_ &send_w);
+  }
+  else if (revents & EV_READ)
+  {
+    int n;
+    char str[100] = ".\0";
+
+    printf("[r,remote]");
+    n = recv(remote_fd, str, 100, 0);
+    if (n <= 0) {
+      if (0 == n) {
+        // an orderly disconnect
+        puts("orderly disconnect");
+        ev_io_stop(EV_A_ &send_w);
+        close(remote_fd);
+      }  else if (EAGAIN == errno) {
+        puts("should never get in this state with libev");
+      } else {
+        perror("recv");
+      }
+      return;
+    }
+    printf("socket client said: %s", str);
+
+  }
+}
+
+static void stdin_cb (EV_P_ ev_io *w, int revents)
+{
+  int len2; // not sure if this is at all useful
+
+  puts ("stdin written to, reading...");
+  len2 = getline(&line, &len, stdin);
+  ev_io_stop(EV_A_ &send_w);
+  ev_io_set (&send_w, remote_fd, EV_READ | EV_WRITE);
+  ev_io_start(EV_A_ &send_w);
+}
+
+static void remote_cb (EV_P_ ev_io *w, int revents)
+{
+  puts ("connected, now watching stdin");
+  // Once the connection is established, listen to stdin
+  ev_io_start(EV_A_ &stdin_watcher);
+  // Once we're connected, that's the end of that
+  ev_io_stop(EV_A_ &remote_w);
+}
+
+
+// Simply adds O_NONBLOCK to the file descriptor of choice
+int setnonblock(int fd)
+{
+  int flags;
+
+  flags = fcntl(fd, F_GETFL);
+  flags |= O_NONBLOCK;
+  return fcntl(fd, F_SETFL, flags);
+}
+
+static void connection_new(EV_P_ char* sock_path) {
+  int len;
+  struct sockaddr_un remote;
+
+  if (-1 == (remote_fd = socket(AF_UNIX, SOCK_STREAM, 0))) {
+      perror("socket");
+      exit(1);
+  }
+
+  // Set it non-blocking
+  if (-1 == setnonblock(remote_fd)) {
+    perror("echo client socket nonblock");
+    exit(EXIT_FAILURE);
+  }
+
+  // this should be initialized before the connect() so
+  // that no packets are dropped when initially sent?
+  // http://cr.yp.to/docs/connect.html
+
+  // initialize the connect callback so that it starts the stdin asap
+  ev_io_init (&remote_w, remote_cb, remote_fd, EV_WRITE);
+  ev_io_start(EV_A_ &remote_w);
+  // initialize the send callback, but wait to start until there is data to write
+  ev_io_init(&send_w, send_cb, remote_fd, EV_READ);
+  ev_io_start(EV_A_ &send_w);
+
+  remote.sun_family = AF_UNIX;
+  strcpy(remote.sun_path, sock_path);
+  len = strlen(remote.sun_path) + sizeof(remote.sun_family);
+
+  if (-1 == connect(remote_fd, (struct sockaddr *)&remote, len)) {
+      perror("connect");
+      //exit(1);
+  }
+}
+
+int main (void)
+{
+  loop = EV_DEFAULT;
+  // initialise an io watcher, then start it
+  // this one will watch for stdin to become readable
+  setnonblock(0);
+  ev_io_init(&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
+
+  connection_new(EV_A_ "/tmp/libev-echo.sock");
+
+  // now wait for events to arrive
+  ev_loop(EV_A_ 0);
+
+  // unloop was called, so exit
+  return 0;
+}
diff --git a/release/src/router/skipdbv2/mgr/unix-echo-server.c b/release/src/router/skipdbv2/mgr/unix-echo-server.c
new file mode 100644
index 0000000000..2914b6f215
--- /dev/null
+++ b/release/src/router/skipdbv2/mgr/unix-echo-server.c
@@ -0,0 +1,198 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+#include <ev.h>
+//#include <glib.h>
+#define g_warning printf
+
+//#include <resolv.h>
+#include <unistd.h>
+
+#include "array-heap.h"
+
+struct sock_ev_serv {
+  ev_io io;
+  int fd;
+  struct sockaddr_un socket;
+  int socket_len;
+  array clients;
+};
+
+struct sock_ev_client {
+  ev_io io;
+  int fd;
+  int index;
+  struct sock_ev_serv* server;
+};
+
+int setnonblock(int fd);
+static void not_blocked(EV_P_ ev_periodic *w, int revents);
+
+// This callback is called when client data is available
+static void client_cb(EV_P_ ev_io *w, int revents) {
+  // a client has become readable
+
+  struct sock_ev_client* client = (struct sock_ev_client*) w;
+
+  int n;
+  char str[100] = ".\0";
+
+  printf("[r]");
+  n = recv(client->fd, str, 100, 0);
+  if (n <= 0) {
+    if (0 == n) {
+      // an orderly disconnect
+      puts("orderly disconnect");
+      ev_io_stop(EV_A_ &client->io);
+      close(client->fd);
+    }  else if (EAGAIN == errno) {
+      puts("should never get in this state with libev");
+    } else {
+      perror("recv");
+    }
+    return;
+  } 
+  printf("socket client said: %s", str);
+
+  // Assuming that whenever a client is readable, it is also writable ?
+  if (send(client->fd, str, n, 0) < 0) {
+    perror("send");
+  }
+}
+
+inline static struct sock_ev_client* client_new(int fd) {
+  struct sock_ev_client* client;
+
+  client = realloc(NULL, sizeof(struct sock_ev_client));
+  client->fd = fd;
+  //client->server = server;
+  setnonblock(client->fd);
+  ev_io_init(&client->io, client_cb, client->fd, EV_READ);
+
+  return client;
+}
+
+// This callback is called when data is readable on the unix socket.
+static void server_cb(EV_P_ ev_io *w, int revents) {
+  puts("unix stream socket has become readable");
+
+  int client_fd;
+  struct sock_ev_client* client;
+
+  // since ev_io is the first member,
+  // watcher `w` has the address of the 
+  // start of the sock_ev_serv struct
+  struct sock_ev_serv* server = (struct sock_ev_serv*) w;
+
+  while (1)
+  {
+    client_fd = accept(server->fd, NULL, NULL);
+    if( client_fd == -1 )
+    {
+      if( errno != EAGAIN && errno != EWOULDBLOCK )
+      {
+        g_warning("accept() failed errno=%i (%s)",  errno, strerror(errno));
+        exit(EXIT_FAILURE);
+      }
+      break;
+    }
+    puts("accepted a client");
+    client = client_new(client_fd);
+    client->server = server;
+    client->index = array_push(&server->clients, client);
+    ev_io_start(EV_A_ &client->io);
+  }
+}
+
+// Simply adds O_NONBLOCK to the file descriptor of choice
+int setnonblock(int fd)
+{
+  int flags;
+
+  flags = fcntl(fd, F_GETFL);
+  flags |= O_NONBLOCK;
+  return fcntl(fd, F_SETFL, flags);
+}
+
+int unix_socket_init(struct sockaddr_un* socket_un, char* sock_path, int max_queue) {
+  int fd;
+
+  unlink(sock_path);
+
+  // Setup a unix socket listener.
+  fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (-1 == fd) {
+    perror("echo server socket");
+    exit(EXIT_FAILURE);
+  }
+
+  // Set it non-blocking
+  if (-1 == setnonblock(fd)) {
+    perror("echo server socket nonblock");
+    exit(EXIT_FAILURE);
+  }
+
+  // Set it as unix socket
+  socket_un->sun_family = AF_UNIX;
+  strcpy(socket_un->sun_path, sock_path);
+
+  return fd;
+}
+
+int server_init(struct sock_ev_serv* server, char* sock_path, int max_queue) {
+    server->fd = unix_socket_init(&server->socket, sock_path, max_queue);
+    server->socket_len = sizeof(server->socket.sun_family) + strlen(server->socket.sun_path);
+
+    array_init(&server->clients, 128);
+
+    if (-1 == bind(server->fd, (struct sockaddr*) &server->socket, server->socket_len))
+    {
+      perror("echo server bind");
+      exit(EXIT_FAILURE);
+    }
+
+    if (-1 == listen(server->fd, max_queue)) {
+      perror("listen");
+      exit(EXIT_FAILURE);
+    }
+    return 0;
+}
+
+int main(void) {
+    int max_queue = 128;
+    struct sock_ev_serv server;
+    struct ev_periodic every_few_seconds;
+    // Create our single-loop for this single-thread application
+    EV_P  = ev_default_loop(0);
+
+    // Create unix socket in non-blocking fashion
+    server_init(&server, "/tmp/libev-echo.sock", max_queue);
+
+    // To be sure that we aren't actually blocking
+    ev_periodic_init(&every_few_seconds, not_blocked, 0, 5, 0);
+    ev_periodic_start(EV_A_ &every_few_seconds);
+
+    // Get notified whenever the socket is ready to read
+    ev_io_init(&server.io, server_cb, server.fd, EV_READ);
+    ev_io_start(EV_A_ &server.io);
+
+    // Run our loop, ostensibly forever
+    puts("unix-socket-echo starting...\n");
+    ev_loop(EV_A_ 0);
+
+    // This point is only ever reached if the loop is manually exited
+    close(server.fd);
+    return EXIT_SUCCESS;
+}
+
+
+static void not_blocked(EV_P_ ev_periodic *w, int revents) {
+  puts("I'm not blocked");
+}
diff --git a/release/src/router/skipdbv2/skipdb/SkipDB.c b/release/src/router/skipdbv2/skipdb/SkipDB.c
new file mode 100644
index 0000000000..eeb9e12492
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDB.c
@@ -0,0 +1,915 @@
+/*#io
+SkipDB ioDoc(
+		   docCopyright("Steve Dekorte", 2004)
+		   docLicense("BSD revised")
+		   docObject("SkipDB")
+		   docDescription("BerkeleyDB style database implemented with skip lists instead of a b-tree.")
+		   */
+
+#include "SkipDB.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// lookups
+
+void SkipDB_clearUpdate(SkipDB *self);
+
+// ops
+
+void SkipDB_readRootRecord(SkipDB *self);
+
+// ----------------------------------------------------------
+
+SkipDB *SkipDB_new(void)
+{
+	SkipDB *self = (SkipDB *)calloc(1, sizeof(SkipDB));
+	self->udb = UDB_new();
+
+	self->p = SKIPDB_PROBABILITY_DISTRIBUTION;
+	self->stream = BStream_new();
+
+	self->cursors = List_new();
+
+	self->pidsToRemove = List_new();
+	self->dirtyRecords = List_new();
+
+	self->cacheHighWaterMark = 10000;
+	self->cacheLowWaterMark  = 500;
+
+	self->pidToRecord = PHash_new();
+	self->randomGen = RandomGen_new();
+
+	/*
+    self->header = SkipDBRecord_newWithDB_(self);
+    SkipDBRecord_keyDatum_(self->header, Datum_Empty());
+    SkipDBRecord_valueDatum_(self->header, Datum_Empty());
+	self->headerPid = 0;
+	*/
+
+        self->headerPid = 1;
+
+	return self;
+}
+
+void SkipDB_dealloc(SkipDB *self)
+{
+	SkipDB_clearUpdate(self);
+
+	BStream_free(self->stream);
+	SkipDB_freeAllCachedRecords(self);
+
+	// cursors are allocated and must be freed individually.
+	List_do_(self->cursors, (ListDoCallback *)SkipDBCursor_release);
+	List_free(self->cursors);
+
+        UDB_free(self->udb);
+        self->udb = NULL;
+
+	List_free(self->pidsToRemove);
+	List_free(self->dirtyRecords);
+	PHash_free(self->pidToRecord);
+	RandomGen_free(self->randomGen);
+	free(self);
+}
+
+void SkipDB_free(SkipDB *self)
+{
+	SkipDB_dealloc(self);
+}
+
+void SkipDB_setPath_(SkipDB *self, char *path)
+{
+	UDB_setPath_(self->udb, path);
+}
+
+SKIPDB_API int SkipDB_open(SkipDB *self)
+{
+    /*
+	Datum key;
+	Datum value;
+    */
+
+	UDB_open(self->udb);
+
+	SkipDB_readRootRecord(self);
+
+#if 0
+        if(0 == self->headerPid) {
+	    SkipDB_beginTransaction(self);
+            key = Datum_FromCString_("__inner__");
+            value = Datum_FromCString_("init");
+	    SkipDB_at_put_(self, key, value);
+	    SkipDB_commitTransaction(self);
+	    SkipDBRecord_markAsDirty(self->header);
+        }
+#endif
+
+        return self->headerPid;
+}
+
+SKIPDB_API void SkipDB_close(SkipDB *self)
+{
+	UDB_close(self->udb);
+}
+
+void SkipDB_headerPid_(SkipDB *self, PID_TYPE pid)
+{
+	self->headerPid = pid;
+}
+
+PID_TYPE SkipDB_headerPid(SkipDB *self)
+{
+	return self->headerPid;
+}
+
+SkipDBRecord *SkipDB_headerRecord(SkipDB *self)
+{
+	return self->header;
+}
+
+UDB *SkipDB_udb(SkipDB *self)
+{
+	return self->udb;
+}
+
+BStream *SkipDB_tmpStream(SkipDB *self)
+{
+	return self->stream;
+}
+
+void SkipDB_delete(SkipDB *self)
+{
+	SkipDB_close(self);
+	UDB_delete(self->udb);
+/*
+	int count = 0;
+	SkipDBRecord *r = self->header;
+
+	while (r)
+	{
+		PID_TYPE pid = SkipDBRecord_pid(r);
+		SkipDBRecord *next = SkipDBRecord_nextRecord(self->header);
+
+		if (pid)
+		{
+			UDB_removeAt_(SkipDB_udb(self), pid);
+		}
+
+		r = next;
+		count ++;
+	}
+
+	return count;
+	*/
+}
+
+// notifications ---------------------------------
+
+void SkipDB_noteNewRecord_(SkipDB *self, SkipDBRecord *r)
+{
+	self->cachedRecordCount ++;
+	SkipDB_noteAccessedRecord_(self, r);
+}
+
+void SkipDB_noteAccessedRecord_(SkipDB *self, SkipDBRecord *r)
+{
+	SkipDBRecord *y = self->youngestRecord;
+
+	//SkipDBRecord_showAgeList(r);
+
+	if (y != r)
+	{
+		if (y)
+		{
+			SkipDBRecord_removeFromAgeList(r);
+			SkipDBRecord_setOlderRecord_(r, y);
+			SkipDBRecord_setYoungerRecord_(y, r);
+		}
+
+		self->youngestRecord = r;
+	}
+
+	//SkipDBRecord_showAgeList(r);
+}
+
+void SkipDB_noteDirtyRecord_(SkipDB *self, SkipDBRecord *r)
+{
+	if (SkipDB_isOpen(self))
+	{
+		List_append_(self->dirtyRecords, r);
+	}
+}
+
+void SkipDB_noteAssignedPidToRecord_(SkipDB *self, SkipDBRecord *r)
+{
+	PHash_at_put_(self->pidToRecord, (void *)SkipDBRecord_pid(r), r);
+}
+
+void SkipDB_noteWillFreeRecord_(SkipDB *self, SkipDBRecord *r)
+{
+	SkipDBFreeObjectFunc *f = self->objectFreeFunc;
+	void *object = SkipDBRecord_object(r);
+
+	if (f && object)
+	{
+		(*f)(object);
+	}
+
+	self->cachedRecordCount --;
+
+	if (r == self->youngestRecord)
+	{
+		self->youngestRecord = SkipDBRecord_olderRecord(r);
+		//printf("will free youngestRecord\n");
+	}
+
+	SkipDBRecord_removeFromAgeList(r);
+	PHash_removeKey_(self->pidToRecord, (void *)SkipDBRecord_pid(r));
+}
+
+void SkipDB_freeAllCachedRecords(SkipDB *self)
+{
+	//SkipDBRecord *r = self->youngestRecord;
+	//self->headerPid = SkipDBRecord_pid(self->header);
+
+	//SkipDBRecord_showAgeList(self->youngestRecord);
+
+	while (self->youngestRecord)
+	{
+		SkipDBRecord_dealloc(self->youngestRecord);
+	}
+
+	self->header = NULL;
+}
+
+// cache -------------------------------------
+
+void SkipDB_setCacheHighWaterMark_(SkipDB *self, size_t recordCount)
+{
+	self->cacheHighWaterMark = recordCount;
+
+	if (recordCount < self->cacheLowWaterMark)
+	{
+		self->cacheLowWaterMark = recordCount / 2;
+	}
+}
+
+size_t SkipDB_cacheHighWaterMark(SkipDB *self)
+{
+	return self->cacheHighWaterMark;
+}
+
+void SkipDB_setCacheLowWaterMark_(SkipDB *self, size_t recordCount)
+{
+	self->cacheLowWaterMark = recordCount;
+
+	if (recordCount > self->cacheHighWaterMark)
+	{
+		self->cacheHighWaterMark = recordCount * 2;
+	}
+}
+
+size_t SkipDB_cacheLowWaterMark(SkipDB *self)
+{
+	return self->cacheLowWaterMark;
+}
+
+int SkipDB_headerIsEmpty(SkipDB *self)
+{
+	return SkipDBRecord_pointersAreEmpty(self->header);
+}
+
+void SkipDB_freeExcessCachedRecords(SkipDB *self)
+{
+	// this is only called after a sync, so there are no dirty records
+	//return;
+
+	if (self->cachedRecordCount > self->cacheHighWaterMark)
+	{
+		SkipDBRecord *r;
+		SkipDBRecord *lastMarkedRecord = NULL;
+		size_t lowMark = self->cacheLowWaterMark;
+
+		//printf("SkipDB_freeExcessCachedRecords() start %i\n", (int)self->cachedRecordCount);
+
+		// make sure we keep the header
+
+		SkipDB_noteAccessedRecord_(self, self->header);
+		r = self->youngestRecord;
+
+		// mark the cursor records
+
+		List_do_(self->cursors, (ListDoCallback *)SkipDBCursor_mark);
+
+		// mark the recent records
+
+		while (lowMark --)
+		{
+			r->mark = 1;
+			r = r->olderRecord;
+		}
+
+		// unmark the rest of the records
+
+		while (r)
+		{
+			r->mark = 0;
+			r = r->olderRecord;
+		}
+
+		// remove the references to older records
+
+		lowMark = self->cacheLowWaterMark;
+		r = self->youngestRecord;
+
+		while (r->mark)
+		{
+			lowMark --;
+			SkipDBRecord_removeReferencesToUnmarked(r);
+			lastMarkedRecord = r; // remember this so we can clip the list
+			r = r->olderRecord;
+		}
+
+		// dealloc the remaining records
+
+		while (r)
+		{
+			SkipDBRecord *next = r->olderRecord;
+
+			// to avoid SkipDBRecord_removeFromAgeList() issues
+			r->olderRecord   = NULL;
+			r->youngerRecord = NULL;
+
+			if (r->mark)
+			{
+				printf("error - attempt to dealloc marked record\n");
+				exit(-1);
+			}
+
+			SkipDBRecord_dealloc(r); // what about SkipDBRecord_removeFromAgeList()?
+			r = next;
+		}
+
+		lastMarkedRecord->olderRecord = NULL; // clip the list
+
+		//printf("SkipDB_freeExcessCachedRecords() done %i\n", (int)self->cachedRecordCount);
+	}
+}
+
+int SkipDB_isOpen(SkipDB *self)
+{
+	return SkipDB_udb(self) && UDB_isOpen(SkipDB_udb(self));
+}
+
+void SkipDB_clearCache(SkipDB *self)
+{
+	printf("\nclearCache\n\n");
+
+	if (self->header)
+	{
+		SkipDB_freeAllCachedRecords(self);
+		SkipDB_readRootRecord(self);
+	}
+}
+
+// transactions ---------------------------------------------------
+
+void SkipDB_sync(SkipDB *self)
+{
+	if (SkipDB_isOpen(self))
+	{
+		if (!self->headerPid)
+		{
+			self->headerPid = SkipDBRecord_pidAllocIfNeeded(self->header);
+		}
+
+		//SkipDB_removeDirtyRecordsFromSavedRecords(self);
+		SkipDB_saveDirtyRecords(self);
+		SkipDB_deleteRecordsToRemove(self);
+	}
+
+	List_removeAll(self->dirtyRecords);
+	List_removeAll(self->pidsToRemove);
+	SkipDB_freeExcessCachedRecords(self);
+}
+
+SKIPDB_API void SkipDB_beginTransaction(SkipDB *self)
+{
+	UDB_beginTransaction(self->udb);
+}
+
+SKIPDB_API void SkipDB_commitTransaction(SkipDB *self)
+{
+	SkipDB_sync(self);
+	UDB_commitTransaction(self->udb);
+}
+
+void SkipDB_saveDirtyRecords(SkipDB *self)
+{
+	List_do_(self->dirtyRecords, (ListDoCallback *)SkipDBRecord_save);
+}
+
+void SkipDB_deleteRecordsToRemove(SkipDB *self)
+{
+	UDB *udb = SkipDB_udb(self);
+	LIST_FOREACH(self->pidsToRemove, i, pid, UDB_removeAt_(udb, (PID_TYPE)pid));
+}
+
+// ops --------------------------------------------------
+
+void SkipDB_readRootRecord(SkipDB *self)
+{
+	SkipDBRecord *r = SkipDB_recordAtPid_(self, self->headerPid);
+
+	if (!r)
+	{
+		r = SkipDBRecord_newWithDB_(self);
+		SkipDBRecord_keyDatum_(r, Datum_Empty());
+		SkipDBRecord_markAsDirty(r);
+		self->headerPid = SkipDBRecord_pid(r);
+	}
+
+	self->header = r;
+}
+
+int SkipDB_level(SkipDB *self)
+{
+	return SkipDBRecord_level(self->header);
+}
+
+void SkipDB_level_(SkipDB *self, int level)
+{
+	SkipDBRecord_level_(self->header, level);
+	SkipDBRecord_markAsDirty(self->header);
+}
+
+int SkipDB_pickRandomRecordLevel(SkipDB *self)
+{
+	float r = (float)RandomGen_randomDouble(self->randomGen);
+	int level = 1;
+
+	while (r < self->p && level < SKIPDB_MAX_LEVEL)
+	{
+		level ++;
+		r = (float)RandomGen_randomDouble(self->randomGen);
+	}
+
+	if (level > SkipDB_level(self))
+	{
+		level = SkipDB_level(self) + 1;
+	}
+
+	return level;
+}
+
+SkipDBRecord *SkipDB_recordAtPid_(SkipDB *self, PID_TYPE pid)
+{
+	if (pid)
+	{
+		SkipDBRecord *r = PHash_at_(self->pidToRecord, (void *)pid);
+
+		if (r)
+		{
+			return r;
+		}
+		else
+		{
+			Datum d = UDB_at_(SkipDB_udb(self), pid);
+
+			if (d.size)
+			{
+				SkipDBRecord *r = SkipDBRecord_newWithDB_(self);
+				BStream_setData_length_(self->stream, d.data, d.size); // need to optimize this out
+				SkipDBRecord_fromStream_(r, self->stream);
+				SkipDBRecord_pid_(r, pid);
+				return r;
+			}
+		}
+
+		if (pid != 1)
+		{
+			UDB *udb = SkipDB_udb(self);
+			printf("MISSING SKIP RECORD WITH PID: %" PID_FORMAT "\n", pid);
+			UDB_at_(udb, pid);
+		}
+	}
+	return NULL;
+}
+
+// lookups -----------------------------
+
+void SkipDB_updateAt_put_(SkipDB *self, int level, SkipDBRecord *r)
+{
+	self->update[level] = r;
+	//if (r) SkipDB_noteAccessedRecord_(self, r);
+}
+
+void SkipDB_clearUpdate(SkipDB *self)
+{
+	int i;
+
+	for (i = 0; i < SKIPDB_MAX_LEVEL; i ++)
+	{
+		SkipDB_updateAt_put_(self, i, NULL);
+	}
+}
+
+// Record API -------------------------------------
+
+SkipDBRecord *SkipDB_recordAt_(SkipDB *self, Datum k)
+{
+	SkipDB_clearUpdate(self);
+	return SkipDBRecord_find_quick_(self->header, k, 0);
+}
+
+int SkipDB_replace_put_(SkipDB *self, Datum k, Datum v)
+{
+	SkipDBRecord *r = SkipDB_recordAt_(self, k);
+        if(r) {
+		// update record
+		SkipDBRecord_valueDatum_(r, v);
+		SkipDBRecord_markAsDirty(r);
+                return 1;
+        }
+
+        return 0;
+}
+
+static int SkipDB_recordAt_put_inner(SkipDB *self, Datum k, Datum v, SkipDBRecord** pp)
+{
+	SkipDBRecord *r = SkipDB_recordAt_(self, k);
+        int rlt;
+	//SkipDB_showUpdate(self);
+
+	if (r)
+	{
+		// update record
+		SkipDBRecord_valueDatum_(r, v);
+		SkipDBRecord_markAsDirty(r);
+                rlt = 1;
+	}
+	else
+	{
+		// create new record
+		r = SkipDBRecord_newWithDB_(self);
+		//printf("%p = SkipDBRecord_newWithDB_(self);\n", (void *)r);
+
+		SkipDBRecord_keyDatum_(r, k);
+		SkipDBRecord_valueDatum_(r, v);
+
+		// pick a level for it, and update header level if needed
+		{
+			int level = SkipDB_pickRandomRecordLevel(self);
+
+			//printf("picked level = %i\n", level);
+			SkipDBRecord_level_(r, level);
+
+			if (level > SkipDB_level(self))
+			{
+				int i;
+
+				for (i = SkipDB_level(self); i < level; i ++)
+				{
+					SkipDB_updateAt_put_(self, i, self->header);
+				}
+
+				SkipDB_level_(self, level);
+			}
+		}
+
+		SkipDBRecord_markAsDirty(r); // need to do this to get a pid
+		//SkipDBRecord_show(r);
+
+		// set the records in the update vector to point to the inserted record
+		{
+			int level = SkipDBRecord_level(r);
+
+			while (level --)
+			{
+				SkipDBRecord *updateRecord = self->update[level];
+
+				if (updateRecord)
+				{
+					SkipDBRecord_copyLevel_from_(r, level, updateRecord);
+					/*
+					 printf("after: %s insert: %s\n",
+						   UArray_asCString(updateRecord->key),
+						   UArray_asCString(r->key));
+					*/
+
+					// update previous pointer
+					// (r is to the right of the update records)
+					if (level == 0)
+					{
+						SkipDBRecord *nextRecord = SkipDBRecord_nextRecord(updateRecord);
+						SkipDBRecord_previousRecord_(r, updateRecord);
+
+						if(nextRecord)
+						{
+							SkipDBRecord_previousRecord_(nextRecord, r);
+							SkipDBRecord_markAsDirty(nextRecord);
+						}
+					}
+
+					SkipDBRecord_atLevel_setRecord_(updateRecord, level, r);
+					SkipDBRecord_markAsDirty(updateRecord);
+				}
+			}
+		}
+
+		SkipDBRecord_markAsDirty(r);
+                rlt = 0;
+	}
+
+        if(NULL != pp) {
+            *pp = r;
+        }
+
+        return rlt;
+}
+
+SkipDBRecord *SkipDB_recordAt_put_(SkipDB *self, Datum k, Datum v) {
+    SkipDBRecord *p = NULL;
+    SkipDB_recordAt_put_inner(self, k, v, &p);
+    return p;
+}
+
+// Datum API -------------------------------------
+
+Datum SkipDB_at_(SkipDB *self, Datum k)
+{
+	SkipDBRecord *r;
+
+	SkipDB_clearUpdate(self);
+
+	r = SkipDBRecord_find_quick_(self->header, k, 1);
+
+	//SkipDBRecord *r = SkipDB_recordAt_(self, k);
+
+	if (r)
+	{
+		return Datum_FromUArray_(SkipDBRecord_value(r));
+	}
+
+	return Datum_Empty();
+}
+
+int SkipDB_at_put_(SkipDB *self, Datum k, Datum v)
+{
+	//SkipDB_recordAt_put_(self, k, v);
+        return SkipDB_recordAt_put_inner(self, k, v, NULL);
+}
+
+void SkipDB_removeAt_(SkipDB *self, Datum k)
+{
+	SkipDBRecord *r = SkipDB_recordAt_(self, k);
+	SkipDBRecord *lastUr = NULL;
+
+	if (r)
+	{
+		int i;
+
+		for (i = 0; i < SKIPDB_MAX_LEVEL; i ++)
+		{
+			SkipDBRecord *ur = self->update[i];
+
+			if (ur == r)
+			{
+				break;
+			}
+
+			if (ur && ur != lastUr)
+			{
+				SkipDBRecord_willRemove_(ur, r);
+			}
+
+			// update previous pointer
+
+			if (i == 0)
+			{
+				SkipDBRecord *nextRecord = SkipDBRecord_nextRecord(r);
+				SkipDBRecord *previousRecord = SkipDBRecord_previousRecord(r);
+
+				if (nextRecord)
+				{
+					SkipDBRecord_previousRecord_(nextRecord, previousRecord);
+				}
+			}
+			lastUr = ur;
+		}
+
+		if (SkipDB_isOpen(self))
+		{
+			PID_TYPE pid = SkipDBRecord_pid(r);
+
+			if (pid)
+			{
+				List_append_(self->pidsToRemove, (void *)pid);
+				List_remove_(self->dirtyRecords, r);
+			}
+			//UDB_removeAt_(SkipDB_udb(self), SkipDBRecord_pid(r));
+		}
+
+		// nothing should be pointing to this record, so we can dealloc it
+
+		//SkipDBRecord_object_(r, NULL);
+		SkipDBRecord_dealloc(r);
+
+#ifdef DEBUG
+		if (SkipDB_recordAt_(self, k))
+		{
+			printf("SkipDB_removeAt_ error - not removed\n");
+			exit(-1);
+		}
+#endif
+	}
+}
+
+void SkipDB_showUpdate(SkipDB *self)
+{
+	int i = self->header->level;
+
+	printf("SkipDB update vector:\n");
+
+	while (i --)
+	{
+		printf("  %i : %s\n", i, UArray_asCString(SkipDBRecord_key(self->update[i])));
+	}
+
+	printf("\n");
+}
+
+void SkipDB_show(SkipDB *self)
+{
+	SkipDBRecord *r = self->header;
+	printf("\nSkipDB:\n");
+	while (r)
+	{
+		SkipDBRecord_show(r);
+		r = SkipDBRecord_recordAtLevel_(r, 0);
+	}
+	printf("\n\n");
+}
+
+// objects --------------------------------------------------
+
+void SkipDB_objectMarkFunc_(SkipDB *self, SkipDBObjectMarkFunc *func)
+{
+	self->objectMarkFunc = func;
+}
+
+void SkipDB_freeObjectCallback_(SkipDB *self, SkipDBFreeObjectFunc *func)
+{
+	self->objectFreeFunc = func;
+}
+
+// cursor ---------------------------------
+
+int SkipDB_count(SkipDB *self)
+{
+	int count = 0;
+	SkipDBRecord *r = SkipDB_firstRecord(self);
+
+	if (!r)
+	{
+		return 0;
+	}
+
+	count = 1;
+
+	while ((r = SkipDBRecord_nextRecord(r)))
+	{
+		count ++;
+	}
+	return count;
+}
+
+SkipDBRecord *SkipDB_firstRecord(SkipDB *self)
+{
+	if (SkipDBRecord_level(self->header) == 0) return NULL;
+	return SkipDBRecord_nextRecord(self->header);
+}
+
+SkipDBRecord *SkipDB_lastRecord(SkipDB *self)
+{
+	return SkipDBRecord_findLastRecord(self->header);
+}
+
+SkipDBRecord *SkipDB_goto_(SkipDB *self, Datum key)
+{
+	SkipDBRecord *r = SkipDB_recordAt_(self, key);
+
+	if (!r)
+	{
+		r = self->update[0];
+	}
+
+	return r;
+}
+
+SkipDBCursor *SkipDB_createCursor(SkipDB *self)
+{
+	SkipDBCursor *cursor = SkipDBCursor_newWithDB_(self);
+	List_append_(self->cursors, cursor);
+	return cursor;
+}
+
+void SkipDB_removeCursor_(SkipDB *self, SkipDBCursor *cursor)
+{
+	SkipDBCursor_release(cursor);
+	List_remove_(self->cursors, cursor);
+	//SkipDBCursor_free(cursor);
+}
+
+// moving from in-memory to on-disk ---------------------------------
+
+void SkipDB_mergeInto_(SkipDB *self, SkipDB *other)
+{
+	SkipDBRecord *r = self->header;
+
+	while ((r = SkipDBRecord_nextRecord(r)))
+	{
+		Datum k = SkipDBRecord_keyDatum(r);
+		Datum v = SkipDBRecord_valueDatum(r);
+		SkipDB_at_put_(other, k, v);
+	}
+}
+
+int SkipDB_exists(SkipDB *self, Datum key) {
+    Datum dvalue = SkipDB_at_(self, key);
+    if(NULL == dvalue.data) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+
+void SkipDB_list_prefix(SkipDB* self, Datum k, void* ctx, skipdb_list_callback callback)
+{
+    Datum t;
+    SkipDBCursor* cursor = SkipDB_createCursor(self);
+    SkipDBRecord* rc = SkipDBCursor_goto_(cursor, k);
+    if(NULL == rc) {
+        goto list_finish;
+    }
+
+    t = SkipDBRecord_keyDatum(rc);
+    //printf("k.size=%d t.size=%d k=%s t=%s\n", k.size, t.size, k.data, t.data);
+    if((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1))) {
+        (*callback)(self, rc, ctx);
+    }
+
+    rc = SkipDBCursor_next(cursor);
+    while(NULL != rc) {
+        t = SkipDBRecord_keyDatum(rc);
+        if((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1))) {
+            (*callback)(self, rc, ctx);
+            rc = SkipDBCursor_next(cursor);
+        } else {
+            break;
+        }
+    }
+
+list_finish:
+    if(NULL != cursor) {
+        SkipDBCursor_release(cursor);
+    }
+}
+
+/* TODO howto make better */
+SkipDBRecord* SkipDB_list_next(SkipDB* self, Datum k, SkipDBCursor* cursor) {
+    Datum t;
+    SkipDBRecord* rc = SkipDBCursor_next(cursor);
+    if(NULL != rc) {
+        t = SkipDBRecord_keyDatum(rc);
+        if(!((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1)))) {
+            rc = NULL;
+        }
+    }
+    return rc;
+}
+
+SkipDBRecord* SkipDB_list_first(SkipDB* self, Datum k, SkipDBCursor** pcur) {
+    Datum t;
+    SkipDBCursor* cursor = SkipDB_createCursor(self);
+    SkipDBRecord* rc = SkipDBCursor_goto_(cursor, k);
+
+    *pcur = cursor;
+    if(NULL == rc) {
+        return NULL;
+    }
+
+    t = SkipDBRecord_keyDatum(rc);
+    //printf("k.size=%d t.size=%d k=%s t=%s\n", k.size, t.size, k.data, t.data);
+    if((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1))) {
+        return rc;
+    } else {
+        return SkipDB_list_next(self, k, cursor);
+    }
+}
+
+int SkipDB_maxPos(SkipDB* self) {
+    return self->udb->records->file->maxPos;
+}
diff --git a/release/src/router/skipdbv2/skipdb/SkipDB.h b/release/src/router/skipdbv2/skipdb/SkipDB.h
new file mode 100644
index 0000000000..d7555bba7e
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDB.h
@@ -0,0 +1,172 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("SkipDB")
+docDescription("A sorted key/value pair database implemented with skip lists on top of UDB.")
+*/
+
+#ifndef SkipDB_DEFINED
+#define SkipDB_DEFINED 1
+
+#if !defined(__MINGW32__) && defined(WIN32)
+#if defined(BUILDING_SKIPDB_DLL) || defined(BUILDING_IOVMALL_DLL)
+#define SKIPDB_API __declspec(dllexport)
+#else
+#define SKIPDB_API __declspec(dllimport)
+#endif
+#else
+#define SKIPDB_API
+#endif
+
+
+#include "SkipDBRecord.h"
+#include "UDB.h"
+#include "PHash.h"
+#include "RandomGen.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// if prob. dist = 0.5, then max level 32 is enough for 2^32 records
+
+//#define SKIPDB_MAX_LEVEL 32
+#define SKIPDB_MAX_LEVEL 16
+#define SKIPDB_PROBABILITY_DISTRIBUTION 0.5
+
+typedef void (SkipDBObjectMarkFunc)(void *);
+typedef void (SkipDBFreeObjectFunc)(void *);
+
+typedef struct
+{
+	UDB *udb;
+
+    void *dbm;
+    PID_TYPE headerPid;
+    SkipDBRecord *header;
+    SkipDBRecord *youngestRecord; // most recently accessed
+
+    SkipDBRecord *update[SKIPDB_MAX_LEVEL];
+    float p;
+
+    BStream *stream;
+    SkipDBObjectMarkFunc *objectMarkFunc;
+    SkipDBFreeObjectFunc *objectFreeFunc;
+    List *cursors;
+
+    List *dirtyRecords;
+    List *pidsToRemove;
+
+    size_t cachedRecordCount;
+    size_t cacheHighWaterMark;
+    size_t cacheLowWaterMark;
+    unsigned char mark; // current record mark identifier
+    PHash *pidToRecord;
+    RandomGen *randomGen;
+} SkipDB;
+
+#include "SkipDBCursor.h"
+
+SKIPDB_API SkipDB *SkipDB_new(void);
+SKIPDB_API void SkipDB_setPath_(SkipDB *self, char *path);
+SKIPDB_API int SkipDB_open(SkipDB *self);
+SKIPDB_API void SkipDB_close(SkipDB *self);
+SKIPDB_API void SkipDB_free(SkipDB *self);
+
+SKIPDB_API void SkipDB_retain(SkipDB *self);
+SKIPDB_API void SkipDB_release(SkipDB *self);
+
+SKIPDB_API BStream *SkipDB_tmpStream(SkipDB *self);
+
+SKIPDB_API void SkipDB_headerPid_(SkipDB *self, PID_TYPE pid);
+SKIPDB_API PID_TYPE SkipDB_headerPid(SkipDB *self);
+SKIPDB_API SkipDBRecord *SkipDB_headerRecord(SkipDB *self);
+
+SKIPDB_API UDB *SkipDB_udb(SkipDB *self);
+SKIPDB_API int SkipDB_isOpen(SkipDB *self);
+SKIPDB_API void SkipDB_delete(SkipDB *self);
+
+// notifications
+
+SKIPDB_API void SkipDB_noteNewRecord_(SkipDB *self, SkipDBRecord *r);
+SKIPDB_API void SkipDB_noteAccessedRecord_(SkipDB *self, SkipDBRecord *r);
+SKIPDB_API void SkipDB_noteDirtyRecord_(SkipDB *self, SkipDBRecord *r);
+SKIPDB_API void SkipDB_noteAssignedPidToRecord_(SkipDB *self, SkipDBRecord *r);
+SKIPDB_API void SkipDB_noteWillFreeRecord_(SkipDB *self, SkipDBRecord *r);
+
+// cache
+
+SKIPDB_API void SkipDB_setCacheHighWaterMark_(SkipDB *self, size_t recordCount);
+SKIPDB_API size_t SkipDB_cacheHighWaterMark(SkipDB *self);
+
+SKIPDB_API void SkipDB_setCacheLowWaterMark_(SkipDB *self, size_t recordCount);
+SKIPDB_API size_t SkipDB_cacheLowWaterMark(SkipDB *self);
+
+SKIPDB_API void SkipDB_clearCache(SkipDB *self);
+SKIPDB_API void SkipDB_freeAllCachedRecords(SkipDB *self);
+SKIPDB_API int SkipDB_headerIsEmpty(SkipDB *self);
+
+// transactions
+
+SKIPDB_API void SkipDB_beginTransaction(SkipDB *self);
+SKIPDB_API void SkipDB_commitTransaction(SkipDB *self);
+
+SKIPDB_API void SkipDB_sync(SkipDB *self);
+SKIPDB_API void SkipDB_removeDirtyRecordsFromSavedRecords(SkipDB *self);
+SKIPDB_API void SkipDB_saveDirtyRecords(SkipDB *self);
+void SkipDB_deleteRecordsToRemove(SkipDB *self);
+
+// record api
+
+SKIPDB_API SkipDBRecord *SkipDB_recordAt_(SkipDB *self, Datum k);
+SKIPDB_API SkipDBRecord *SkipDB_recordAt_put_(SkipDB *self, Datum k, Datum v);
+SKIPDB_API int SkipDB_replace_put_(SkipDB *self, Datum k, Datum v);
+
+// bdb style api
+
+SKIPDB_API int SkipDB_at_put_(SkipDB *self, Datum k, Datum v);
+SKIPDB_API Datum SkipDB_at_(SkipDB *self, Datum k);
+SKIPDB_API void SkipDB_removeAt_(SkipDB *self, Datum k);
+
+// compact
+
+SKIPDB_API int SkipDB_compact(SkipDB *self);
+
+// debugging
+
+SKIPDB_API void SkipDB_showUpdate(SkipDB *self);
+SKIPDB_API void SkipDB_show(SkipDB *self);
+
+// private
+
+SKIPDB_API void SkipDB_updateAt_put_(SkipDB *self, int level, SkipDBRecord *r);
+SKIPDB_API SkipDBRecord *SkipDB_recordAtPid_(SkipDB *self, PID_TYPE pid);
+
+// objects
+
+SKIPDB_API void SkipDB_objectMarkFunc_(SkipDB *self, SkipDBObjectMarkFunc *func);
+SKIPDB_API void SkipDB_freeObjectCallback_(SkipDB *, SkipDBFreeObjectFunc *func);
+
+// cursor
+
+SKIPDB_API int SkipDB_count(SkipDB *self);
+
+SKIPDB_API SkipDBRecord *SkipDB_firstRecord(SkipDB *self);
+SKIPDB_API SkipDBRecord *SkipDB_lastRecord(SkipDB *self);
+SKIPDB_API SkipDBRecord *SkipDB_goto_(SkipDB *self, Datum key);
+
+SKIPDB_API SkipDBCursor *SkipDB_createCursor(SkipDB *self);
+SKIPDB_API void SkipDB_removeCursor_(SkipDB *self, SkipDBCursor *cursor);
+
+// moving from in-memory to on-disk
+
+SKIPDB_API void SkipDB_mergeInto_(SkipDB *self, SkipDB *other);
+
+SKIPDB_API int SkipDB_exists(SkipDB *self, Datum key);
+typedef void (*skipdb_list_callback)(SkipDB* self, SkipDBRecord* rc, void* ctx);
+SKIPDB_API void SkipDB_list_prefix(SkipDB* self, Datum k, void* ctx, skipdb_list_callback callback);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/skipdb/SkipDBCursor.c b/release/src/router/skipdbv2/skipdb/SkipDBCursor.c
new file mode 100644
index 0000000000..4000d6d5bf
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDBCursor.c
@@ -0,0 +1,97 @@
+/*#io
+SkipDBCursor ioDoc(
+			    docCopyright("Steve Dekorte", 2004)
+			    docLicense("BSD revised")
+			    docObject("SkipDBCursor")
+			    docDescription("A cursor for a skipdb.")
+			    */
+
+#include "SkipDBCursor.h"
+
+SkipDBCursor *SkipDBCursor_new(void)
+{
+	SkipDBCursor *self = (SkipDBCursor *)calloc(1, sizeof(SkipDBCursor));
+	SkipDBCursor_retain(self);
+	return self;
+}
+
+SkipDBCursor *SkipDBCursor_newWithDB_(SkipDB *sdb)
+{
+	SkipDBCursor *self = SkipDBCursor_new();
+	self->sdb = sdb;
+	return self;
+}
+
+void SkipDBCursor_retain(SkipDBCursor *self)
+{
+	self->refCount ++;
+}
+
+void SkipDBCursor_dealloc(SkipDBCursor *self)
+{
+	if (self->sdb) SkipDB_removeCursor_(self->sdb, self);
+	free(self);
+}
+
+void SkipDBCursor_release(SkipDBCursor *self)
+{
+	self->refCount --;
+
+	if (self->refCount == 0)
+	{
+		SkipDBCursor_dealloc(self);
+	}
+}
+
+void SkipDBCursor_mark(SkipDBCursor *self)
+{
+	if (self->record)
+	{
+		SkipDBRecord_mark(self->record);
+	}
+}
+
+SkipDBRecord *SkipDBCursor_goto_(SkipDBCursor *self, Datum key)
+{
+	return (self->record = SkipDB_goto_((SkipDB *)(self->sdb), key));
+}
+
+SkipDBRecord *SkipDBCursor_first(SkipDBCursor *self)
+{
+	return (self->record = SkipDB_firstRecord(self->sdb));
+}
+
+SkipDBRecord *SkipDBCursor_last(SkipDBCursor *self)
+{
+	return (self->record = SkipDB_lastRecord(self->sdb));
+}
+
+SkipDBRecord *SkipDBCursor_current(SkipDBCursor *self)
+{
+	return self->record;
+}
+
+SkipDBRecord *SkipDBCursor_previous(SkipDBCursor *self)
+{
+	if (self->record)
+	{
+		self->record = SkipDBRecord_previousRecord(self->record);
+
+		if (self->record == SkipDB_headerRecord(self->sdb))
+		{
+			self->record = NULL;
+		}
+	}
+	return self->record;
+}
+
+SkipDBRecord *SkipDBCursor_next(SkipDBCursor *self)
+{
+	if (!self->record)
+	{
+		return NULL;
+	}
+
+	return (self->record = SkipDBRecord_nextRecord(self->record));
+}
+
diff --git a/release/src/router/skipdbv2/skipdb/SkipDBCursor.h b/release/src/router/skipdbv2/skipdb/SkipDBCursor.h
new file mode 100644
index 0000000000..dc4490c74d
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDBCursor.h
@@ -0,0 +1,48 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("SkipDBCursor")    
+docDescription("A cursor for a skipdb.")
+*/
+
+
+#ifndef SkipDBCursor_DEFINED
+#define SkipDBCursor_DEFINED 1
+
+typedef struct SkipDBCursor SkipDBCursor;
+
+#include "SkipDB.h"
+#include <stdio.h>
+#include <sys/types.h> 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct SkipDBCursor
+{
+    int refCount;
+    SkipDB *sdb;
+    SkipDBRecord *record;
+};
+
+SKIPDB_API SkipDBCursor *SkipDBCursor_new(void);
+SKIPDB_API SkipDBCursor *SkipDBCursor_newWithDB_(SkipDB *sdb);
+SKIPDB_API void SkipDBCursor_sdb_(SkipDB *sdb);
+SKIPDB_API void SkipDBCursor_retain(SkipDBCursor *self);
+SKIPDB_API void SkipDBCursor_release(SkipDBCursor *self);
+SKIPDB_API void SkipDBCursor_mark(SkipDBCursor *self);
+
+SKIPDB_API SkipDBRecord *SkipDBCursor_goto_(SkipDBCursor *self, Datum key);
+
+SKIPDB_API SkipDBRecord *SkipDBCursor_first(SkipDBCursor *self);
+SKIPDB_API SkipDBRecord *SkipDBCursor_last(SkipDBCursor *self);
+
+SKIPDB_API SkipDBRecord *SkipDBCursor_previous(SkipDBCursor *self);
+SKIPDB_API SkipDBRecord *SkipDBCursor_current(SkipDBCursor *self);
+SKIPDB_API SkipDBRecord *SkipDBCursor_next(SkipDBCursor *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/skipdb/SkipDBRecord.c b/release/src/router/skipdbv2/skipdb/SkipDBRecord.c
new file mode 100644
index 0000000000..2b121ed406
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDBRecord.c
@@ -0,0 +1,739 @@
+
+
+#include "SkipDB.h"
+#include "SkipDBRecord.h"
+
+static void SkipDBPointer_setRecord_(SkipDBPointer *self, SkipDBRecord *r)
+{
+	self->record = r;
+}
+
+
+static PID_TYPE SkipDBPointer_pid(SkipDBPointer *self)
+{
+	return self->pid;
+}
+
+//-----------------------------------------------------
+
+SkipDBRecord *SkipDBRecord_new(void)
+{
+	//SkipDBRecord *self = (SkipDBRecord *)calloc(1, sizeof(SkipDBRecord));
+	SkipDBRecord *self = (SkipDBRecord *)malloc(sizeof(SkipDBRecord));
+	memset(self, 0, sizeof(SkipDBRecord));
+	self->key = UArray_new();
+	self->ownsKey = 1;
+	self->value = UArray_new();
+	return self;
+}
+
+SkipDBRecord *SkipDBRecord_newWithDB_(void *db)
+{
+	SkipDB *sdb = (SkipDB *)db;
+	SkipDBRecord *self = SkipDBRecord_new();
+	SkipDBRecord_db_(self, sdb);
+	SkipDB_noteNewRecord_(sdb, self);
+	return self;
+}
+
+// older/younger ------------------------
+
+void SkipDBRecord_setOlderRecord_(SkipDBRecord *self, SkipDBRecord *r)
+{
+	if (r == self)
+	{
+		printf("error: r == self\n");
+	}
+
+	self->olderRecord = r;
+}
+
+SkipDBRecord *SkipDBRecord_olderRecord(SkipDBRecord *self)
+{
+	return self->olderRecord;
+}
+
+void SkipDBRecord_setYoungerRecord_(SkipDBRecord *self, SkipDBRecord *r)
+{
+	if (r == self)
+	{
+		printf("error: r == self\n");
+	}
+
+	self->youngerRecord = r;
+}
+
+SkipDBRecord *SkipDBRecord_youngerRecord(SkipDBRecord *self)
+{
+	return self->youngerRecord;
+}
+
+void SkipDBRecord_removeFromAgeList(SkipDBRecord *self)
+{
+	SkipDBRecord *or = self->olderRecord;
+	SkipDBRecord *yr = self->youngerRecord;
+
+	if (or) SkipDBRecord_setYoungerRecord_(or, yr);
+	if (yr) SkipDBRecord_setOlderRecord_(yr, or);
+}
+
+void SkipDBRecord_showAgeList(SkipDBRecord *self)
+{
+	SkipDBRecord *r = self;
+
+	printf("age list:\n");
+
+	while (r)
+	{
+		printf("  record %p '%s'\n",
+			  (void *)r, (char *)UArray_asCString(r->key));
+		r = r->olderRecord;
+	}
+}
+
+//-----------------------------------------
+
+int SkipDBRecord_pointersAreEmpty(SkipDBRecord *self)
+{
+	SkipDBPointer *pointers = self->pointers;
+
+	if (pointers)
+	{
+		int i, max = self->level;
+
+		for (i = 0; i < max; i ++)
+		{
+			SkipDBRecord *r = pointers[i].record;
+			PID_TYPE pid = pointers[i].pid;
+
+			if (r || pid) return 0;
+		}
+	}
+
+	return 1;
+}
+
+
+void SkipDBRecord_removeReferencesToUnmarked(SkipDBRecord *self)
+{
+	SkipDBPointer *pointers = self->pointers;
+
+	if (pointers)
+	{
+		int i, max = self->level;
+
+		for (i = 0; i < max; i ++)
+		{
+			SkipDBRecord *r = pointers[i].record;
+
+			if (r && r->mark == 0)
+			{
+				pointers[i].pid = SkipDBRecord_pid(r);
+				pointers[i].record = NULL;
+			}
+		}
+	}
+
+	if (self->previousRecord && self->previousRecord->mark == 0)
+	{
+		self->previousPid = SkipDBRecord_pid(self->previousRecord);
+		self->previousRecord = NULL;
+	}
+}
+
+//#define SKIPDB_DEBUG 1
+
+#ifdef SKIPDB_DEBUG
+static List *deallocedRecords = NULL;
+#endif
+
+void SkipDBRecord_dealloc(SkipDBRecord *self)
+{
+#ifdef SKIPDB_DEBUG
+	if (!deallocedRecords) deallocedRecords = List_new();
+	printf("SkipDBRecord_dealloc(%p)\n", (void *)self);
+	List_append_(deallocedRecords, self);
+#endif
+
+	SkipDB_noteWillFreeRecord_((SkipDB *)(self->sdb), self);
+
+	if (self->pointers)
+	{
+
+// Commented out since we should not touch records linked
+//  from here, because they may have already been freed.
+//  (e.g. see SkipDB_freeAllCachedRecords or SkipDB_freeExcessCachedRecords).
+//		SkipDBPointer *next = self->pointers + 0;
+//
+//		if (next && next->record)
+//		{
+//			next->record->previousRecord = NULL;
+//		}
+
+		free(self->pointers);
+	}
+
+	if (self->ownsKey) // is this correct?
+	{
+		UArray_free(self->key);
+	}
+
+	UArray_free(self->value);
+
+
+#ifdef SKIPDB_DEBUG
+	return;
+#endif
+	free(self);
+}
+
+void SkipDBRecord_db_(SkipDBRecord *self, void *sdb)
+{
+	self->sdb = sdb;
+}
+
+void SkipDBRecord_pid_(SkipDBRecord *self, PID_TYPE pid)
+{
+	self->pid = pid;
+	SkipDB_noteAssignedPidToRecord_(self->sdb, self);
+}
+
+PID_TYPE SkipDBRecord_pid(SkipDBRecord *self)
+{
+	return self->pid;
+}
+
+PID_TYPE SkipDBRecord_pidAllocIfNeeded(SkipDBRecord *self)
+{
+	if (!self->pid)
+	{
+		PID_TYPE pid = UDB_allocPid(SkipDB_udb(self->sdb));
+		SkipDBRecord_pid_(self, pid);
+		//printf("record '%s' alloced pid %i\n", (char *)UArray_asCString(self->key), (int)self->pid);
+	}
+
+	return self->pid;
+}
+
+void SkipDBRecord_mark(SkipDBRecord *self)
+{
+	self->mark = 1;
+}
+
+void SkipDBRecord_markAsDirty(SkipDBRecord *self)
+{
+	if (!self->isDirty)
+	{
+		self->isDirty = 1;
+		SkipDB_noteDirtyRecord_(self->sdb, self);
+	}
+}
+
+void SkipDBRecord_markAsClean(SkipDBRecord *self)
+{
+	self->isDirty = 0;
+}
+
+uint8_t SkipDBRecord_isDirty(SkipDBRecord *self)
+{
+	return self->isDirty;
+}
+
+// key ------------------------------------
+
+void SkipDBRecord_keyDatum_(SkipDBRecord *self, Datum k)
+{
+	UArray_setData_type_size_copy_(self->key, k.data, CTYPE_uint8_t, k.size, 1);
+}
+
+Datum SkipDBRecord_keyDatum(SkipDBRecord *self)
+{
+	return Datum_FromUArray_(self->key);
+}
+
+UArray *SkipDBRecord_key(SkipDBRecord *self)
+{
+	return self->key;
+}
+
+// value ------------------------------------
+
+void SkipDBRecord_valueDatum_(SkipDBRecord *self, Datum v)
+{
+	UArray_setData_type_size_copy_(self->value, v.data, CTYPE_uint8_t, v.size, 1);
+}
+
+Datum SkipDBRecord_valueDatum(SkipDBRecord *self)
+{
+	return Datum_FromUArray_(self->value);
+}
+
+UArray *SkipDBRecord_value(SkipDBRecord *self)
+{
+	return self->value;
+}
+
+// pointers ------------------------------------
+
+int SkipDBRecord_level(SkipDBRecord *self)
+{
+	return self->level;
+}
+
+void SkipDBRecord_level_(SkipDBRecord *self, int level)
+{
+	int oldLevel = self->level;
+	self->level = level;
+
+	self->pointers = (SkipDBPointer *)realloc(self->pointers, level * sizeof(SkipDBPointer));
+
+	if (level > oldLevel)
+	{
+		memset(self->pointers + oldLevel, 0, (level - oldLevel) * sizeof(SkipDBPointer));
+	}
+}
+
+static void SkipDBRecord_checkLevel_(SkipDBRecord *self, int level)
+{
+     if (level > self->level - 1)
+     {
+		printf("SkipDBRecord level out of range\n");
+		exit(1);
+     }
+}
+
+static SkipDBPointer *SkipDBRecord_pointerAtLevel_(SkipDBRecord *self, int level)
+{
+	SkipDBRecord_checkLevel_(self, level);
+	return self->pointers + level;
+}
+
+void SkipDBRecord_atLevel_setPid_setSuffix_(SkipDBRecord *self, int level, PID_TYPE pid, uint8_t sMatch)
+{
+	SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+	p->pid = pid;
+	SkipDBPointer_setRecord_(p, NULL);
+	p->matchingPrefixSize = sMatch;
+}
+
+void SkipDBRecord_atLevel_setPid_(SkipDBRecord *self, int level, PID_TYPE pid)
+{
+	SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+	p->pid = pid;
+	SkipDBPointer_setRecord_(p, NULL);
+}
+
+PID_TYPE SkipDBRecord_allocedPidAtLevel_(SkipDBRecord *self, int level)
+{
+	SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+	PID_TYPE pid = p->pid;
+
+	if (!pid && p->record)
+	{
+		pid = SkipDBRecord_pidAllocIfNeeded(p->record);
+	}
+
+	return pid;
+}
+
+PID_TYPE SkipDBRecord_pidAtLevel_(SkipDBRecord *self, int level)
+{
+	SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+	PID_TYPE pid = p->pid;
+
+	if (!pid && p->record)
+	{
+		pid = SkipDBRecord_pid(self);
+	}
+
+	return pid;
+}
+
+unsigned char SkipDBRecord_matchingPrefixSizeWith_(SkipDBRecord *self, SkipDBRecord *r)
+{
+	Datum k1 = Datum_FromUArray_(self->key);
+	Datum k2 = Datum_FromUArray_(r->key);
+	return Datum_matchingPrefixSizeWith_(&k1, &k2);
+	//return UArray_matchingPrefixSizeWith_(self->key, r->key);
+}
+
+void SkipDBRecord_atLevel_setRecord_(SkipDBRecord *self, int level, SkipDBRecord *r)
+{
+	SkipDBRecord_checkLevel_(self, level);
+	SkipDBRecord_atLevel_setPid_(self, level, SkipDBRecord_pid(r));
+
+	{
+		SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+		SkipDBPointer_setRecord_(p, r);
+		p->matchingPrefixSize = SkipDBRecord_matchingPrefixSizeWith_(self, r);
+	}
+}
+
+SkipDBRecord *SkipDBRecord_cachedRecordAtLevel_(SkipDBRecord *self, int level)
+{
+	SkipDBRecord_checkLevel_(self, level);
+
+	return self->pointers[level].record;
+}
+
+//直接下降到0层级，获取下个元素
+SkipDBRecord *SkipDBRecord_recordAtLevel_(SkipDBRecord *self, int level)
+{
+	SkipDBRecord_checkLevel_(self, level);
+
+	{
+		SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+		SkipDBRecord *r = p->record;
+
+		if (!r && p->pid)
+		{
+			r = SkipDB_recordAtPid_((SkipDB *)(self->sdb), p->pid);
+			SkipDBPointer_setRecord_(p, r);
+		}
+
+		return r;
+	}
+}
+
+// serialization ------------------------------------
+
+void SkipDBRecord_toStream_(SkipDBRecord *self, BStream *s)
+{
+	BStream_writeTaggedUArray_(s, self->key);
+	BStream_writeTaggedUArray_(s, self->value);
+
+	//printf("writing record '%s'\n", (char *)UArray_asCString(self->key));
+
+	{
+		int level, max = SkipDBRecord_level(self);
+		BStream_writeTaggedInt32_(s, max);
+
+		for (level = 0; level < max; level ++)
+		{
+			SkipDBPointer *p = SkipDBRecord_pointerAtLevel_(self, level);
+			PID_TYPE pid = SkipDBRecord_allocedPidAtLevel_(self, level);
+			BStream_writeTaggedInt32_(s, pid);
+
+			//if (p->record) printf("'%s' %i\n", (char *)UArray_asCString(p->record->key), (int)pid);
+
+			BStream_writeTaggedUint8_(s, p->matchingPrefixSize);
+		}
+	}
+
+	//printf("\n");
+
+	//BStream_show(s);
+}
+
+void SkipDBRecord_fromStream_(SkipDBRecord *self, BStream *s)
+{
+	BStream_readTaggedUArray_(s, self->key);
+	BStream_readTaggedUArray_(s, self->value);
+
+	{
+		int level, max = BStream_readTaggedInt32(s);
+
+		SkipDBRecord_level_(self, max);
+
+		for (level = 0; level < max; level ++)
+		{
+			PID_TYPE pid = BStream_readTaggedInt32(s);
+			uint8_t sMatch = BStream_readTaggedUint8(s);
+			SkipDBRecord_atLevel_setPid_setSuffix_(self, level, pid, sMatch);
+		}
+	}
+
+	//BStream_show(s);
+}
+
+void SkipDBRecord_save(SkipDBRecord *self)
+{
+	if (self->isDirty)
+	{
+		SkipDB *sdb = self->sdb;
+		BStream *s = SkipDB_tmpStream(sdb);
+		BStream_empty(s);
+		SkipDBRecord_toStream_(self, s);
+
+		{
+			Datum d = Datum_FromUArray_(BStream_byteArray(s));
+			PID_TYPE pid = SkipDBRecord_pid(self);
+
+			if (pid)
+			{
+				UDB_at_put_(SkipDB_udb(sdb), pid, d);
+			}
+			else
+			{
+				pid = UDB_put_(SkipDB_udb(sdb), d);
+				SkipDBRecord_pid_(self, pid);
+			}
+		}
+
+		SkipDBRecord_markAsClean(self);
+	}
+}
+
+// search ------------------------------------
+
+static int SkipDBRecord_compareKey_(SkipDBRecord *self, Datum key)
+{
+	Datum d = Datum_FromUArray_(self->key);
+	return Datum_compare_(&d, &key);
+}
+
+//Added by jannson
+//#define USE_SUFFIX_MATCHING 1
+
+SkipDBRecord *SkipDBRecord_find_quick_(SkipDBRecord *self, Datum key, int quick)
+{
+	SkipDB *db = (SkipDB *)(self->sdb);
+	int level = self->level;
+
+#ifdef USE_SUFFIX_MATCHING
+	//Datum kDatum = UArray_asDatum(self->key);
+        Datum kDatum = Datum_FromUArray_(self->key);
+	unsigned char skMatchSize = Datum_matchingPrefixSizeWith_(&kDatum, &key);
+#endif
+
+	//printf("record: %s find: %s in ", UArray_asCString(self->key), key.data);
+	//SkipDBRecord_show(self);
+        //printf("skMatchSize %i\n", skMatchSize);
+        //printf("-------------\n\n");
+
+	while (level --)
+	{
+		SkipDBRecord *r = SkipDBRecord_recordAtLevel_(self, level);
+#ifdef USE_SUFFIX_MATCHING
+		unsigned char pkMatchSize = self->pointers[level].matchingPrefixSize;
+                printf("pkMatchSize=%d, skMatchSize=%d\n", pkMatchSize, skMatchSize);
+#endif
+
+		SkipDB_updateAt_put_(db, level, self);
+
+		//if (r && !(pkMatchSize > skMatchSize))
+		if (r)
+		{
+			int c;
+
+#ifdef USE_SUFFIX_MATCHING
+			if (pkMatchSize > skMatchSize)
+			{
+				//printf("search key: '%s' \n", key.data);
+				//printf("self key:   '%s' %i\n", UArray_asCString(self->key), skMatchSize);
+				//printf("p key:      '%s' %i\n", UArray_asCString(r->key), pkMatchSize);
+				//printf("skip compare\n");
+				return SkipDBRecord_find_quick_(r, key, quick);
+			}
+#endif
+
+			c = SkipDBRecord_compareKey_(r, key);
+
+			//printf("key: %s at level: %i\n", UArray_asCString(r->key), level);
+
+			/*
+			 if (UArray_sizeInBytes(r->key) == 0)
+			 {
+				 printf("ERROR: key length = 0\n");
+				 exit(1);
+			 }
+			 */
+
+			if (c == 0) // record is a match
+			{
+				if (level == 0 || quick)
+				{
+					return r;
+				}
+			}
+			else if (c < 0) // record key is smaller
+			{
+                //往前面节点找，遇到大的，就往下个level找
+				return SkipDBRecord_find_quick_(r, key, quick);
+			}
+			// otherwise record key is bigger so we keep searching
+		}
+	}
+
+	return NULL;
+}
+
+SkipDBRecord *SkipDBRecord_findLastRecord(SkipDBRecord *self)
+{
+	int level = self->level;
+
+	while (level --)
+	{
+		SkipDBRecord *r = SkipDBRecord_recordAtLevel_(self, level);
+
+		if (r)
+		{
+			return SkipDBRecord_findLastRecord(r);
+		}
+
+	}
+
+	return self;
+}
+
+void SkipDBRecord_copyLevel_from_(SkipDBRecord *self, int level, SkipDBRecord *other)
+{
+	PID_TYPE newPid = SkipDBRecord_pidAtLevel_(other, level);
+	SkipDBRecord *cachedRecord = SkipDBRecord_cachedRecordAtLevel_(other, level);
+
+	if (cachedRecord)
+	{
+		SkipDBRecord_atLevel_setRecord_(self, level, cachedRecord);
+	}
+	else
+	{
+		SkipDBRecord_atLevel_setPid_(self, level, newPid);
+	}
+}
+
+void SkipDBRecord_willRemove_(SkipDBRecord *self, SkipDBRecord *other)
+{
+	PID_TYPE otherPid = SkipDBRecord_pid(other);
+	int level = self->level;
+
+	while (level --)
+	{
+		if ((otherPid && SkipDBRecord_pidAtLevel_(self, level) == otherPid) ||
+		    (SkipDBRecord_recordAtLevel_(self, level) == other))
+		{
+			SkipDBRecord_copyLevel_from_(self, level, other);
+			SkipDBRecord_markAsDirty(self);
+		}
+	}
+
+	/*
+	 if (SkipDBRecord_hasRecord_(self, other))
+	 {
+		 printf("error - has record after remove\n");
+		 exit(-1);
+	 }
+	 */
+}
+
+int SkipDBRecord_hasRecord_(SkipDBRecord *self, SkipDBRecord *other)
+{
+	int i;
+
+	for (i = 0; i < self->level; i ++)
+	{
+		if (self->pointers[i].record == other)
+		{
+			return 1;
+		}
+	}
+	return 0;
+}
+
+void SkipDBRecord_show(SkipDBRecord *self)
+{
+	int i;
+	//printf("SRec %i '%s' '%s' (", self->pid,
+	//	UArray_asCString(self->key), UArray_asCString(self->value));
+	//printf("SRec %i '%s' (", self->pid, UArray_asCString(self->key));
+	printf("  record %i '%s'\t:\t", (int)self->pid, UArray_asCString(self->key));
+
+	for (i = 0; i < self->level; i ++)
+	{
+		SkipDBRecord *r = self->pointers[i].record;
+
+		if (r)
+		{
+			printf("'%s'", UArray_asCString(r->key));
+		}
+		else
+		{
+			printf("%i", (int)(self->pointers[i].pid));
+		}
+
+		printf("\t");
+
+		//if (i != self->level - 1) printf(", ");
+	}
+
+	printf("\n");
+}
+
+// object ------------------------------------
+
+void SkipDBRecord_object_(SkipDBRecord *self, void *object)
+{
+	self->object = object;
+}
+
+void *SkipDBRecord_object(SkipDBRecord *self)
+{
+	return self->object;
+}
+
+// next ------------------------------------
+
+SkipDBRecord *SkipDBRecord_nextRecord(SkipDBRecord *self)
+{
+	return SkipDBRecord_recordAtLevel_(self, 0);
+}
+
+// previous ------------------------------------
+
+void SkipDBRecord_previousPid_(SkipDBRecord *self, PID_TYPE pid)
+{
+	self->previousPid = pid;
+	self->previousRecord = NULL;
+}
+
+PID_TYPE SkipDBRecord_previousPid(SkipDBRecord *self)
+{
+	return self->previousPid;
+}
+
+void SkipDBRecord_previousRecord_(SkipDBRecord *self, SkipDBRecord *r)
+{
+	if (r != self->previousRecord)
+	{
+		if (r == self)
+		{
+			printf("SkipDB error: attempt to set previousRecord to self\n");
+		}
+
+		self->previousRecord = r;
+
+		if (r)
+		{
+			self->previousPid = SkipDBRecord_pid(r);
+		}
+
+		SkipDBRecord_markAsDirty(self);
+	}
+}
+
+#ifdef SKIPDB_DEBUG
+void textValid(void *record)
+{
+	if (!deallocedRecords) deallocedRecords = List_new();
+	if (List_contains_(deallocedRecords, record))
+	{
+		printf("attempt to access freed record %p\n", (void *)record);
+		exit(-1);
+	}
+}
+#endif
+
+SkipDBRecord *SkipDBRecord_previousRecord(SkipDBRecord *self)
+{
+	if (!self->previousRecord && self->previousPid)
+	{
+		self->previousRecord = SkipDB_recordAtPid_((SkipDB *)(self->sdb), self->previousPid);
+	}
+
+#ifdef SKIPDB_DEBUG
+	textValid(self);
+	textValid(self->previousRecord);
+#endif
+
+	return self->previousRecord;
+}
+
diff --git a/release/src/router/skipdbv2/skipdb/SkipDBRecord.h b/release/src/router/skipdbv2/skipdb/SkipDBRecord.h
new file mode 100644
index 0000000000..308c6fced4
--- /dev/null
+++ b/release/src/router/skipdbv2/skipdb/SkipDBRecord.h
@@ -0,0 +1,141 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("SkipDBRecord")    
+docDescription("A skip list record.")
+*/
+
+#ifndef SkipDBRecord_DEFINED
+#define SkipDBRecord_DEFINED 1
+
+#include "List.h"
+#include "BStream.h"
+#include "UDB.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct SkipDBRecord  SkipDBRecord;
+typedef struct SkipDBPointer SkipDBPointer;
+
+#define SKIPDBRECORD_UNMARKED  0
+#define SKIPDBRECORD_MARKED    1
+
+struct SkipDBPointer
+{
+    PID_TYPE pid;
+    unsigned char matchingPrefixSize;
+    SkipDBRecord *record;
+};
+
+struct SkipDBRecord
+{
+    int level;
+    SkipDBPointer *pointers;
+    
+    PID_TYPE previousPid;
+    SkipDBRecord *previousRecord;
+
+    UArray *key;
+    UArray *value;
+
+    void *sdb;
+    PID_TYPE pid;
+    void *object; // extra pointer for user to make use of - not stored 
+    int ownsKey;
+    uint8_t isDirty;
+
+    // cache related 
+
+    SkipDBRecord *youngerRecord; // accessed before self 
+    SkipDBRecord *olderRecord;   // accessed after self 
+    unsigned char mark;
+};
+
+SKIPDB_API int SkipDBRecord_pointersAreEmpty(SkipDBRecord *self);
+
+SKIPDB_API SkipDBRecord *SkipDBRecord_new(void);
+SKIPDB_API SkipDBRecord *SkipDBRecord_newWithDB_(void *db);
+
+SKIPDB_API void SkipDBRecord_setOlderRecord_(SkipDBRecord *self, SkipDBRecord *r);
+SKIPDB_API SkipDBRecord *SkipDBRecord_olderRecord(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_setYoungerRecord_(SkipDBRecord *self, SkipDBRecord *r);
+SKIPDB_API SkipDBRecord *SkipDBRecord_youngerRecord(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_removeFromAgeList(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_removeReferencesToUnmarked(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_dealloc(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_db_(SkipDBRecord *self, void *db);
+
+SKIPDB_API void SkipDBRecord_pid_(SkipDBRecord *self, PID_TYPE pid);
+SKIPDB_API PID_TYPE SkipDBRecord_pid(SkipDBRecord *self);
+SKIPDB_API PID_TYPE SkipDBRecord_pidAllocIfNeeded(SkipDBRecord *self);
+
+SKIPDB_API int SkipDBRecord_level(SkipDBRecord *self);
+SKIPDB_API void SkipDBRecord_level_(SkipDBRecord *self, int level);
+
+SKIPDB_API void SkipDBRecord_mark(SkipDBRecord *self);
+
+SKIPDB_API uint8_t SkipDBRecord_isDirty(SkipDBRecord *self);
+SKIPDB_API void SkipDBRecord_markAsDirty(SkipDBRecord *self);
+SKIPDB_API void SkipDBRecord_markAsClean(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_atLevel_setPid_(SkipDBRecord *self, int level, PID_TYPE pid);
+SKIPDB_API PID_TYPE SkipDBRecord_pidAtLevel_(SkipDBRecord *self, int level);
+
+SKIPDB_API void SkipDBRecord_atLevel_setRecord_(SkipDBRecord *self, int level, SkipDBRecord *r);
+SKIPDB_API SkipDBRecord *SkipDBRecord_recordAtLevel_(SkipDBRecord *self, int level);
+
+SKIPDB_API void SkipDBRecord_copyLevel_from_(SkipDBRecord *self, int level, SkipDBRecord *other);
+
+//-------------------------------------------- 
+
+SKIPDB_API void SkipDBRecord_keyDatum_(SkipDBRecord *self, Datum k);
+SKIPDB_API Datum SkipDBRecord_keyDatum(SkipDBRecord *self);
+SKIPDB_API UArray *SkipDBRecord_key(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_valueDatum_(SkipDBRecord *self, Datum v);
+SKIPDB_API Datum SkipDBRecord_valueDatum(SkipDBRecord *self);
+SKIPDB_API UArray *SkipDBRecord_value(SkipDBRecord *self);
+
+// serialization ----------------------------- 
+
+SKIPDB_API void SkipDBRecord_toStream_(SkipDBRecord *self, BStream *s);
+SKIPDB_API void SkipDBRecord_fromStream_(SkipDBRecord *self, BStream *s);
+SKIPDB_API void SkipDBRecord_save(SkipDBRecord *self);
+
+// search ------------------------------------ 
+
+SKIPDB_API SkipDBRecord *SkipDBRecord_find_quick_(SkipDBRecord *self, Datum key, int quick);
+SkipDBRecord *SkipDBRecord_findLastRecord(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_willRemove_(SkipDBRecord *self, SkipDBRecord *other);
+
+SKIPDB_API void SkipDBRecord_show(SkipDBRecord *self);
+
+// object ------------------------------------ 
+
+SKIPDB_API void SkipDBRecord_object_(SkipDBRecord *self, void *object);
+SKIPDB_API void *SkipDBRecord_object(SkipDBRecord *self);
+
+// next ------------------------------------ 
+
+SKIPDB_API SkipDBRecord *SkipDBRecord_nextRecord(SkipDBRecord *self);
+
+// previous ------------------------------------ 
+
+SKIPDB_API void SkipDBRecord_previousPid_(SkipDBRecord *self, PID_TYPE pid);
+SKIPDB_API PID_TYPE SkipDBRecord_previousPid(SkipDBRecord *self);
+
+SKIPDB_API void SkipDBRecord_previousRecord_(SkipDBRecord *self, SkipDBRecord *r);
+SKIPDB_API SkipDBRecord *SkipDBRecord_previousRecord(SkipDBRecord *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/tests/check.sh b/release/src/router/skipdbv2/tests/check.sh
new file mode 100644
index 0000000000..62dfeb5bd9
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/check.sh
@@ -0,0 +1,13 @@
+#!/bin/sh 
+
+COUNTER=0
+V="your are the best"
+K="hello"
+eval `../build/bin/dbus export hello`
+while [  $COUNTER -lt 10000 ]; do
+    eval "KV=$"$K$COUNTER
+    if [ "$KV" != "$V$COUNTER" ]; then
+        echo "$KV $V$COUNTER"
+    fi
+    let COUNTER=COUNTER+1 
+done
diff --git a/release/src/router/skipdbv2/tests/env.c b/release/src/router/skipdbv2/tests/env.c
new file mode 100644
index 0000000000..3d58254323
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/env.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+//TODO for shell env
+int main(int argc, char **argv, char * envp[])
+{
+    char** env;
+    char* this_env;
+    char *v;
+
+    for (env = envp; *env != 0; env++) {
+        this_env = (char*)strdup(*env);
+        v = strstr(this_env, "=");
+        if(v != NULL) {
+            *v = '\0';
+            v += 1;
+            printf("%s=%s\n", this_env, v);
+        }
+        if(this_env != NULL) {
+            free(this_env);
+        }
+    }
+  putenv("SomeVariable=SomeValue");
+  return 0;
+}
diff --git a/release/src/router/skipdbv2/tests/example.c b/release/src/router/skipdbv2/tests/example.c
new file mode 100644
index 0000000000..f331d4c9ae
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/example.c
@@ -0,0 +1,70 @@
+#include "SkipDB.h"
+
+int main(void)
+{
+	Datum key;
+	Datum value;
+	Datum key2;
+	Datum value2;
+	int count;
+
+	// open
+	
+	SkipDB *db = SkipDB_new();
+	SkipDB_setPath_(db, "test.skipdb");
+	if(0 == SkipDB_open(db)) {
+	    SkipDB_beginTransaction(db);
+            key = Datum_FromCString_("__inner__");
+            value = Datum_FromCString_("__begin__");
+	    SkipDB_commitTransaction(db);
+            SkipDB_close(db);
+            SkipDB_open(db);
+        }
+	
+	// write
+	
+#if 0
+	SkipDB_beginTransaction(db);
+	key = Datum_FromCString_("testKey");
+	value = Datum_FromCString_("testValue");
+	SkipDB_at_put_(db, key, value);
+
+	key2 = Datum_FromCString_("testKey2");
+	value2 = Datum_FromCString_("testValue2");
+	SkipDB_at_put_(db, key2, value2);
+
+	SkipDB_commitTransaction(db);
+#else
+	key = Datum_FromCString_("testKey");
+	key2 = Datum_FromCString_("testKey2");
+	//key = Datum_FromCString_("testKey88");
+	//key2 = Datum_FromCString_("testKey233");
+#endif
+        SkipDB_show(db);
+	
+	// read
+	value = SkipDB_at_(db, key);
+        printf("%s=%s\n", key.data, value.data);
+	
+	value2 = SkipDB_at_(db, key2);
+        printf("%s=%s\n", key2.data, value2.data);
+
+	// count
+	
+	count = SkipDB_count(db);
+
+	// remove
+	
+	//SkipDB_beginTransaction(db);
+	//SkipDB_removeAt_(db, key);
+	//SkipDB_commitTransaction(db);
+	
+	// there's also a cursor API
+	// not shown in this example code
+
+	// close
+	
+	SkipDB_close(db);
+	
+	return 0;
+}
diff --git a/release/src/router/skipdbv2/tests/jftest.c b/release/src/router/skipdbv2/tests/jftest.c
new file mode 100644
index 0000000000..283883e17c
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/jftest.c
@@ -0,0 +1,30 @@
+#include <stdlib.h>
+#include <time.h>
+#include "JFile.h"
+#include "List.h"
+#include "PortableGettimeofday.h"
+#include "Date.h"
+
+int main(void)
+{
+    int value = 444, nv;
+    JFile *j = JFile_new();
+    JFile_setPath_(j, "test.jfile");
+
+#if 0
+    JFile_remove(j);
+    JFile_open(j);
+
+    JFile_begin(j);
+    JFile_setPosition_(j, 0);
+    JFile_writeInt_(j, value);
+    JFile_commitToLog(j);
+    JFile_commitToFile(j);
+#else
+    JFile_open(j);
+#endif
+
+    JFile_setPosition_(j, 0);
+    printf("%d\n", JFile_readInt(j));
+}
+
diff --git a/release/src/router/skipdbv2/tests/remove.sh b/release/src/router/skipdbv2/tests/remove.sh
new file mode 100644
index 0000000000..4e86378c73
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/remove.sh
@@ -0,0 +1,10 @@
+#!/bin/sh 
+
+COUNTER=0
+
+V="your are the best"
+K="hello"
+while [  $COUNTER -lt 2000 ]; do
+    ../build/bin/dbus remove $K$COUNTER
+    let COUNTER=COUNTER+1 
+done
diff --git a/release/src/router/skipdbv2/tests/skiplist.c b/release/src/router/skipdbv2/tests/skiplist.c
new file mode 100644
index 0000000000..441b140614
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/skiplist.c
@@ -0,0 +1,185 @@
+/* Skip Lists: A Probabilistic Alternative to Balanced Trees */
+
+/*
+Skip List定义
+一个跳表，应该具有以下特征：
+	一个跳表应该有几个层（level）组成；
+	跳表的第一层包含所有的元素；
+	每一层都是一个有序的链表；
+	如果元素x出现在第i层，则所有比i小的层都包含x；
+	第i层的元素通过一个down指针指向下一层拥有相同值的元素；
+	在每一层中，-1和1两个元素都出现(分别表示INT_MIN和INT_MAX)；
+	Top指针指向最高层的第一个元素。
+*/
+ 
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+ 
+#define SKIPLIST_MAX_LEVEL 6
+ 
+typedef struct snode {
+    int key;
+    int value;
+    struct snode **forward;
+} snode;
+ 
+typedef struct skiplist {
+    int level;
+    int size;
+    struct snode *header;
+} skiplist;
+ 
+skiplist *skiplist_init(skiplist *list)
+{
+    int i;
+    snode *header = (snode *)malloc(sizeof(struct snode));
+    list->header = header;
+    header->key = INT_MAX;
+    header->forward = (snode **)malloc(sizeof(snode*) * (SKIPLIST_MAX_LEVEL+1));
+    for (i = 0; i <= SKIPLIST_MAX_LEVEL; i++) {
+        header->forward[i] = list->header;
+    }
+ 
+    list->level = 1;
+    list->size = 0;
+ 
+    return list;
+}
+ 
+static int rand_level()
+{
+    int level = 1;
+    while (rand() < RAND_MAX/2 && level < SKIPLIST_MAX_LEVEL)
+        level++;
+    return level;
+}
+ 
+int skiplist_insert(skiplist *list, int key, int value)
+{
+    snode *update[SKIPLIST_MAX_LEVEL+1];
+    snode *x = list->header;
+    int i, level;
+    for (i = list->level; i >= 1; i--) {
+        while (x->forward[i]->key < key)
+            x = x->forward[i];
+        update[i] = x;
+    }
+    x = x->forward[1];
+ 
+    if (key == x->key) {
+        x->value = value;
+        return 0;
+    } else {
+        level = rand_level();
+        if (level > list->level) {
+            for (i = list->level+1; i <= level; i++) {
+                update[i] = list->header;
+            }
+            list->level = level;
+        }
+ 
+        x = (snode *)malloc(sizeof(snode));
+        x->key = key;
+        x->value = value;
+        x->forward = (snode **)malloc(sizeof(snode*) * (level + 1));
+        for (i = 1; i <= level; i++) {
+            x->forward[i] = update[i]->forward[i];
+            update[i]->forward[i] = x;
+        }
+    }
+    return 0;
+}
+ 
+snode *skiplist_search(skiplist *list, int key)
+{
+    snode *x = list->header;
+    int i;
+    for (i = list->level; i >= 1; i--) {
+        while (x->forward[i]->key < key)
+            x = x->forward[i];
+    }
+    if (x->forward[1]->key == key) {
+        return x->forward[1];
+    } else {
+        return NULL;
+    }
+    return NULL;
+}
+ 
+static void skiplist_node_free(snode *x)
+{
+    if (x) {
+        free(x->forward);
+        free(x);
+    }
+}
+ 
+int skiplist_delete(skiplist *list, int key)
+{
+    int i;
+    snode *update[SKIPLIST_MAX_LEVEL + 1];
+    snode *x = list->header;
+    for (i = list->level; i >= 1; i--) {
+        while (x->forward[i]->key < key)
+            x = x->forward[i];
+        update[i] = x;
+    }
+ 
+    x = x->forward[1];
+    if (x->key == key) {
+        for (i = 1; i <= list->level; i++) {
+            if (update[i]->forward[i] != x)
+                break;
+            update[i]->forward[1] = x->forward[i];
+        }
+        skiplist_node_free(x);
+ 
+        while (list->level > 1 && list->header->forward[list->level] == list->header)
+            list->level--;
+        return 0;
+    }
+    return 1;
+}
+ 
+static void skiplist_dump(skiplist *list)
+{
+    snode *x = list->header;
+    while (x && x->forward[1] != list->header) {
+        printf("%d[%d]->", x->forward[1]->key, x->forward[1]->value);
+        x = x->forward[1];
+    }
+    printf("NIL\n");
+}
+ 
+int main()
+{
+    int arr[] = {3, 6, 9, 2, 11, 1, 4}, i;
+    skiplist list;
+    skiplist_init(&list);
+ 
+    printf("Insert:--------------------\n");
+    for (i = 0; i < sizeof(arr)/sizeof(arr[0]); i++) {
+        skiplist_insert(&list, arr[i], arr[i]);
+    }
+    skiplist_dump(&list);
+ 
+    printf("Search:--------------------\n");
+    int keys[] = {3, 4, 7, 10, 111};
+ 
+    for (i = 0; i < sizeof(keys)/sizeof(keys[0]); i++) {
+        snode *x = skiplist_search(&list, keys[i]);
+        if (x) {
+            printf("key = %d, value = %d\n", keys[i], x->value);
+        } else {
+            printf("key = %d, not fuound\n", keys[i]);
+        }
+    }
+ 
+    printf("Search:--------------------\n");
+    skiplist_delete(&list, 3);
+    skiplist_delete(&list, 9);
+    skiplist_dump(&list);
+ 
+    return 0;
+}
diff --git a/release/src/router/skipdbv2/tests/test.c b/release/src/router/skipdbv2/tests/test.c
new file mode 100644
index 0000000000..b63350e231
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/test.c
@@ -0,0 +1,162 @@
+
+#include "SkipDB.h"
+#include <time.h>
+#include <stdlib.h>
+#include "Date.h"
+
+int main(void)
+{
+	Datum k;
+	int i, max;
+	time_t t1;
+	double dt; 
+	char s[100];
+		
+	SkipDB *u = SkipDB_new();
+	
+	printf("SkipDB (ordered key/value database) performance test:\n");
+	SkipDB_setPath_(u, "test.skipdb");
+	SkipDB_delete(u);
+	SkipDB_open(u);
+	
+	max = 1;
+
+	t1 = Date_SecondsFrom1970ToNow();
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+		
+		SkipDB_at_put_(u, k, k);
+	}
+	SkipDB_commitTransaction(u);
+	dt = Date_SecondsFrom1970ToNow()-t1;;
+	printf("	%i individual sequential transactional writes per second\n", (int)((double)max/dt));
+
+	SkipDB_close(u);
+	SkipDB_open(u);
+	
+	t1 = Date_SecondsFrom1970ToNow();
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+				
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+			printf("ERROR: no record at %i\n", i);
+			exit(-1);
+		}
+		else
+		{
+			if (strcmp(s, (char *)d.data) != 0)
+			{
+				printf("ERROR: bad value at %i\n", i);
+				exit(-1);
+			}
+		}
+	}
+	printf("writes verified\n");
+	
+	printf("testing removes\n");
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+		SkipDB_removeAt_(u, k);
+	}
+	//SkipDB_show(u);
+	SkipDB_commitTransaction(u);
+
+	SkipDB_close(u);
+	printf("closing after removes\n");
+	SkipDB_open(u);
+	
+	t1 = Date_SecondsFrom1970ToNow();
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+				
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+		}
+		else
+		{
+			printf("ERROR: record %i not removed\n", i);
+			exit(-1);
+		}
+	}
+	printf("removes verified\n");
+	
+	SkipDB_close(u);
+	SkipDB_delete(u);
+	SkipDB_open(u);
+
+	max = 1024*64;
+	
+	t1 = Date_SecondsFrom1970ToNow();
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+
+		SkipDB_at_put_(u, k, k);
+	}
+	SkipDB_commitTransaction(u);
+	dt = Date_SecondsFrom1970ToNow()-t1;;
+	printf("	%i group transactional writes per second\n", (int)((double)max/dt));
+
+
+	t1 = Date_SecondsFrom1970ToNow();
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		k = Datum_FromCString_(s);
+				
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+			printf("ERROR: no record at %i\n", i);
+			exit(-1);
+		}
+		else
+		{
+			if (strcmp(s, (char *)d.data) != 0)
+			{
+				printf("ERROR: bad value at %i\n", i);
+				exit(-1);
+			}
+		}
+	}
+	dt = Date_SecondsFrom1970ToNow()-t1;;
+	printf("	%i reads per second\n", (int)((float)max/dt));
+	
+	
+	t1 = Date_SecondsFrom1970ToNow();
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "%i", i);
+		k = Datum_FromCString_(s);
+				
+		SkipDB_removeAt_(u, k);
+	}
+	SkipDB_commitTransaction(u);
+	dt = Date_SecondsFrom1970ToNow()-t1;;
+	printf("	%i group transactional removes per second\n", (int)((float)max/dt));
+	
+	SkipDB_delete(u);
+	SkipDB_free(u);
+	return 0;
+}
diff --git a/release/src/router/skipdbv2/tests/test.sh b/release/src/router/skipdbv2/tests/test.sh
new file mode 100755
index 0000000000..4c245d3db6
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/test.sh
@@ -0,0 +1,14 @@
+#!/bin/sh 
+
+COUNTER=0
+
+V="your are the best"
+K="hello"
+while [  $COUNTER -lt 10000 ]; do
+    #echo The counter is $V$COUNTER
+    #../build/bin/dbus set $K$COUNTER=$V$COUNTER
+    #../build/bin/dbus get $K$COUNTER
+    export $K$COUNTER="$V$COUNTER"
+    let COUNTER=COUNTER+1 
+done
+../build/bin/dbus save $K
diff --git a/release/src/router/skipdbv2/tests/test2.c b/release/src/router/skipdbv2/tests/test2.c
new file mode 100644
index 0000000000..217877e3be
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/test2.c
@@ -0,0 +1,174 @@
+#include "SkipDB.h"
+#include <time.h>
+#include <stdlib.h>
+#include "Date.h"
+
+void skipdb_list(SkipDB* self, SkipDBRecord* rc, void* ctx)
+{
+	Datum k = SkipDBRecord_keyDatum(rc);
+    Datum v = SkipDBRecord_valueDatum(rc);
+    printf("%s=%s\n", k.data, v.data);
+}
+
+void SkipDB_show_by_prefix(SkipDB *u, Datum k)
+{
+	Datum t;
+    SkipDBCursor* cursor = SkipDBCursor_newWithDB_(u);
+    SkipDBRecord* rc = SkipDBCursor_goto_(cursor, k);
+    if(NULL == rc) {
+        printf("hear\n");
+        return;
+    }
+
+    t = SkipDBRecord_valueDatum(rc);
+    //printf("k.size=%d t.size=%d k=%s t=%s\n", k.size, t.size, k.data, t.data);
+    if((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1))) {
+        printf("%s\n", t.data);
+    }
+
+    rc = SkipDBCursor_next(cursor);
+    while(NULL != rc) {
+        t = SkipDBRecord_valueDatum(rc);
+        if((k.size <= t.size) && (0 == strncmp((char*)t.data, (char*)k.data, k.size-1))) {
+            printf("%s\n", t.data);
+            rc = SkipDBCursor_next(cursor);
+        } else {
+            break;
+        }
+    }
+
+    SkipDBCursor_release(cursor);
+}
+
+int main(void)
+{
+	Datum k, t;
+	int i, max;
+	time_t t1;
+	double dt;
+	char s[100];
+
+	SkipDB *u = SkipDB_new();
+
+	printf("SkipDB (ordered key/value database) performance test:\n");
+	SkipDB_setPath_(u, "test.skipdb");
+	SkipDB_delete(u);
+	SkipDB_open(u);
+
+	max = 3000;
+
+	t1 = Date_SecondsFrom1970ToNow();
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "test%i", i);
+		k = Datum_FromCString_(s);
+
+		SkipDB_at_put_(u, k, k);
+	}
+
+	SkipDB_commitTransaction(u);
+	dt = Date_SecondsFrom1970ToNow()-t1;;
+	printf("	%i individual sequential transactional writes per second\n", (int)((double)max/dt));
+
+	SkipDB_close(u);
+	SkipDB_open(u);
+
+	//SkipDB_show(u);
+
+	sprintf(s, "test%d", 33);
+	t = Datum_FromCString_(s);
+    SkipDB_list_prefix(u, t, NULL, skipdb_list);
+#if 0
+	t1 = Date_SecondsFrom1970ToNow();
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		sprintf(s, "test%i", i);
+		k = Datum_FromCString_(s);
+
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+			printf("ERROR: no record at %i\n", i);
+			exit(-1);
+		}
+		else
+		{
+			if (strcmp(s, (char *)d.data) != 0)
+			{
+				printf("ERROR: bad value at %i\n", i);
+				exit(-1);
+			}
+		}
+	}
+
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		sprintf(s, "test%i", i);
+		k = Datum_FromCString_(s);
+
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+			printf("ERROR: no record at %i\n", i);
+			exit(-1);
+		}
+		else
+		{
+			if (strcmp(s, (char *)d.data) != 0)
+			{
+				printf("ERROR: bad value at %i\n", i);
+				exit(-1);
+			}
+		}
+	}
+	printf("writes verified\n");
+
+	SkipDB_show(u);
+
+	printf("testing removes\n");
+	SkipDB_beginTransaction(u);
+	for (i = 0; i < max; i ++)
+	{
+		sprintf(s, "test%i", i);
+		k = Datum_FromCString_(s);
+		SkipDB_removeAt_(u, k);
+	}
+	//SkipDB_show(u);
+	SkipDB_commitTransaction(u);
+
+	SkipDB_close(u);
+	printf("closing after removes\n");
+	SkipDB_open(u);
+
+	SkipDB_show(u);
+
+	t1 = Date_SecondsFrom1970ToNow();
+	for (i = 0; i < max; i ++)
+	{
+		Datum d;
+		sprintf(s, "test%i", i);
+		k = Datum_FromCString_(s);
+
+		d = SkipDB_at_(u, k);
+
+		if (d.data == NULL || d.size == 0)
+		{
+		}
+		else
+		{
+			printf("ERROR: record %i not removed\n", i);
+			exit(-1);
+		}
+	}
+	printf("removes verified\n");
+#endif
+
+	SkipDB_delete(u);
+	SkipDB_free(u);
+	return 0;
+}
diff --git a/release/src/router/skipdbv2/tests/udbtest.c b/release/src/router/skipdbv2/tests/udbtest.c
new file mode 100644
index 0000000000..d579995f3a
--- /dev/null
+++ b/release/src/router/skipdbv2/tests/udbtest.c
@@ -0,0 +1,66 @@
+#include <time.h>
+#include <stdlib.h>
+#include "UDB.h"
+#include "Date.h"
+
+int main(void)
+{
+    int max, i, v;
+    PID_TYPE pid;
+    Datum d;
+    UDB *u = UDB_new();
+    UDB_setPath_(u, "test.skipdb");
+    //UDB_delete(u);
+    UDB_open(u);
+
+    max = 30;
+
+#if 0
+    for (i = 0; i < max; i++) {
+            UDB_beginTransaction(u);
+            d.size = sizeof(int);
+            v = i;
+            d.data = (void *)&v;
+            
+            pid = UDB_allocPid(u);
+            fprintf(stderr, "pid=%d\n", pid);
+            UDB_at_put_(u, pid, d);
+            UDB_commitTransaction(u);
+    }
+#endif
+
+#if 0
+    for (i = 0; i < max; i++) {
+        pid = i+1;
+        d = UDB_at_(u, pid);
+
+        if (d.data == NULL || d.size == 0) {
+            printf("ERROR: no record at %i\n", pid);
+        } else {
+            if(d.size != 4) {
+                printf("ERROR: wrong size %i at pid %i\n", d.size, pid);
+            } else {
+                memcpy(&v, d.data, sizeof(int));
+                if(v != i) {
+                    printf("ERROR: wrong value %i at pid %i\n", v, i);
+                }
+            }
+        }
+    }
+#endif
+
+    pid = 1;
+    d = UDB_at_(u, pid);
+    printf("size:%d %s\n", d.size, d.data);
+
+    pid = 2;
+    d = UDB_at_(u, pid);
+    printf("size:%d %s\n", d.size, d.data);
+
+    pid = 3;
+    d = UDB_at_(u, pid);
+    printf("size:%d %s\n", d.size, d.data);
+
+    return 0;
+}
+
diff --git a/release/src/router/skipdbv2/udb/UDB.c b/release/src/router/skipdbv2/udb/UDB.c
new file mode 100644
index 0000000000..cd8db824e9
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDB.c
@@ -0,0 +1,378 @@
+/*#io
+UDB ioDoc(
+		docCopyright("Steve Dekorte", 2004)
+		docLicense("BSD revised")
+		docObject("UDB")    
+		docDescription("")
+		*/
+
+#include "UDB.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+
+UDB *UDB_new(void)
+{
+	UDB *self = (UDB *)calloc(1, sizeof(UDB));
+	
+	self->index       = UDBIndex_new();
+	self->records     = UDBRecords_new();
+	
+	UDB_setPath_(self, "default");
+	return self;
+}
+
+void UDB_free(UDB *self)
+{
+	UDB_close(self);
+	free(self->path);    
+	free(self->committedPath);    
+	
+	UDBIndex_free(self->index);   
+	UDBRecords_free(self->records);   
+	free(self);
+}
+
+void UDB_delete(UDB *self)
+{
+	UDB_close(self);
+	UDBIndex_delete(self->index);
+	UDBRecords_delete(self->records);
+	remove(self->committedPath);
+}
+
+void UDB_setPath_(UDB *self, const char *path)
+{
+	self->path = strcpy((char *)realloc(self->path, strlen(path)+1), path);
+	self->committedPath = strcpy((char *)realloc(self->committedPath, strlen(path)+20), path);
+	strcat(self->committedPath, ".committed");
+	
+	UDBIndex_setPath_(self->index, path);
+	UDBRecords_setPath_(self->records, path);
+}
+
+/*
+void UDB_setSecondaryPath_(UDB *self, const char *secondaryPath)
+{
+	UDBIndex_setPath_(self->index, self->path);
+	UDBIndex_setLogPath_(self->index, secondaryPath);
+	
+	UDBRecords_setPath_(self->records, secondaryPath);
+	UDBRecords_setLogPath_(self->records, self->path);
+}
+*/
+
+
+char *UDB_path(UDB *self) 
+{ 
+	return self->path; 
+}
+
+void UDB_open(UDB *self)
+{
+	self->committedFile = fopen(self->committedPath, "r+");
+
+	if (!self->committedFile) 
+	{
+		self->committedFile = fopen(self->committedPath, "w");
+		fclose(self->committedFile);
+		self->committedFile = fopen(self->committedPath, "r+");
+	}
+	
+	
+	if (UDB_readCommitted(self) == 0)
+	{
+		JFile_clipLog(self->index->file);
+		JFile_clipLog(self->records->file);
+	}
+	
+	UDBIndex_open(self->index);
+	UDBRecords_open(self->records);
+	self->isOpen = 1;
+}
+
+int UDB_isOpen(UDB *self)
+{
+	return self->isOpen;
+}
+
+void UDB_close(UDB *self)
+{
+        if(self->isOpen) {
+                UDBIndex_close(self->index);
+                UDBRecords_close(self->records);
+                if (self->committedFile) fclose(self->committedFile);
+                self->isOpen = 0;
+        }
+}
+
+// transactions --------------------------------------------------- 
+
+int UDB_isInTransaction(UDB *self)
+{
+	if (!self->withinTransaction)
+	{
+		printf("UDB error - mutation operations must be within a transaction\n");
+		exit(1);
+		return 0;
+	}
+	return 1;
+}
+
+void UDB_beginTransaction(UDB *self)
+{
+	UDBIndex_begin(self->index);
+	UDBRecords_begin(self->records);
+	self->withinTransaction = 1;
+}
+
+int UDB_readCommitted(UDB *self)
+{
+	fseek(self->committedFile, 0, SEEK_SET);
+	return fgetc(self->committedFile);
+}
+
+void UDB_setCommittedFlag_(UDB *self, int flag)
+{
+	fseek(self->committedFile, 0, SEEK_SET);
+	fputc(flag, self->committedFile);
+	#ifdef F_FULLFSYNC
+		fcntl(fileno(self->committedFile), F_FULLFSYNC, NULL);
+	#else
+		#warning Linux doesn't support syncing to physical media
+		fsync(fileno(self->committedFile));
+	#endif
+}
+
+void UDB_commitTransaction(UDB *self)
+{
+	UDBIndex_preCommit(self->index);
+	UDBRecords_preCommit(self->records);
+	
+	UDB_setCommittedFlag_(self, 1);
+	
+	UDBIndex_commit(self->index);
+	UDBRecords_commit(self->records);
+	
+	UDB_setCommittedFlag_(self, 0);
+	
+	self->withinTransaction = 0;
+}
+
+// ops --------------------------------------------------- 
+
+PID_TYPE UDB_nextPid(UDB *self)
+{
+	return UDBIndex_nextPid(self->index);
+}
+
+PID_TYPE UDB_allocPid(UDB *self)
+{
+	return UDBIndex_allocPid(self->index);
+}
+
+void UDB_append_withPid_(UDB *self, Datum d, PID_TYPE pid) 
+{
+	UDBRecord *record = UDBRecords_newRecord(self->records);
+	UDBRecord_pid_(record, pid);
+	UDBRecord_saveWithDatum_(record, d);
+	UDBIndex_setPos_forPid_(self->index, UDBRecord_pos(record), pid);
+}
+
+PID_TYPE UDB_put_(UDB *self, Datum d) // returns pid 
+{
+	if (UDB_isInTransaction(self))
+	{
+		PID_TYPE pid = UDBIndex_allocPid(self->index);
+		UDB_append_withPid_(self, d, pid);
+		return pid;
+	}
+	
+	return 0;
+}
+
+void UDB_at_put_(UDB *self, PID_TYPE pid, Datum d)
+{
+	if (UDB_isInTransaction(self))
+	{
+		UDB_append_withPid_(self, d, pid);
+	}
+}
+
+UDBRecord *UDB_recordAtPid_(UDB *self, PID_TYPE pid)
+{
+	PID_TYPE pos = UDBIndex_posForPid_(self->index, pid);
+	if (!pos) return NULL;
+	return UDBRecords_recordAtPos_(self->records, pos);
+}
+
+Datum UDB_at_(UDB *self, PID_TYPE pid)
+{
+	Datum d;
+	UDBRecord *record = UDB_recordAtPid_(self, pid);
+	
+	if (!record)
+	{
+		d.size = 0;
+		d.data = NULL;
+		//printf("missing record with pid %i\n", pid);
+		return d;
+	}
+	
+	return UDBRecord_readDatum(record);
+}
+
+void UDB_removeAt_(UDB *self, PID_TYPE pid)
+{
+	if (UDB_isInTransaction(self))
+	{
+		UDBRecord *record = UDB_recordAtPid_(self, pid);
+		
+		if (!record)
+		{
+                        //TODO jannson
+			//printf("UDB error: missing record with pid %" PID_FORMAT " for remove\n", pid);
+			record = UDB_recordAtPid_(self, pid);
+			return;
+		}
+		
+		UDBRecords_removeRecord_(self->records, record);
+		UDBIndex_setPos_forPid_(self->index, 0, pid);
+	}
+}
+
+// compact --------------------------------------------------- 
+
+UDBRecord *UDB_firstEmptyRecord(UDB *self)
+{
+	UDBRecord *record = UDBRecords_firstRecord(self->records);
+	
+	while (record)
+	{	
+		if (UDBRecord_isEmpty(record)) return record;
+		record = UDBRecords_nextRecord(self->records);
+	}
+	return NULL;
+}
+
+int UDB_compact(UDB *self)
+{
+	int count = 0;
+	int compactions;
+	
+	do 
+	{
+		compactions = UDB_compactStepFor_(self, 0.1);
+		count += compactions;
+	} while (compactions);
+	
+	return count;
+}
+
+//#define DEBUG 1
+
+int UDB_compactStep(UDB *self)
+{
+	return UDB_compactStepFor_(self, 0.0);
+}
+
+int UDB_compactStepFor_(UDB *self, double maxSeconds)
+{   
+	UDBRecord *firstEmptyRecord = UDBRecords_firstEmptyRecord(self->records);
+	
+	if (!firstEmptyRecord)
+	{
+		return 0;
+	}
+	
+	if (!UDBRecord_isEmpty(firstEmptyRecord))
+	{
+		printf("firstEmptyRecord not empty!\n");
+		firstEmptyRecord = UDBRecords_firstEmptyRecord(self->records);
+		UDBRecord_isEmpty(firstEmptyRecord);
+		exit(1);
+	}
+	
+#ifdef DEBUG
+	printf("empty record pid: %i pos: %i size: %i isEmpty: %i\n", 
+		  UDBRecord_pid(firstEmptyRecord), 
+		  UDBRecord_pos(firstEmptyRecord), 
+		  UDBRecord_totalSize(firstEmptyRecord), 
+		  UDBRecord_isEmpty(firstEmptyRecord));
+#endif
+	    
+	if (firstEmptyRecord)
+	{
+		UDBRecord *record = UDBRecords_recordAfter_(self->records, firstEmptyRecord);
+		
+		if (!record)
+		{
+			// reached end of file 
+			PID_TYPE size = UDBRecord_pos(firstEmptyRecord);
+			UDBRecords_truncate_(self->records, size);
+			return 0;
+		}
+		
+#ifdef DEBUG
+		printf("next  record pid: %i pos: %i size: %i isEmpty: %i\n\n", 
+			  UDBRecord_pid(record), 
+			  UDBRecord_pos(record), 
+			  UDBRecord_totalSize(record), 
+			  UDBRecord_isEmpty(record));
+#endif
+		
+		UDB_beginTransaction(self);
+		
+		if (UDBRecord_isEmpty(record))
+		{
+			// coalese this empty record into the first empty record 
+			PID_TYPE newSize = UDBRecord_totalSize(firstEmptyRecord) 
+			- sizeof(UDBRecordHeader) + UDBRecord_totalSize(record);
+			UDBRecord_size_(firstEmptyRecord, newSize);
+			UDBRecord_saveHeader(firstEmptyRecord);
+#ifdef DEBUG
+			printf("merge\n");
+#endif
+			UDBIndex_setPos_forPid_(self->index, 0, UDBRecord_pid(record));
+		}
+		else
+		{
+			// swap places with the first empty record 
+			PID_TYPE oldEmptyPos = UDBRecord_pos(firstEmptyRecord);
+			PID_TYPE newEmptyPos = oldEmptyPos + UDBRecord_totalSize(record);
+			UDBRecords_firstEmptyRecordPos_(self->records, newEmptyPos);
+			UDBRecord_moveToPos_(record, UDBRecord_pos(firstEmptyRecord));
+			UDBRecord_setPos_(firstEmptyRecord, newEmptyPos);
+			UDBRecord_saveHeader(firstEmptyRecord);
+#ifdef DEBUG
+			printf("move\n");
+#endif
+			UDBIndex_setPos_forPid_(self->index, newEmptyPos, UDBRecord_pid(firstEmptyRecord));
+			UDBIndex_setPos_forPid_(self->index, oldEmptyPos, UDBRecord_pid(record));
+		}
+		
+		UDB_commitTransaction(self);
+		
+		return 1;
+	}
+	return 0;
+}
+
+void UDB_show(UDB *self)
+{
+	UDBRecord *record = UDBRecords_firstRecord(self->records);
+	printf("UDB Records:\n");
+	
+	while (record)
+	{	
+		UDBRecord_show(record);
+		record = UDBRecords_nextRecord(self->records);
+	}
+}
+
+void UDB_showIndex(UDB *self)
+{
+	UDBIndex_show(self->index);
+}
+
diff --git a/release/src/router/skipdbv2/udb/UDB.h b/release/src/router/skipdbv2/udb/UDB.h
new file mode 100644
index 0000000000..99eb3a977a
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDB.h
@@ -0,0 +1,80 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("UDB")    
+docDescription("An unordered value database. (sort of like malloc for disk space)
+    It compacts the data like a single space copying garbage collector.")
+*/
+
+#ifndef UDB_DEFINED
+#define UDB_DEFINED 1
+
+#if !defined(__MINGW32__) && defined(WIN32)
+#if defined(BUILDING_SKIPDB_DLL) || defined(BUILDING_IOVMALL_DLL)
+#define UDB_API __declspec(dllexport)
+#else
+#define UDB_API __declspec(dllimport)
+#endif
+#else
+#define UDB_API
+#endif
+
+
+#include "List.h"
+#include "UDBRecord.h"
+#include "UDBIndex.h"
+#include "UDBRecords.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    char *path;
+    UDBIndex *index;
+    UDBRecords *records;
+    int withinTransaction;
+    int isOpen;
+	FILE *committedFile;
+	char *committedPath;
+} UDB;
+
+UDB_API UDB *UDB_new(void);
+UDB_API void UDB_free(UDB *self);
+
+UDB_API void UDB_setPath_(UDB *self, const char *s);
+UDB_API void UDB_setLogPath_(UDB *self, const char *s);
+UDB_API char *UDB_path(UDB *self);
+
+UDB_API void UDB_delete(UDB *self);
+UDB_API void UDB_open(UDB *self);
+UDB_API int UDB_isOpen(UDB *self);
+UDB_API void UDB_close(UDB *self);
+
+// transactions --------------------------------------------------- 
+
+UDB_API void UDB_beginTransaction(UDB *self);
+UDB_API void UDB_commitTransaction(UDB *self);
+
+// ops -------------------------------------------------- 
+
+UDB_API PID_TYPE UDB_nextPid(UDB *self);
+UDB_API PID_TYPE UDB_allocPid(UDB *self);
+
+UDB_API PID_TYPE UDB_put_(UDB *self, Datum d);
+UDB_API void UDB_at_put_(UDB *self, PID_TYPE pid, Datum d);
+UDB_API Datum UDB_at_(UDB *self, PID_TYPE pid);
+UDB_API void UDB_removeAt_(UDB *self, PID_TYPE id);
+
+UDB_API int UDB_compact(UDB *self);
+UDB_API int UDB_compactStep(UDB *self);
+UDB_API int UDB_compactStepFor_(UDB *self, double maxSeconds);
+
+UDB_API void UDB_show(UDB *self);
+UDB_API void UDB_showIndex(UDB *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/udb/UDBIndex.c b/release/src/router/skipdbv2/udb/UDBIndex.c
new file mode 100644
index 0000000000..0a7916d0cf
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBIndex.c
@@ -0,0 +1,198 @@
+/*#io
+UDBIndex ioDoc(
+			docCopyright("Steve Dekorte", 2004)
+			docLicense("BSD revised")
+			docObject("UDBIndex")    
+			docDescription("")
+			*/
+
+#include "UDBIndex.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+UDBIndex *UDBIndex_new(void)
+{
+	UDBIndex *self = (UDBIndex *)calloc(1, sizeof(UDBIndex));
+	self->file = JFile_new();
+	UDBIndex_setPath_(self, "default");
+	self->holes = List_new();
+	return self;
+}
+
+void UDBIndex_free(UDBIndex *self)
+{
+	UDBIndex_close(self);
+	JFile_free(self->file);
+	List_free(self->holes);
+	free(self);
+}
+
+JFile *UDBIndex_jfile(UDBIndex *self)
+{
+	return self->file;
+}
+
+void UDBIndex_delete(UDBIndex *self)
+{
+	JFile_close(self->file);
+	JFile_delete(self->file);
+}
+
+void UDBIndex_setPath_(UDBIndex *self, const char *path)
+{
+	JFile_setPath_withExtension_(self->file, path, "udbIndex");
+}
+
+void UDBIndex_setLogPath_(UDBIndex *self, const char *s)
+{
+	JFile_setLogPath_(self->file, s);
+}
+
+char *UDBIndex_path(UDBIndex *self) 
+{ 
+	return JFile_path(self->file); 
+}
+
+void UDBIndex_open(UDBIndex *self)
+{
+	JFile_open(self->file);
+	// need to also call UDBIndex_finishOpening
+	UDBIndex_finishOpening(self);
+	self->maxPid = 0;
+}
+
+void UDBIndex_finishOpening(UDBIndex *self)
+{
+	JFile_begin(self->file);
+	UDBIndex_setPos_forPid_(self, 0, 0);
+	UDBIndex_preCommit(self);
+	UDBIndex_findHoles(self);
+}
+
+void UDBIndex_close(UDBIndex *self)
+{
+	JFile_close(self->file);
+}
+
+void UDBIndex_begin(UDBIndex *self)
+{
+	JFile_begin(self->file);
+}
+
+void UDBIndex_preCommit(UDBIndex *self)
+{
+	JFile_commitToLog(self->file);
+}
+
+void UDBIndex_commit(UDBIndex *self)
+{
+	JFile_commitToFile(self->file);
+}
+
+// holes ------------------------------------------- 
+
+void UDBIndex_findHoles(UDBIndex *self)
+{
+	PID_TYPE pid = UDBIndex_pidCount(self);
+	
+	List_removeAll(self->holes);
+	
+	while (pid --)
+	{
+		if (!UDBIndex_posForPid_(self, pid)) 
+		{
+			List_push_(self->holes, (void *)pid);
+		}
+	}
+}
+
+// pid ops ------------------------------------------- 
+
+PID_TYPE UDBIndex_nextPid(UDBIndex *self)
+{
+	PID_TYPE hole = (PID_TYPE)List_top(self->holes);
+	
+	if (hole) 
+	{
+		return hole;
+	}
+	
+	return JFile_setPositionToEnd(self->file) / sizeof(UDBIndexEntry);
+}
+
+PID_TYPE UDBIndex_allocPid(UDBIndex *self)
+{
+	PID_TYPE hole = (PID_TYPE)List_pop(self->holes);
+	
+	if (hole) 
+	{
+		return hole;
+	}
+	else
+	{
+		PID_TYPE max = JFile_setPositionToEnd(self->file) / sizeof(UDBIndexEntry);
+		
+		if (max > self->maxPid)
+		{
+			self->maxPid = max;
+		}
+		else
+		{
+			self->maxPid ++;
+		}
+		
+		return self->maxPid;
+	}
+}
+
+PID_TYPE UDBIndex_posForPid_(UDBIndex *self, PID_TYPE pid)
+{
+	UDBIndexEntry entry;
+	
+	JFile_setPosition_(self->file, pid * sizeof(UDBIndexEntry));
+	
+	//#ifdef JFILE_SUPPORTS_MMAP
+	//JFile_mmapfread(self->file, (unsigned char *)(&pos), sizeof(UDBIndexEntry), 1);
+	//#else
+	JFile_fread(self->file, (unsigned char *)(&entry), sizeof(UDBIndexEntry), 1);    
+	//#endif
+	
+	return entry.pos;
+}
+
+void UDBIndex_setPos_forPid_(UDBIndex *self, PID_TYPE pos, PID_TYPE pid)
+{
+	UDBIndexEntry entry;
+	entry.pos = pos;
+	//entry.size = 0;
+	
+	JFile_setPosition_(self->file, pid * sizeof(UDBIndexEntry));
+	JFile_fwrite(self->file, (unsigned char *)(&entry), sizeof(UDBIndexEntry), 1);
+	
+	if (pos == 0)
+	{
+		List_push_(self->holes, (void *)pid);
+	}
+}
+
+long UDBIndex_pidCount(UDBIndex *self)
+{
+	return JFile_setPositionToEnd(self->file) / sizeof(UDBIndexEntry);
+}
+
+void UDBIndex_show(UDBIndex *self)
+{
+	PID_TYPE pid, maxPid = UDBIndex_pidCount(self);
+	
+	printf("UDBIndex: (pid/pos)\n\n");
+	
+	for (pid = 0; pid < maxPid; pid ++)
+	{
+		PID_TYPE pos = UDBIndex_posForPid_(self, pid);
+		printf("  %i -> %i\n", (int)pid, (int)pos);
+	}
+	
+	printf("\n");
+}
+
diff --git a/release/src/router/skipdbv2/udb/UDBIndex.h b/release/src/router/skipdbv2/udb/UDBIndex.h
new file mode 100644
index 0000000000..5ddce822ae
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBIndex.h
@@ -0,0 +1,66 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("UDBIndex")    
+docDescription("An on-disk array of indexes into the data file.")
+*/
+
+#ifndef UDBIndex_DEFINED
+#define UDBIndex_DEFINED 1
+
+#include "List.h"
+#include "UDBRecord.h"
+#include "JFile.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    //unsigned char sizeLog2; // size = 2^sizeLog2 
+    PID_TYPE pos;
+} UDBIndexEntry;
+
+typedef struct
+{
+    JFile *file;
+    List *holes;
+    PID_TYPE maxPid;
+} UDBIndex;
+
+UDBIndex *UDBIndex_new(void);
+void UDBIndex_free(UDBIndex *self);
+
+JFile *UDBIndex_jfile(UDBIndex *self);
+
+void UDBIndex_setPath_(UDBIndex *self, const char *s);
+void UDBIndex_setLogPath_(UDBIndex *self, const char *s);
+char *UDBIndex_path(UDBIndex *self);
+
+void UDBIndex_delete(UDBIndex *self);
+void UDBIndex_open(UDBIndex *self);
+void UDBIndex_finishOpening(UDBIndex *self);
+void UDBIndex_close(UDBIndex *self);
+
+void UDBIndex_begin(UDBIndex *self);
+void UDBIndex_preCommit(UDBIndex *self);
+void UDBIndex_commit(UDBIndex *self);
+
+// holes ------------------------------------------- 
+
+void UDBIndex_findHoles(UDBIndex *self);
+
+// pid ops ------------------------------------------- 
+
+PID_TYPE UDBIndex_nextPid(UDBIndex *self);
+PID_TYPE UDBIndex_allocPid(UDBIndex *self);
+PID_TYPE UDBIndex_posForPid_(UDBIndex *self, PID_TYPE pid);
+void UDBIndex_setPos_forPid_(UDBIndex *self, PID_TYPE pos, PID_TYPE pid);
+long UDBIndex_pidCount(UDBIndex *self);
+void UDBIndex_show(UDBIndex *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/udb/UDBRecord.c b/release/src/router/skipdbv2/udb/UDBRecord.c
new file mode 100644
index 0000000000..9e5d6dc7e6
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBRecord.c
@@ -0,0 +1,169 @@
+/*#io
+UDBRecord ioDoc(
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("UDBRecord")    
+docDescription("")
+*/
+
+#include "UDB.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+UDBRecord *UDBRecord_new(void)
+{
+    UDBRecord *self = (UDBRecord *)calloc(1, sizeof(UDBRecord));
+    return self;
+}
+
+UDBRecord *UDBRecord_clone(UDBRecord *self)
+{
+    UDBRecord *clone = (UDBRecord *)cpalloc(self, sizeof(UDBRecord));
+    return clone;
+}
+
+void UDBRecord_free(UDBRecord *self)
+{
+    if (self->data) UArray_free(self->data);
+    free(self);
+}
+
+UArray *UDBRecord_data(UDBRecord *self)
+{
+    if (!self->data) self->data = UArray_new();
+    return self->data;
+}
+
+void UDBRecord_setJFile_(UDBRecord *self, JFile *file)
+{ 
+    self->file = file;
+}
+
+void UDBRecord_setPos_(UDBRecord *self, PID_TYPE pos)
+{   
+    self->pos = pos;
+}
+
+PID_TYPE UDBRecord_pos(UDBRecord *self)
+{
+    return self->pos;
+}
+
+void UDBRecord_setPosToEnd(UDBRecord *self)
+{
+    self->pos = JFile_setPositionToEnd(self->file);
+}
+
+void UDBRecord_pid_(UDBRecord *self, PID_TYPE pid)
+{
+    self->header.pid = pid;
+}
+
+PID_TYPE UDBRecord_pid(UDBRecord *self)
+{
+    return self->header.pid;
+}
+
+void UDBRecord_size_(UDBRecord *self, PID_TYPE size)
+{
+    self->header.size = size;
+}
+
+PID_TYPE UDBRecord_size(UDBRecord *self)
+{
+    return self->header.size;
+}
+
+void UDBRecord_remove(UDBRecord *self)
+{
+    self->header.tag = RECORD_TAG_EMPTY;
+    UDBRecord_saveHeader(self);
+}
+
+int UDBRecord_isEmpty(UDBRecord *self)
+{
+    return (self->header.tag == RECORD_TAG_EMPTY);
+}
+
+
+// save ----------------------------------------- 
+
+void UDBRecord_saveHeader(UDBRecord *self) 
+{ 
+    if (self->pos) JFile_setPosition_(self->file, self->pos);
+    JFile_fwrite(self->file, (unsigned char *)(&(self->header)), sizeof(UDBRecordHeader), 1);
+}
+
+void UDBRecord_saveWithDatum_(UDBRecord *self, Datum d)
+{
+    self->header.size = d.size;
+    UDBRecord_saveHeader(self);
+    JFile_fwrite(self->file, d.data, d.size, 1);
+}
+
+// read ----------------------------------------- 
+
+int UDBRecord_readHeader(UDBRecord *self) 
+{ 
+    int objectsRead;
+    
+    JFile_setPosition_(self->file, self->pos);
+    objectsRead = JFile_fread(self->file, (unsigned char *)(&(self->header)), sizeof(UDBRecordHeader), 1);
+    
+    if (objectsRead != 1)
+    {
+	self->header.pid = 0;
+	self->header.size = 0;
+	return 0;
+    }
+    
+    return 1;
+}
+
+Datum UDBRecord_readDatum(UDBRecord *self)
+{
+    UArray *ba = UDBRecord_data(self);
+    Datum d;
+    PID_TYPE size = self->header.size;
+    
+    JFile_fseek(self->file, self->pos + sizeof(UDBRecordHeader), SEEK_SET);
+    
+    UArray_setSize_(ba, size);
+    JFile_fread(self->file, UArray_bytes(ba), size, 1);
+    d.size = size;
+    d.data = UArray_bytes(ba);
+    return d;
+}
+
+// compact ----------------------------------------- 
+
+void UDBRecord_moveToPos_(UDBRecord *self, PID_TYPE newPos)
+{
+    PID_TYPE totalSize = UDBRecord_totalSize(self);
+    unsigned char *data;
+    UArray *ba = UDBRecord_data(self);
+    UArray_setSize_(ba, totalSize);
+    data = UArray_bytes(ba); 
+       
+    JFile_fseek(self->file, self->pos, SEEK_SET);
+    JFile_fread(self->file, data, totalSize, 1);
+    
+    JFile_fseek(self->file, newPos, SEEK_SET);
+    JFile_fwrite(self->file, data, totalSize, 1);
+}
+
+PID_TYPE UDBRecord_totalSize(UDBRecord *self)
+{
+    return sizeof(UDBRecordHeader) + self->header.size;
+}
+
+void UDBRecord_show(UDBRecord *self)
+{
+    printf("Record pos: %" PID_FORMAT "\n", self->pos);
+    printf("  pid: %" PID_FORMAT "\n", self->header.pid);
+    printf("  size: %" PID_FORMAT "\n", self->header.size);
+    printf("\n");
+}
+
+
diff --git a/release/src/router/skipdbv2/udb/UDBRecord.h b/release/src/router/skipdbv2/udb/UDBRecord.h
new file mode 100644
index 0000000000..17629ecfb4
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBRecord.h
@@ -0,0 +1,72 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("UDBRecord")    
+docDescription("An individual UDB Record.")
+*/
+
+#ifndef UDBRecord_DEFINED
+#define UDBRecord_DEFINED 1
+
+#include <stdio.h>
+#include "JFile.h"
+#include "Datum.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define RECORD_TAG_NORMAL 0
+#define RECORD_TAG_EMPTY  1
+
+typedef struct
+{
+    //unsigned char recordSizeLog2; 
+    unsigned char tag;
+    PID_TYPE pid;
+    PID_TYPE size; // the actual size of the datum 
+} UDBRecordHeader;
+
+typedef struct
+{
+    JFile *file;
+    PID_TYPE pos;
+    UDBRecordHeader header;
+    UArray *data;
+} UDBRecord;
+
+UDBRecord *UDBRecord_new(void);
+UDBRecord *UDBRecord_clone(UDBRecord *self);
+void UDBRecord_free(UDBRecord *self);
+
+void UDBRecord_setJFile_(UDBRecord *self, JFile *file);
+
+void UDBRecord_setPos_(UDBRecord *self, PID_TYPE pos);
+void UDBRecord_setPosToEnd(UDBRecord *self);
+PID_TYPE UDBRecord_pos(UDBRecord *self);
+
+void UDBRecord_pid_(UDBRecord *self, PID_TYPE pid);
+PID_TYPE UDBRecord_pid(UDBRecord *self);
+
+void UDBRecord_size_(UDBRecord *self, PID_TYPE size);
+PID_TYPE UDBRecord_size(UDBRecord *self);
+
+void UDBRecord_remove(UDBRecord *self);
+
+void UDBRecord_saveHeader(UDBRecord *self);
+void UDBRecord_saveWithDatum_(UDBRecord *self, Datum d);
+
+int UDBRecord_readHeader(UDBRecord *self);
+Datum UDBRecord_readDatum(UDBRecord *self);
+
+int UDBRecord_isEmpty(UDBRecord *self);
+//int UDBRecord_readNextHeader(UDBRecord *self);
+void UDBRecord_moveToPos_(UDBRecord *self, PID_TYPE newPos);
+
+PID_TYPE UDBRecord_totalSize(UDBRecord *self);
+void UDBRecord_show(UDBRecord *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/skipdbv2/udb/UDBRecords.c b/release/src/router/skipdbv2/udb/UDBRecords.c
new file mode 100644
index 0000000000..05c5c92541
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBRecords.c
@@ -0,0 +1,234 @@
+/*#io
+UDBRecords ioDoc(
+			  docCopyright("Steve Dekorte", 2004)
+			  docLicense("BSD revised")
+			  docObject("UDBRecords")    
+			  docDescription("")
+			  */
+
+#include "UDB.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+UDBRecords *UDBRecords_new(void)
+{
+	UDBRecords *self = (UDBRecords *)calloc(1, sizeof(UDB));
+	self->file = JFile_new();
+	self->record = UDBRecord_new();
+	self->firstEmptyRecord = UDBRecord_new();
+	UDBRecords_setPath_(self, "default");
+	return self;
+}
+
+void UDBRecords_free(UDBRecords *self)
+{
+	UDBRecords_close(self);
+	JFile_free(self->file);    
+	UDBRecord_free(self->record);   
+	UDBRecord_free(self->firstEmptyRecord);   
+	free(self);
+}
+
+JFile *UDBRecords_jfile(UDBIndex *self)
+{
+	return self->file;
+}
+
+void UDBRecords_delete(UDBRecords *self)
+{
+	JFile_delete(self->file);
+}
+
+void UDBRecords_setPath_(UDBRecords *self, const char *path)
+{
+	JFile_setPath_withExtension_(self->file, path, "udbData");
+}
+
+void UDBRecords_setLogPath_(UDBRecords *self, const char *path)
+{
+	JFile_setLogPath_(self->file, path);
+}
+
+char *UDBRecords_path(UDBRecords *self) 
+{ 
+	return JFile_path(self->file); 
+}
+
+void UDBRecords_open(UDBRecords *self)
+{
+	JFile_open(self->file);  
+	
+	if (JFile_setPositionToEnd(self->file) == 0) 
+	{ 
+		// position 0-4 holds the pos of the first empty record 
+		JFile_begin(self->file);
+		UDBRecords_firstEmptyRecordPos_(self, 0);
+		//UDBRecords_setEndPos_(self, 0);
+		JFile_commitToLog(self->file);
+	}
+	
+	UDBRecord_setJFile_(self->record, self->file);
+	UDBRecord_setJFile_(self->firstEmptyRecord, self->file);
+	self->firstEmptyPos = UDBRecords_firstEmptyRecordPos(self);
+}
+
+void UDBRecords_close(UDBRecords *self)
+{
+	JFile_close(self->file);
+}
+
+void UDBRecords_begin(UDBRecords *self)
+{
+	JFile_begin(self->file);
+}
+
+void UDBRecords_preCommit(UDBRecords *self)
+{
+	JFile_commitToLog(self->file);
+}
+
+void UDBRecords_commit(UDBRecords *self)
+{
+	JFile_commitToFile(self->file);	
+}
+
+// ops -------------------------------------------------- 
+
+UDBRecord *UDBRecords_firstRecord(UDBRecords *self)
+{
+	return UDBRecords_recordAtPos_(self, 1);
+}
+
+UDBRecord *UDBRecords_newRecord(UDBRecords *self)
+{
+	UDBRecord_setPosToEnd(self->record);
+	return self->record;
+}
+
+UDBRecord *UDBRecords_nextRecord(UDBRecords *self)
+{
+	PID_TYPE nextPos = self->record->pos + UDBRecord_totalSize(self->record);
+	//printf("rec %i totalSize: %i\n", 
+	//	self->record->header.pid, UDBRecord_totalSize(self->record));
+	return UDBRecords_recordAtPos_(self, nextPos);
+}
+
+UDBRecord *UDBRecords_recordAfter_(UDBRecords *self, UDBRecord *record)
+{
+	PID_TYPE nextPos = record->pos + UDBRecord_totalSize(record);
+	return UDBRecords_recordAtPos_(self, nextPos);
+}
+
+
+UDBRecord *UDBRecords_recordAtPos_(UDBRecords *self, PID_TYPE pos)
+{
+	UDBRecord_setPos_(self->record, pos);
+	
+	if (UDBRecord_readHeader(self->record))
+	{
+		return self->record;
+	}
+	
+	return NULL;
+}
+
+void UDBRecords_removeRecord_(UDBRecords *self, UDBRecord *record)
+{
+	PID_TYPE pos = UDBRecord_pos(record);
+	
+	if ((!self->firstEmptyPos) || 
+	    (pos && pos < self->firstEmptyPos)) 
+	{
+		UDBRecords_firstEmptyRecordPos_(self, pos);
+	}
+	
+	UDBRecord_remove(record);
+}
+
+/*
+ void UDBRecords_moveRecord_toPos_(UDBRecords *self, UDBRecord *record, PID_TYPE emptyPos)
+ {
+	 UDBRecord_moveToPos_(record, emptyPos);
+ }
+ */
+
+void UDBRecords_show(UDBRecords *self)
+{
+	UDBRecord *record = UDBRecords_firstRecord(self);
+	printf("UDB Records:\n");
+	if (record)
+	{	
+		for (;;)
+		{
+			UDBRecord_show(record);
+			if (!UDBRecords_nextRecord(self)) break;
+		}
+	}
+}
+
+// first empty record ------------------------------------ 
+
+UDBRecord *UDBRecords_findFirstEmptyRecord(UDBRecords *self)
+{
+	UDBRecord *record = UDBRecords_firstRecord(self);
+	
+	while (record)
+	{	
+		if (UDBRecord_isEmpty(record)) return record;
+		record = UDBRecords_nextRecord(self);
+	}
+	
+	return NULL;
+}
+
+/*
+ UDBRecord *UDBRecords_nextEmptyRecordAfter_(UDBRecords *self, UDBRecord *record)
+ {
+	 UDBRecord *record;
+	 
+	 while (record = UDBRecords_nextRecord(self))
+	 {	
+		 if (UDBRecord_isEmpty(record)) return record;
+	 }
+	 
+	 return NULL;
+ }
+ */
+
+PID_TYPE UDBRecords_firstEmptyRecordPos(UDBRecords *self)
+{
+	JFile_fseek(self->file, 0, SEEK_SET);
+	JFile_fread(self->file, (unsigned char *)(&(self->firstEmptyPos)), sizeof(PID_TYPE), 1);
+	return self->firstEmptyPos;
+}
+
+void UDBRecords_firstEmptyRecordPos_(UDBRecords *self, PID_TYPE pos)
+{
+	self->firstEmptyPos = pos;
+	JFile_fseek(self->file, 0, SEEK_SET);
+	JFile_fwrite(self->file, (unsigned char *)(&(self->firstEmptyPos)), sizeof(PID_TYPE), 1);
+}
+
+UDBRecord *UDBRecords_firstEmptyRecord(UDBRecords *self)
+{
+	// store the position of the first empty record 
+	
+	//printf("self->firstEmptyPos = %i\n", (int)self->firstEmptyPos);
+	if (self->firstEmptyPos)
+	{
+		UDBRecord_setPos_(self->firstEmptyRecord, self->firstEmptyPos);
+		
+		if (UDBRecord_readHeader(self->firstEmptyRecord))
+		{
+			return self->firstEmptyRecord;
+		}
+	}
+	
+	return NULL;
+}
+
+void UDBRecords_truncate_(UDBRecords *self, off_t size)
+{
+	JFile_truncate_(self->file, size);
+}
diff --git a/release/src/router/skipdbv2/udb/UDBRecords.h b/release/src/router/skipdbv2/udb/UDBRecords.h
new file mode 100644
index 0000000000..135b87aef5
--- /dev/null
+++ b/release/src/router/skipdbv2/udb/UDBRecords.h
@@ -0,0 +1,69 @@
+/*#io
+docCopyright("Steve Dekorte", 2004)
+docLicense("BSD revised")
+docObject("UDBRecords")    
+docDescription("An object for storing and fetching UDB records from the records file.")
+*/
+
+#ifndef UDBRecords_DEFINED
+#define UDBRecords_DEFINED 1
+
+#include "List.h"
+#include "UDBRecord.h"
+#include "UDBIndex.h"
+#include "JFile.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct
+{
+    JFile *file;
+    UDBRecord *record;
+    UDBRecord *firstEmptyRecord;
+    PID_TYPE firstEmptyPos;
+} UDBRecords;
+
+UDBRecords *UDBRecords_new(void);
+void UDBRecords_free(UDBRecords *self);
+
+JFile *UDBRecords_jfile(UDBIndex *self);
+
+void UDBRecords_setPath_(UDBRecords *self, const char *s);
+void UDBRecords_setLogPath_(UDBRecords *self, const char *s);
+char *UDBRecords_path(UDBRecords *self);
+
+void UDBRecords_delete(UDBRecords *self);
+void UDBRecords_open(UDBRecords *self);
+void UDBRecords_close(UDBRecords *self);
+
+void UDBRecords_begin(UDBRecords *self);
+void UDBRecords_preCommit(UDBRecords *self);
+void UDBRecords_commit(UDBRecords *self);
+int UDBRecords_isUncommitted(UDBRecords *self);
+
+// ops -------------------------------------------------- 
+
+UDBRecord *UDBRecords_firstRecord(UDBRecords *self);
+UDBRecord *UDBRecords_newRecord(UDBRecords *self);
+UDBRecord *UDBRecords_nextRecord(UDBRecords *self);
+UDBRecord *UDBRecords_recordAfter_(UDBRecords *self, UDBRecord *record);
+UDBRecord *UDBRecords_recordAtPos_(UDBRecords *self, PID_TYPE pos);
+void UDBRecords_removeRecord_(UDBRecords *self, UDBRecord *record);
+void UDBRecords_moveRecord_toPos_(UDBRecords *self, UDBRecord *record, PID_TYPE pos);
+
+void UDBRecords_truncate_(UDBRecords *self, off_t size);
+
+// first empty record ------------------------------------ 
+
+UDBRecord *UDBRecords_findFirstEmptyRecord(UDBRecords *self);
+//UDBRecord *UDBRecords_nextEmptyRecordAfter_(UDBRecords *self, UDBRecord *record);
+PID_TYPE UDBRecords_firstEmptyRecordPos(UDBRecords *self);
+void UDBRecords_firstEmptyRecordPos_(UDBRecords *self, PID_TYPE firstEmptyPos);
+UDBRecord *UDBRecords_firstEmptyRecord(UDBRecords *self);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/release/src/router/softcenter/Makefile b/release/src/router/softcenter/Makefile
new file mode 100755
index 0000000000..dfb7ff929c
--- /dev/null
+++ b/release/src/router/softcenter/Makefile
@@ -0,0 +1,61 @@
+include ../common.mak
+
+#export SC_BUILD=y
+ifeq ($(SC_BUILD), y)
+all: versioncmp base64_encode resolveip
+
+versioncmp:
+	$(CC) -static versioncmp.c -o versioncmp
+	$(STRIP) versioncmp
+base64_encode:
+	$(CC) -static base64.c -o base64_encode
+	$(STRIP) base64_encode
+resolveip:
+	$(CC) -static resolveip.c -o resolveip
+	$(STRIP) resolveip
+else
+all:
+endif
+
+install:
+	install -d $(INSTALLDIR)/sbin
+	install -d $(INSTALLDIR)/usr/sbin
+	install -d $(INSTALLDIR)/lib
+	install -d $(INSTALLDIR)/usr/bin
+	install -d $(INSTALLDIR)/usr/share
+	install -d $(INSTALLDIR)/usr/lib
+	install -d $(INSTALLDIR)/rom/etc
+ifeq ($(HND_ROUTER), y)
+	install -d $(INSTALLDIR)/www/www
+	install -d $(INSTALLDIR)/www/www/js
+	install -d $(INSTALLDIR)/www/www/res
+else
+	install -d $(INSTALLDIR)/www
+	install -d $(INSTALLDIR)/www/js
+	install -d $(INSTALLDIR)/www/res
+endif
+ifeq ($(BUILD_NAME), $(filter $(BUILD_NAME), GT-AC2900 GT-AC5300))
+	install -d $(INSTALLDIR)/rom/etc/koolshare/ROG/res
+	install -d $(INSTALLDIR)/rom/etc/koolshare/ROG/webs
+else ifeq  ($(BUILD_NAME), $(filter $(BUILD_NAME), TUF-AX3000))
+	install -d $(INSTALLDIR)/rom/etc/koolshare/TUF/res
+	install -d $(INSTALLDIR)/rom/etc/koolshare/TUF/webs
+endif
+# softcenter
+	mkdir -p $(INSTALLDIR)/rom/etc/koolshare
+	cp ./softcenter/. $(INSTALLDIR)/rom/etc/koolshare/ -rf
+ifeq ($(BUILD_NAME), $(filter $(BUILD_NAME), GT-AC2900 GT-AC5300))
+	install -m 0755 softcenter/res/softcenter.css $(INSTALLDIR)/rom/etc/koolshare/ROG/res
+	install -m 0755 softcenter/webs/Module_Softcenter.asp $(INSTALLDIR)/rom/etc/koolshare/ROG/webs
+	install -m 0755 softcenter/webs/Module_Softsetting.asp $(INSTALLDIR)/rom/etc/koolshare/ROG/webs
+else ifeq  ($(BUILD_NAME), $(filter $(BUILD_NAME), TUF-AX3000))
+	install -m 0755 softcenter/res/softcenter.css $(INSTALLDIR)/rom/etc/koolshare/TUF/res
+	install -m 0755 softcenter/webs/Module_Softcenter.asp $(INSTALLDIR)/rom/etc/koolshare/TUF/webs
+	install -m 0755 softcenter/webs/Module_Softsetting.asp $(INSTALLDIR)/rom/etc/koolshare/TUF/webs
+endif
+	install -m 0755 jffsinit.sh $(INSTALLDIR)/usr/bin
+	install -m 0755 koolshare-reset $(INSTALLDIR)/usr/bin
+	ln -snrf $(INSTALLDIR)/jffs/.koolshare $(INSTALLDIR)/koolshare
+
+clean:
+
diff --git a/release/src/router/softcenter/jffsinit.sh b/release/src/router/softcenter/jffsinit.sh
new file mode 100755
index 0000000000..b1db84fba6
--- /dev/null
+++ b/release/src/router/softcenter/jffsinit.sh
@@ -0,0 +1,84 @@
+#!/bin/sh
+
+# make some folders
+mkdir -p /jffs/scripts
+mkdir -p /jffs/configs/dnsmasq.d
+mkdir -p /tmp/upload
+
+# install all
+if [ -f "/koolshare/.soft_ver" ];then
+	CUR_VERSION=$(cat /koolshare/.soft_ver)
+else
+	CUR_VERSION="0"
+fi
+ROM_VERSION=$(cat /rom/etc/koolshare/.soft_ver)
+COMP=$(/rom/etc/koolshare/bin/versioncmp $CUR_VERSION $ROM_VERSION)
+if [ ! -d "/jffs/.koolshare" -o "$COMP" == "1" ]; then
+	#cp -a /rom/etc/koolshare/ /jffs/.koolshare
+	mkdir -p /jffs/.koolshare
+	cp -rf /rom/etc/koolshare/* /jffs/.koolshare/
+	cp -rf /rom/etc/koolshare/.soft_ver /jffs/.koolshare/
+	mkdir -p /jffs/.koolshare/configs/
+	chmod 755 /koolshare/bin/*
+	chmod 755 /koolshare/init.d/*
+	chmod 755 /koolshare/perp/*
+	chmod 755 /koolshare/perp/.boot/*
+	chmod 755 /koolshare/perp/.control/*
+	chmod 755 /koolshare/perp/httpdb/*
+	chmod 755 /koolshare/scripts/*
+	[ ! -L "/koolshare/bin/base64_decode" ] && ln -sf /koolshare/bin/base64_encode /koolshare/bin/base64_decode
+	[ ! -L "/koolshare/scripts/ks_app_remove.sh" ] && ln -sf /koolshare/scripts/ks_app_install.sh /koolshare/scripts/ks_app_remove.sh
+	[ ! -L "/jffs/.asusrouter" ] && ln -sf /koolshare/bin/kscore.sh /jffs/.asusrouter
+	[ ! -L "/jffs/configs/profile.add" ] && ln -sf /koolshare/scripts/base.sh /jffs/configs/profile.add
+	#service restart_skipd
+fi
+
+# check start up scripts
+if [ ! -f "/jffs/scripts/wan-start" ];then
+	cat > /jffs/scripts/wan-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-wan-start.sh start
+	EOF
+	chmod +x /jffs/scripts/wan-start
+else
+	STARTCOMAND1=$(cat /jffs/scripts/wan-start | grep -c "/koolshare/bin/ks-wan-start.sh start")
+	[ "$STARTCOMAND1" -gt "1" ] && sed -i '/ks-wan-start.sh/d' /jffs/scripts/wan-start && sed -i '1a /koolshare/bin/ks-wan-start.sh start' /jffs/scripts/wan-start
+	[ "$STARTCOMAND1" == "0" ] && sed -i '1a /koolshare/bin/ks-wan-start.sh start' /jffs/scripts/wan-start
+fi
+
+if [ ! -f "/jffs/scripts/nat-start" ];then
+	cat > /jffs/scripts/nat-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-nat-start.sh start_nat
+	EOF
+	chmod +x /jffs/scripts/nat-start
+else
+	STARTCOMAND2=$(cat /jffs/scripts/nat-start | grep -c "/koolshare/bin/ks-nat-start.sh start_nat")
+	[ "$STARTCOMAND2" -gt "1" ] && sed -i '/ks-nat-start.sh/d' /jffs/scripts/nat-start && sed -i '1a /koolshare/bin/ks-nat-start.sh start_nat' /jffs/scripts/nat-start
+	[ "$STARTCOMAND2" == "0" ] && sed -i '1a /koolshare/bin/ks-nat-start.sh start_nat' /jffs/scripts/nat-start
+fi
+
+if [ ! -f "/jffs/scripts/post-mount" ];then
+	cat > /jffs/scripts/post-mount <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-mount-start.sh start
+	EOF
+	chmod +x /jffs/scripts/post-mount
+else
+	STARTCOMAND3=$(cat /jffs/scripts/post-mount | grep -c "/koolshare/bin/ks-mount-start.sh start")
+	[ "$STARTCOMAND3" -gt "1" ] && sed -i '/ks-mount-start.sh/d' /jffs/scripts/post-mount && sed -i '1a /koolshare/bin/ks-mount-start.sh start' /jffs/scripts/post-mount
+	[ "$STARTCOMAND3" == "0" ] && sed -i '1a /koolshare/bin/ks-mount-start.sh start' /jffs/scripts/post-mount
+fi
+
+if [ ! -f "/jffs/scripts/services-start" ];then
+	cat > /jffs/scripts/services-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-services-start.sh start
+	EOF
+	chmod +x /jffs/scripts/services-start
+else
+	STARTCOMAND4=$(cat /jffs/scripts/services-start | grep -c "/koolshare/bin/ks-services-start.sh start")
+	[ "$STARTCOMAND4" -gt "1" ] && sed -i '/ks-services-start.sh/d' /jffs/scripts/services-start && sed -i '1a /koolshare/bin/ks-services-start.sh start' /jffs/scripts/services-start
+	[ "$STARTCOMAND4" == "0" ] && sed -i '1a /koolshare/bin/ks-services-start.sh start' /jffs/scripts/services-start
+fi
+
diff --git a/release/src/router/softcenter/koolshare-reset b/release/src/router/softcenter/koolshare-reset
new file mode 100755
index 0000000000..ad84bd713e
--- /dev/null
+++ b/release/src/router/softcenter/koolshare-reset
@@ -0,0 +1,26 @@
+#!/bin/sh
+
+echo "开始重置软件中心！"
+
+# stop httpdb
+kill -9 $(pidof skipd) >/dev/null 2>&1
+cd /koolshare/perp
+sh perp.sh stop >/dev/null 2>&1
+
+# remove software center files
+cd /
+rm -rf /jffs/db
+rm -rf /jffs/.asusrouter
+rm -rf /jffs/.koolshare
+rm -rf /jffs/scripts/dnsmasq.postconf
+rm -rf /jffs/configs/dnsmasq/*
+service restart_dnsmasq >/dev/null 2>&1
+
+sleep 1
+
+# initiate software center
+jffsinit.sh >/dev/null 2>&1
+cd /koolshare/perp
+sh perp.sh start >/dev/null 2>&1
+
+echo "软件中心完成，请清空浏览器缓存后重新进入软件中心！"
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/.soft_ver b/release/src/router/softcenter/softcenter/.soft_ver
new file mode 100644
index 0000000000..ee90284c27
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/.soft_ver
@@ -0,0 +1 @@
+1.0.4
diff --git a/release/src/router/softcenter/softcenter/.valid b/release/src/router/softcenter/softcenter/.valid
new file mode 100644
index 0000000000..662e79fb11
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/.valid
@@ -0,0 +1 @@
+arm384
diff --git a/release/src/router/softcenter/softcenter/bin/base64_encode b/release/src/router/softcenter/softcenter/bin/base64_encode
new file mode 100755
index 0000000000000000000000000000000000000000..1dce8062ee75ee882970f436b1c733ac3ce258da
GIT binary patch
literal 4424
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
AS^xk5

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/helper.sh b/release/src/router/softcenter/softcenter/bin/helper.sh
new file mode 100755
index 0000000000..baac2d589b
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/helper.sh
@@ -0,0 +1,37 @@
+#!/bin/sh
+
+# Asuswrt-Merlin helper functions
+# For use with Postconf scripts (and others)
+
+_quote() {
+	echo $1 | sed 's/[]\/()$*.^|[]/\\&/g'
+}
+
+# This function looks for a string, and inserts a specified string after it inside a given file
+# $1: the line to locate, $2: the line to insert, $3: Config file where to insert
+pc_insert() {
+	PATTERN=$(_quote "$1")
+	CONTENT=$(_quote "$2")
+	sed -i "/$PATTERN/a$CONTENT" $3
+}
+
+# This function looks for a string, and replace it with a different string inside a given file
+# $1: the line to locate, $2: the line to replace with, $3: Config file where to insert
+pc_replace() {
+	PATTERN=$(_quote "$1")
+	CONTENT=$(_quote "$2")
+	sed -i "s/$PATTERN/$CONTENT/" $3
+}
+
+# This function will append a given string at the end of a given file
+# $1 The line to append at the end, $2: Config file where to append
+pc_append() {
+	echo "$1" >> $2
+}
+
+# This function will delete a line containing a given string inside a given file
+# $1 The line to locate, $2: Config file where to delete
+pc_delete() {
+	PATTERN=$(_quote "$1")
+	sed -i "/$PATTERN/d" $2
+}
diff --git a/release/src/router/softcenter/softcenter/bin/htop b/release/src/router/softcenter/softcenter/bin/htop
new file mode 100755
index 0000000000000000000000000000000000000000..bbc526194fffc1e1121b2ce5cceefca07152ad1c
GIT binary patch
literal 426824
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%0D?ApI{R5g#XZd2K2m>-&R*daO`6`B)fg5J`Mfz
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/httpdb b/release/src/router/softcenter/softcenter/bin/httpdb
new file mode 100755
index 0000000000000000000000000000000000000000..d3541fa6212a3cfc55e2afc555a6a4c98a9941f8
GIT binary patch
literal 620104
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/ks-mount-start.sh b/release/src/router/softcenter/softcenter/bin/ks-mount-start.sh
new file mode 100755
index 0000000000..e4c4f376ac
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/ks-mount-start.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+ACTION=$1
+KSPATH=$2
+
+for i in $(find /koolshare/init.d/ -name 'M*' | sort -n) ;
+do
+    case "$i" in
+        M* | *.sh )
+            # fork subprocess.
+            trap "" INT QUIT TSTP EXIT
+            logger "plugin_mount_log_1 $i"
+            if [ -r "$i" ]; then
+            	$i $ACTION $KSPATH
+            fi
+            ;;
+        *)
+            # No sh extension, Source shell script for speed.
+            logger "plugin_mount_log_2 $i"
+            . $i $ACTION $KSPATH
+            ;;
+    esac
+done
diff --git a/release/src/router/softcenter/softcenter/bin/ks-nat-start.sh b/release/src/router/softcenter/softcenter/bin/ks-nat-start.sh
new file mode 100755
index 0000000000..073b22b6b1
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/ks-nat-start.sh
@@ -0,0 +1,31 @@
+#!/bin/sh
+
+ACTION=$1
+#ACTION="start_nat"
+
+#echo start `date` > /tmp/ks_nat_log.txt
+
+ks_nat=`nvram get ks_nat`
+[ "$ks_nat" == "1" ] && echo exit `date` >> /tmp/ks_nat_log.txt && exit
+
+for i in $(find /koolshare/init.d/ -name 'N*' | sort) ;
+do
+    case "$i" in
+        *.sh )
+            # Source shell script for speed.
+            trap "" INT QUIT TSTP EXIT
+            #set $1
+            logger "plugin_nat_log_1 $i"
+            if [ -r "$i" ]; then
+            $i $ACTION
+            fi
+            ;;
+        *)
+            # No sh extension, so fork subprocess.
+            logger "plugin_nat_log_2 $i"
+            . $i $ACTION
+            ;;
+    esac
+done
+
+#echo finish `date` >> /tmp/ks_nat_log.txt
diff --git a/release/src/router/softcenter/softcenter/bin/ks-services-start.sh b/release/src/router/softcenter/softcenter/bin/ks-services-start.sh
new file mode 100755
index 0000000000..ee1d48c963
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/ks-services-start.sh
@@ -0,0 +1,33 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+ACTION=$1
+
+if [ $# -lt 1 ]; then
+    printf "Usage: $0 {start|stop|restart|reconfigure|check|kill}\n" >&2
+    exit 1
+fi
+
+[ $ACTION = stop -o $ACTION = restart -o $ACTION = kill ] && ORDER="-r"
+
+for i in $(find /koolshare/init.d/ -name 'V*' | sort $ORDER ) ;
+do
+    case "$i" in
+        V* | *.sh )
+            # Source shell script for speed.
+            trap "" INT QUIT TSTP EXIT
+            #set $1
+            logger "plugin_service_log_1 $i"
+            if [ -r "$i" ]; then
+            $i $ACTION
+            fi
+            ;;
+        *)
+            # No sh extension, so fork subprocess.
+            logger "plugin_service_log_2 $i"
+            . $i $ACTION
+            ;;
+    esac
+done
diff --git a/release/src/router/softcenter/softcenter/bin/ks-unmount.sh b/release/src/router/softcenter/softcenter/bin/ks-unmount.sh
new file mode 100755
index 0000000000..531d39ba57
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/ks-unmount.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+KSPATH=$1
+
+for i in $(find /koolshare/init.d/ -name 'U*' | sort -n) ;
+do
+    case "$i" in
+        U* | *.sh )
+            # fork subprocess.
+            trap "" INT QUIT TSTP EXIT
+            logger "plugin_mount_log_1 $i"
+            if [ -r "$i" ]; then
+            	$i $KSPATH
+            fi
+            ;;
+        *)
+            # No sh extension, Source shell script for speed.
+            logger "plugin_mount_log_2 $i"
+            . $i $KSPATH
+            ;;
+    esac
+done
diff --git a/release/src/router/softcenter/softcenter/bin/ks-wan-start.sh b/release/src/router/softcenter/softcenter/bin/ks-wan-start.sh
new file mode 100755
index 0000000000..98225886aa
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/ks-wan-start.sh
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+ACTION=$1
+
+if [ $# -lt 1 ]; then
+    printf "Usage: $0 {start|stop|restart|reconfigure|check|kill}\n" >&2
+    exit 1
+fi
+
+[ $ACTION = stop -o $ACTION = restart -o $ACTION = kill ] && ORDER="-r"
+
+for i in $(find /koolshare/init.d/ -name 'S*' | sort $ORDER ) ;
+do
+    case "$i" in
+        S* | *.sh )
+            # Source shell script for speed.
+            trap "" INT QUIT TSTP EXIT
+            #set $1
+            logger "plugin_wan_log_1 $i"
+            if [ -r "$i" ]; then
+            $i $ACTION
+            fi
+            ;;
+        *)
+            # No sh extension, so fork subprocess.
+            logger "plugin_wan_log_2 $i"
+            . $i $ACTION
+            ;;
+    esac
+done
+
diff --git a/release/src/router/softcenter/softcenter/bin/kscore.sh b/release/src/router/softcenter/softcenter/bin/kscore.sh
new file mode 100755
index 0000000000..c0dad6144f
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/bin/kscore.sh
@@ -0,0 +1,67 @@
+#!/bin/sh
+
+# this scripts used for .asusrouer to start httpdb
+source /koolshare/scripts/base.sh
+mkdir -p /tmp/upload
+sh /koolshare/perp/perp.sh
+nvram set jffs2_scripts=1
+nvram commit
+
+#============================================
+# check start up scripts 
+if [ ! -f "/jffs/scripts/wan-start" ];then
+	cat > /jffs/scripts/wan-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-wan-start.sh start
+	EOF
+else
+	STARTCOMAND1=$(cat /jffs/scripts/wan-start | grep -c "/koolshare/bin/ks-wan-start.sh start")
+	[ "$STARTCOMAND1" -gt "1" ] && sed -i '/ks-wan-start.sh/d' /jffs/scripts/wan-start && sed -i '1a /koolshare/bin/ks-wan-start.sh start' /jffs/scripts/wan-start
+	[ "$STARTCOMAND1" == "0" ] && sed -i '1a /koolshare/bin/ks-wan-start.sh start' /jffs/scripts/wan-start
+fi
+
+if [ ! -f "/jffs/scripts/nat-start" ];then
+	cat > /jffs/scripts/nat-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-nat-start.sh start_nat
+	EOF
+else
+	STARTCOMAND2=$(cat /jffs/scripts/nat-start | grep -c "/koolshare/bin/ks-nat-start.sh start_nat")
+	[ "$STARTCOMAND2" -gt "1" ] && sed -i '/ks-nat-start.sh/d' /jffs/scripts/nat-start && sed -i '1a /koolshare/bin/ks-nat-start.sh start_nat' /jffs/scripts/nat-start
+	[ "$STARTCOMAND2" == "0" ] && sed -i '1a /koolshare/bin/ks-nat-start.sh start_nat' /jffs/scripts/nat-start
+fi
+
+if [ ! -f "/jffs/scripts/post-mount" ];then
+	cat > /jffs/scripts/post-mount <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-mount-start.sh start \$1
+	EOF
+else
+	STARTCOMAND3=$(cat /jffs/scripts/post-mount | grep -c "/koolshare/bin/ks-mount-start.sh start \$1")
+	[ "$STARTCOMAND3" -gt "1" ] && sed -i '/ks-mount-start.sh/d' /jffs/scripts/post-mount && sed -i '1a /koolshare/bin/ks-mount-start.sh start $1' /jffs/scripts/post-mount
+	[ "$STARTCOMAND3" == "0" ] && sed -i '/ks-mount-start.sh/d' /jffs/scripts/post-mount && sed -i '1a /koolshare/bin/ks-mount-start.sh start $1' /jffs/scripts/post-mount
+fi
+
+if [ ! -f "/jffs/scripts/services-start" ];then
+	cat > /jffs/scripts/services-start <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-services-start.sh start
+	EOF
+else
+	STARTCOMAND4=$(cat /jffs/scripts/services-start | grep -c "/koolshare/bin/ks-services-start.sh start")
+	[ "$STARTCOMAND4" -gt "1" ] && sed -i '/ks-services-start.sh/d' /jffs/scripts/services-start && sed -i '1a /koolshare/bin/ks-services-start.sh start' /jffs/scripts/services-start
+	[ "$STARTCOMAND4" == "0" ] && sed -i '1a /koolshare/bin/ks-services-start.sh start' /jffs/scripts/services-start
+fi
+
+if [ ! -f "/jffs/scripts/unmount" ];then
+	cat > /jffs/scripts/unmount <<-EOF
+	#!/bin/sh
+	/koolshare/bin/ks-unmount.sh \$1
+	EOF
+else
+	STARTCOMAND5=$(cat /jffs/scripts/unmount | grep -c "/koolshare/bin/ks-unmount.sh $1")
+	[ "$STARTCOMAND5" -gt "1" ] && sed -i '/ks-unmount.sh/d' /jffs/scripts/unmount && sed -i '1a /koolshare/bin/ks-unmount.sh $1' /jffs/scripts/unmount
+	[ "$STARTCOMAND5" == "0" ] && sed -i '1a /koolshare/bin/ks-unmount.sh $1' /jffs/scripts/unmount
+fi
+chmod +x /jffs/scripts/*
+#============================================
diff --git a/release/src/router/softcenter/softcenter/bin/perpboot b/release/src/router/softcenter/softcenter/bin/perpboot
new file mode 100755
index 0000000000000000000000000000000000000000..c4a51be5b4b70b85227bf252a690441bd7bb9224
GIT binary patch
literal 11472
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
W&`4c7^?wJ{5`Wk*<ss%9+Wa3#aoke?

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perpctl b/release/src/router/softcenter/softcenter/bin/perpctl
new file mode 100755
index 0000000000000000000000000000000000000000..89afdfe886d8f0cd90157bbac4fe08b3a1068a29
GIT binary patch
literal 11364
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perpd b/release/src/router/softcenter/softcenter/bin/perpd
new file mode 100755
index 0000000000000000000000000000000000000000..00a5768acd86d256ccfffcaed76f4f61d9a9ba48
GIT binary patch
literal 24012
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
TKKuXs<SIKI9v&GM!KwZSxZId;

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perphup b/release/src/router/softcenter/softcenter/bin/perphup
new file mode 100755
index 0000000000000000000000000000000000000000..9304fb2716d82c0c6a7c12aeb4618fe1979b296d
GIT binary patch
literal 9008
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perpls b/release/src/router/softcenter/softcenter/bin/perpls
new file mode 100755
index 0000000000000000000000000000000000000000..0682610534badc952da10b6a6aee8717c380955d
GIT binary patch
literal 13532
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perpok b/release/src/router/softcenter/softcenter/bin/perpok
new file mode 100755
index 0000000000000000000000000000000000000000..54a3fbc8aceedead93b4d5ae5eb54044cb9a6cac
GIT binary patch
literal 10940
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/perpstat b/release/src/router/softcenter/softcenter/bin/perpstat
new file mode 100755
index 0000000000000000000000000000000000000000..466e0d02caadd90d8f3304fb6da683d1e63b02b6
GIT binary patch
literal 13084
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/sissylog b/release/src/router/softcenter/softcenter/bin/sissylog
new file mode 100755
index 0000000000000000000000000000000000000000..8b75fcee102702543ef20e75adc57f29d0bed872
GIT binary patch
literal 6584
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
E13!?0g8%>k

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/start-stop-daemon b/release/src/router/softcenter/softcenter/bin/start-stop-daemon
new file mode 100755
index 0000000000000000000000000000000000000000..74153b87d006751827e5a4d396a982e4c36cc418
GIT binary patch
literal 22548
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/tinylog b/release/src/router/softcenter/softcenter/bin/tinylog
new file mode 100755
index 0000000000000000000000000000000000000000..ab4678e33f2d77d86c2714eec41078f349aebcc4
GIT binary patch
literal 15380
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
ZUeMhk{BnES|FxyBIk*P5h9EZ#`aec?zHtBm

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/bin/versioncmp b/release/src/router/softcenter/softcenter/bin/versioncmp
new file mode 100755
index 0000000000000000000000000000000000000000..7257890335f8e69645b9684cdf2a1057f4845f68
GIT binary patch
literal 4824
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
KuVR`=>HQmJhN4{n

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/init.d/S01softok.sh b/release/src/router/softcenter/softcenter/init.d/S01softok.sh
new file mode 100755
index 0000000000..90d0ab3435
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/init.d/S01softok.sh
@@ -0,0 +1,43 @@
+#!/bin/sh
+
+source /koolshare/scripts/base.sh
+
+detect_skipd(){
+	i=120
+	skipd=$(pidof skipd)
+	until [ -n "$skipd" ]
+	do
+		i=$(($i-1))
+		    skipd=$(pidof skipd)
+		if [ "$i" -lt 1 ];then
+		    logger "[软件中心]wan-start报告: 错误，skipd进程未能成功启动！"
+		    exit
+		fi
+		sleep 1
+	done
+	logger "[软件中心]wan-start报告: skipd进程准备就绪！"
+	dbus set softcenter_installing_status="1"
+}
+
+detect_httpdb(){
+	i=120
+	httpdb=$(pidof httpdb)
+	until [ -n "$httpdb" ]
+	do
+		i=$(($i-1))
+		    httpdb=$(pidof httpdb)
+		if [ "$i" -lt 1 ];then
+		    logger "[软件中心]wan-start报告: 错误，httpdb进程未能成功启动！"
+		    exit
+		fi
+		sleep 1
+	done
+	logger "[软件中心]wan-start报告: httpdb进程准备就绪！"
+}
+
+start(){
+	detect_skipd
+	detect_httpdb
+}
+
+start
diff --git a/release/src/router/softcenter/softcenter/init.d/V01softok.sh b/release/src/router/softcenter/softcenter/init.d/V01softok.sh
new file mode 100755
index 0000000000..2fb1639de7
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/init.d/V01softok.sh
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+source /koolshare/scripts/base.sh
+
+detect_skipd(){
+	i=120
+	skipd=$(pidof skipd)
+	until [ -n "$skipd" ]
+	do
+		i=$(($i-1))
+		    skipd=$(pidof skipd)
+		if [ "$i" -lt 1 ];then
+		    logger "[软件中心]services-start报告: 错误，skipd进程未能成功启动！"
+		    exit
+		fi
+		sleep 1
+	done
+	logger "[软件中心]services-start报告: skipd进程准备就绪！"
+	dbus set softcenter_installing_status="1"
+}
+
+start(){
+	detect_skipd
+	sleep 1
+	if [ -f "/koolshare/.soft_ver" ];then
+		dbus set softcenter_version=$(cat /koolshare/.soft_ver)
+	fi
+}
+
+start
diff --git a/release/src/router/softcenter/softcenter/perp/.boot/rc.log b/release/src/router/softcenter/softcenter/perp/.boot/rc.log
new file mode 100755
index 0000000000..a8fce5b0ed
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/perp/.boot/rc.log
@@ -0,0 +1,3 @@
+#!/bin/sh
+LOGDIR=/var/log/perpd
+exec tinylog -k 3 -s 50000 -t ${LOGDIR}
diff --git a/release/src/router/softcenter/softcenter/perp/.boot/rc.perp b/release/src/router/softcenter/softcenter/perp/.boot/rc.perp
new file mode 100755
index 0000000000..4098b4338a
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/perp/.boot/rc.perp
@@ -0,0 +1,2 @@
+#!/bin/sh
+exec perpd -a 6 $PERP_BASE
diff --git a/release/src/router/softcenter/softcenter/perp/.control/perpd.pid b/release/src/router/softcenter/softcenter/perp/.control/perpd.pid
new file mode 100644
index 0000000000..d96ebc2c70
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/perp/.control/perpd.pid
@@ -0,0 +1 @@
+30237
diff --git a/release/src/router/softcenter/softcenter/perp/httpdb/rc.main b/release/src/router/softcenter/softcenter/perp/httpdb/rc.main
new file mode 100755
index 0000000000..4b16f0e1fe
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/perp/httpdb/rc.main
@@ -0,0 +1,7 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+exec 2>&1
+exec httpdb
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/perp/perp.sh b/release/src/router/softcenter/softcenter/perp/perp.sh
new file mode 100755
index 0000000000..62dbd35f64
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/perp/perp.sh
@@ -0,0 +1,34 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+kill_all_process(){
+	killall perpboot >/dev/null 2>&1
+	killall tinylog >/dev/null 2>&1
+	killall perpd >/dev/null 2>&1
+	#killall skipd >/dev/null 2>&1
+	#[ -n `pidof skipd` ] && kill -9 `pidof skipd` >/dev/null 2>&1
+	killall httpdb >/dev/null 2>&1
+	[ -n `pidof httpdb` ] && kill -9 `pidof httpdb` >/dev/null 2>&1
+}
+
+case $ACTION in
+start)
+	kill_all_process >/dev/null 2>&1
+	sleep 1
+	chmod +t $PERP_BASE/httpdb
+	#chmod +t $PERP_BASE/skipd
+	perpboot -d
+	;;
+stop)
+	kill_all_process >/dev/null 2>&1
+	;;
+*)
+	kill_all_process >/dev/null 2>&1
+	sleep 1
+	chmod +t $PERP_BASE/httpdb
+	#chmod +t $PERP_BASE/skipd
+	perpboot -d
+	;;
+esac
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/res/icon-default.png b/release/src/router/softcenter/softcenter/res/icon-default.png
new file mode 100644
index 0000000000000000000000000000000000000000..f752f2915ac7dcd96ec16a0b991a960812b8be62
GIT binary patch
literal 5486
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/koolshare.png b/release/src/router/softcenter/softcenter/res/koolshare.png
new file mode 100644
index 0000000000000000000000000000000000000000..6db65d3db941e38c84c6e0fe8531e506152b006e
GIT binary patch
literal 2574
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/layer/layer.js b/release/src/router/softcenter/softcenter/res/layer/layer.js
new file mode 100644
index 0000000000..59986783bd
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/layer/layer.js
@@ -0,0 +1,652 @@
+/*! layer-v3.1.0 Web弹层组件 MIT License  http://layer.layui.com/  By 贤心 */ ;
+! function(e, t) {
+	"use strict";
+	var i, n, a = e.layui && layui.define,
+		o = {
+			getPath: function() {
+				var e = document.scripts,
+					t = e[e.length - 1],
+					i = t.src;
+				if (!t.getAttribute("merge")) return i.substring(0, i.lastIndexOf("/") + 1)
+			}(),
+			config: {},
+			end: {},
+			minIndex: 0,
+			minLeft: [],
+			btn: ["&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;"],
+			type: ["dialog", "page", "iframe", "loading", "tips"],
+			getStyle: function(t, i) {
+				var n = t.currentStyle ? t.currentStyle : e.getComputedStyle(t, null);
+				return n[n.getPropertyValue ? "getPropertyValue" : "getAttribute"](i)
+			},
+			link: function(t, i, n) {
+				if (r.path) {
+					var a = document.getElementsByTagName("head")[0],
+						s = document.createElement("link");
+					"string" == typeof i && (n = i);
+					var l = (n || t).replace(/\.|\//g, ""),
+						f = "layuicss-" + l,
+						c = 0;
+					s.rel = "stylesheet", s.href = r.path + t, s.id = f, document.getElementById(f) || a.appendChild(s), "function" == typeof i && ! function u() {
+						return ++c > 80 ? e.console && console.error("layer.css: Invalid") : void(1989 === parseInt(o.getStyle(document.getElementById(f), "width")) ? i() : setTimeout(u, 100))
+					}()
+				}
+			}
+		},
+		r = {
+			v: "3.1.0",
+			ie: function() {
+				var t = navigator.userAgent.toLowerCase();
+				return !!(e.ActiveXObject || "ActiveXObject" in e) && ((t.match(/msie\s(\d+)/) || [])[1] || "11")
+			}(),
+			index: e.layer && e.layer.v ? 1e5 : 0,
+			path: o.getPath,
+			config: function(e, t) {
+				return e = e || {}, r.cache = o.config = i.extend({}, o.config, e), r.path = o.config.path || r.path, "string" == typeof e.extend && (e.extend = [e.extend]), o.config.path && r.ready(), e.extend ? (a ? layui.addcss("modules/layer/" + e.extend) : o.link("theme/" + e.extend), this) : this
+			},
+			ready: function(e) {
+				var t = "layer",
+					i = "",
+					n = (a ? "modules/layer/" : "theme/") + "default/layer.css?v=" + r.v + i;
+				return a ? layui.addcss(n, e, t) : o.link(n, e, t), this
+			},
+			alert: function(e, t, n) {
+				var a = "function" == typeof t;
+				return a && (n = t), r.open(i.extend({
+					content: e,
+					yes: n
+				}, a ? {} : t))
+			},
+			confirm: function(e, t, n, a) {
+				var s = "function" == typeof t;
+				return s && (a = n, n = t), r.open(i.extend({
+					content: e,
+					btn: o.btn,
+					yes: n,
+					btn2: a
+				}, s ? {} : t))
+			},
+			msg: function(e, n, a) {
+				var s = "function" == typeof n,
+					f = o.config.skin,
+					c = (f ? f + " " + f + "-msg" : "") || "layui-layer-msg",
+					u = l.anim.length - 1;
+				return s && (a = n), r.open(i.extend({
+					content: e,
+					time: 3e3,
+					shade: !1,
+					skin: c,
+					title: !1,
+					closeBtn: !1,
+					btn: !1,
+					resize: !1,
+					end: a
+				}, s && !o.config.skin ? {
+					skin: c + " layui-layer-hui",
+					anim: u
+				} : function() {
+					return n = n || {}, (n.icon === -1 || n.icon === t && !o.config.skin) && (n.skin = c + " " + (n.skin || "layui-layer-hui")), n
+				}()))
+			},
+			load: function(e, t) {
+				return r.open(i.extend({
+					type: 3,
+					icon: e || 0,
+					resize: !1,
+					shade: .01
+				}, t))
+			},
+			tips: function(e, t, n) {
+				return r.open(i.extend({
+					type: 4,
+					content: [e, t],
+					closeBtn: !1,
+					time: 3e3,
+					shade: !1,
+					resize: !1,
+					fixed: !1,
+					maxWidth: 210
+				}, n))
+			}
+		},
+		s = function(e) {
+			var t = this;
+			t.index = ++r.index, t.config = i.extend({}, t.config, o.config, e), document.body ? t.creat() : setTimeout(function() {
+				t.creat()
+			}, 30)
+		};
+	s.pt = s.prototype;
+	var l = ["layui-layer", ".layui-layer-title", ".layui-layer-main", ".layui-layer-dialog", "layui-layer-iframe", "layui-layer-content", "layui-layer-btn", "layui-layer-close"];
+	l.anim = ["layer-anim-00", "layer-anim-01", "layer-anim-02", "layer-anim-03", "layer-anim-04", "layer-anim-05", "layer-anim-06"], s.pt.config = {
+		type: 0,
+		shade: .3,
+		fixed: !0,
+		move: l[1],
+		title: "&#x4FE1;&#x606F;",
+		offset: "auto",
+		area: "auto",
+		closeBtn: 1,
+		time: 0,
+		zIndex: 19891014,
+		maxWidth: 360,
+		anim: 0,
+		isOutAnim: !0,
+		icon: -1,
+		moveType: 1,
+		resize: !0,
+		scrollbar: !0,
+		tips: 2
+	}, s.pt.vessel = function(e, t) {
+		var n = this,
+			a = n.index,
+			r = n.config,
+			s = r.zIndex + a,
+			f = "object" == typeof r.title,
+			c = r.maxmin && (1 === r.type || 2 === r.type),
+			u = r.title ? '<div class="layui-layer-title" style="' + (f ? r.title[1] : "") + '">' + (f ? r.title[0] : r.title) + "</div>" : "";
+		return r.zIndex = s, t([r.shade ? '<div class="layui-layer-shade" id="layui-layer-shade' + a + '" times="' + a + '" style="' + ("z-index:" + (s - 1) + "; ") + '"></div>' : "", '<div class="' + l[0] + (" layui-layer-" + o.type[r.type]) + (0 != r.type && 2 != r.type || r.shade ? "" : " layui-layer-border") + " " + (r.skin || "") + '" id="' + l[0] + a + '" type="' + o.type[r.type] + '" times="' + a + '" showtime="' + r.time + '" conType="' + (e ? "object" : "string") + '" style="z-index: ' + s + "; width:" + r.area[0] + ";height:" + r.area[1] + (r.fixed ? "" : ";position:absolute;") + '">' + (e && 2 != r.type ? "" : u) + '<div id="' + (r.id || "") + '" class="layui-layer-content' + (0 == r.type && r.icon !== -1 ? " layui-layer-padding" : "") + (3 == r.type ? " layui-layer-loading" + r.icon : "") + '">' + (0 == r.type && r.icon !== -1 ? '<i class="layui-layer-ico layui-layer-ico' + r.icon + '"></i>' : "") + (1 == r.type && e ? "" : r.content || "") + '</div><span class="layui-layer-setwin">' + function() {
+			var e = c ? '<a class="layui-layer-min" href="javascript:;"><cite></cite></a><a class="layui-layer-ico layui-layer-max" href="javascript:;"></a>' : "";
+			return r.closeBtn && (e += '<a class="layui-layer-ico ' + l[7] + " " + l[7] + (r.title ? r.closeBtn : 4 == r.type ? "1" : "2") + '" href="javascript:;"></a>'), e
+		}() + "</span>" + (r.btn ? function() {
+			var e = "";
+			"string" == typeof r.btn && (r.btn = [r.btn]);
+			for (var t = 0, i = r.btn.length; t < i; t++) e += '<a class="' + l[6] + t + '">' + r.btn[t] + "</a>";
+			return '<div class="' + l[6] + " layui-layer-btn-" + (r.btnAlign || "") + '">' + e + "</div>"
+		}() : "") + (r.resize ? '<span class="layui-layer-resize"></span>' : "") + "</div>"], u, i('<div class="layui-layer-move"></div>')), n
+	}, s.pt.creat = function() {
+		var e = this,
+			t = e.config,
+			a = e.index,
+			s = t.content,
+			f = "object" == typeof s,
+			c = i("body");
+		if (!t.id || !i("#" + t.id)[0]) {
+			switch ("string" == typeof t.area && (t.area = "auto" === t.area ? ["", ""] : [t.area, ""]), t.shift && (t.anim = t.shift), 6 == r.ie && (t.fixed = !1), t.type) {
+				case 0:
+					t.btn = "btn" in t ? t.btn : o.btn[0], r.closeAll("dialog");
+					break;
+				case 2:
+					var s = t.content = f ? t.content : [t.content || "http://layer.layui.com", "auto"];
+					t.content = '<iframe scrolling="' + (t.content[1] || "auto") + '" allowtransparency="true" id="' + l[4] + a + '" name="' + l[4] + a + '" onload="this.className=\'\';" class="layui-layer-load" frameborder="0" src="' + t.content[0] + '"></iframe>';
+					break;
+				case 3:
+					delete t.title, delete t.closeBtn, t.icon === -1 && 0 === t.icon, r.closeAll("loading");
+					break;
+				case 4:
+					f || (t.content = [t.content, "body"]), t.follow = t.content[1], t.content = t.content[0] + '<i class="layui-layer-TipsG"></i>', delete t.title, t.tips = "object" == typeof t.tips ? t.tips : [t.tips, !0], t.tipsMore || r.closeAll("tips")
+			}
+			if (e.vessel(f, function(n, r, u) {
+				c.append(n[0]), f ? function() {
+					2 == t.type || 4 == t.type ? function() {
+						i("body").append(n[1])
+					}() : function() {
+						s.parents("." + l[0])[0] || (s.data("display", s.css("display")).show().addClass("layui-layer-wrap").wrap(n[1]), i("#" + l[0] + a).find("." + l[5]).before(r))
+					}()
+				}() : c.append(n[1]), i(".layui-layer-move")[0] || c.append(o.moveElem = u), e.layero = i("#" + l[0] + a), t.scrollbar || l.html.css("overflow", "hidden").attr("layer-full", a)
+			}).auto(a), i("#layui-layer-shade" + e.index).css({
+				"background-color": t.shade[1] || "#000",
+				opacity: t.shade[0] || t.shade
+			}), 2 == t.type && 6 == r.ie && e.layero.find("iframe").attr("src", s[0]), 4 == t.type ? e.tips() : e.offset(), t.fixed && n.on("resize", function() {
+				e.offset(), (/^\d+%$/.test(t.area[0]) || /^\d+%$/.test(t.area[1])) && e.auto(a), 4 == t.type && e.tips()
+			}), t.time <= 0 || setTimeout(function() {
+				r.close(e.index)
+			}, t.time), e.move().callback(), l.anim[t.anim]) {
+				var u = "layer-anim " + l.anim[t.anim];
+				e.layero.addClass(u).one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend", function() {
+					i(this).removeClass(u)
+				})
+			}
+			t.isOutAnim && e.layero.data("isOutAnim", !0)
+		}
+	}, s.pt.auto = function(e) {
+		var t = this,
+			a = t.config,
+			o = i("#" + l[0] + e);
+		"" === a.area[0] && a.maxWidth > 0 && (r.ie && r.ie < 8 && a.btn && o.width(o.innerWidth()), o.outerWidth() > a.maxWidth && o.width(a.maxWidth));
+		var s = [o.innerWidth(), o.innerHeight()],
+			f = o.find(l[1]).outerHeight() || 0,
+			c = o.find("." + l[6]).outerHeight() || 0,
+			u = function(e) {
+				e = o.find(e), e.height(s[1] - f - c - 2 * (0 | parseFloat(e.css("padding-top"))))
+			};
+		switch (a.type) {
+			case 2:
+				u("iframe");
+				break;
+			default:
+				"" === a.area[1] ? a.maxHeight > 0 && o.outerHeight() > a.maxHeight ? (s[1] = a.maxHeight, u("." + l[5])) : a.fixed && s[1] >= n.height() && (s[1] = n.height(), u("." + l[5])) : u("." + l[5])
+		}
+		return t
+	}, s.pt.offset = function() {
+		var e = this,
+			t = e.config,
+			i = e.layero,
+			a = [i.outerWidth(), i.outerHeight()],
+			o = "object" == typeof t.offset;
+		e.offsetTop = (n.height() - a[1]) / 2, e.offsetLeft = (n.width() - a[0]) / 2, o ? (e.offsetTop = t.offset[0], e.offsetLeft = t.offset[1] || e.offsetLeft) : "auto" !== t.offset && ("t" === t.offset ? e.offsetTop = 0 : "r" === t.offset ? e.offsetLeft = n.width() - a[0] : "b" === t.offset ? e.offsetTop = n.height() - a[1] : "l" === t.offset ? e.offsetLeft = 0 : "lt" === t.offset ? (e.offsetTop = 0, e.offsetLeft = 0) : "lb" === t.offset ? (e.offsetTop = n.height() - a[1], e.offsetLeft = 0) : "rt" === t.offset ? (e.offsetTop = 0, e.offsetLeft = n.width() - a[0]) : "rb" === t.offset ? (e.offsetTop = n.height() - a[1], e.offsetLeft = n.width() - a[0]) : e.offsetTop = t.offset), t.fixed || (e.offsetTop = /%$/.test(e.offsetTop) ? n.height() * parseFloat(e.offsetTop) / 100 : parseFloat(e.offsetTop), e.offsetLeft = /%$/.test(e.offsetLeft) ? n.width() * parseFloat(e.offsetLeft) / 100 : parseFloat(e.offsetLeft), e.offsetTop += n.scrollTop(), e.offsetLeft += n.scrollLeft()), i.attr("minLeft") && (e.offsetTop = n.height() - (i.find(l[1]).outerHeight() || 0), e.offsetLeft = i.css("left")), i.css({
+			top: e.offsetTop,
+			left: e.offsetLeft
+		})
+	}, s.pt.tips = function() {
+		var e = this,
+			t = e.config,
+			a = e.layero,
+			o = [a.outerWidth(), a.outerHeight()],
+			r = i(t.follow);
+		r[0] || (r = i("body"));
+		var s = {
+				width: r.outerWidth(),
+				height: r.outerHeight(),
+				top: r.offset().top,
+				left: r.offset().left
+			},
+			f = a.find(".layui-layer-TipsG"),
+			c = t.tips[0];
+		t.tips[1] || f.remove(), s.autoLeft = function() {
+			s.left + o[0] - n.width() > 0 ? (s.tipLeft = s.left + s.width - o[0], f.css({
+				right: 12,
+				left: "auto"
+			})) : s.tipLeft = s.left
+		}, s.where = [
+			function() {
+				s.autoLeft(), s.tipTop = s.top - o[1] - 10, f.removeClass("layui-layer-TipsB").addClass("layui-layer-TipsT").css("border-right-color", t.tips[1])
+			},
+			function() {
+				s.tipLeft = s.left + s.width + 10, s.tipTop = s.top, f.removeClass("layui-layer-TipsL").addClass("layui-layer-TipsR").css("border-bottom-color", t.tips[1])
+			},
+			function() {
+				s.autoLeft(), s.tipTop = s.top + s.height + 10, f.removeClass("layui-layer-TipsT").addClass("layui-layer-TipsB").css("border-right-color", t.tips[1])
+			},
+			function() {
+				s.tipLeft = s.left - o[0] - 10, s.tipTop = s.top, f.removeClass("layui-layer-TipsR").addClass("layui-layer-TipsL").css("border-bottom-color", t.tips[1])
+			}
+		], s.where[c - 1](), 1 === c ? s.top - (n.scrollTop() + o[1] + 16) < 0 && s.where[2]() : 2 === c ? n.width() - (s.left + s.width + o[0] + 16) > 0 || s.where[3]() : 3 === c ? s.top - n.scrollTop() + s.height + o[1] + 16 - n.height() > 0 && s.where[0]() : 4 === c && o[0] + 16 - s.left > 0 && s.where[1](), a.find("." + l[5]).css({
+			"background-color": t.tips[1],
+			"padding-right": t.closeBtn ? "30px" : ""
+		}), a.css({
+			left: s.tipLeft - (t.fixed ? n.scrollLeft() : 0),
+			top: s.tipTop - (t.fixed ? n.scrollTop() : 0)
+		})
+	}, s.pt.move = function() {
+		var e = this,
+			t = e.config,
+			a = i(document),
+			s = e.layero,
+			l = s.find(t.move),
+			f = s.find(".layui-layer-resize"),
+			c = {};
+		return t.move && l.css("cursor", "move"), l.on("mousedown", function(e) {
+			e.preventDefault(), t.move && (c.moveStart = !0, c.offset = [e.clientX - parseFloat(s.css("left")), e.clientY - parseFloat(s.css("top"))], o.moveElem.css("cursor", "move").show())
+		}), f.on("mousedown", function(e) {
+			e.preventDefault(), c.resizeStart = !0, c.offset = [e.clientX, e.clientY], c.area = [s.outerWidth(), s.outerHeight()], o.moveElem.css("cursor", "se-resize").show()
+		}), a.on("mousemove", function(i) {
+			if (c.moveStart) {
+				var a = i.clientX - c.offset[0],
+					o = i.clientY - c.offset[1],
+					l = "fixed" === s.css("position");
+				if (i.preventDefault(), c.stX = l ? 0 : n.scrollLeft(), c.stY = l ? 0 : n.scrollTop(), !t.moveOut) {
+					var f = n.width() - s.outerWidth() + c.stX,
+						u = n.height() - s.outerHeight() + c.stY;
+					a < c.stX && (a = c.stX), a > f && (a = f), o < c.stY && (o = c.stY), o > u && (o = u)
+				}
+				s.css({
+					left: a,
+					top: o
+				})
+			}
+			if (t.resize && c.resizeStart) {
+				var a = i.clientX - c.offset[0],
+					o = i.clientY - c.offset[1];
+				i.preventDefault(), r.style(e.index, {
+					width: c.area[0] + a,
+					height: c.area[1] + o
+				}), c.isResize = !0, t.resizing && t.resizing(s)
+			}
+		}).on("mouseup", function(e) {
+			c.moveStart && (delete c.moveStart, o.moveElem.hide(), t.moveEnd && t.moveEnd(s)), c.resizeStart && (delete c.resizeStart, o.moveElem.hide())
+		}), e
+	}, s.pt.callback = function() {
+		function e() {
+			var e = a.cancel && a.cancel(t.index, n);
+			e === !1 || r.close(t.index)
+		}
+		var t = this,
+			n = t.layero,
+			a = t.config;
+		t.openLayer(), a.success && (2 == a.type ? n.find("iframe").on("load", function() {
+			a.success(n, t.index)
+		}) : a.success(n, t.index)), 6 == r.ie && t.IE6(n), n.find("." + l[6]).children("a").on("click", function() {
+			var e = i(this).index();
+			if (0 === e) a.yes ? a.yes(t.index, n) : a.btn1 ? a.btn1(t.index, n) : r.close(t.index);
+			else {
+				var o = a["btn" + (e + 1)] && a["btn" + (e + 1)](t.index, n);
+				o === !1 || r.close(t.index)
+			}
+		}), n.find("." + l[7]).on("click", e), a.shadeClose && i("#layui-layer-shade" + t.index).on("click", function() {
+			r.close(t.index)
+		}), n.find(".layui-layer-min").on("click", function() {
+			var e = a.min && a.min(n);
+			e === !1 || r.min(t.index, a)
+		}), n.find(".layui-layer-max").on("click", function() {
+			i(this).hasClass("layui-layer-maxmin") ? (r.restore(t.index), a.restore && a.restore(n)) : (r.full(t.index, a), setTimeout(function() {
+				a.full && a.full(n)
+			}, 100))
+		}), a.end && (o.end[t.index] = a.end)
+	}, o.reselect = function() {
+		i.each(i("select"), function(e, t) {
+			var n = i(this);
+			n.parents("." + l[0])[0] || 1 == n.attr("layer") && i("." + l[0]).length < 1 && n.removeAttr("layer").show(), n = null
+		})
+	}, s.pt.IE6 = function(e) {
+		i("select").each(function(e, t) {
+			var n = i(this);
+			n.parents("." + l[0])[0] || "none" === n.css("display") || n.attr({
+				layer: "1"
+			}).hide(), n = null
+		})
+	}, s.pt.openLayer = function() {
+		var e = this;
+		r.zIndex = e.config.zIndex, r.setTop = function(e) {
+			var t = function() {
+				r.zIndex++, e.css("z-index", r.zIndex + 1)
+			};
+			return r.zIndex = parseInt(e[0].style.zIndex), e.on("mousedown", t), r.zIndex
+		}
+	}, o.record = function(e) {
+		var t = [e.width(), e.height(), e.position().top, e.position().left + parseFloat(e.css("margin-left"))];
+		e.find(".layui-layer-max").addClass("layui-layer-maxmin"), e.attr({
+			area: t
+		})
+	}, o.rescollbar = function(e) {
+		l.html.attr("layer-full") == e && (l.html[0].style.removeProperty ? l.html[0].style.removeProperty("overflow") : l.html[0].style.removeAttribute("overflow"), l.html.removeAttr("layer-full"))
+	}, e.layer = r, r.getChildFrame = function(e, t) {
+		return t = t || i("." + l[4]).attr("times"), i("#" + l[0] + t).find("iframe").contents().find(e)
+	}, r.getFrameIndex = function(e) {
+		return i("#" + e).parents("." + l[4]).attr("times")
+	}, r.iframeAuto = function(e) {
+		if (e) {
+			var t = r.getChildFrame("html", e).outerHeight(),
+				n = i("#" + l[0] + e),
+				a = n.find(l[1]).outerHeight() || 0,
+				o = n.find("." + l[6]).outerHeight() || 0;
+			n.css({
+				height: t + a + o
+			}), n.find("iframe").css({
+				height: t
+			})
+		}
+	}, r.iframeSrc = function(e, t) {
+		i("#" + l[0] + e).find("iframe").attr("src", t)
+	}, r.style = function(e, t, n) {
+		var a = i("#" + l[0] + e),
+			r = a.find(".layui-layer-content"),
+			s = a.attr("type"),
+			f = a.find(l[1]).outerHeight() || 0,
+			c = a.find("." + l[6]).outerHeight() || 0;
+		a.attr("minLeft");
+		s !== o.type[3] && s !== o.type[4] && (n || (parseFloat(t.width) <= 260 && (t.width = 260), parseFloat(t.height) - f - c <= 64 && (t.height = 64 + f + c)), a.css(t), c = a.find("." + l[6]).outerHeight(), s === o.type[2] ? a.find("iframe").css({
+			height: parseFloat(t.height) - f - c
+		}) : r.css({
+			height: parseFloat(t.height) - f - c - parseFloat(r.css("padding-top")) - parseFloat(r.css("padding-bottom"))
+		}))
+	}, r.min = function(e, t) {
+		var a = i("#" + l[0] + e),
+			s = a.find(l[1]).outerHeight() || 0,
+			f = a.attr("minLeft") || 181 * o.minIndex + "px",
+			c = a.css("position");
+		o.record(a), o.minLeft[0] && (f = o.minLeft[0], o.minLeft.shift()), a.attr("position", c), r.style(e, {
+			width: 180,
+			height: s,
+			left: f,
+			top: n.height() - s,
+			position: "fixed",
+			overflow: "hidden"
+		}, !0), a.find(".layui-layer-min").hide(), "page" === a.attr("type") && a.find(l[4]).hide(), o.rescollbar(e), a.attr("minLeft") || o.minIndex++, a.attr("minLeft", f)
+	}, r.restore = function(e) {
+		var t = i("#" + l[0] + e),
+			n = t.attr("area").split(",");
+		t.attr("type");
+		r.style(e, {
+			width: parseFloat(n[0]),
+			height: parseFloat(n[1]),
+			top: parseFloat(n[2]),
+			left: parseFloat(n[3]),
+			position: t.attr("position"),
+			overflow: "visible"
+		}, !0), t.find(".layui-layer-max").removeClass("layui-layer-maxmin"), t.find(".layui-layer-min").show(), "page" === t.attr("type") && t.find(l[4]).show(), o.rescollbar(e)
+	}, r.full = function(e) {
+		var t, a = i("#" + l[0] + e);
+		o.record(a), l.html.attr("layer-full") || l.html.css("overflow", "hidden").attr("layer-full", e), clearTimeout(t), t = setTimeout(function() {
+			var t = "fixed" === a.css("position");
+			r.style(e, {
+				top: t ? 0 : n.scrollTop(),
+				left: t ? 0 : n.scrollLeft(),
+				width: n.width(),
+				height: n.height()
+			}, !0), a.find(".layui-layer-min").hide()
+		}, 100)
+	}, r.title = function(e, t) {
+		var n = i("#" + l[0] + (t || r.index)).find(l[1]);
+		n.html(e)
+	}, r.close = function(e) {
+		var t = i("#" + l[0] + e),
+			n = t.attr("type"),
+			a = "layer-anim-close";
+		if (t[0]) {
+			var s = "layui-layer-wrap",
+				f = function() {
+					if (n === o.type[1] && "object" === t.attr("conType")) {
+						t.children(":not(." + l[5] + ")").remove();
+						for (var a = t.find("." + s), r = 0; r < 2; r++) a.unwrap();
+						a.css("display", a.data("display")).removeClass(s)
+					} else {
+						if (n === o.type[2]) try {
+							var f = i("#" + l[4] + e)[0];
+							f.contentWindow.document.write(""), f.contentWindow.close(), t.find("." + l[5])[0].removeChild(f)
+						} catch (c) {}
+						t[0].innerHTML = "", t.remove()
+					}
+					"function" == typeof o.end[e] && o.end[e](), delete o.end[e]
+				};
+			t.data("isOutAnim") && t.addClass("layer-anim " + a), i("#layui-layer-moves, #layui-layer-shade" + e).remove(), 6 == r.ie && o.reselect(), o.rescollbar(e), t.attr("minLeft") && (o.minIndex--, o.minLeft.push(t.attr("minLeft"))), r.ie && r.ie < 10 || !t.data("isOutAnim") ? f() : setTimeout(function() {
+				f()
+			}, 200)
+		}
+	}, r.closeAll = function(e) {
+		i.each(i("." + l[0]), function() {
+			var t = i(this),
+				n = e ? t.attr("type") === e : 1;
+			n && r.close(t.attr("times")), n = null
+		})
+	};
+	var f = r.cache || {},
+		c = function(e) {
+			return f.skin ? " " + f.skin + " " + f.skin + "-" + e : ""
+		};
+	r.prompt = function(e, t) {
+		var a = "";
+		if (e = e || {}, "function" == typeof e && (t = e), e.area) {
+			var o = e.area;
+			a = 'style="width: ' + o[0] + "; height: " + o[1] + ';"', delete e.area
+		}
+		var s, l = 2 == e.formType ? '<textarea class="layui-layer-input"' + a + ">" + (e.value || "") + "</textarea>" : function() {
+				return '<input type="' + (1 == e.formType ? "password" : "text") + '" class="layui-layer-input" value="' + (e.value || "") + '">'
+			}(),
+			f = e.success;
+		return delete e.success, r.open(i.extend({
+			type: 1,
+			btn: ["&#x786E;&#x5B9A;", "&#x53D6;&#x6D88;"],
+			content: l,
+			skin: "layui-layer-prompt" + c("prompt"),
+			maxWidth: n.width(),
+			success: function(e) {
+				s = e.find(".layui-layer-input"), s.focus(), "function" == typeof f && f(e)
+			},
+			resize: !1,
+			yes: function(i) {
+				var n = s.val();
+				"" === n ? s.focus() : n.length > (e.maxlength || 500) ? r.tips("&#x6700;&#x591A;&#x8F93;&#x5165;" + (e.maxlength || 500) + "&#x4E2A;&#x5B57;&#x6570;", s, {
+					tips: 1
+				}) : t && t(n, i, s)
+			}
+		}, e))
+	}, r.tab = function(e) {
+		e = e || {};
+		var t = e.tab || {},
+			n = "layui-this",
+			a = e.success;
+		return delete e.success, r.open(i.extend({
+			type: 1,
+			skin: "layui-layer-tab" + c("tab"),
+			resize: !1,
+			title: function() {
+				var e = t.length,
+					i = 1,
+					a = "";
+				if (e > 0)
+					for (a = '<span class="' + n + '">' + t[0].title + "</span>"; i < e; i++) a += "<span>" + t[i].title + "</span>";
+				return a
+			}(),
+			content: '<ul class="layui-layer-tabmain">' + function() {
+				var e = t.length,
+					i = 1,
+					a = "";
+				if (e > 0)
+					for (a = '<li class="layui-layer-tabli ' + n + '">' + (t[0].content || "no content") + "</li>"; i < e; i++) a += '<li class="layui-layer-tabli">' + (t[i].content || "no  content") + "</li>";
+				return a
+			}() + "</ul>",
+			success: function(t) {
+				var o = t.find(".layui-layer-title").children(),
+					r = t.find(".layui-layer-tabmain").children();
+				o.on("mousedown", function(t) {
+					t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0;
+					var a = i(this),
+						o = a.index();
+					a.addClass(n).siblings().removeClass(n), r.eq(o).show().siblings().hide(), "function" == typeof e.change && e.change(o)
+				}), "function" == typeof a && a(t)
+			}
+		}, e))
+	}, r.photos = function(t, n, a) {
+		function o(e, t, i) {
+			var n = new Image;
+			return n.src = e, n.complete ? t(n) : (n.onload = function() {
+				n.onload = null, t(n)
+			}, void(n.onerror = function(e) {
+				n.onerror = null, i(e)
+			}))
+		}
+		var s = {};
+		if (t = t || {}, t.photos) {
+			var l = t.photos.constructor === Object,
+				f = l ? t.photos : {},
+				u = f.data || [],
+				d = f.start || 0;
+			s.imgIndex = (0 | d) + 1, t.img = t.img || "img";
+			var y = t.success;
+			if (delete t.success, l) {
+				if (0 === u.length) return r.msg("&#x6CA1;&#x6709;&#x56FE;&#x7247;")
+			} else {
+				var p = i(t.photos),
+					h = function() {
+						u = [], p.find(t.img).each(function(e) {
+							var t = i(this);
+							t.attr("layer-index", e), u.push({
+								alt: t.attr("alt"),
+								pid: t.attr("layer-pid"),
+								src: t.attr("layer-src") || t.attr("src"),
+								thumb: t.attr("src")
+							})
+						})
+					};
+				if (h(), 0 === u.length) return;
+				if (n || p.on("click", t.img, function() {
+					var e = i(this),
+						n = e.attr("layer-index");
+					r.photos(i.extend(t, {
+						photos: {
+							start: n,
+							data: u,
+							tab: t.tab
+						},
+						full: t.full
+					}), !0), h()
+				}), !n) return
+			}
+			s.imgprev = function(e) {
+				s.imgIndex--, s.imgIndex < 1 && (s.imgIndex = u.length), s.tabimg(e)
+			}, s.imgnext = function(e, t) {
+				s.imgIndex++, s.imgIndex > u.length && (s.imgIndex = 1, t) || s.tabimg(e)
+			}, s.keyup = function(e) {
+				if (!s.end) {
+					var t = e.keyCode;
+					e.preventDefault(), 37 === t ? s.imgprev(!0) : 39 === t ? s.imgnext(!0) : 27 === t && r.close(s.index)
+				}
+			}, s.tabimg = function(e) {
+				if (!(u.length <= 1)) return f.start = s.imgIndex - 1, r.close(s.index), r.photos(t, !0, e)
+			}, s.event = function() {
+				s.bigimg.hover(function() {
+					s.imgsee.show()
+				}, function() {
+					s.imgsee.hide()
+				}), s.bigimg.find(".layui-layer-imgprev").on("click", function(e) {
+					e.preventDefault(), s.imgprev()
+				}), s.bigimg.find(".layui-layer-imgnext").on("click", function(e) {
+					e.preventDefault(), s.imgnext()
+				}), i(document).on("keyup", s.keyup)
+			}, s.loadi = r.load(1, {
+				shade: !("shade" in t) && .9,
+				scrollbar: !1
+			}), o(u[d].src, function(n) {
+				r.close(s.loadi), s.index = r.open(i.extend({
+					type: 1,
+					id: "layui-layer-photos",
+					area: function() {
+						var a = [n.width, n.height],
+							o = [i(e).width() - 100, i(e).height() - 100];
+						if (!t.full && (a[0] > o[0] || a[1] > o[1])) {
+							var r = [a[0] / o[0], a[1] / o[1]];
+							r[0] > r[1] ? (a[0] = a[0] / r[0], a[1] = a[1] / r[0]) : r[0] < r[1] && (a[0] = a[0] / r[1], a[1] = a[1] / r[1])
+						}
+						return [a[0] + "px", a[1] + "px"]
+					}(),
+					title: !1,
+					shade: .9,
+					shadeClose: !0,
+					closeBtn: !1,
+					move: ".layui-layer-phimg img",
+					moveType: 1,
+					scrollbar: !1,
+					moveOut: !0,
+					isOutAnim: !1,
+					skin: "layui-layer-photos" + c("photos"),
+					content: '<div class="layui-layer-phimg"><img src="' + u[d].src + '" alt="' + (u[d].alt || "") + '" layer-pid="' + u[d].pid + '"><div class="layui-layer-imgsee">' + (u.length > 1 ? '<span class="layui-layer-imguide"><a href="javascript:;" class="layui-layer-iconext layui-layer-imgprev"></a><a href="javascript:;" class="layui-layer-iconext layui-layer-imgnext"></a></span>' : "") + '<div class="layui-layer-imgbar" style="display:' + (a ? "block" : "") + '"><span class="layui-layer-imgtit"><a href="javascript:;">' + (u[d].alt || "") + "</a><em>" + s.imgIndex + "/" + u.length + "</em></span></div></div></div>",
+					success: function(e, i) {
+						s.bigimg = e.find(".layui-layer-phimg"), s.imgsee = e.find(".layui-layer-imguide,.layui-layer-imgbar"), s.event(e), t.tab && t.tab(u[d], e), "function" == typeof y && y(e)
+					},
+					end: function() {
+						s.end = !0, i(document).off("keyup", s.keyup)
+					}
+				}, t))
+			}, function() {
+				r.close(s.loadi), r.msg("&#x5F53;&#x524D;&#x56FE;&#x7247;&#x5730;&#x5740;&#x5F02;&#x5E38;<br>&#x662F;&#x5426;&#x7EE7;&#x7EED;&#x67E5;&#x770B;&#x4E0B;&#x4E00;&#x5F20;&#xFF1F;", {
+					time: 3e4,
+					btn: ["&#x4E0B;&#x4E00;&#x5F20;", "&#x4E0D;&#x770B;&#x4E86;"],
+					yes: function() {
+						u.length > 1 && s.imgnext(!0, !0)
+					}
+				})
+			})
+		}
+	}, o.run = function(t) {
+		i = t, n = i(e), l.html = i("html"), r.open = function(e) {
+			var t = new s(e);
+			return t.index
+		}
+	}, e.layui && layui.define ? (r.ready(), layui.define("jquery", function(t) {
+		r.path = layui.cache.dir, o.run(layui.$j), e.layer = r, t("layer", r)
+	})) : "function" == typeof define && define.amd ? define(["jquery"], function() {
+		return o.run(e.jQuery), r
+	}) : function() {
+		o.run(e.jQuery), r.ready()
+	}()
+}(window);
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/res/layer/mobile/layer.js b/release/src/router/softcenter/softcenter/res/layer/mobile/layer.js
new file mode 100644
index 0000000000..f9cf69313e
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/layer/mobile/layer.js
@@ -0,0 +1,2 @@
+/*! layer mobile-v2.0.0 Web弹层组件 MIT License  http://layer.layui.com/mobile  By 贤心 */
+ ;!function(e){"use strict";var t=document,n="querySelectorAll",i="getElementsByClassName",a=function(e){return t[n](e)},s={type:0,shade:!0,shadeClose:!0,fixed:!0,anim:"scale"},l={extend:function(e){var t=JSON.parse(JSON.stringify(s));for(var n in e)t[n]=e[n];return t},timer:{},end:{}};l.touch=function(e,t){e.addEventListener("click",function(e){t.call(this,e)},!1)};var r=0,o=["layui-m-layer"],c=function(e){var t=this;t.config=l.extend(e),t.view()};c.prototype.view=function(){var e=this,n=e.config,s=t.createElement("div");e.id=s.id=o[0]+r,s.setAttribute("class",o[0]+" "+o[0]+(n.type||0)),s.setAttribute("index",r);var l=function(){var e="object"==typeof n.title;return n.title?'<h3 style="'+(e?n.title[1]:"")+'">'+(e?n.title[0]:n.title)+"</h3>":""}(),c=function(){"string"==typeof n.btn&&(n.btn=[n.btn]);var e,t=(n.btn||[]).length;return 0!==t&&n.btn?(e='<span yes type="1">'+n.btn[0]+"</span>",2===t&&(e='<span no type="0">'+n.btn[1]+"</span>"+e),'<div class="layui-m-layerbtn">'+e+"</div>"):""}();if(n.fixed||(n.top=n.hasOwnProperty("top")?n.top:100,n.style=n.style||"",n.style+=" top:"+(t.body.scrollTop+n.top)+"px"),2===n.type&&(n.content='<i></i><i class="layui-m-layerload"></i><i></i><p>'+(n.content||"")+"</p>"),n.skin&&(n.anim="up"),"msg"===n.skin&&(n.shade=!1),s.innerHTML=(n.shade?"<div "+("string"==typeof n.shade?'style="'+n.shade+'"':"")+' class="layui-m-layershade"></div>':"")+'<div class="layui-m-layermain" '+(n.fixed?"":'style="position:static;"')+'><div class="layui-m-layersection"><div class="layui-m-layerchild '+(n.skin?"layui-m-layer-"+n.skin+" ":"")+(n.className?n.className:"")+" "+(n.anim?"layui-m-anim-"+n.anim:"")+'" '+(n.style?'style="'+n.style+'"':"")+">"+l+'<div class="layui-m-layercont">'+n.content+"</div>"+c+"</div></div></div>",!n.type||2===n.type){var d=t[i](o[0]+n.type),y=d.length;y>=1&&layer.close(d[0].getAttribute("index"))}document.body.appendChild(s);var u=e.elem=a("#"+e.id)[0];n.success&&n.success(u),e.index=r++,e.action(n,u)},c.prototype.action=function(e,t){var n=this;e.time&&(l.timer[n.index]=setTimeout(function(){layer.close(n.index)},1e3*e.time));var a=function(){var t=this.getAttribute("type");0==t?(e.no&&e.no(),layer.close(n.index)):e.yes?e.yes(n.index):layer.close(n.index)};if(e.btn)for(var s=t[i]("layui-m-layerbtn")[0].children,r=s.length,o=0;o<r;o++)l.touch(s[o],a);if(e.shade&&e.shadeClose){var c=t[i]("layui-m-layershade")[0];l.touch(c,function(){layer.close(n.index,e.end)})}e.end&&(l.end[n.index]=e.end)},e.layer={v:"2.0",index:r,open:function(e){var t=new c(e||{});return t.index},close:function(e){var n=a("#"+o[0]+e)[0];n&&(n.innerHTML="",t.body.removeChild(n),clearTimeout(l.timer[e]),delete l.timer[e],"function"==typeof l.end[e]&&l.end[e](),delete l.end[e])},closeAll:function(){for(var e=t[i](o[0]),n=0,a=e.length;n<a;n++)layer.close(0|e[0].getAttribute("index"))}},"function"==typeof define?define(function(){return layer}):function(){var e=document.scripts,n=e[e.length-1],i=n.src,a=i.substring(0,i.lastIndexOf("/")+1);n.getAttribute("merge")||document.head.appendChild(function(){var e=t.createElement("link");return e.href=a+"need/layer.css?2.0",e.type="text/css",e.rel="styleSheet",e.id="layermcss",e}())}()}(window);
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/res/layer/mobile/need/layer.css b/release/src/router/softcenter/softcenter/res/layer/mobile/need/layer.css
new file mode 100644
index 0000000000..b9dbf20102
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/layer/mobile/need/layer.css
@@ -0,0 +1 @@
+.layui-m-layer{position:relative;z-index:19891014}.layui-m-layer *{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}.layui-m-layermain,.layui-m-layershade{position:fixed;left:0;top:0;width:100%;height:100%}.layui-m-layershade{background-color:rgba(0,0,0,.7);pointer-events:auto}.layui-m-layermain{display:table;font-family:Helvetica,arial,sans-serif;pointer-events:none}.layui-m-layermain .layui-m-layersection{display:table-cell;vertical-align:middle;text-align:center}.layui-m-layerchild{position:relative;display:inline-block;text-align:left;background-color:#fff;font-size:14px;border-radius:5px;box-shadow:0 0 8px rgba(0,0,0,.1);pointer-events:auto;-webkit-overflow-scrolling:touch;-webkit-animation-fill-mode:both;animation-fill-mode:both;-webkit-animation-duration:.2s;animation-duration:.2s}@-webkit-keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}@keyframes layui-m-anim-scale{0%{opacity:0;-webkit-transform:scale(.5);transform:scale(.5)}100%{opacity:1;-webkit-transform:scale(1);transform:scale(1)}}.layui-m-anim-scale{animation-name:layui-m-anim-scale;-webkit-animation-name:layui-m-anim-scale}@-webkit-keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes layui-m-anim-up{0%{opacity:0;-webkit-transform:translateY(800px);transform:translateY(800px)}100%{opacity:1;-webkit-transform:translateY(0);transform:translateY(0)}}.layui-m-anim-up{-webkit-animation-name:layui-m-anim-up;animation-name:layui-m-anim-up}.layui-m-layer0 .layui-m-layerchild{width:90%;max-width:640px}.layui-m-layer1 .layui-m-layerchild{border:none;border-radius:0}.layui-m-layer2 .layui-m-layerchild{width:auto;max-width:260px;min-width:40px;border:none;background:0 0;box-shadow:none;color:#fff}.layui-m-layerchild h3{padding:0 10px;height:60px;line-height:60px;font-size:16px;font-weight:400;border-radius:5px 5px 0 0;text-align:center}.layui-m-layerbtn span,.layui-m-layerchild h3{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.layui-m-layercont{padding:50px 30px;line-height:22px;text-align:center}.layui-m-layer1 .layui-m-layercont{padding:0;text-align:left}.layui-m-layer2 .layui-m-layercont{text-align:center;padding:0;line-height:0}.layui-m-layer2 .layui-m-layercont i{width:25px;height:25px;margin-left:8px;display:inline-block;background-color:#fff;border-radius:100%;-webkit-animation:layui-m-anim-loading 1.4s infinite ease-in-out;animation:layui-m-anim-loading 1.4s infinite ease-in-out;-webkit-animation-fill-mode:both;animation-fill-mode:both}.layui-m-layerbtn,.layui-m-layerbtn span{position:relative;text-align:center;border-radius:0 0 5px 5px}.layui-m-layer2 .layui-m-layercont p{margin-top:20px}@-webkit-keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}@keyframes layui-m-anim-loading{0%,100%,80%{transform:scale(0);-webkit-transform:scale(0)}40%{transform:scale(1);-webkit-transform:scale(1)}}.layui-m-layer2 .layui-m-layercont i:first-child{margin-left:0;-webkit-animation-delay:-.32s;animation-delay:-.32s}.layui-m-layer2 .layui-m-layercont i.layui-m-layerload{-webkit-animation-delay:-.16s;animation-delay:-.16s}.layui-m-layer2 .layui-m-layercont>div{line-height:22px;padding-top:7px;margin-bottom:20px;font-size:14px}.layui-m-layerbtn{display:box;display:-moz-box;display:-webkit-box;width:100%;height:50px;line-height:50px;font-size:0;border-top:1px solid #D0D0D0;background-color:#F2F2F2}.layui-m-layerbtn span{display:block;-moz-box-flex:1;box-flex:1;-webkit-box-flex:1;font-size:14px;cursor:pointer}.layui-m-layerbtn span[yes]{color:#40AFFE}.layui-m-layerbtn span[no]{border-right:1px solid #D0D0D0;border-radius:0 0 0 5px}.layui-m-layerbtn span:active{background-color:#F6F6F6}.layui-m-layerend{position:absolute;right:7px;top:10px;width:30px;height:30px;border:0;font-weight:400;background:0 0;cursor:pointer;-webkit-appearance:none;font-size:30px}.layui-m-layerend::after,.layui-m-layerend::before{position:absolute;left:5px;top:15px;content:'';width:18px;height:1px;background-color:#999;transform:rotate(45deg);-webkit-transform:rotate(45deg);border-radius:3px}.layui-m-layerend::after{transform:rotate(-45deg);-webkit-transform:rotate(-45deg)}body .layui-m-layer .layui-m-layer-footer{position:fixed;width:95%;max-width:100%;margin:0 auto;left:0;right:0;bottom:10px;background:0 0}.layui-m-layer-footer .layui-m-layercont{padding:20px;border-radius:5px 5px 0 0;background-color:rgba(255,255,255,.8)}.layui-m-layer-footer .layui-m-layerbtn{display:block;height:auto;background:0 0;border-top:none}.layui-m-layer-footer .layui-m-layerbtn span{background-color:rgba(255,255,255,.8)}.layui-m-layer-footer .layui-m-layerbtn span[no]{color:#FD482C;border-top:1px solid #c2c2c2;border-radius:0 0 5px 5px}.layui-m-layer-footer .layui-m-layerbtn span[yes]{margin-top:10px;border-radius:5px}body .layui-m-layer .layui-m-layer-msg{width:auto;max-width:90%;margin:0 auto;bottom:-150px;background-color:rgba(0,0,0,.7);color:#fff}.layui-m-layer-msg .layui-m-layercont{padding:10px 20px}
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/icon-ext.png b/release/src/router/softcenter/softcenter/res/layer/theme/default/icon-ext.png
new file mode 100644
index 0000000000000000000000000000000000000000..bbbb669bb311514baa5db3a6a00b4644d0e280f1
GIT binary patch
literal 5911
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
YZmOLxGt_1UThtH@6<y_WCF{ul0LuG;00000

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/icon.png b/release/src/router/softcenter/softcenter/res/layer/theme/default/icon.png
new file mode 100644
index 0000000000000000000000000000000000000000..3e17da8b1aaae2935e19ac97d9015f0fe24e8770
GIT binary patch
literal 11493
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
IBuu~mA09cwRsaA1

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/layer.css b/release/src/router/softcenter/softcenter/res/layer/theme/default/layer.css
new file mode 100644
index 0000000000..17b874ecaf
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/layer/theme/default/layer.css
@@ -0,0 +1,795 @@
+.layui-layer-imgbar,.layui-layer-imgtit a,.layui-layer-tab .layui-layer-title span,.layui-layer-title{
+    text-overflow:ellipsis;
+    white-space:nowrap
+}
+html #layuicss-layer{
+    display:none;
+    position:absolute;
+    width:1989px
+}
+.layui-layer,.layui-layer-shade{
+    position:fixed;
+    _position:absolute;
+    pointer-events:auto
+}
+.layui-layer-shade{
+    top:0;
+    left:0;
+    width:100%;
+    height:100%;
+    _height:expression(document.body.offsetHeight+"px")
+}
+.layui-layer{
+    -webkit-overflow-scrolling:touch;
+    top:150px;
+    left:0;
+    margin:0;
+    padding:0;
+    background-color:#fff;
+    -webkit-background-clip:content;
+    border-radius:2px;
+    box-shadow:1px 1px 50px rgba(0,0,0,.3)
+}
+.layui-layer-close{
+    position:absolute
+}
+.layui-layer-content{
+    position:relative
+}
+.layui-layer-border{
+    border:1px solid #B2B2B2;
+    border:1px solid rgba(0,0,0,.1);
+    box-shadow:1px 1px 5px rgba(0,0,0,.2)
+}
+.layui-layer-load{
+    background:url(loading-1.gif) center center no-repeat #eee
+}
+.layui-layer-ico{
+    background:url(icon.png) no-repeat
+}
+.layui-layer-btn a,.layui-layer-dialog .layui-layer-ico,.layui-layer-setwin a{
+    display:inline-block;
+    *display:inline;
+    *zoom:1;
+    vertical-align:top
+}
+.layui-layer-move{
+    display:none;
+    position:fixed;
+    *position:absolute;
+    left:0;
+    top:0;
+    width:100%;
+    height:100%;
+    cursor:move;
+    opacity:0;
+    filter:alpha(opacity=0);
+    background-color:#fff;
+    z-index:2147483647
+}
+.layui-layer-resize{
+    position:absolute;
+    width:15px;
+    height:15px;
+    right:0;
+    bottom:0;
+    cursor:se-resize
+}
+.layer-anim{
+    -webkit-animation-fill-mode:both;
+    animation-fill-mode:both;
+    -webkit-animation-duration:.3s;
+    animation-duration:.3s
+}
+@-webkit-keyframes layer-bounceIn{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.5);
+        transform:scale(.5)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:scale(1);
+        transform:scale(1)
+    }
+}
+@keyframes layer-bounceIn{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.5);
+        -ms-transform:scale(.5);
+        transform:scale(.5)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:scale(1);
+        -ms-transform:scale(1);
+        transform:scale(1)
+    }
+}
+.layer-anim-00{
+    -webkit-animation-name:layer-bounceIn;
+    animation-name:layer-bounceIn
+}
+@-webkit-keyframes layer-zoomInDown{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.1) translateY(-2000px);
+        transform:scale(.1) translateY(-2000px);
+        -webkit-animation-timing-function:ease-in-out;
+        animation-timing-function:ease-in-out
+    }
+    60%{
+        opacity:1;
+        -webkit-transform:scale(.475) translateY(60px);
+        transform:scale(.475) translateY(60px);
+        -webkit-animation-timing-function:ease-out;
+        animation-timing-function:ease-out
+    }
+}
+@keyframes layer-zoomInDown{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.1) translateY(-2000px);
+        -ms-transform:scale(.1) translateY(-2000px);
+        transform:scale(.1) translateY(-2000px);
+        -webkit-animation-timing-function:ease-in-out;
+        animation-timing-function:ease-in-out
+    }
+    60%{
+        opacity:1;
+        -webkit-transform:scale(.475) translateY(60px);
+        -ms-transform:scale(.475) translateY(60px);
+        transform:scale(.475) translateY(60px);
+        -webkit-animation-timing-function:ease-out;
+        animation-timing-function:ease-out
+    }
+}
+.layer-anim-01{
+    -webkit-animation-name:layer-zoomInDown;
+    animation-name:layer-zoomInDown
+}
+@-webkit-keyframes layer-fadeInUpBig{
+    0%{
+        opacity:0;
+        -webkit-transform:translateY(2000px);
+        transform:translateY(2000px)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:translateY(0);
+        transform:translateY(0)
+    }
+}
+@keyframes layer-fadeInUpBig{
+    0%{
+        opacity:0;
+        -webkit-transform:translateY(2000px);
+        -ms-transform:translateY(2000px);
+        transform:translateY(2000px)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:translateY(0);
+        -ms-transform:translateY(0);
+        transform:translateY(0)
+    }
+}
+.layer-anim-02{
+    -webkit-animation-name:layer-fadeInUpBig;
+    animation-name:layer-fadeInUpBig
+}
+@-webkit-keyframes layer-zoomInLeft{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.1) translateX(-2000px);
+        transform:scale(.1) translateX(-2000px);
+        -webkit-animation-timing-function:ease-in-out;
+        animation-timing-function:ease-in-out
+    }
+    60%{
+        opacity:1;
+        -webkit-transform:scale(.475) translateX(48px);
+        transform:scale(.475) translateX(48px);
+        -webkit-animation-timing-function:ease-out;
+        animation-timing-function:ease-out
+    }
+}
+@keyframes layer-zoomInLeft{
+    0%{
+        opacity:0;
+        -webkit-transform:scale(.1) translateX(-2000px);
+        -ms-transform:scale(.1) translateX(-2000px);
+        transform:scale(.1) translateX(-2000px);
+        -webkit-animation-timing-function:ease-in-out;
+        animation-timing-function:ease-in-out
+    }
+    60%{
+        opacity:1;
+        -webkit-transform:scale(.475) translateX(48px);
+        -ms-transform:scale(.475) translateX(48px);
+        transform:scale(.475) translateX(48px);
+        -webkit-animation-timing-function:ease-out;
+        animation-timing-function:ease-out
+    }
+}
+.layer-anim-03{
+    -webkit-animation-name:layer-zoomInLeft;
+    animation-name:layer-zoomInLeft
+}
+@-webkit-keyframes layer-rollIn{
+    0%{
+        opacity:0;
+        -webkit-transform:translateX(-100%) rotate(-120deg);
+        transform:translateX(-100%) rotate(-120deg)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:translateX(0) rotate(0);
+        transform:translateX(0) rotate(0)
+    }
+}
+@keyframes layer-rollIn{
+    0%{
+        opacity:0;
+        -webkit-transform:translateX(-100%) rotate(-120deg);
+        -ms-transform:translateX(-100%) rotate(-120deg);
+        transform:translateX(-100%) rotate(-120deg)
+    }
+    100%{
+        opacity:1;
+        -webkit-transform:translateX(0) rotate(0);
+        -ms-transform:translateX(0) rotate(0);
+        transform:translateX(0) rotate(0)
+    }
+}
+.layer-anim-04{
+    -webkit-animation-name:layer-rollIn;
+    animation-name:layer-rollIn
+}
+@keyframes layer-fadeIn{
+    0%{
+        opacity:0
+    }
+    100%{
+        opacity:1
+    }
+}
+.layer-anim-05{
+    -webkit-animation-name:layer-fadeIn;
+    animation-name:layer-fadeIn
+}
+@-webkit-keyframes layer-shake{
+    0%,100%{
+        -webkit-transform:translateX(0);
+        transform:translateX(0)
+    }
+    10%,30%,50%,70%,90%{
+        -webkit-transform:translateX(-10px);
+        transform:translateX(-10px)
+    }
+    20%,40%,60%,80%{
+        -webkit-transform:translateX(10px);
+        transform:translateX(10px)
+    }
+}
+@keyframes layer-shake{
+    0%,100%{
+        -webkit-transform:translateX(0);
+        -ms-transform:translateX(0);
+        transform:translateX(0)
+    }
+    10%,30%,50%,70%,90%{
+        -webkit-transform:translateX(-10px);
+        -ms-transform:translateX(-10px);
+        transform:translateX(-10px)
+    }
+    20%,40%,60%,80%{
+        -webkit-transform:translateX(10px);
+        -ms-transform:translateX(10px);
+        transform:translateX(10px)
+    }
+}
+.layer-anim-06{
+    -webkit-animation-name:layer-shake;
+    animation-name:layer-shake
+}
+@-webkit-keyframes fadeIn{
+    0%{
+        opacity:0
+    }
+    100%{
+        opacity:1
+    }
+}
+.layui-layer-title{
+    padding:0 80px 0 20px;
+    height:42px;
+    line-height:42px;
+    border-bottom:1px solid #eee;
+    font-size:14px;
+    color:#333;
+    overflow:hidden;
+    background-color:#F8F8F8;
+    border-radius:2px 2px 0 0
+}
+.layui-layer-setwin{
+    position:absolute;
+    right:15px;
+    *right:0;
+    top:15px;
+    font-size:0;
+    line-height:initial
+}
+.layui-layer-setwin a{
+    position:relative;
+    width:16px;
+    height:16px;
+    margin-left:10px;
+    font-size:12px;
+    _overflow:hidden
+}
+.layui-layer-setwin .layui-layer-min cite{
+    position:absolute;
+    width:14px;
+    height:2px;
+    left:0;
+    top:50%;
+    margin-top:-1px;
+    background-color:#2E2D3C;
+    cursor:pointer;
+    _overflow:hidden
+}
+.layui-layer-setwin .layui-layer-min:hover cite{
+    background-color:#2D93CA
+}
+.layui-layer-setwin .layui-layer-max{
+    background-position:-32px -40px
+}
+.layui-layer-setwin .layui-layer-max:hover{
+    background-position:-16px -40px
+}
+.layui-layer-setwin .layui-layer-maxmin{
+    background-position:-65px -40px
+}
+.layui-layer-setwin .layui-layer-maxmin:hover{
+    background-position:-49px -40px
+}
+.layui-layer-setwin .layui-layer-close1{
+    background-position:1px -40px;
+    cursor:pointer
+}
+.layui-layer-setwin .layui-layer-close1:hover{
+    opacity:.7
+}
+.layui-layer-setwin .layui-layer-close2{
+    position:absolute;
+    right:-28px;
+    top:-28px;
+    width:30px;
+    height:30px;
+    margin-left:0;
+    background-position:-149px -31px;
+    *right:-18px;
+    _display:none
+}
+.layui-layer-setwin .layui-layer-close2:hover{
+    background-position:-180px -31px
+}
+.layui-layer-btn{
+    text-align:right;
+    padding:0 15px 12px;
+    pointer-events:auto;
+    user-select:none;
+    -webkit-user-select:none
+}
+.layui-layer-btn a{
+    height:28px;
+    line-height:28px;
+    margin:5px 5px 0;
+    padding:0 15px;
+    border:1px solid #dedede;
+    background-color:#fff;
+    color:#333;
+    border-radius:2px;
+    font-weight:400;
+    cursor:pointer;
+    text-decoration:none
+}
+.layui-layer-btn a:hover{
+    opacity:.9;
+    text-decoration:none
+}
+.layui-layer-btn a:active{
+    opacity:.8
+}
+.layui-layer-btn .layui-layer-btn0{
+    border-color:#1E9FFF;
+    background-color:#1E9FFF;
+    color:#fff
+}
+.layui-layer-btn-l{
+    text-align:left
+}
+.layui-layer-btn-c{
+    text-align:center
+}
+.layui-layer-dialog{
+    min-width:260px
+}
+.layui-layer-dialog .layui-layer-content{
+    position:relative;
+    padding:20px;
+    line-height:24px;
+    word-break:break-all;
+    overflow:hidden;
+    font-size:14px;
+    overflow-x:hidden;
+    overflow-y:auto;
+    color: #000;
+}
+.layui-layer-dialog .layui-layer-content .layui-layer-ico{
+    position:absolute;
+    top:16px;
+    left:15px;
+    _left:-40px;
+    width:30px;
+    height:30px
+}
+.layui-layer-ico1{
+    background-position:-30px 0
+}
+.layui-layer-ico2{
+    background-position:-60px 0
+}
+.layui-layer-ico3{
+    background-position:-90px 0
+}
+.layui-layer-ico4{
+    background-position:-120px 0
+}
+.layui-layer-ico5{
+    background-position:-150px 0
+}
+.layui-layer-ico6{
+    background-position:-180px 0
+}
+.layui-layer-rim{
+    border:6px solid #8D8D8D;
+    border:6px solid rgba(0,0,0,.3);
+    border-radius:5px;
+    box-shadow:none
+}
+.layui-layer-msg{
+    min-width:180px;
+    border:1px solid #D3D4D3;
+    box-shadow:none
+}
+.layui-layer-hui{
+    min-width:100px;
+    background-color:#000;
+    filter:alpha(opacity=60);
+    background-color:rgba(0,0,0,.6);
+    color:#fff;
+    border:none
+}
+.layui-layer-hui .layui-layer-content{
+    padding:12px 25px;
+    text-align:center;
+    color: white;
+}
+.layui-layer-dialog .layui-layer-padding{
+    padding:20px 20px 20px 55px;
+    text-align:left
+}
+.layui-layer-page .layui-layer-content{
+    position:relative;
+    overflow:auto
+}
+.layui-layer-iframe .layui-layer-btn,.layui-layer-page .layui-layer-btn{
+    padding-top:10px
+}
+.layui-layer-nobg{
+    background:0 0
+}
+.layui-layer-iframe iframe{
+    display:block;
+    width:100%
+}
+.layui-layer-loading{
+    border-radius:100%;
+    background:0 0;
+    box-shadow:none;
+    border:none
+}
+.layui-layer-loading .layui-layer-content{
+    width:60px;
+    height:24px;
+    background:url(loading-0.gif) no-repeat
+}
+.layui-layer-loading .layui-layer-loading1{
+    width:37px;
+    height:37px;
+    background:url(loading-1.gif) no-repeat
+}
+.layui-layer-ico16,.layui-layer-loading .layui-layer-loading2{
+    width:32px;
+    height:32px;
+    background:url(loading-2.gif) no-repeat
+}
+.layui-layer-tips{
+    background:0 0;
+    box-shadow:none;
+    border:none
+}
+.layui-layer-tips .layui-layer-content{
+    position:relative;
+    line-height:22px;
+    min-width:12px;
+    padding:8px 15px;
+    font-size:12px;
+    _float:left;
+    border-radius:2px;
+    box-shadow:1px 1px 3px rgba(0,0,0,.2);
+    background-color:#000;
+    color:#fff
+}
+.layui-layer-tips .layui-layer-close{
+    right:-2px;
+    top:-1px
+}
+.layui-layer-tips i.layui-layer-TipsG{
+    position:absolute;
+    width:0;
+    height:0;
+    border-width:8px;
+    border-color:transparent;
+    border-style:dashed;
+    *overflow:hidden
+}
+.layui-layer-tips i.layui-layer-TipsB,.layui-layer-tips i.layui-layer-TipsT{
+    left:5px;
+    border-right-style:solid;
+    border-right-color:#000
+}
+.layui-layer-tips i.layui-layer-TipsT{
+    bottom:-8px
+}
+.layui-layer-tips i.layui-layer-TipsB{
+    top:-8px
+}
+.layui-layer-tips i.layui-layer-TipsL,.layui-layer-tips i.layui-layer-TipsR{
+    top:5px;
+    border-bottom-style:solid;
+    border-bottom-color:#000
+}
+.layui-layer-tips i.layui-layer-TipsR{
+    left:-8px
+}
+.layui-layer-tips i.layui-layer-TipsL{
+    right:-8px
+}
+.layui-layer-lan[type=dialog]{
+    min-width:280px
+}
+.layui-layer-lan .layui-layer-title{
+    background:#4476A7;
+    color:#fff;
+    border:none
+}
+.layui-layer-lan .layui-layer-btn{
+    padding:5px 10px 10px;
+    text-align:right;
+    border-top:1px solid #E9E7E7
+}
+.layui-layer-lan .layui-layer-btn a{
+    background:#fff;
+    border-color:#E9E7E7;
+    color:#333
+}
+.layui-layer-lan .layui-layer-btn .layui-layer-btn1{
+    background:#C9C5C5
+}
+.layui-layer-molv .layui-layer-title{
+    background:#009f95;
+    color:#fff;
+    border:none
+}
+.layui-layer-molv .layui-layer-btn a{
+    background:#009f95;
+    border-color:#009f95
+}
+.layui-layer-molv .layui-layer-btn .layui-layer-btn1{
+    background:#92B8B1
+}
+.layui-layer-iconext{
+    background:url(icon-ext.png) no-repeat
+}
+.layui-layer-prompt .layui-layer-input{
+    display:block;
+    width:230px;
+    height:36px;
+    margin:0 auto;
+    line-height:30px;
+    padding-left:10px;
+    border:1px solid #e6e6e6;
+    color:#333
+}
+.layui-layer-prompt textarea.layui-layer-input{
+    width:300px;
+    height:100px;
+    line-height:20px;
+    padding:6px 10px
+}
+.layui-layer-prompt .layui-layer-content{
+    padding:20px
+}
+.layui-layer-prompt .layui-layer-btn{
+    padding-top:0
+}
+.layui-layer-tab{
+    box-shadow:1px 1px 50px rgba(0,0,0,.4)
+}
+.layui-layer-tab .layui-layer-title{
+    padding-left:0;
+    overflow:visible
+}
+.layui-layer-tab .layui-layer-title span{
+    position:relative;
+    float:left;
+    min-width:80px;
+    max-width:260px;
+    padding:0 20px;
+    text-align:center;
+    overflow:hidden;
+    cursor:pointer
+}
+.layui-layer-tab .layui-layer-title span.layui-this{
+    height:43px;
+    border-left:1px solid #eee;
+    border-right:1px solid #eee;
+    background-color:#fff;
+    z-index:10
+}
+.layui-layer-tab .layui-layer-title span:first-child{
+    border-left:none
+}
+.layui-layer-tabmain{
+    line-height:24px;
+    clear:both
+}
+.layui-layer-tabmain .layui-layer-tabli{
+    display:none
+}
+.layui-layer-tabmain .layui-layer-tabli.layui-this{
+    display:block
+}
+.layui-layer-photos{
+    -webkit-animation-duration:.8s;
+    animation-duration:.8s
+}
+.layui-layer-photos .layui-layer-content{
+    overflow:hidden;
+    text-align:center
+}
+.layui-layer-photos .layui-layer-phimg img{
+    position:relative;
+    width:100%;
+    display:inline-block;
+    *display:inline;
+    *zoom:1;
+    vertical-align:top
+}
+.layui-layer-imgbar,.layui-layer-imguide{
+    display:none
+}
+.layui-layer-imgnext,.layui-layer-imgprev{
+    position:absolute;
+    top:50%;
+    width:27px;
+    _width:44px;
+    height:44px;
+    margin-top:-22px;
+    outline:0;
+    blr:expression(this.onFocus=this.blur())
+}
+.layui-layer-imgprev{
+    left:10px;
+    background-position:-5px -5px;
+    _background-position:-70px -5px
+}
+.layui-layer-imgprev:hover{
+    background-position:-33px -5px;
+    _background-position:-120px -5px
+}
+.layui-layer-imgnext{
+    right:10px;
+    _right:8px;
+    background-position:-5px -50px;
+    _background-position:-70px -50px
+}
+.layui-layer-imgnext:hover{
+    background-position:-33px -50px;
+    _background-position:-120px -50px
+}
+.layui-layer-imgbar{
+    position:absolute;
+    left:0;
+    bottom:0;
+    width:100%;
+    height:32px;
+    line-height:32px;
+    background-color:rgba(0,0,0,.8);
+    background-color:#000\9;
+    filter:Alpha(opacity=80);
+    color:#fff;
+    overflow:hidden;
+    font-size:0
+}
+.layui-layer-imgtit *{
+    display:inline-block;
+    *display:inline;
+    *zoom:1;
+    vertical-align:top;
+    font-size:12px
+}
+.layui-layer-imgtit a{
+    max-width:65%;
+    overflow:hidden;
+    color:#fff
+}
+.layui-layer-imgtit a:hover{
+    color:#fff;
+    text-decoration:underline
+}
+.layui-layer-imgtit em{
+    padding-left:10px;
+    font-style:normal
+}
+@-webkit-keyframes layer-bounceOut{
+    100%{
+        opacity:0;
+        -webkit-transform:scale(.7);
+        transform:scale(.7)
+    }
+    30%{
+        -webkit-transform:scale(1.05);
+        transform:scale(1.05)
+    }
+    0%{
+        -webkit-transform:scale(1);
+        transform:scale(1)
+    }
+}
+@keyframes layer-bounceOut{
+    100%{
+        opacity:0;
+        -webkit-transform:scale(.7);
+        -ms-transform:scale(.7);
+        transform:scale(.7)
+    }
+    30%{
+        -webkit-transform:scale(1.05);
+        -ms-transform:scale(1.05);
+        transform:scale(1.05)
+    }
+    0%{
+        -webkit-transform:scale(1);
+        -ms-transform:scale(1);
+        transform:scale(1)
+    }
+}
+.layer-anim-close{
+    -webkit-animation-name:layer-bounceOut;
+    animation-name:layer-bounceOut;
+    -webkit-animation-fill-mode:both;
+    animation-fill-mode:both;
+    -webkit-animation-duration:.2s;
+    animation-duration:.2s
+}
+@media screen and (max-width:1100px){
+    .layui-layer-iframe{
+        overflow-y:auto;
+        -webkit-overflow-scrolling:touch
+    }
+}
diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-0.gif b/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-0.gif
new file mode 100644
index 0000000000000000000000000000000000000000..6f3c9539a22171cc2f12639492e346d97a9078e8
GIT binary patch
literal 5793
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
bWW^%>x7XlHV^#Q1uOX^B?ki3(VEg|7!QHuF

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-1.gif b/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-1.gif
new file mode 100644
index 0000000000000000000000000000000000000000..db3a483e4b74971fbfb1cc0fb6499852cedfe650
GIT binary patch
literal 701
zcmZ?wbhEHbRAo?Qn8?Ji_w)@mZNLBj|1&T!DE{a6a}5c0b_{Se(lcOY1PT3QVdY|A
zV$cDyff`g97?`@J^shYqmS1s(LX_+4yGox$4el*+Jm?ved2^25GBru=T^dGm#<906
za&AQCZ08H8P;Bd&{NT;vl&}c_^L4%p?g_hjB<KpSb=eisoiA+`yS^%|&b8})KEqJ9
z;%V-@${+t;2BtNdDE)AlntY<|=n3;@Gu#&cXcp%TK3Tf5oipv4W}EAE^<696tGcQJ
zklZH#bR-J{H_&~oJwW%xAY3lWz{<b{mJywz-zc&7=AF*Mpj5rKD`onI4>u{YB2<bq
z2r}?6FvHA1k`ZMPg_<EeC28itEFRgOtZiAT$AW|3>9{c>Ob}p@z~Ks3xCw+@!HClp
xtZ<(QPf3`00FNu+VbOvoEE+h73k#4LIKl$IE8t;)<_eUs!0QU6uz<M28UPBGzXAXN

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-2.gif b/release/src/router/softcenter/softcenter/res/layer/theme/default/loading-2.gif
new file mode 100644
index 0000000000000000000000000000000000000000..5bb90fd6a49107a321c35b9cee4a7b810314b51f
GIT binary patch
literal 1787
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

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/proceding.gif b/release/src/router/softcenter/softcenter/res/proceding.gif
new file mode 100644
index 0000000000000000000000000000000000000000..05b276581ad7d960174329456fd2dec572c63740
GIT binary patch
literal 1150
zcmZ?wbhEHbWMmL!*v!D7(|y)*@}<^8Z>OC3>@w?`-Lxz9`(Nj5ep0#nW%2gsvoCz@
zI`%$r(XF^u_r2%ch*)-4@jrKjZ-9bJVo4&9wz01$NKDR7Em25HP0!4;ReHaBzmh^`
zimg((sjq==fpcm`rbks#YH*cbNODznvSo^ry`6$hg;hmvL2hbEqC!P(PF}H9g{@Lz
zN`6wR6_5=Q)>l#hD=EpgRdNJLD1hvA&M!(;Fx4~FO*SwzQ82gEGc+|cu`tw8FfuSS
z);BQLH#F8YG_o?Vv@$eRfC43;ZAB?*RzWUqP`iLUTcwPWk^(Dz{qpj1y>er{{GxPy
zLrY6beFGzXBO_g)3f<z$ypqHU-MnIDm<cYa#mPmP1tppJc?uvC6O-~wOKg>ZE`@j@
zw*YQzUa=n7J9^3ax%w4}1^R}11|ToN6#Dw&SDKp(S6y5Zl!|aKR)dQ}DhpEegHnt0
zON)|Ify$LZRuxz|7o{ea<QIkH=jXseF(4zqB)>Q#zd*s+SwSN_GcP5-yjT;g+}GF2
zGq1QLF)umQ)5TT^Xn<a3W{Q=mqot#TiLr~ho11~5p{uE-vx%jPo1vMBg{h;HrK>4S
zuS<S%X>Mv>2~2MaLa!@My`YqkTL84#CABECEH%ZgC_h&L>|?7;+-`BgX&zK>3U0SJ
z<J7AUbc{YIUXkJ%CIn18ASOK30y*$>pPC0u>_xy-&G`S{-#@>9{rvI$+t)9jKYjf0
z{@vR*uV1}<@%-7-CyyUJd~pBX-8;8$-Mn%A+SMzUFI~KF{@mF!r%#<cas1fPBZm(i
zJg|S?-aWf_?cA|_+tw|cH*MUoe%;zNt5>aDv3%LmC5sm=Trhv$+&Qyn&73iP+SDnN
zCrzBt-`CsI-PPIA-qzaE+|<}mUsqdGT~%38URGLCTvS+)pO>4Hot2r9o|c-DoRpXl
z9~T=F9Tgc79u^uB926Mf@8|2|?d9p=?&j*^?BwWRZ)a;`ZDna;Zf0s?Y-DJlucxb{
zt);1<uBNJ@tfZ(QFDEM_EhQ--E+#4>EF>tv&&SKd&Be*V&c@2Z%*4pRp!k!80R(hF
d1gLmnU=avdX*kV5W9~J%Vi!Rc1_4F}YXE^jo}d5#

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/res/softcenter.css b/release/src/router/softcenter/softcenter/res/softcenter.css
new file mode 100644
index 0000000000..e3025dea6d
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/softcenter.css
@@ -0,0 +1,64 @@
+/*  For software center  */
+.KoolshareBottom {
+	width: 205px;
+	height: 100px;
+	background: url(/res/koolshare.png) 0px 3px no-repeat;
+	text-align: left;
+	padding-left:150px;
+	padding-top:7px;
+	margin-top:20px;
+	float:right;
+}
+
+.input_ss_table{
+	margin-left:2px;
+	padding-left:0.4em;
+	height:21px;
+	width:158.2px;
+	line-height:23px \9;	/*IE*/
+	font-size:13px;
+	font-family: Lucida Console;
+	background-image:none;
+	background-color: #576d73;
+	border:1px solid gray;
+	color:#FFFFFF;
+}
+
+.FormTitle i {
+    color: #FC0;
+    font-style: normal;
+}
+.FormTitle em {
+    color: #00ffe4;
+    font-style: normal;
+}
+.FormTitle b {
+    color: #1cfe16;
+    font-style: normal;
+	font-weight:normal;
+}
+.FormTitle_firefox i {
+    color: #FC0;
+    font-style: normal;
+}
+.FormTitle_firefox em {
+    color: #00ffe4;
+    font-style: normal;
+}
+.FormTitle_firefox b {
+    color: #1cfe16;
+    font-style: normal;
+	font-weight:normal;
+}
+.IE8HACK{
+	display: none \9;
+}
+.splitLine{
+	background: #32393B;
+	background: -webkit-linear-gradient(#32393B 0%, #32393B 20%, #667881 80%, #667881 100%);
+	background: -o-linear-gradient(#32393B 0%, #32393B 20%, #667881 80%, #667881 100%);
+	background: linear-gradient(#32393B 0%, #32393B 20%, #667881 80%,#667881 100%);
+	height: 2px;
+	width: 740px;
+	margin: 1px 0;
+}
diff --git a/release/src/router/softcenter/softcenter/res/softcenter.js b/release/src/router/softcenter/softcenter/res/softcenter.js
new file mode 100644
index 0000000000..5cf0d9e7bf
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/res/softcenter.js
@@ -0,0 +1,131 @@
+function E(e) {
+	return (typeof(e) == 'string') ? document.getElementById(e) : e;
+}
+
+function done_validating() {
+	return true;
+}
+
+
+function reload_Soft_Center() {
+	location.href = "/Module_Softcenter.asp";
+}
+
+String.prototype.replaceAll = function(s1,s2){
+　　return this.replace(new RegExp(s1,"gm"),s2);
+}
+
+String.prototype.format = String.prototype.f = function() {
+	var s = this,
+		i = arguments.length;
+	while (i--) {
+		s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
+	}
+	return s;
+};
+String.prototype.capitalizeFirstLetter = function() {
+	return this.charAt(0).toUpperCase() + this.slice(1);
+}
+
+var Base64;
+if (typeof btoa == "Function") {
+	Base64 = {
+		encode: function(e) {
+			return btoa(e);
+		},
+		decode: function(e) {
+			return atob(e);
+		}
+	};
+} else {
+	Base64 = {
+		_keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
+		encode: function(e) {
+			var t = "";
+			var n, r, i, s, o, u, a;
+			var f = 0;
+			e = Base64._utf8_encode(e);
+			while (f < e.length) {
+				n = e.charCodeAt(f++);
+				r = e.charCodeAt(f++);
+				i = e.charCodeAt(f++);
+				s = n >> 2;
+				o = (n & 3) << 4 | r >> 4;
+				u = (r & 15) << 2 | i >> 6;
+				a = i & 63;
+				if (isNaN(r)) {
+					u = a = 64
+				} else if (isNaN(i)) {
+					a = 64
+				}
+				t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)
+			}
+			return t
+		},
+		decode: function(e) {
+			var t = "";
+			var n, r, i;
+			var s, o, u, a;
+			var f = 0;
+			e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
+			while (f < e.length) {
+				s = this._keyStr.indexOf(e.charAt(f++));
+				o = this._keyStr.indexOf(e.charAt(f++));
+				u = this._keyStr.indexOf(e.charAt(f++));
+				a = this._keyStr.indexOf(e.charAt(f++));
+				n = s << 2 | o >> 4;
+				r = (o & 15) << 4 | u >> 2;
+				i = (u & 3) << 6 | a;
+				t = t + String.fromCharCode(n);
+				if (u != 64) {
+					t = t + String.fromCharCode(r)
+				}
+				if (a != 64) {
+					t = t + String.fromCharCode(i)
+				}
+			}
+			t = Base64._utf8_decode(t);
+			return t
+		},
+		_utf8_encode: function(e) {
+			e = e.replace(/\r\n/g, "\n");
+			var t = "";
+			for (var n = 0; n < e.length; n++) {
+				var r = e.charCodeAt(n);
+				if (r < 128) {
+					t += String.fromCharCode(r)
+				} else if (r > 127 && r < 2048) {
+					t += String.fromCharCode(r >> 6 | 192);
+					t += String.fromCharCode(r & 63 | 128)
+				} else {
+					t += String.fromCharCode(r >> 12 | 224);
+					t += String.fromCharCode(r >> 6 & 63 | 128);
+					t += String.fromCharCode(r & 63 | 128)
+				}
+			}
+			return t
+		},
+		_utf8_decode: function(e) {
+			var t = "";
+			var n = 0;
+			var r = c1 = c2 = 0;
+			while (n < e.length) {
+				r = e.charCodeAt(n);
+				if (r < 128) {
+					t += String.fromCharCode(r);
+					n++
+				} else if (r > 191 && r < 224) {
+					c2 = e.charCodeAt(n + 1);
+					t += String.fromCharCode((r & 31) << 6 | c2 & 63);
+					n += 2
+				} else {
+					c2 = e.charCodeAt(n + 1);
+					c3 = e.charCodeAt(n + 2);
+					t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
+					n += 3
+				}
+			}
+			return t
+		}
+	}
+}
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/res/upgrade.png b/release/src/router/softcenter/softcenter/res/upgrade.png
new file mode 100755
index 0000000000000000000000000000000000000000..7cfef8271a87b100ba225a6156fd294142d26f53
GIT binary patch
literal 14302
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
R|GjaiAfqB(DQOz^{{RPU1dIRx

literal 0
HcmV?d00001

diff --git a/release/src/router/softcenter/softcenter/scripts/base.sh b/release/src/router/softcenter/softcenter/scripts/base.sh
new file mode 100755
index 0000000000..4db71be66a
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/scripts/base.sh
@@ -0,0 +1,14 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+export PERP_BASE=$KSROOT/perp
+export PATH=$KSROOT/bin:$KSROOT/scripts:$PATH
+
+ACTION=$1
+ID=$1
+export LANIP=127.0.0.1
+
+http_response()  {
+    ARG0="$@"
+    curl -X POST -d "$ARG0" http://$LANIP/_resp/$ID
+}
diff --git a/release/src/router/softcenter/softcenter/scripts/dummy_script.sh b/release/src/router/softcenter/softcenter/scripts/dummy_script.sh
new file mode 100755
index 0000000000..f2b68521c5
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/scripts/dummy_script.sh
@@ -0,0 +1,5 @@
+#!/bin/sh
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+http_response "$1"
\ No newline at end of file
diff --git a/release/src/router/softcenter/softcenter/scripts/ks_app_install.sh b/release/src/router/softcenter/softcenter/scripts/ks_app_install.sh
new file mode 100755
index 0000000000..8e2c66861a
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/scripts/ks_app_install.sh
@@ -0,0 +1,285 @@
+#!/bin/sh
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+
+
+#From dbus to local variable
+eval $(dbus export softcenter_installing_)
+source /koolshare/scripts/base.sh
+export PERP_BASE=/koolshare/perp
+
+#softcenter_installing_module 	#正在安装的模块
+#softcenter_installing_todo 	#希望安装的模块
+#softcenter_installing_tick 	#上次安装开始的时间
+#softcenter_installing_version 	#正在安装的版本
+#softcenter_installing_md5 	#正在安装的版本的md5值
+#softcenter_installing_tar_url 	#模块对应的下载地址
+
+#softcenter_installing_status=		#尚未安装
+#softcenter_installing_status=0		#尚未安装
+#softcenter_installing_status=1		#已安装
+#softcenter_installing_status=2		#将被安装到jffs分区...
+#softcenter_installing_status=3		#正在下载中...请耐心等待...
+#softcenter_installing_status=4		#正在安装中...
+#softcenter_installing_status=5		#安装成功！请5秒后刷新本页面！...
+#softcenter_installing_status=6		#卸载中......
+#softcenter_installing_status=7		#卸载成功！
+#softcenter_installing_status=8		#没有检测到在线版本号！
+#softcenter_installing_status=9		#正在下载更新......
+#softcenter_installing_status=10	#正在安装更新...
+#softcenter_installing_status=11	#安装更新成功，5秒后刷新本页！
+#softcenter_installing_status=12	#下载文件校验不一致！
+#softcenter_installing_status=13	#然而并没有更新！
+#softcenter_installing_status=14	#正在检查是否有更新~
+#softcenter_installing_status=15	#检测更新错误！
+#softcenter_installing_status=16	#下载错误，代码：！
+#softcenter_installing_status=17	#卸载失败！请关闭插件后重试！
+
+softcenter_home_url=$(dbus get softcenter_home_url)
+CURR_TICK=$(date +%s)
+BIN_NAME=$(basename "$0")
+BIN_NAME="${BIN_NAME%.*}"
+if [ "$ACTION" != "" ]; then
+	BIN_NAME=$ACTION
+fi
+
+if [ "$(nvram get model)" == "GT-AC5300" ] || [ "$(nvram get model)" == "GT-AX11000" ] || [ -n "$(nvram get extendno | grep koolshare)" -a "$(nvram get productid)" == "RT-AC86U" ];then
+	ROG=1
+fi
+
+LOGGER() {
+#	echo $1
+	logger $1
+}
+
+install_module() {
+	if [ "${softcenter_home_url}" = "" -o "${softcenter_installing_md5}" = "" -o "${softcenter_installing_version}" = "" ]; then
+		LOGGER "【软件中心】input error, something not found"
+		exit 1
+	fi
+
+	if [ "${softcenter_installing_tick}" = "" ]; then
+		export softcenter_installing_tick=0
+	fi
+	LAST_TICK=$(expr ${softcenter_installing_tick} + 20)
+	if [ "${LAST_TICK}" -ge "${CURR_TICK}" -a "${softcenter_installing_module}" != "" ]; then
+		LOGGER "【软件中心】module ${softcenter_installing_module} is installing"
+		exit 2
+	fi
+
+	if [ "${softcenter_installing_todo}" = "" ]; then
+		#curr module name not found
+		LOGGER "【软件中心】module name not found"
+		exit 3
+	fi
+
+	# Just ignore the old installing_module
+	export softcenter_installing_module=${softcenter_installing_todo}
+	export softcenter_installing_tick=$(date +%s)
+	dbus set softcenter_installing_status="2"
+	sleep 1
+	dbus save softcenter_installing_
+
+	URL_SPLIT="/"
+	#OLD_MD5=$(dbus get softcenter_module_${softcenter_installing_module_md5})
+	OLD_VERSION=$(dbus get softcenter_module_${softcenter_installing_module}_version)
+	HOME_URL=$(dbus get softcenter_home_url)
+	TAR_URL=${HOME_URL}${URL_SPLIT}${softcenter_installing_tar_url}
+	FNAME=$(basename ${softcenter_installing_tar_url})
+
+	if [ "$OLD_VERSION" = "" ]; then
+		OLD_VERSION=0
+	fi
+
+	CMP=$(versioncmp ${softcenter_installing_version} ${OLD_VERSION})
+	if [ -f "/koolshare/webs/Module_${softcenter_installing_module}.sh" -o "${softcenter_installing_todo}" = "softcenter" ]; then
+		CMP="-1"
+	fi
+	if [ "$CMP" = "-1" ]; then
+
+	cd /tmp
+	rm -f ${FNAME}
+	rm -rf "/tmp/$softcenter_installing_module"
+	dbus set softcenter_installing_status="3"
+	sleep 1
+	wget -t 2 -T 20 --dns-timeout=15 --no-check-certificate -q ${TAR_URL}
+	RETURN_CODE=$?
+
+	if [ "$RETURN_CODE" != "0" ]; then
+		dbus set softcenter_installing_status="16"
+		sleep 3
+		dbus set softcenter_installing_status="0"
+		dbus set softcenter_installing_module=""
+		dbus set softcenter_installing_todo=""
+		LOGGER "【软件中心】wget ${TAR_URL} error, ${RETURN_CODE}"
+		exit ${RETURN_CODE}
+	fi
+
+	md5sum_gz=$(md5sum /tmp/${FNAME} | sed 's/ /\n/g'| sed -n 1p)
+	if [ "$md5sum_gz"x != "$softcenter_installing_md5"x ]; then
+		LOGGER "【软件中心】md5 not equal $md5sum_gz"
+		dbus set softcenter_installing_status="12"
+		rm -f ${FNAME}
+		sleep 3
+
+		dbus set softcenter_installing_status="0"
+		dbus set softcenter_installing_module=""
+		dbus set softcenter_installing_todo=""
+
+		rm -f ${FNAME}
+		rm -rf "/tmp/$softcenter_installing_module"
+		exit
+	else
+		tar -zxf ${FNAME}
+		dbus set softcenter_installing_status="4"
+
+		if [ ! -f /tmp/${softcenter_installing_module}/install.sh ]; then
+			dbus set softcenter_installing_status="0"
+			dbus set softcenter_installing_module=""
+			dbus set softcenter_installing_todo=""
+
+			#rm -f ${FNAME}
+			#rm -rf "/tmp/${softcenter_installing_module}"
+
+			LOGGER "【软件中心】package hasn't install.sh"
+			exit 5
+		fi
+
+		if [ -f /tmp/${softcenter_installing_module}/uninstall.sh ]; then
+			chmod 755 /tmp/${softcenter_installing_module}/uninstall.sh
+			mv /tmp/${softcenter_installing_module}/uninstall.sh /koolshare/scripts/uninstall_${softcenter_installing_todo}.sh
+		fi
+
+		if [ -d /tmp/${softcenter_installing_module}/GT-AC5300 -a "$ROG" == "1" ]; then
+			cp -rf /tmp/${softcenter_installing_module}/GT-AC5300/* /tmp/${softcenter_installing_module}/
+		fi
+
+		if [ -d /tmp/${softcenter_installing_module}/ROG -a "$ROG" == "1" ]; then
+			cp -rf /tmp/${softcenter_installing_module}/ROG/* /tmp/${softcenter_installing_module}/
+		fi
+
+		chmod a+x /tmp/${softcenter_installing_module}/install.sh
+		sh /tmp/${softcenter_installing_module}/install.sh
+		sleep 3
+
+		rm -f ${FNAME}
+		rm -rf "/tmp/$softcenter_installing_module"
+
+		if [ "$softcenter_installing_module" != "softcenter" ]; then
+			dbus set softcenter_module_${softcenter_installing_module}_md5=${softcenter_installing_md5}
+			dbus set softcenter_module_${softcenter_installing_module}_version=${softcenter_installing_version}
+			dbus set softcenter_module_${softcenter_installing_module}_install=1
+			dbus set ${softcenter_installing_module}_version=${softcenter_installing_version}
+		else
+			dbus set softcenter_version=${softcenter_installing_version};
+			dbus set softcenter_md5=${softcenter_installing_md5}
+		fi
+		dbus set softcenter_installing_module=""
+		dbus set softcenter_installing_todo=""
+		dbus set softcenter_installing_status="1"
+	fi
+
+	else
+		LOGGER "【软件中心】current version is newest version"
+		dbus set softcenter_installing_status="13"
+		sleep 3
+
+		dbus set softcenter_installing_status="0"
+		dbus set softcenter_installing_module=""
+		dbus set softcenter_installing_todo=""
+	fi
+}
+
+uninstall_module() {
+	if [ "${softcenter_installing_tick}" = "" ]; then
+		export softcenter_installing_tick=0
+	fi
+	LAST_TICK=$(expr ${softcenter_installing_tick} + 20)
+	if [ "${LAST_TICK}" -ge "${CURR_TICK}" -a "${softcenter_installing_module}" != "" ]; then
+		LOGGER "【软件中心】module ${softcenter_installing_module} is installing"
+		exit 2
+	fi
+
+	if [ "${softcenter_installing_todo}" = "" -o "${softcenter_installing_todo}" = "softcenter" ]; then
+		#curr module name not found
+		LOGGER "【软件中心】module name not found"
+		exit 3
+	fi
+
+	local ENABLED=$(dbus get ${softcenter_installing_todo}_enable)
+	if [ "${ENABLED}" == "1" ]; then
+		LOGGER "【软件中心】please disable ${softcenter_installing_module} then try again"
+		dbus set softcenter_installing_status="17"
+		sleep 3
+		dbus set softcenter_installing_status="0"
+		exit 4
+	fi
+
+	# Just ignore the old installing_module
+	export softcenter_installing_module=${softcenter_installing_todo}
+	export softcenter_installing_tick=$(date +%s)
+	export softcenter_installing_status="6"
+	dbus save softcenter_installing_
+
+	dbus remove softcenter_module_${softcenter_installing_module}_md5
+	dbus remove softcenter_module_${softcenter_installing_module}_version
+	dbus remove softcenter_module_${softcenter_installing_module}_install
+	dbus remove softcenter_module_${softcenter_installing_module}_description
+	dbus remove softcenter_module_${softcenter_installing_module}_name
+	dbus remove softcenter_module_${softcenter_installing_module}_title
+
+	txt=$(dbus list ${softcenter_installing_todo})
+	printf "%s\n" "$txt" |
+	while IFS= read -r line; do
+		line2="${line%=*}"
+		if [ "${line2}" != "" ]; then
+			dbus remove ${line2}
+		fi
+	done
+
+	sleep 3
+	dbus set softcenter_installing_module=""
+	dbus set softcenter_installing_status="7"
+	dbus set softcenter_installing_todo=""
+
+	#try to call uninstall script
+	if [ -f /koolshare/scripts/${softcenter_installing_todo}_uninstall.sh]; then
+ 		sh /koolshare/scripts/${softcenter_installing_todo}_uninstall.sh
+	elif [ -f "/koolshare/scripts/uninstall_${softcenter_installing_todo}.sh" ]; then
+		sh /koolshare/scripts/uninstall_${softcenter_installing_todo}.sh
+	else
+		if [ -n "${softcenter_installing_todo}" ]; then
+			rm -rf /koolshare/${softcenter_installing_todo}
+			rm -rf /koolshare/bin/${softcenter_installing_todo}
+			rm -rf /koolshare/init.d/*${softcenter_installing_todo}*
+			rm -rf /koolshare/scripts/${softcenter_installing_todo}*.sh
+			rm -rf /koolshare/res/icon-${softcenter_installing_todo}.png
+			rm -rf /koolshare/webs/Module_${softcenter_installing_todo}.asp
+		fi
+	fi
+}
+
+#LOGGER $BIN_NAME
+case $2 in
+update)
+	http_response $1
+	install_module
+	;;
+install)
+	http_response $1
+	install_module
+	;;
+ks_app_install)
+	http_response $1
+	install_module
+	;;
+ks_app_remove)
+	http_response $1
+	uninstall_module
+	;;
+*)
+	http_response $1
+	install_module
+	;;
+esac
diff --git a/release/src/router/softcenter/softcenter/scripts/ks_tar_install.sh b/release/src/router/softcenter/softcenter/scripts/ks_tar_install.sh
new file mode 100755
index 0000000000..40fead916f
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/scripts/ks_tar_install.sh
@@ -0,0 +1,153 @@
+#!/bin/sh
+
+# for hnd platform
+
+export KSROOT=/koolshare
+source $KSROOT/scripts/base.sh
+alias echo_date='echo 【$(date +%Y年%m月%d日\ %X)】:'
+eval `dbus export soft`
+TARGET_DIR=/tmp/upload
+if [ "`nvram get model`" == "GT-AC5300" ] || [ "`nvram get model`" == "GT-AX11000" ] || [ -n "`nvram get extendno | grep koolshare`" -a "`nvram get productid`" == "RT-AC86U" ];then
+	ROG=1
+fi
+
+clean(){
+	[ -n "$name" ] && rm -rf /tmp/$name >/dev/null 2>&1
+	[ -n "$MODULE_NAME" ] && rm -rf /tmp/$MODULE_NAME >/dev/null 2>&1
+	[ -n "$soft_name" ] && rm -rf /tmp/$soft_name >/dev/null 2>&1
+	rm -rf /tmp/*.tar.gz >/dev/null 2>&1
+	dbus remove soft_install_version
+	dbus remove soft_name
+}
+
+install_tar(){
+	name=`echo "$soft_name"|sed 's/.tar.gz//g'|awk -F "_" '{print $1}'|awk -F "-" '{print $1}'`
+	INSTALL_SUFFIX=_install
+	VER_SUFFIX=_version
+	NAME_SUFFIX=_name
+	cd /tmp
+	echo_date ====================== step 1 ===========================
+	echo_date 开启软件离线安装！
+	if [ -f $TARGET_DIR/$soft_name ];then
+		local _SIZE=$(ls -lh $TARGET_DIR/$soft_name|awk '{print $5}')
+		echo_date $TARGET_DIR目录下检测到上传的离线安装包$soft_name，大小：$_SIZE
+		mv /tmp/upload/$soft_name /tmp
+		echo_date 尝试解压离线安装包离线安装包
+		tar -zxvf $soft_name >/dev/null 2>&1
+		if [ "$?" == "0" ];then
+			echo_date 解压完成！
+			cd /tmp
+		else
+			echo_date 解压错误，错误代码："$?"！
+			echo_date 估计是错误或者不完整的的离线安装包！
+			echo_date 删除相关文件并退出...
+			clean
+			dbus remove "softcenter_module_$MODULE_NAME$INSTALL_SUFFIX"
+			echo_date ======================== end ============================
+			echo XU6J03M6
+			exit
+		fi
+
+		if [ -f "/tmp/$name/.valid" ] && [ "`cat /tmp/$name/.valid`" == "arm384" ];then
+			continue
+		else
+			echo_date 你上传的离线安装包不是arm384平台的离线包！！！
+			echo_date 请上传正确的离线安装包！！！
+			echo_date 删除相关文件并退出...
+			clean
+			dbus remove "softcenter_module_$MODULE_NAME$INSTALL_SUFFIX"
+			echo_date ======================== end ============================
+			echo XU6J03M6
+			exit		
+		fi
+		
+		if [ -f /tmp/$name/install.sh ];then
+			INSTALL_SCRIPT=/tmp/$name/install.sh
+		else
+			INSTALL_SCRIPT_NU=`find /tmp -name "install.sh"|wc -l` 2>/dev/null
+			[ "$INSTALL_SCRIPT_NU" == "1" ] && INSTALL_SCRIPT=`find /tmp -name "install.sh"` || INSTALL_SCRIPT=""
+		fi
+
+		if [ -n "$INSTALL_SCRIPT" -a -f "$INSTALL_SCRIPT" ];then
+			SCRIPT_AB_DIR=`dirname $INSTALL_SCRIPT`
+			MODULE_NAME=${SCRIPT_AB_DIR##*/}
+			echo_date 准备安装$MODULE_NAME插件！
+			echo_date 找到安装脚本！
+			chmod +x $INSTALL_SCRIPT >/dev/null 2>&1
+			echo_date 运行安装脚本...
+			echo_date ====================== step 2 ===========================
+
+			if [ -d /tmp/$MODULE_NAME/GT-AC5300 -a "$ROG" == "1" ]; then
+				cp -rf /tmp/$MODULE_NAME/GT-AC5300/* /tmp/$MODULE_NAME/
+			fi
+
+			if [ -d /tmp/$MODULE_NAME/ROG -a "$ROG" == "1" ]; then
+				cp -rf /tmp/$MODULE_NAME/ROG/* /tmp/$MODULE_NAME/
+			fi
+			
+			sleep 1
+			start-stop-daemon -S -q -x $INSTALL_SCRIPT 2>&1
+			if [ "$?" != "0" ];then
+				echo_date 因为$MODULE_NAME插件安装失败！退出离线安装！
+				clean
+				dbus remove "softcenter_module_$MODULE_NAME$INSTALL_SUFFIX"
+				echo_date ======================== end ============================
+				echo XU6J03M6
+				exit
+			fi
+			echo_date ====================== step 3 ===========================
+			dbus set "softcenter_module_$MODULE_NAME$NAME_SUFFIX=$MODULE_NAME"
+			dbus set "softcenter_module_$MODULE_NAME$INSTALL_SUFFIX=1"
+			if [ -n "$soft_install_version" ];then
+				dbus set "softcenter_module_$MODULE_NAME$VER_SUFFIX=$soft_install_version"
+				echo_date "从插件文件名中获取到了版本号：$soft_install_version"
+			else
+				if [ -z "`dbus get softcenter_module_$MODULE_NAME$VER_SUFFIX`" ];then
+					dbus set "softcenter_module_$MODULE_NAME$VER_SUFFIX=0.1"
+					echo_date "插件安装脚本里没有找到版本号，设置默认版本号为0.1"
+				else
+					echo_date "插件安装脚本已经设置了插件版本号为：`dbus get softcenter_module_$MODULE_NAME$VER_SUFFIX`"
+				fi
+			fi
+			install_pid=`ps | grep -w install.sh | grep -v grep | awk '{print $1}'`
+			i=120
+			until [ -z "$install_pid" ]
+			do
+				install_pid=`ps | grep -w install.sh | grep -v grep | awk '{print $1}'`
+				i=$(($i-1))
+				if [ "$i" -lt 1 ];then
+					echo_date "Could not load nat rules!"
+					echo_date 安装似乎出了点问题，请手动重启路由器后重新尝试...
+					echo_date 删除相关文件并退出...
+					sleep 1
+					clean
+					dbus remove "softcenter_module_$MODULE_NAME$INSTALL_SUFFIX"
+					echo_date ======================== end ============================
+					echo XU6J03M6
+					exit
+				fi
+				sleep 1
+			done
+			echo_date 离线包安装完成！
+			echo_date 一点点清理工作...
+			clean
+			echo_date 完成！离线安装插件成功，现在你可以退出本页面~
+		else
+			echo_date 没有找到安装脚本！
+			echo_date 删除相关文件并退出...
+			clean
+		fi
+	else
+		echo_date 没有找到离线安装包！
+		echo_date 删除相关文件并退出...
+		clean
+	fi
+	clean
+	echo_date ======================== end ============================
+	echo XU6J03M6
+}
+
+echo " " > /tmp/upload/soft_log.txt
+http_response "$1"
+install_tar > /tmp/upload/soft_log.txt
+
diff --git a/release/src/router/softcenter/softcenter/webs/Module_Softcenter.asp b/release/src/router/softcenter/softcenter/webs/Module_Softcenter.asp
new file mode 100644
index 0000000000..0eb7c27868
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/webs/Module_Softcenter.asp
@@ -0,0 +1,752 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="X-UA-Compatible" content="IE=Edge">
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+<meta HTTP-EQUIV="Pragma" CONTENT="no-cache">
+<meta HTTP-EQUIV="Expires" CONTENT="-1">
+<link rel="shortcut icon" href="images/favicon.png">
+<link rel="icon" href="images/favicon.png">
+<title>Merlin software center</title>
+<link rel="stylesheet" type="text/css" href="index_style.css">
+<link rel="stylesheet" type="text/css" href="form_style.css">
+<link rel="stylesheet" type="text/css" href="/res/softcenter.css">
+<link rel="stylesheet" type="text/css" href="/res/layer/theme/default/layer.css">
+<script language="JavaScript" type="text/javascript" src="/state.js"></script>
+<script language="JavaScript" type="text/javascript" src="/help.js"></script>
+<script language="JavaScript" type="text/javascript" src="/general.js"></script>
+<script language="JavaScript" type="text/javascript" src="/popup.js"></script>
+<script language="JavaScript" type="text/javascript" src="/client_function.js"></script>
+<script language="JavaScript" type="text/javascript" src="/validator.js"></script>
+<script type="text/javascript" src="/js/jquery.js"></script>
+<script type="text/javascript" src="/general.js"></script>
+<script type="text/javascript" src="/switcherplugin/jquery.iphone-switch.js"></script>
+<script type="text/javascript" src="/res/softcenter.js"></script>
+<script type="text/javascript" src="/form.js"></script>
+<style>
+.cloud_main_radius_left {
+	-webkit-border-radius: 10px 0 0 10px;
+	-moz-border-radius: 10px 0 0 10px;
+	border-radius: 10px 0 0 10px;
+}
+.cloud_main_radius_right {
+	-webkit-border-radius: 0 10px 10px 0;
+	-moz-border-radius: 0 10px 10px 0;
+	border-radius: 0 10px 10px 0;
+}
+.cloud_main_radius {
+	-webkit-border-radius: 10px;
+	-moz-border-radius: 10px;
+	border-radius: 10px;
+}
+/* 软件中心icon新样式 by acelan */
+ dl, dt, dd {
+	padding:0;
+	margin:0;
+}
+input[type=button]:focus {
+	outline: none;
+}
+.icon {
+	float:left;
+	position:relative;
+	margin: 10px 0px 30px 0px;
+}
+.icon-title {
+	line-height: 3em;
+	text-align:center;
+}
+.icon-pic {
+	margin: 10px 30px 0px 30px;
+}
+.icon-pic img {
+	border:0;
+	width: 60px;
+	height: 60px;
+	margin:2px;
+}
+.icon-desc {
+	position: absolute;
+	left: 0;
+	top: 0;
+	height: 105%;
+	visibility: hidden;
+	font-size:0;
+	width: 119px;
+	border-radius: 8px;
+	font-size: 16px;
+	opacity: 0;
+	background-color:#000;
+	margin:5px;
+	text-overflow:ellipsis;
+	transition: opacity .5s ease-in;
+}
+.icon-desc .text {
+	font-size: 12px;
+	line-height: 1.4em;
+	display: block;
+	height: 100%;
+	padding: 10px;
+	box-sizing: border-box;
+}
+.icon:hover .icon-desc {
+	opacity: .8;
+	visibility: visible;
+}
+.icon-desc .opt {
+	position: absolute;
+	bottom: 0;
+	height: 18px;
+	width: 100%;
+}
+.install-status-0 .icon-desc .opt {
+	height: 100%;
+}
+.icon-desc .install-btn, .icon-desc .uninstall-btn, .icon-desc .update-btn {
+	background: #fff;
+	color:#333;
+	cursor:pointer;
+	text-align: center;
+	font-size: 13px;
+	padding-bottom: 5px;
+	margin-left: 10px;
+	margin-right: 10px;
+	display: block;
+	width: 100%;
+	height: 18px;
+	border-radius: 0px 0px 5px 5px;
+	border: 0px;
+	position: absolute;
+	bottom: 0;
+	left: -10px;
+}
+.icon-desc .uninstall-btn {
+	display: none;
+}
+.icon-desc .update-btn {
+	display: none;
+	border-radius: 0px 0px 0px 5px;
+	width:60%;
+	border-right: 1px solid #000;
+}
+.show-install-btn, .show-uninstall-btn {
+	border: none;
+	background: #444;
+	color: #fff;
+	padding: 10px 20px;
+	border-radius: 5px 5px 0px 0px;
+}
+.active {
+	background: #444f53;
+}
+.install-status-1 .uninstall-btn {
+	display: block;
+}
+.install-status-1 .install-btn {
+	display: none;
+}
+.update-btn {
+	display: none;
+}
+.install-status-1 .update-btn {
+	display: none;
+}
+.install-status-4 .uninstall-btn {
+	display: block;
+}
+.install-status-4 .install-btn {
+	display: none;
+}
+.install-status-4 .update-btn {
+	display: none;
+}
+.install-status-2 .uninstall-btn {
+	display: block;
+	width: 40%;
+	border-radius: 0px 0px 5px 0px;
+	right: -10px;
+	left: auto;
+	border-left: 1px solid #000;
+}
+.install-status-2 .install-btn {
+	display: none;
+}
+.install-status-2 .update-btn {
+	display: block;
+}
+.install-status-1 {
+	display: none;
+}
+.install-status-2 {
+	display: none;
+}
+.install-status-0 {
+	display: block;
+}
+.install-status-4 {
+	display: none;
+}
+.install-view .install-status-1 {
+	display: block;
+}
+.install-view .install-status-2 {
+	display: block;
+}
+.install-view .install-status-0 {
+	display: none;
+}
+.install-view .install-status-4 {
+	display: block;
+}
+.cloud_main_radius h2 {
+	border-bottom:1px #AAA dashed;
+	height:32px;
+	margin-top:15px;
+	margin-bottom:15px;
+}
+.cloud_main_radius h3, .cloud_main_radius h4 {
+	font-size:12px;
+	color:#FC0;
+	font-weight:normal;
+	font-style: normal;
+	margin-top:12px;
+	margin-bottom:12px;
+}
+.cloud_main_radius h5 {
+	color:#FFF;
+	font-weight:normal;
+	font-style: normal;
+	margin-top:9px;
+	margin-bottom:9x;
+}
+</style>
+<script>
+var db_softcenter_ = {};
+var TIMEOUT_SECONDS = 18;
+var softInfo = null;
+var syncRemoteSuccess = 0; //判断是否进入页面后已经成功进行远端同步
+var currState = {
+	"installing": false,
+	"lastChangeTick": 0,
+	"lastStatus": "-1",
+	"module": ""
+};
+function checkField(o, f, d) {
+	if (typeof o[f] == "undefined") {
+		o[f] = d;
+	}
+
+	return o[f];
+}
+function appPostScript(moduleInfo, script) {
+	if (currState.installing) {
+		console.log("current is in installing state");
+		return;
+	}
+	//Current page must has prefix of "Module_"
+	var data = {};
+	//currState.name = moduleInfo.name;
+	//TODO auto choose for home_url
+	data["softcenter_home_url"] = "https://armsoft.ddnsto.com";
+	data["softcenter_installing_todo"] = moduleInfo.name;
+	if (script == "ks_app_install.sh") {
+		data["softcenter_installing_tar_url"] = moduleInfo.tar_url;
+		data["softcenter_installing_md5"] = moduleInfo.md5;
+		data["softcenter_installing_version"] = moduleInfo.version;
+		//Update title for this module
+		data[moduleInfo.name + "_title"] = moduleInfo.title;
+		action = "ks_app_install";
+	} else if (script == "ks_app_remove.sh") {
+		action = "ks_app_remove";
+	}
+	var id = parseInt(Math.random() * 100000000);
+	var postData = {
+		"id": id,
+		"method": script,
+		"params": [action],
+		"fields": data
+	};
+	$.ajax({
+		type: "POST",
+		url: "/_api/",
+		data: JSON.stringify(postData),
+		dataType: "json",
+		success: function(response) {
+			var d = new Date();
+			//持续更新
+			currState.lastChangeTick = d / 1000 + TIMEOUT_SECONDS;
+			currState.installing = true;
+			showInstallStatus(true);
+		},
+		error: function() {
+			currState.installing = false;
+		}
+	});
+}
+function appInstallModule(moduleInfo) {
+	appPostScript(moduleInfo, "ks_app_install.sh");
+}
+function appUninstallModule(moduleInfo) {
+	if (!window.confirm('确定卸载吗')) {
+		return;
+	}
+	appPostScript(moduleInfo, "ks_app_remove.sh");
+}
+function initInstallStatus() {
+	var o = db_softcenter_;
+	var base = "softcenter_installing_";
+	if (o[base + "status"]) {
+		//状态不是0/1/7,则当前正处于安装状态,实时更新安装信息
+		if ((o[base + "status"] != "0") && (o[base + "status"] != "1") && (o[base + "status"] != "7")) {
+			var d = new Date();
+			currState.lastChangeTick = d / 1000 + TIMEOUT_SECONDS;
+			currState.lastStatus = o[base + "status"];
+			currState.installing = true;
+			//currState.name = o[base+"module"];
+			showInstallStatus(true);
+		}
+	}
+}
+function showInstallStatus(isInit) {
+	$.ajax({
+		type: "GET",
+		url: "/_api/softcenter_installing_",
+		dataType: "json",
+		async: false,
+		success: function(resp) {
+			var o = resp.result[0];
+			var base = "softcenter_installing_";
+			console.log("status: " + o[base + "status"]);
+			if (isInit) {
+				currState.lastStatus = o[base + "status"];
+			}
+			var d = new Date();
+			var curr = d.getTime() / 1000;
+			curr_module = checkField(o, "softcenter_installing_module", "");
+			if (o[base + "status"] != currState.lastStatus) {
+				currState.lastStatus = o[base + "status"];
+				showInstallInfo(curr_module, currState.lastStatus);
+				// Install ok now
+				if (currState.lastStatus == "1" || currState.lastStatus == "7" || currState.lastStatus == "13") {
+					currState.installing = false;
+					setTimeout("window.location.reload()", 1000);
+					return;
+				} else if (currState.lastStatus == "0") {
+					currState.installing = false;
+				}
+			}
+			if (currState.lastChangeTick > curr) {
+				setTimeout("showInstallStatus()", 400);
+			} else {
+				currState.installing = false;
+				$("#appInstallInfo").html("等待超时,可尝试手动刷新");
+				//showInstallInfo("", currState.lastStatus);
+			}
+		}
+	})
+}
+function showInstallInfo(module, scode) {
+		var code = parseInt(scode);
+		var s = module.capitalizeFirstLetter();
+		var infos = [
+			"操作失败",
+			"已安装",
+			"插件将被安装到jffs分区...",
+			"正在下载中...请耐心等待...",
+			"正在安装中...",
+			"安装成功！请5秒后刷新本页面！...",
+			"卸载中......",
+			"卸载成功！",
+			"没有检测到在线版本号！",
+			"正在下载更新......",
+			"正在安装更新...",
+			"安装更新成功，5秒后刷新本页！ ",
+			"下载文件校验不一致！",
+			"然而并没有更新！",
+			"正在检查是否有更新~",
+			"检测更新错误！",
+			" wget下载错误，详情见系统日志！",
+			"卸载失败！请关闭插件后重试！"
+		];
+		document.getElementById("install_status").style.display = "";
+		$("#appInstallInfo").html(s + infos[code]);
+	}
+	//切换安装未安装面板
+function toggleAppPanel(showInstall) {
+		$('.show-install-btn').removeClass('active');
+		$('.show-uninstall-btn').removeClass('active');
+		$(showInstall ? '.show-install-btn' : '.show-uninstall-btn').addClass('active');
+		$('#IconContainer')[showInstall ? 'addClass' : 'removeClass']('install-view');
+	}
+	/**
+	 * 渲染apps，安装和未安装按照class hook进行显示隐藏，存在同一个面板中
+	 */
+function renderView(apps) {
+	// set apps to global variable of softInfo
+	softInfo = apps;
+	//console.log(softInfo);
+	//简单模板函数
+	function _format(source, opts) {
+			var source = source.valueOf(),
+				data = Array.prototype.slice.call(arguments, 1),
+				toString = Object.prototype.toString;
+			if (data.length) {
+				data = data.length == 1 ?
+					(opts !== null && (/\[object Array\]|\[object Object\]/.test(toString.call(opts))) ? opts : data) : data;
+				return source.replace(/#\{(.+?)\}/g, function(match, key) {
+					var replacer = data[key];
+					// chrome 下 typeof /a/ == 'function'
+					if ('[object Function]' == toString.call(replacer)) {
+						replacer = replacer(key);
+					}
+					return ('undefined' == typeof replacer ? '' : replacer);
+				});
+			}
+			return source;
+		}
+		//app 模板
+	var tpl = ['',
+		'<dl class="icon install-status-#{install}" data-name="#{name}">',
+		'<dd class="icon-pic">',
+		//当图标娶不到的时候，使用默认图标，如果已经是默认图标且娶不到，就狗带了，不管
+		'<img src="#{icon}" onerror="this.src.indexOf(\'icon-default.png\')===-1 && (this.src=\'/res/icon-default.png\');" alt="图标出走了～"/>',
+		'<img class="update-btn" style="position: absolute;width:20px;height:20px;margin-top:-66px;margin-left:44px;" src="/res/upgrade.png"',
+		'</dd>',
+		'<dt class="icon-title">#{title}</dt>',
+		'<dd class="icon-desc">',
+		'<a class="text" href="/#{home_url}" #{target}>',
+		'#{description}',
+		'</a>',
+		'<div class="opt">',
+		'<a type="button" class="install-btn" data-name="#{name}">安装</a>',
+		'<a type="button" class="update-btn" data-name="#{name}">更新</a>',
+		'<a type="button" class="uninstall-btn" data-name="#{name}">卸载</a>',
+		'</div>',
+		'</dd>',
+		'</dl>'
+	].join('');
+	var installCount = 0;
+	var uninstallCount = 0;
+	var html = $.map(apps, function(app, name) {
+		parseInt(app.install, 10) ? installCount++ : uninstallCount++;
+		return _format(tpl, app);
+	});
+	$('#IconContainer').html(html.join(''));
+	//更新安装数
+	$('.show-install-btn').val('已安装(' + installCount + ')');
+	$('.show-uninstall-btn').val('未安装(' + uninstallCount + ')');
+}
+function getRemoteData() {
+	var remoteURL = db_softcenter_["softcenter_home_url"] + '/softcenter/app.json.js';
+	return $.ajax({
+		url: remoteURL,
+		method: 'GET',
+		dataType: 'jsonp',
+		timeout: 3500
+	});
+}
+function softceterInitData(data) {
+	var remoteData = data;
+	$("#spnOnlineVersion").html("<em>" + remoteData.version + "</em>");
+	if (remoteData.version != db_softcenter_["softcenter_version"]) {
+		$("#updateBtn").show();
+		$("#updateBtn").click(function() {
+			var moduleInfo = {
+				"name": "softcenter",
+				"md5": remoteData.md5,
+				"tar_url": remoteData.tar_url,
+				"version": remoteData.version
+			};
+			appPostScript(moduleInfo, "ks_app_install.sh");
+		});
+	}
+}
+function init(cb) {
+		//设置默认值
+		function _setDefault(source, defaults) {
+				$.map(defaults, function(value, key) {
+					if (!source[key]) {
+						source[key] = value;
+					}
+				});
+			}
+		//把本地数据平面化转换成以app为对象
+		function _formatLocalData(localData) {
+				var result = {};
+				$.map(db_softcenter_, function(item, key) {
+					key = key.split('_');
+					if ('module' === key[1]) {
+						var name = key[2];
+						var prop = key.slice(3).join("_");
+						if (!result[name]) {
+							result[name] = {};
+							result[name].name = name;
+						}
+						if (prop) {
+							result[name][prop] = item;
+						}
+					}
+				});
+				for (var field in result) {
+					if (!result[field].install){
+						delete(result[field]);
+					}
+				}
+				//console.log(result)
+				return result;
+			}
+		//将本地和远程进行一次对比合并
+		function _mergeData(remoteData) {
+			var result = {};
+			var localData = _formatLocalData(db_softcenter_);
+			$.each(remoteData, function(i, app) {
+				var name = app.name;
+				var oldApp = localData[name] || {};
+				var install = (parseInt(oldApp.install, 10) === 1 && app.version !== oldApp.version) ? 2 : oldApp.install || "0";
+				result[name] = $.extend(oldApp, app);
+				result[name].install = install;
+			});
+			$.map(localData, function(app, name) {
+				if (!result[name]) {
+					result[name] = app;
+				}
+			});
+			//设置默认值和设置icon的路径
+			$.map(result, function(item, name) {
+				_setDefault(item, {
+					home_url: "Module_" + name + ".asp",
+					title: name.capitalizeFirstLetter(),
+					tar_url: "{0}/{0}.tar.gz".format(name),
+					install: "0",
+					description: "暂无",
+					new_version: false
+				});
+				// icon 规则:
+				// 如果已安装的插件,那图标必定在 /koolshare/res 目录, 通过 /res/icon-{name}.png 请求路径得到图标
+				// 如果是未安装的插件,则必定在 https://armsoft.ddnsto.com/{name}/{name}/icon-{name}.png
+				// TODO 如果因为一些错误导致没有图标, 有可能显示一张默认图标吗?
+				item.icon = parseInt(item.install, 10) !== 0 ? ('/res/icon-' + item.name + '.png') : ('https://armsoft.ddnsto.com' + new Array(3).join('/softcenter') + '/res/icon-' + item.name + '.png');
+			});
+			return result;
+		};
+		if (syncRemoteSuccess) {
+			cb();
+			return;
+		} else {
+			renderView(_mergeData({}));
+			cb();
+			getRemoteData()
+				.done(function(remoteData) {
+					//远端更新成功
+					syncRemoteSuccess = 1;
+					softceterInitData(remoteData);
+					remoteData = remoteData.apps || [];
+					renderView(_mergeData(remoteData));
+					cb();
+				})
+				.fail(function() {
+					//如果没有更新成功，比如没网络，就用空数据merge本地
+				//renderView(_mergeData({}));
+				//cb();
+				$("#spnOnlineVersion").html("<i>获取在线版本失败！请尝试重新刷新本页面，或者检查你的网络设置！</i>")
+				});
+		}
+		notice_show();
+	}
+	//初始化整个界面展现，包括安装未安装的获取
+	//当初始化过程获取软件列表失败时候，用本地的模块进行渲染
+	//只要一次获取成功，以后不在重新获取，知道页面刷新重入
+$(function() {
+	//梅林要求用这个函数来显示左测菜单
+	show_menu(menu_hook);
+	//pop_111();
+	$.ajax({
+		type: "GET",
+		url: "/_api/soft",
+		dataType: "json",
+		async: false,
+		cache: false,
+		success: function(response) {
+			db_softcenter_ = response.result[0];
+			db_softcenter_["softcenter_home_url"] = "https://armsoft.ddnsto.com";
+			if (!db_softcenter_["softcenter_version"]) {
+				db_softcenter_["softcenter_version"] = "0.0";
+			}
+			$("#spnCurrVersion").html("<em>" + db_softcenter_["softcenter_version"] + "</em>");
+			var jff2_scripts="<% nvram_get("jffs2_scripts"); %>";
+			if(jff2_scripts != 1){
+				$('#software_center_message').html('<h2><font color="#FF9900">错误！</font></h2><h2>软件中心不可用！因为你没有开启Enable JFFS custom scripts and configs选项！</h2><h2>请前往【系统管理】-<a href="Advanced_System_Content.asp"><u><em>【系统设置】</em></u></a>开启此选项再使用软件中心！！</h2>')
+			}else{
+				init(function() {
+					toggleAppPanel(1);
+					//一刷新界面是否就正在插件在安装.
+					initInstallStatus();
+				});
+				//挂接tab切换安装状态事件
+				$('.show-install-btn').click(function() {
+					init(function() {
+						toggleAppPanel(1);
+					});
+				});
+				$('.show-uninstall-btn').click(function() {
+					init(function() {
+						toggleAppPanel(0);
+					});
+				});
+				//挂接安装或者卸载事件
+				$('#IconContainer').on('click', '.install-btn', function() {
+					var name = $(this).data('name');
+					console.log('install', name);
+					appInstallModule(softInfo[name]);
+				});
+				$('#IconContainer').on('click', '.uninstall-btn', function() {
+					var name = $(this).data('name');
+					console.log('uninstall', name);
+					appUninstallModule(softInfo[name]);
+				});
+				$('#IconContainer').on('click', '.update-btn', function() {
+					var name = $(this).data('name');
+					console.log('update', name);
+					appInstallModule(softInfo[name]);
+				});
+			}
+		}
+	});
+});
+function menu_hook() {
+	tabtitle[tabtitle.length - 1] = new Array("", "软件中心", "离线安装");
+	tablink[tablink.length - 1] = new Array("", "Module_Softcenter.asp", "Module_Softsetting.asp");
+}
+function notice_show() {
+	$.ajax({
+		url: 'https://armsoft.ddnsto.com/softcenter/push_message.json.js',
+		type: 'GET',
+		dataType: 'jsonp',
+		success: function(res) {
+			$("#push_titile").html(res.title);
+			$("#push_content1").html(res.content1);
+			if (res.content2) {
+				document.getElementById("push_content2_li").style.display = "";
+				$("#push_content2").html(res.content2);
+			}
+			if (res.content3) {
+				document.getElementById("push_content3_li").style.display = "";
+				$("#push_content3").html(res.content3);
+			}
+			if (res.content4) {
+				document.getElementById("push_content4_li").style.display = "";
+				$("#push_content4").html(res.content4);
+			}
+		}
+	});
+}
+</script>
+</head>
+<body>
+	<div id="TopBanner"></div>
+	<div id="Loading" class="popup_bg"></div>
+	<table class="content" align="center" cellpadding="0" cellspacing="0">
+		<tr>
+			<td width="17">&nbsp;</td>
+			<td valign="top" width="202">
+				<div id="mainMenu"></div>
+				<div id="subMenu"></div>
+			</td>
+			<td valign="top">
+				<div id="tabMenu" class="submenuBlock"></div>
+					<table width="98%" border="0" align="left" cellpadding="0" cellspacing="0">
+						<tr>
+							<td align="left" valign="top">
+								<div>
+									<table width="760px" border="0" cellpadding="5" cellspacing="0" bordercolor="#6b8fa3" class="FormTitle" id="FormTitle">
+										<tr>
+											<td bgcolor="#4D595D" colspan="3" valign="top">
+												<div>&nbsp;</div>
+												<div id="title_name" class="formfonttitle"></div>
+												<script type="text/javascript">
+													var MODEL = '<% nvram_get("odmpid"); %>' || '<% nvram_get("model"); %>';
+													$("#title_name").html("Software Center " + MODEL)
+												</script>
+												<div style="margin:10px 0 10px 5px;" class="splitLine"></div>
+													<table width="100%" border="1" align="center" cellpadding="4" cellspacing="0" bordercolor="#6b8fa3" class="FormTable">
+													</table>
+													<table width="100%" height="150px" style="border-collapse:collapse;">
+														<tr bgcolor="#444f53">
+															<td colspan="5" bgcolor="#444f53" class="cloud_main_radius">
+																<div style="width:95%;font-style:italic;font-size:14px;">
+																	<table width="100%">
+																		<tr>
+																			<td>
+																				<ul style="padding-left:25px;">
+																					<h2 id="push_titile"><em>软件中心&nbsp;-&nbsp;by&nbsp;koolshare</em></h2>
+																					<li>
+																						<h4 id="push_content1" ><font color='#1E90FF'>交流反馈:&nbsp;&nbsp;</font><a href='https://github.com/koolshare/rogsoft' target='_blank'><em>1.软件中心GitHub项目</em></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href='https://t.me/xbchat' target='_blank'><em>2.加入telegram群</em></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href='http://shang.qq.com/wpa/qunwpa?idkey=f475468129ba8019245425559b5df5bdad7d7201ac7780417dd0218bbb4e1322' target='_blank'><em>3.加入QQ群</em></a>&nbsp;&nbsp;&nbsp;&nbsp;<a href='http://koolshare.cn/forum-98-1.html' target='_blank'><em>4.Koolshare论坛插件版块</em></a></h4>
+																					</li>
+																					<li id="push_content2_li" style="display: none;">
+																						<h4 id="push_content2"></h4>
+																					</li>
+																					<li id="push_content3_li" style="display: none;">
+																						<h4 id="push_content3"></h4>
+																					</li>
+																					<li id="push_content4_li" style="display: none;">
+																						<h4 id="push_content4"></h4>
+																					</li>
+																					<li>
+																						<h5>当前版本：<span id="spnCurrVersion"></span>&nbsp;&nbsp;&nbsp;&nbsp;在线版本：<span id="spnOnlineVersion"></span>
+																						<input type="button" id="updateBtn" value="更新" style="display:none" /></h5>
+																					</li>
+																				</ul>
+																			</td>
+																		</tr>
+																	</table>
+																</div>
+															</td>
+														</tr>
+														<tr height="10px">
+															<td colspan="3"></td>
+														</tr>
+														<tr bgcolor="#444f53" id="install_status" style="display: none;" width="235px">
+															<td>
+																<div style="padding:10px;width:95%;font-size:14px;" id="appInstallInfo">
+																</div>
+															</td>
+															<td class="cloud_main_radius_right">
+															</td>
+														 </tr>
+														<tr height="10px">
+															<td colspan="3"></td>
+														</tr>
+														<tr width="235px">
+															<td colspan="4" cellpadding="0" cellspacing="0" style="padding:0">
+																<input class="show-install-btn" type="button" value="已安装"/>
+																<input class="show-uninstall-btn" type="button" value="未安装"/>
+															</td>
+														</tr>
+														<tr bgcolor="#444f53" width="235px">
+															<td colspan="4" id="IconContainer">
+																<div id="software_center_message" style="text-align:center; line-height: 4em;">更新中...</div>
+															</td>
+														</tr>
+														<tr height="10px">
+															<td colspan="3"></td>
+														</tr>
+													</table>
+												<div class="KoolshareBottom">
+													论坛技术支持: <a href="https://koolshare.cn" target="_blank"> <i><u>https://koolshare.cn</u></i></a><br />
+													GitHub: <a href="https://github.com/koolshare/rogsoft" target="_blank"><i><u>https://github.com/koolshare</u></i></a><br />
+													Shell & Web by: <a href="mailto:sadoneli@gmail.com"><i>sadoneli</i></a>, <i>Xiaobao</i>
+												</div>
+											</td>
+										</tr>
+								</table>
+							</div>
+						</td>
+					</tr>
+				</table>
+			</td>
+			<td width="10" align="center" valign="top"></td>
+		</tr>
+	</table>
+<div id="footer"></div>
+</body>
+</html>
diff --git a/release/src/router/softcenter/softcenter/webs/Module_Softsetting.asp b/release/src/router/softcenter/softcenter/webs/Module_Softsetting.asp
new file mode 100644
index 0000000000..c8b445a65d
--- /dev/null
+++ b/release/src/router/softcenter/softcenter/webs/Module_Softsetting.asp
@@ -0,0 +1,191 @@
+﻿<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
+<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+<meta HTTP-EQUIV="Pragma" CONTENT="no-cache"/>
+<meta HTTP-EQUIV="Expires" CONTENT="-1"/>
+<link rel="shortcut icon" href="images/favicon.png"/>
+<link rel="icon" href="images/favicon.png"/>
+<title>软件中心 - 离线安装</title>
+<link rel="stylesheet" type="text/css" href="index_style.css"/>
+<link rel="stylesheet" type="text/css" href="form_style.css"/>
+<link rel="stylesheet" type="text/css" href="/res/softcenter.css">
+<script type="text/javascript" src="/js/jquery.js"></script>
+<script type="text/javascript" src="/state.js"></script>
+<script type="text/javascript" src="/popup.js"></script>
+<script type="text/javascript" src="/help.js"></script>
+<script type="text/javascript" src="/validator.js"></script>
+<script type="text/javascript" src="/general.js"></script>
+<script type="text/javascript" src="/switcherplugin/jquery.iphone-switch.js"></script>
+<script type="text/javascript" src="/res/softcenter.js"></script>
+<script language="JavaScript" type="text/javascript" src="/client_function.js"></script>
+<script>
+var _responseLen;
+var noChange = 0;
+function init(menu_hook) {
+	show_menu();
+	get_log();
+}
+function menu_hook() {
+	tabtitle[tabtitle.length - 1] = new Array("", "软件中心", "离线安装");
+	tablink[tablink.length - 1] = new Array("", "Module_Softcenter.asp", "Module_Softsetting.asp");
+}
+function upload_software() {
+	var filename = $("#file").val();
+	filename = filename.split('\\');
+	filename = filename[filename.length - 1];
+	var filelast = filename.split('.');
+	filelast = filelast[filelast.length - 1];
+	if (filelast != 'gz') {
+		alert('插件压缩包格式不正确！');
+		return false;
+	}
+	document.getElementById('file_info').style.display = "none";
+	var formData = new FormData();
+	formData.append(filename, $('#file')[0].files[0]);
+	//changeButton(true);
+	$.ajax({
+		url: '/_upload',
+		type: 'POST',
+		cache: false,
+		data: formData,
+		processData: false,
+		contentType: false,
+		complete: function(res) {
+			if (res.status == 200) {
+				var moduleInfo = {
+					"soft_name": filename,
+				};
+				document.getElementById('file_info').style.display = "block";
+				install_now(moduleInfo);
+			}
+		}
+	});
+}
+function install_now(moduleInfo) {
+	var id = parseInt(Math.random() * 100000000);
+	var postData = {
+		"id": id,
+		"method": "ks_tar_install.sh",
+		"params": [],
+		"fields": moduleInfo
+	};
+	$.ajax({
+		type: "POST",
+		url: "/_api/",
+		data: JSON.stringify(postData),
+		dataType: "json",
+		success: function(response) {
+			if(response.result == id){
+				get_log(1);
+			}
+		}
+	});
+}
+function get_log(s) {
+	var retArea = E("soft_log");
+	$.ajax({
+		url: '/_temp/soft_log.txt',
+		type: 'GET',
+		dataType: 'text',
+		cache: false,
+		success: function(response) {
+			if (response.search("XU6J03M6") != -1) {
+				retArea.value = response.replace("XU6J03M6", " ");
+				retArea.scrollTop = retArea.scrollHeight;
+				if (s) {
+					setTimeout("window.location.reload()", 3000);
+				}
+				return true;
+			}
+			if (_responseLen == response.length) {
+				noChange++;
+			} else {
+				noChange = 0;
+			}
+			if (noChange > 4000) {
+				//tabSelect("app1");
+				return false;
+			} else {
+				setTimeout("get_log(1);", 100); //100 is radical but smooth!
+			}
+			retArea.value = response;
+			retArea.scrollTop = retArea.scrollHeight;
+			_responseLen = response.length;
+		},
+		error: function(xhr, status, error) {
+			if (s) {
+				E("soft_log").value = "获取日志失败！";
+			}
+		}
+	});
+}
+</script>
+</head>
+<body onload="init();">
+	<div id="TopBanner"></div>
+	<div id="Loading" class="popup_bg"></div>
+	<table class="content" align="center" cellpadding="0" cellspacing="0">
+		<tr>
+			<td width="17">&nbsp;</td>
+			<td valign="top" width="202">
+				<div id="mainMenu"></div>
+				<div id="subMenu"></div>
+			</td>
+			<td valign="top">
+				<div id="tabMenu" class="submenuBlock"></div>
+				<table width="98%" border="0" align="left" cellpadding="0" cellspacing="0">
+					<tr>
+						<td align="left" valign="top">
+							<table width="760px" border="0" cellpadding="5" cellspacing="0" bordercolor="#6b8fa3" class="FormTitle" id="FormTitle">
+								<tr>
+									<td bgcolor="#4D595D" colspan="3" valign="top">
+										<div>&nbsp;</div>
+										<div style="float:left;" class="formfonttitle">软件中心 - 插件离线安装</div>
+										<div style="float:right; width:15px; height:25px;margin-top:10px"><img id="return_btn" onclick="reload_Soft_Center();" align="right" style="cursor:pointer;position:absolute;margin-left:-30px;margin-top:-25px;" title="返回软件中心" src="/images/backprev.png" onMouseOver="this.src='/images/backprevclick.png'" onMouseOut="this.src='/images/backprev.png'"></img></div>
+										<div style="margin:30px 0 10px 5px;" class="splitLine"></div>
+										<div class="formfontdesc" style="padding-top:5px;margin-top:0px;float: left;" id="cmdDesc"></div>
+										<div style="padding-top:5px;margin-top:0px;float: left;" id="NoteBox" >
+											<li>通过本页面，你可以上传插件的离线安装包来安装插件; </li>
+											<li>离线安装会自动解压tar.gz后缀的压缩包，识别压缩包一级目录下的install.sh文件并执行； </li>
+										</div>
+										<div class="formfontdesc" id="cmdDesc"></div>
+										<table style="margin:10px 0px 0px 0px;" width="100%" border="1" align="center" cellpadding="4" cellspacing="0" bordercolor="#6b8fa3" class="FormTable" id="routing_table">
+											<thead>
+											<tr>
+												<td colspan="2">软件中心 - 高级设置</td>
+											</tr>
+											</thead>
+											<tr>
+												<th><a class="hintstyle" href="javascript:void(0);" onclick="openssHint(24)">离线安装插件</a></th>
+												<td>
+													<input type="button" id="upload_btn" class="button_gen" onclick="upload_software();" value="上传并安装"/>
+													<input style="color:#FFCC00;*color:#000;width: 200px;" id="file" type="file" name="file"/>
+													<img id="loadingicon" style="margin-left:5px;margin-right:5px;display:none;" src="/images/InternetScan.gif">
+													<span id="file_info" style="display:none;">完成</span>
+												</td>
+											</tr>
+										</table>
+										<div id="log_content" style="margin-top:10px;display: block;">
+											<textarea cols="63" rows="40" wrap="off" readonly="readonly" id="soft_log" style="width:99%; font-family:'Lucida Console'; font-size:12px;background:#475A5F;color:#FFFFFF;"></textarea>
+										</div>
+										<div class="KoolshareBottom">
+											论坛技术支持: <a href="https://koolshare.cn" target="_blank"> <i><u>https://koolshare.cn</u></i></a><br />
+											GitHub: <a href="https://github.com/koolshare/armsoft" target="_blank"><i><u>https://github.com/koolshare</u></i></a><br />
+											Shell & Web by: <a href="mailto:sadoneli@gmail.com"><i>sadoneli</i></a>, <i>Xiaobao</i>
+										</div>
+									</td>
+								</tr>
+							</table>
+						</td>
+						<td width="10" align="center" valign="top"></td>
+					</tr>
+				</table>
+			</td>
+		</tr>
+	</table>
+	</td>
+	<div id="footer"></div>
+</body>
+</html>
diff --git a/release/src/router/www/images/New_ui/softcenter.png b/release/src/router/www/images/New_ui/softcenter.png
new file mode 100755
index 0000000000000000000000000000000000000000..f6c9fe9b9790069093357713239965ba64b21e0b
GIT binary patch
literal 1344
zcmV-G1;6@<P)<h;3K|Lk000e1NJLTq001Na001Ni1^@s6;Q*MJ000FCNkl<ZScUDE
zS!i5k7>1uSTRJgOgS4b=YN^30QiF<HQLv)kDMcGEtO|;t5D{D|UZ_a%(&a|Q3YLO`
zSc#Wv5yb_exK=Q&X{<?WizL;m=`xwj%$f1xd%ttetciFf_Q2t6|ML9r_x}I)A2@yd
z$Bw{nHtnx1s+{gq4bK7K4J5BsfYG(IZ9E8qy64OSz>Q_Sb^x3O3;;RcPoN~wzkpMM
z2>^yC00=vQEf&btNGD+WfJ=Z4zzskz@FQ>%$O03<H^48z3~*Haq=qL5N7oWA)FA+O
zOtgegVG4kS;8I{SunAbvq21%a_rMtN4zLF(s=YE$ed~Nvt1)EJ(>({8fE>pCu@QI_
zxKiJXm>T0)h)Tc`fvy9VtK5FzRp1R^PVJR}aK|9EwjRo->fWdHEe(X2BF_W;dL9G5
z1wIF+1y{yG)(xxzZU$}wE&#R)WV`BTfa=H;K)tUbpzatb5J*;|zFZCV1IK`mfL#fY
zG_l8On3u+Y!<fNu$0ooQ%unwVPk<&rML<322qq<%j7EDGFbMn%yeVZ0i8hK@DCShR
zSM>_OD6mvYtpsiZzR<v2{f<DWphIoMOgx2!Y)tQ~#9=xH<bexSe;Qi``Y?09hfRhq
z;48J?MZ7Gu4q0z1QYWKA%YpkaV{Zq((|sYK$}ASr%^K}Aa7f@MRQ>?454b{Qe6aJ4
z>eK_7LMh_eb(zkefUl)Sh<Ril_(L#{10U<GsD2fjc@+(A9JmfxP3*T6^%<ZgkcTS|
zTrIF&m>DaW84DWyQs7?T6JVRZBbdC-n%>Xo{W)sC)(WN$XhklXT|UFkmKr}`UdRe&
zPD)*+&R$oYoRq6b%|5*^5QnE*Fl|#v1k@h`Wr*c0VbT{9qb+Il>l5Gd`c~EHO6GK*
zm8!mCH<`H!s4w=AgXJ{Rg03m*JyHeEm0CXPvflTo*;&D^6VR6lwOT3_0d=LKn0ldf
zLnl=|XRxsC0d55@2KGvYl?fFyQsa8e&>sMk8c-?GUTdIotq!K9#&W<J4Haux&f1Ha
z^%3A9l|NIRO{v@vHVY2|uVHEj#Nll^BB0qy^v;vtG`4^ZNG)%`XHgM&0eDi^7qLY$
zP@NkE`YZ4(a76vN1zK)HBA}Uaw8INjcpQuOMFN{A&Oa4mPrM8~jU~~2Sm@5fX6dI`
zra!9pb5gJZghSmOLUyDSZ#juG`tQIkz-}z5mh|0yl2xb2v6Xn0lzUfo+%p*ss7S&;
zL){$|nl%9(DhvFEEqV_C4+?Nf3i{Oc@b1R)l+VOk0wfg3JaMSn?iwSY6JZ2X!4|MN
z;6q>-Sc7H!Ln>ZV2R?PPiNW|v915T;cn?+W{$;HV-3SD+Kg!rl8V7a)Bfz!ThRp3B
z63bsE&Qb2cYN9P~*VnAJM+9`TULjwNi@@8!HNc&~XPB3Kjq*+^)F;epqAiCD0iGG?
z3=}1}EeC7<oE1!u&I-1l*@jK)yRof^r;9MrR^$I!HF4#+)y*(%H~AxzQP~W(AUaeY
z^V0@wlXe(*7z>~O1h@(g5*@FsSwN9R{B^iWNvNEl)&oxf%diD;Cl=l`^45;Qg?|P+
z0Yx5~kA3gn@DPBdk1lK>d<^>wc?#PrZ^d?no^=1!5doFz$K{430k%ZtCxMqRbB9<e
z@M+(1uk(+9S{x1)B<{OZ=M=UWmIM`r?DX-!JN^ca(ZrO!+_sVc0000<MNUMnLSTaa
C$z-np

literal 0
HcmV?d00001

diff --git a/release/src/router/www/index_style.css b/release/src/router/www/index_style.css
index 933718502f..1f2707636a 100644
--- a/release/src/router/www/index_style.css
+++ b/release/src/router/www/index_style.css
@@ -890,6 +890,10 @@ width:122px;
 	background-size: 100%;
 	background-repeat: no-repeat;
 }
+.menu_Softcenter{
+	background: url(images/New_ui/softcenter.png);
+	background-position: 0px 0px;
+}
 .menuClicked{
 	background: #8AA6BE; /* Old browsers */
 	background: -moz-linear-gradient(top, #8AA6BE  0%, #668CAD 44%, #4A779D 45%, #3A6894 46%, #376C9B 100%); /* FF3.6+ */
diff --git a/release/src/router/www/require/menuTrees/menuTree_bwdpi_no_traffic_analyzer.js b/release/src/router/www/require/menuTrees/menuTree_bwdpi_no_traffic_analyzer.js
index de08edb3c6..c5d121b46d 100644
--- a/release/src/router/www/require/menuTrees/menuTree_bwdpi_no_traffic_analyzer.js
+++ b/release/src/router/www/require/menuTrees/menuTree_bwdpi_no_traffic_analyzer.js
@@ -290,6 +290,22 @@ define(function(){
 					{url: "Advanced_Smart_Connect.asp", tabName: "<#smart_connect_rule#>"},
 					{url: "NULL", tabName: "__INHERIT__"}
 				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Split",
+				tab: [
+					{url: "NULL", tabName: "__HIDE__"}
+				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Softcenter",
+				tab: [
+					{url: "Module_Softcenter.asp", tabName: "软件中心"},
+					{url: "Module_Softsetting.asp", tabName: "离线安装"},
+					{url: "NULL", tabName: "__INHERIT__"}
+				]
 			}
 		],
 
diff --git a/release/src/router/www/require/menuTrees/menuTree_bwdpi_traffic_analyzer.js b/release/src/router/www/require/menuTrees/menuTree_bwdpi_traffic_analyzer.js
index d93118825f..cd5e21bef8 100644
--- a/release/src/router/www/require/menuTrees/menuTree_bwdpi_traffic_analyzer.js
+++ b/release/src/router/www/require/menuTrees/menuTree_bwdpi_traffic_analyzer.js
@@ -354,6 +354,22 @@ define(function(){
 					{url: "Advanced_Smart_Connect.asp", tabName: "<#smart_connect_rule#>"},
 					{url: "NULL", tabName: "__INHERIT__"}
 				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Split",
+				tab: [
+					{url: "NULL", tabName: "__HIDE__"}
+				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Softcenter",
+				tab: [
+					{url: "Module_Softcenter.asp", tabName: "软件中心"},
+					{url: "Module_Softsetting.asp", tabName: "离线安装"},
+					{url: "NULL", tabName: "__INHERIT__"}
+				]
 			}
 		],
 
diff --git a/release/src/router/www/require/menuTrees/menuTree_no_bwdpi.js b/release/src/router/www/require/menuTrees/menuTree_no_bwdpi.js
index b151e1fbc0..bec99ba21d 100644
--- a/release/src/router/www/require/menuTrees/menuTree_no_bwdpi.js
+++ b/release/src/router/www/require/menuTrees/menuTree_no_bwdpi.js
@@ -288,6 +288,22 @@ define(function(){
 					{url: "Advanced_Smart_Connect.asp", tabName: "<#smart_connect_rule#>"},
 					{url: "NULL", tabName: "__INHERIT__"}
 				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Split",
+				tab: [
+					{url: "NULL", tabName: "__HIDE__"}
+				]
+			},
+			{
+				menuName: "软件中心",
+				index: "menu_Softcenter",
+				tab: [
+					{url: "Module_Softcenter.asp", tabName: "软件中心"},
+					{url: "Module_Softsetting.asp", tabName: "离线安装"},
+					{url: "NULL", tabName: "__INHERIT__"}
+				]
 			}
 		],
 
diff --git a/release/src/router/www/state.js b/release/src/router/www/state.js
index ca7a5350c2..f69928c986 100644
--- a/release/src/router/www/state.js
+++ b/release/src/router/www/state.js
@@ -1298,7 +1298,26 @@ function show_menu(){
 			menus: menuTree.exclude.menus(),
 			tabs: menuTree.exclude.tabs()
 		};
-
+		if (typeof menu_hook != "undefined") {
+			menu_hook();
+			for (var i = 0; i < tablink[0].length - 1; i++) {
+				menuList[menuList.length - 1].tab[i] = {
+					url: tablink[0][i + 1],
+					tabName: tabtitle[0][i + 1]
+				}
+			}
+			menuList[menuList.length - 1].tab[tablink[0].length - 1] = {
+				url: "NULL",
+				tabName: "__INHERIT__"
+			}
+		} else {
+			if(window.location.pathname.indexOf("Module_") != -1) {
+				menuList[menuList.length - 1].tab[0] = {
+					url: window.location.pathname.split("/")[1],
+					tabName: window.location.pathname.split(".asp")[0].split("/Module_")[1]
+				}
+			}
+		}
 		Session.set("menuList", menuList);
 		Session.set("menuExclude", menuExclude);
 		showMenuTree(menuList, menuExclude);
-- 
2.25.1

