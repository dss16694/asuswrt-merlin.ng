From 6f461e26d376ae198f05ded22e9c5693f682085e Mon Sep 17 00:00:00 2001
From: Rokis <ghost1988102@gmail.com>
Date: Tue, 16 Feb 2021 11:47:34 +0800
Subject: [PATCH 101/122] kernel: add FullCone Nat to 2.6.36

Signed-off-by: Rokis <ghost1988102@gmail.com>
---
 .../src/linux/linux-2.6.36/config_base.6a     |   1 +
 .../src/linux/linux-2.6.36/net/Kconfig        |   6 +-
 .../net/ipv4/netfilter/ipt_MASQUERADE.c       | 197 ++++++++++++++++++
 3 files changed, 203 insertions(+), 1 deletion(-)

diff --git a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
index b6c3a5ca58..9f2467d28f 100644
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/config_base.6a
@@ -492,6 +492,7 @@ CONFIG_NETFILTER=y
 # CONFIG_NETFILTER_DEBUG is not set
 CONFIG_NETFILTER_ADVANCED=y
 # CONFIG_BRIDGE_NETFILTER is not set
+CONFIG_BCM_KF_NETFILTER=y
 
 #
 # Core Netfilter Configuration
diff --git a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/Kconfig b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/Kconfig
index f7a317427a..e497ef9964 100644
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/Kconfig
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/Kconfig
@@ -10,7 +10,7 @@ menuconfig NET
 	  The reason is that some programs need kernel networking support even
 	  when running on a stand-alone machine that isn't connected to any
 	  other computer.
-	  
+
 	  If you are upgrading from an older kernel, you
 	  should consider updating your networking tools too because changes
 	  in the kernel and the tools often go hand in hand. The tools are
@@ -187,6 +187,10 @@ config BRIDGE_NETFILTER
 
 	  If unsure, say N.
 
+config BCM_KF_NETFILTER:
+	bool "Boardcom KF NETFILTER"
+	default y
+
 source "net/netfilter/Kconfig"
 source "net/ipv4/netfilter/Kconfig"
 source "net/ipv6/netfilter/Kconfig"
diff --git a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/ipv4/netfilter/ipt_MASQUERADE.c b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/ipv4/netfilter/ipt_MASQUERADE.c
index 1a9e2b6f01..abae0494d4 100644
--- a/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/ipv4/netfilter/ipt_MASQUERADE.c
+++ b/release/src-rt-7.14.114.x/src/linux/linux-2.6.36/net/ipv4/netfilter/ipt_MASQUERADE.c
@@ -23,10 +23,145 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter/x_tables.h>
 
+#if defined(CONFIG_BCM_KF_NETFILTER)
+#include <net/netfilter/nf_conntrack_zones.h>
+#include <net/netfilter/nf_conntrack_helper.h>
+#include <net/netfilter/nf_conntrack_core.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: automatic-address SNAT");
 
+#if defined(CONFIG_BCM_KF_NETFILTER)
+/****************************************************************************/
+static void bcm_nat_expect(struct nf_conn *ct,
+			   struct nf_conntrack_expect *exp)
+{
+	struct nf_nat_range range;
+
+	/* This must be a fresh one. */
+	BUG_ON(ct->status & IPS_NAT_DONE_MASK);
+
+	/* Change src to where new ct comes from */
+	range.flags = IP_NAT_RANGE_MAP_IPS;
+	range.min_ip = range.max_ip =
+		ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+	nf_nat_setup_info(ct, &range, IP_NAT_MANIP_SRC);
+
+	/* For DST manip, map port here to where it's expected. */
+	range.flags = (IP_NAT_RANGE_MAP_IPS | IP_NAT_RANGE_PROTO_SPECIFIED);
+	range.min = range.max = exp->saved_proto;
+	range.min_ip = range.max_ip = exp->saved_ip;
+	nf_nat_setup_info(ct, &range, IP_NAT_MANIP_DST);
+}
+
+/****************************************************************************/
+static int bcm_nat_help(struct sk_buff *skb, unsigned int protoff,
+			struct nf_conn *ct, enum ip_conntrack_info ctinfo)
+{
+	int dir = CTINFO2DIR(ctinfo);
+	struct nf_conn_help *help = nfct_help(ct);
+	struct nf_conntrack_expect *exp;
+	
+	if (dir != IP_CT_DIR_ORIGINAL ||
+	    help->expecting[NF_CT_EXPECT_CLASS_DEFAULT])
+		return NF_ACCEPT;
+
+	pr_debug("bcm_nat: packet[%d bytes] ", skb->len);
+	nf_ct_dump_tuple(&ct->tuplehash[dir].tuple);
+	pr_debug("reply: ");
+	nf_ct_dump_tuple(&ct->tuplehash[!dir].tuple);
+	
+	/* Create expect */
+	if ((exp = nf_ct_expect_alloc(ct)) == NULL)
+		return NF_ACCEPT;
+
+	nf_ct_expect_init(exp, NF_CT_EXPECT_CLASS_DEFAULT, AF_INET, NULL,
+			  &ct->tuplehash[!dir].tuple.dst.u3, IPPROTO_UDP,
+			  NULL, &ct->tuplehash[!dir].tuple.dst.u.udp.port);
+	exp->flags = NF_CT_EXPECT_PERMANENT;
+	exp->saved_ip = ct->tuplehash[dir].tuple.src.u3.ip;
+	exp->saved_proto.udp.port = ct->tuplehash[dir].tuple.src.u.udp.port;
+	exp->dir = !dir;
+	exp->expectfn = bcm_nat_expect;
+
+	/* Setup expect */
+	nf_ct_expect_related(exp);
+	nf_ct_expect_put(exp);
+	pr_debug("bcm_nat: expect setup\n");
+
+	return NF_ACCEPT;
+}
+
+/****************************************************************************/
+static struct nf_conntrack_expect_policy bcm_nat_exp_policy __read_mostly = {
+	.max_expected 	= 1000,
+	.timeout	= 240,
+};
+
+/****************************************************************************/
+static struct nf_conntrack_helper nf_conntrack_helper_bcm_nat __read_mostly = {
+	.name = "BCM-NAT",
+	.me = THIS_MODULE,
+	.tuple.src.l3num = AF_INET,
+	.tuple.dst.protonum = IPPROTO_UDP,
+	.expect_policy = &bcm_nat_exp_policy,
+	.expect_class_max = 1,
+	.help = bcm_nat_help,
+};
+
+/****************************************************************************/
+static inline int find_exp(__be32 ip, __be16 port, struct nf_conn *ct)
+{
+	struct nf_conntrack_tuple tuple;
+	struct nf_conntrack_expect *i = NULL;
+
+	
+	memset(&tuple, 0, sizeof(tuple));
+	tuple.src.l3num = AF_INET;
+	tuple.dst.protonum = IPPROTO_UDP;
+	tuple.dst.u3.ip = ip;
+	tuple.dst.u.udp.port = port;
+
+	rcu_read_lock();
+	i = __nf_ct_expect_find(nf_ct_net(ct), nf_ct_zone(ct), &tuple);
+	rcu_read_unlock();
+
+	return i != NULL;
+}
+
+/****************************************************************************/
+static inline struct nf_conntrack_expect *find_fullcone_exp(struct nf_conn *ct)
+{
+	struct nf_conntrack_tuple * tp =
+		&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;
+	struct net *net = nf_ct_net(ct);
+	struct nf_conntrack_expect * exp = NULL;
+	struct nf_conntrack_expect * i;
+	struct hlist_node *n;
+	unsigned int h;
+
+	rcu_read_lock();
+	for (h = 0; h < nf_ct_expect_hsize; h++) {
+		hlist_for_each_entry_rcu(i, n, &net->ct.expect_hash[h], hnode) {
+			if (i->saved_ip == tp->src.u3.ip &&
+		    	    i->saved_proto.all == tp->src.u.all &&
+		    	    i->tuple.dst.protonum == tp->dst.protonum &&
+		    	    i->tuple.src.u3.ip == 0 &&
+		    	    i->tuple.src.u.udp.port == 0) {
+				exp = i;
+				break;
+			}
+		}
+	}
+	rcu_read_unlock();
+
+	return exp;
+}
+#endif /* CONFIG_KF_NETFILTER */
+
+
 static int masquerade_tg_check(const struct xt_tgchk_param *par)
 {
 	const struct nf_nat_multi_range_compat *mr = par->targinfo;
@@ -81,6 +216,65 @@ masquerade_tg(struct sk_buff *skb, const struct xt_action_param *par)
 
 	nat->masq_index = par->out->ifindex;
 
+#if defined(CONFIG_BCM_KF_NETFILTER)
+	if (mr->range[0].min_ip != 0 /* nat_mode == full cone */
+	    && (nfct_help(ct) == NULL || nfct_help(ct)->helper == NULL)
+	    && nf_ct_protonum(ct) == IPPROTO_UDP) {
+		unsigned int ret;
+		u_int16_t minport;
+		u_int16_t maxport;
+		struct nf_conntrack_expect *exp;
+
+		pr_debug("bcm_nat: need full cone NAT\n");
+
+		/* Choose port */
+		spin_lock_bh(&nf_conntrack_lock);
+		/* Look for existing expectation */
+		exp = find_fullcone_exp(ct);
+		if (exp) {
+			minport = maxport = exp->tuple.dst.u.udp.port;
+			pr_debug("bcm_nat: existing mapped port = %hu\n",
+			       	 ntohs(minport));
+		} else { /* no previous expect */
+			u_int16_t newport, tmpport;
+
+			minport = mr->range[0].min.all == 0?
+				ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.
+				u.udp.port : mr->range[0].min.all;
+			maxport = mr->range[0].max.all == 0?
+				htons(65535) : mr->range[0].max.all;
+			for (newport = ntohs(minport),tmpport = ntohs(maxport);
+			     newport <= tmpport; newport++) {
+			     	if (!find_exp(newsrc, htons(newport), ct)) {
+					pr_debug("bcm_nat: new mapped port = "
+					       	 "%hu\n", newport);
+					minport = maxport = htons(newport);
+					break;
+				}
+			}
+		}
+		spin_unlock_bh(&nf_conntrack_lock);
+
+		newrange.flags = mr->range[0].flags | IP_NAT_RANGE_MAP_IPS |
+			IP_NAT_RANGE_PROTO_SPECIFIED;
+		newrange.max_ip = newrange.min_ip = newsrc;
+		newrange.min.udp.port = newrange.max.udp.port = minport;
+
+		/* Set ct helper */
+		ret = nf_nat_setup_info(ct, &newrange, IP_NAT_MANIP_SRC);
+		if (ret == NF_ACCEPT) {
+			struct nf_conn_help *help = nfct_help(ct);
+			if (help == NULL)
+				help = nf_ct_helper_ext_add(ct, GFP_ATOMIC);
+			if (help != NULL) {
+				help->helper = &nf_conntrack_helper_bcm_nat;
+				pr_debug("bcm_nat: helper set\n");
+			}
+		}
+		return ret;
+	}
+#endif /* CONFIG_KF_NETFILTER */
+
 	/* Transfer from original range. */
 	newrange = ((struct nf_nat_range)
 		{ mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,
@@ -167,6 +361,9 @@ static int __init masquerade_tg_init(void)
 
 static void __exit masquerade_tg_exit(void)
 {
+#if defined(CONFIG_BCM_KF_NETFILTER)
+	nf_conntrack_helper_unregister(&nf_conntrack_helper_bcm_nat);
+#endif
 	xt_unregister_target(&masquerade_tg_reg);
 	unregister_netdevice_notifier(&masq_dev_notifier);
 	unregister_inetaddr_notifier(&masq_inet_notifier);
-- 
2.25.1

